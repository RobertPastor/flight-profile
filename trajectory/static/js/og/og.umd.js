(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.og = {}));
})(this, (function (exports) { 'use strict';

    /**
     * @module og/ajax
     */

    /**
     * Ajax parameters.
     * @namespace og.ajax
     */
    const ajax = {
        /**
         * Ajax ready state result.
         * @enum
         */
        ReadyState: {
            Uninitialized: 0,
            Loading: 1,
            Loaded: 2,
            Interactive: 3,
            Complete: 4
        },
        /**
         * Ajax status code.
         * @enum
         */
        Status: {
            OK: 200,
            Created: 201,
            Accepted: 202,
            NoContent: 204,
            BadRequest: 400,
            Forbidden: 403,
            NotFound: 404,
            Gone: 410,
            ServerError: 500
        },
        /**
         * Ajax query method.
         * @enum
         */
        Method: {
            Get: "GET",
            Post: "POST"
        },
        /**
         * Ajax query type is asynchronous.
         * @type {boolean}
         */
        Asynchronous: true,
        /**
         * Ajax query type is synchronous.
         * @type {boolean}
         */
        Synchronous: false
    };

    /**
     * Xhr object that returned by ajax query.
     * @class
     * @param {Object} xhr - Current ActiveXObject object.
     */
    const Xhr = function (xhr) {
        /**
         * ActiveXObject object.
         * @private
         * @type {Object}
         */
        var _xhr = xhr;

        /**
         * Aborts current ajax.
         * @public
         */
        this.abort = function () {
            _xhr.aborted = true;
            _xhr.abort();
        };
    };

    const defaultParams = {
        type: ajax.Method.Get,
        async: ajax.Asynchronous,
        data: null,
        sender: null,
        responseType: "text"
    };

    /**
     * Send an ajax request.
     * @function
     * @param {string} url - Url path.
     * @param {Object} [params] - Ajax parameters:
     * @param {ajax.Method|string} [params.type] - 'POST' or 'GET' ajax method. 'GET' is default.
     * @param {boolean} [params.async] - Asynchronous ajax flag. True is default.
     * @param {Object} [params.data] - Qery data.
     * @param {Object} [params.sender] - Sender object, that success callback binded with. ActiveXObject is default.
     * @param {string} [params.responseType] - Responce data type. Culd be 'text', 'json', 'jsonp', 'html'. 'text' is default.
     * @param {ajax.Xhr~successCallback} [params.success] - The callback that handles the success response.
     * @param {ajax.Xhr~errorCallback} [params.error] - The callback that handles the failed response.
     * @param {ajax.Xhr~abortCallback} [params.abort] - The callback that handles aborted requests.
     * @returns {ajax.Xhr} - Returns object that could be aborted.
     */
    ajax.request = function (url, params) {
        params = params || {};

        var p = {},
            i;

        for (i in defaultParams) {
            p[i] = defaultParams[i];
        }

        for (i in params) {
            p[i] = params[i];
        }

        p.data = params.data;

        var xhr = new XMLHttpRequest();

        var customXhr = new Xhr(xhr);

        var body = null,
            d;

        if (p.type === ajax.Method.Post) {
            if (p.data) {
                body = "";
                for (let key in p.data) {
                    d = p.data[key];
                    body +=
                        key +
                        "=" +
                        encodeURIComponent(d instanceof Object ? JSON.stringify(d) : d) +
                        "&";
                }
                body = body.slice(0, -1);
            }
            xhr.open(p.type, url, p.async);
            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
        } else if (p.data) {
            var tail = "?";
            for (let key in p.data) {
                d = p.data[key];
                tail +=
                    key + "=" + encodeURIComponent(d instanceof Object ? JSON.stringify(d) : d) + "&";
            }
            tail = tail.slice(0, -1);
            xhr.open(p.type, url + tail, p.async);
        } else {
            xhr.open(p.type, url, p.async);
        }

        if (p.async) {
            xhr.responseType = p.responseType;
        }

        xhr.overrideMimeType("text/plain");

        xhr.onreadystatechange = function () {
            if (xhr.readyState === ajax.ReadyState.Complete) {
                if (xhr.status === ajax.Status.OK) {
                    if (params.success) {
                        /**
                         * Success callback.
                         * @callback ajax.Xhr~successCallback
                         * @param {Object} Response data
                         */
                        params.success.call(params.sender || customXhr, xhr.response);
                    }
                } else if (xhr.aborted) {
                    /**
                     * Abort callback.
                     * @callback ajax.Xhr~abortCallback
                     * @param {Object} Response data
                     * @param {Object} Status object
                     */
                    params.abort &&
                        params.abort.call(params.sender || customXhr, xhr.response, xhr.status);
                } else {
                    /**
                     * Error callback.
                     * @callback ajax.Xhr~errorCallback
                     * @param {Object} Response data
                     * @param {Object} Status object
                     */
                    params.error &&
                        params.error.call(params.sender || customXhr, xhr.response, xhr.status);
                }
                delete xhr["onreadystatechange"];
                xhr.onreadystatechange = null;
                xhr = null;
            }
        };

        xhr.send(body);

        return customXhr;
    };

    const colorTable = {
        "aliceblue": "#f0f8ff",
        "antiquewhite": "#faebd7",
        "aqua": "#00ffff",
        "aquamarine": "#7fffd4",
        "azure": "#f0ffff",
        "beige": "#f5f5dc",
        "bisque": "#ffe4c4",
        "black": "#000000",
        "blanchedalmond": "#ffebcd",
        "blue": "#0000ff",
        "blueviolet": "#8a2be2",
        "brown": "#a52a2a",
        "burlywood": "#deb887",
        "cadetblue": "#5f9ea0",
        "chartreuse": "#7fff00",
        "chocolate": "#d2691e",
        "coral": "#ff7f50",
        "cornflowerblue": "#6495ed",
        "cornsilk": "#fff8dc",
        "crimson": "#dc143c",
        "cyan": "#00ffff",
        "darkblue": "#00008b",
        "darkcyan": "#008b8b",
        "darkgoldenrod": "#b8860b",
        "darkgray": "#a9a9a9",
        "darkgreen": "#006400",
        "darkkhaki": "#bdb76b",
        "darkmagenta": "#8b008b",
        "darkolivegreen": "#556b2f",
        "darkorange": "#ff8c00",
        "darkorchid": "#9932cc",
        "darkred": "#8b0000",
        "darksalmon": "#e9967a",
        "darkseagreen": "#8fbc8f",
        "darkslateblue": "#483d8b",
        "darkslategray": "#2f4f4f",
        "darkturquoise": "#00ced1",
        "darkviolet": "#9400d3",
        "deeppink": "#ff1493",
        "deepskyblue": "#00bfff",
        "dimgray": "#696969",
        "dodgerblue": "#1e90ff",
        "firebrick": "#b22222",
        "floralwhite": "#fffaf0",
        "forestgreen": "#228b22",
        "fuchsia": "#ff00ff",
        "gainsboro": "#dcdcdc",
        "ghostwhite": "#f8f8ff",
        "gold": "#ffd700",
        "goldenrod": "#daa520",
        "gray": "#808080",
        "green": "#008000",
        "greenyellow": "#adff2f",
        "honeydew": "#f0fff0",
        "hotpink": "#ff69b4",
        "indianred ": "#cd5c5c",
        "indigo": "#4b0082",
        "ivory": "#fffff0",
        "khaki": "#f0e68c",
        "lavender": "#e6e6fa",
        "lavenderblush": "#fff0f5",
        "lawngreen": "#7cfc00",
        "lemonchiffon": "#fffacd",
        "lightblue": "#add8e6",
        "lightcoral": "#f08080",
        "lightcyan": "#e0ffff",
        "lightgoldenrodyellow": "#fafad2",
        "lightgrey": "#d3d3d3",
        "lightgreen": "#90ee90",
        "lightpink": "#ffb6c1",
        "lightsalmon": "#ffa07a",
        "lightseagreen": "#20b2aa",
        "lightskyblue": "#87cefa",
        "lightslategray": "#778899",
        "lightsteelblue": "#b0c4de",
        "lightyellow": "#ffffe0",
        "lime": "#00ff00",
        "limegreen": "#32cd32",
        "linen": "#faf0e6",
        "magenta": "#ff00ff",
        "maroon": "#800000",
        "mediumaquamarine": "#66cdaa",
        "mediumblue": "#0000cd",
        "mediumorchid": "#ba55d3",
        "mediumpurple": "#9370d8",
        "mediumseagreen": "#3cb371",
        "mediumslateblue": "#7b68ee",
        "mediumspringgreen": "#00fa9a",
        "mediumturquoise": "#48d1cc",
        "mediumvioletred": "#c71585",
        "midnightblue": "#191970",
        "mintcream": "#f5fffa",
        "mistyrose": "#ffe4e1",
        "moccasin": "#ffe4b5",
        "navajowhite": "#ffdead",
        "navy": "#000080",
        "oldlace": "#fdf5e6",
        "olive": "#808000",
        "olivedrab": "#6b8e23",
        "orange": "#ffa500",
        "orangered": "#ff4500",
        "orchid": "#da70d6",
        "palegoldenrod": "#eee8aa",
        "palegreen": "#98fb98",
        "paleturquoise": "#afeeee",
        "palevioletred": "#d87093",
        "papayawhip": "#ffefd5",
        "peachpuff": "#ffdab9",
        "peru": "#cd853f",
        "pink": "#ffc0cb",
        "plum": "#dda0dd",
        "powderblue": "#b0e0e6",
        "purple": "#800080",
        "rebeccapurple": "#663399",
        "red": "#ff0000",
        "rosybrown": "#bc8f8f",
        "royalblue": "#4169e1",
        "saddlebrown": "#8b4513",
        "salmon": "#fa8072",
        "sandybrown": "#f4a460",
        "seagreen": "#2e8b57",
        "seashell": "#fff5ee",
        "sienna": "#a0522d",
        "silver": "#c0c0c0",
        "skyblue": "#87ceeb",
        "slateblue": "#6a5acd",
        "slategray": "#708090",
        "snow": "#fffafa",
        "springgreen": "#00ff7f",
        "steelblue": "#4682b4",
        "tan": "#d2b48c",
        "teal": "#008080",
        "thistle": "#d8bfd8",
        "tomato": "#ff6347",
        "turquoise": "#40e0d0",
        "violet": "#ee82ee",
        "wheat": "#f5deb3",
        "white": "#ffffff",
        "whitesmoke": "#f5f5f5",
        "yellow": "#ffff00",
        "yellowgreen": "#9acd32"
    };

    /**
     * @module og/math
     */

    /** @const */
    const TWO_PI = 2.0 * Math.PI;

    /** @const */
    const PI_TWO = Math.PI / 2.0;

    const X = 0;
    const Y = 1;
    const Z = 2;
    const W$1 = 3;

    const MAX_FLOAT = Number.MAX_VALUE || 1.7976931348623157e308;

    /** @const */
    const LOG2 = Math.log(2);
    /** @const */
    const MAX32 = 2147483647;
    /** @const */
    const MAX = 549755748352;
    /** @const */
    const MIN = -MAX;

    /** @const */
    const RADIANS = Math.PI / 180.0;
    /** @const */
    const DEGREES = 180.0 / Math.PI;

    /** @const */
    const DEGREES_DOUBLE = 2.0 * DEGREES;
    /** @const */
    const RADIANS_HALF = 0.5 * RADIANS;

    /** @const */
    const ARCSECONDS_TO_RADIANS = 0.00000484813681109536;
    /** @const */
    const RADIANS_TO_HOURS = 3.8197186342054880584532103209403;
    /** @const */
    const HOURS_TO_RADIANS = 0.26179938779914943653855361527329;
    /** @const */
    const HOURS_TO_DEGREES = 15.0;
    /** @const */
    const DEGREES_TO_HOURS = 1.0 / 15.0;

    /** @const */
    const SQRT_HALF = Math.sqrt(0.5);

    const EPSILON1 = 0.1;
    const EPSILON2 = 0.01;
    const EPSILON3 = 0.001;
    const EPSILON4 = 0.0001;
    const EPSILON5 = 0.00001;
    const EPSILON6 = 0.000001;
    const EPSILON7 = 1e-7;
    const EPSILON8 = 1e-8;
    const EPSILON9 = 1e-9;
    const EPSILON10 = 1e-10;
    const EPSILON11 = 1e-11;
    const EPSILON12 = 1e-12;
    const EPSILON13 = 1e-13;
    const EPSILON14 = 1e-14;
    const EPSILON15 = 1e-15;
    const EPSILON16 = 1e-16;
    const EPSILON17 = 1e-17;
    const EPSILON18 = 1e-18;
    const EPSILON19 = 1e-19;
    const EPSILON20 = 1e-20;

    /**
     * The log function returns the power to which the base value has to be raised to produce n.
     * @function
     * @param {number} n - Produce value.
     * @param {number} base - Base value.
     * @returns {number} -
     * @example
     * log(64, 2)
     * //returns 6
     */
    function log(n, base) {
        return Math.log(n) / Math.log(base);
    }

    /**
     * Clamp the number.
     * @function
     * @param {number} number - Input number.
     * @param {number} min - Minimal edge.
     * @param {number} max - Maximal edge.
     * @returns {number} -
     * @example
     * clamp(12, 1, 5)
     * //returns 5
     */
    function clamp(number, min, max) {
        return Math.max(min, Math.min(number, max));
    }

    /**
     * Converts degrees value to radians.
     * @function
     * @param {number} degrees - Degree value.
     * @returns {number} -
     */
    function DEG2RAD(degrees) {
        return degrees * RADIANS;
    }

    /**
     * Converts radians value to degrees.
     * @function
     * @param {number} angle - Degree value.
     * @returns {number} -
     */
    function RAD2DEG(angle) {
        return angle * DEGREES;
    }

    /**
     * Check the number is a power of two.
     * @function
     * @param {number} x - Input value.
     * @returns {boolean} -
     */
    function isPowerOfTwo(x) {
        return (x & (x - 1)) === 0;
    }

    /**
     * Returns next value that is power of two.
     * @function
     * @param {number} x - Input value.
     * @returns {number} -
     */
    function nextHighestPowerOfTwo(x) {
        --x;
        for (var i = 1; i < 32; i <<= 1) {
            x = x | (x >> i);
        }
        return x + 1;
    }

    /**
     * Returns random integer number within the bounds.
     * @function
     * @param {number} min - Minimal bound.
     * @param {number} max - Maximal bound.
     * @returns {number} -
     */
    function randomi(min = 0, max = 1) {
        return Math.floor(Math.random() * (max - min)) + min;
    }

    /**
     * Returns random number within the bounds.
     * @function
     * @param {number} [min=0] - Minimal bound.
     * @param {number} [max=1] - Maximal bound.
     * @returns {number} -
     */
    function random(min = 0, max = 1) {
        return Math.random() * (max - min) + min;
    }

    /**
     * Converts degrees value to decimal.
     * @function
     * @param {number} d - Degrees.
     * @param {number} m - Minutes.
     * @param {number} s - Seconds.
     * @param {boolean} [p] - Positive flag. False - default.
     * @returns {number} -
     **/
    function degToDec(d, m, s, p) {
        if (p) {
            return d + m / 60.0 + s / 3600.0;
        } else {
            return -d - m / 60.0 - s / 3600.0;
        }
    }

    /**
     * The modulo operation that also works for negative dividends.
     * @function
     * @param {number} m - The dividend.
     * @param {number} n - The divisor.
     * @returns {number} The remainder.
     */
    function mod(m, n) {
        return ((m % n) + n) % n;
    }

    /**
     * Returns an angle in the range 0 <= angle <= 2Pi which is equivalent to the provided angle.
     * @function
     * @param {number} a - Angle in radians
     * @returns {number} -
     */
    function zeroTwoPI(a) {
        const res = mod(a, TWO_PI);
        if (Math.abs(res) < EPSILON14 && Math.abs(a) > EPSILON14) {
            return TWO_PI;
        }
        return res;
    }

    /**
     * Returns 0.0 if x is smaller than edge and otherwise 1.0.
     * @function
     * @param {number} edge -
     * @param {number} x - Value to edge.
     * @returns {number} -
     */
    function step(edge, x) {
        return x < edge ? 0.0 : 1.0;
    }

    /**
     * The fract function returns the fractional part of x, i.e. x minus floor(x).
     * @function
     * @param {number} x - Input value.
     * @returns {number} -
     */
    function frac(x) {
        return x - Math.floor(x);
    }

    /**
     * Returns Math.log(x) / Math.log(2)
     * @function
     * @param {number} x - Input value.
     * @returns {number} -
     */
    function log2(x) {
        return Math.log(x) / LOG2;
    }

    /**
     * Returns two power of n.
     * @function
     * @param {number} n - Power value.
     * @returns {number} -
     */
    function exp2(n) {
        return Math.pow(2, n);
    }

    /**
     * Returns two power of integer n.
     * @function
     * @param {number} n - Integer power value.
     * @returns {number} -
     */
    function pow2i(n) {
        return 2 << (n - 1);
    }

    /**
     * Returns a slice of linear interpolation t * (h1 - h0)
     * @param {number} t - A value that linearly interpolates between the h0 parameter and the h1 parameter.
     * @param {number} h1 - End value.
     * @param {number} h0 - Start value.
     * @returns {number} -
     */
    function slice(t, h1, h0) {
        return t * (h1 - h0);
    }

    /**
     * Performs a linear interpolation.
     * @function
     * @param {number} t - A value that linearly interpolates between the h0 parameter and the h1 parameter.
     * @param {number} h1 - End value.
     * @param {number} h0 - Start value.
     * @returns {number} -
     */
    function lerp(t, h1, h0) {
        return h0 + t * (h1 - h0);
    }

    function cube(f) {
        return f * f * f;
    }

    function square(f) {
        return f * f;
    }

    function bezier1v(t, p0, p1, p2, p3) {
        return (
            cube(1 - t) * p0 + 3 * square(1 - t) * t * p1 + 3 * (1 - t) * square(t) * p2 + cube(t) * p3
        );
    }

    /**
     * Performs a 3D bezier interpolation.
     * @function
     * @param {number} t - Interpolation value.
     * @param {Vec3} p0 - First control point.
     * @param {Vec3} p1 - Second control point.
     * @param {Vec3} p2 - Third control point.
     * @param {Vec3} p3 - Fourth control point.
     * @returns {Vec3} -
     */
    function bezier3v(t, p0, p1, p2, p3) {
        var u = 1 - t;
        var tt = t * t;
        var uu = u * u;
        var uuu = uu * u;
        var ttt = tt * t;

        return p0
            .scaleTo(uuu)
            .addA(p1.scaleTo(3 * uu * t))
            .addA(p2.scaleTo(3 * u * tt))
            .addA(p3.scaleTo(ttt));
    }

    /**
     * Clamp angle value within 360.
     * @function
     * @param {number} x - Input angle.
     * @returns {number} -
     */
    function rev(x) {
        return x - Math.floor(x / 360.0) * 360.0;
    }

    /**
     * Clamp longitude within: -180 to +180 degrees.
     * @function
     * @param {number} lon - Longitude.
     * @returns {number} -
     */
    function norm_lon(lon) {
        return lon > 180 ? ((lon + 180) % 360) - 180 : lon < -180 ? ((lon - 180) % 360) + 180 : lon;
    }

    /**
     * Returns an angle in the range -Pi <= angle <= Pi which is equivalent to the provided angle.
     * @function
     * @param {number} a - Angle in radians.
     * @returns {number} -
     */
    function negativePItoPI(a) {
        return zeroTwoPI(a + Math.PI) - Math.PI;
    }

    /**
     * Solve using iteration method and a fixed number of steps.
     * @function
     * @param {equationCallback} f - Equation. Used in Euler's equation(see og.orbit) solving.
     * @param {number} x0 - First approximation.
     * @param {number} maxIter - Maximum iterations.
     * @returns {number} -
     */
    function solve_iteration_fixed(f, x0, maxIter) {
        var x = 0;
        var x2 = x0;
        for (var i = 0; i < maxIter; i++) {
            x = x2;
            x2 = f(x);
        }
        return x2;
    }

    /**
     * Solve using iteration; terminate when error is below err or the maximum
     * number of iterations is reached. Used in Euler's equation(see og.orbit) solving.
     * @function
     * @param {equationCallback} f - Equation.
     * @param {number} x0 - First approximation.
     * @param {number} err - Maximal accepted error value.
     * @param {number} maxIter - Maximum iterations.
     * @returns {number} -
     */
    function solve_iteration(f, x0, err, maxIter = 50) {
        var x = 0;
        var x2 = x0;
        for (var i = 0; i < maxIter; i++) {
            x = x2;
            x2 = f(x);
            if (Math.abs(x2 - x) < err) {
                return x2;
            }
        }
        return x2;
    }

    /**
     * Equation function.
     * @callback equationCallback
     * @param {number} x - Equation variable.
     */

    var math = /*#__PURE__*/Object.freeze({
        __proto__: null,
        TWO_PI: TWO_PI,
        PI_TWO: PI_TWO,
        X: X,
        Y: Y,
        Z: Z,
        W: W$1,
        MAX_FLOAT: MAX_FLOAT,
        LOG2: LOG2,
        MAX32: MAX32,
        MAX: MAX,
        MIN: MIN,
        RADIANS: RADIANS,
        DEGREES: DEGREES,
        DEGREES_DOUBLE: DEGREES_DOUBLE,
        RADIANS_HALF: RADIANS_HALF,
        ARCSECONDS_TO_RADIANS: ARCSECONDS_TO_RADIANS,
        RADIANS_TO_HOURS: RADIANS_TO_HOURS,
        HOURS_TO_RADIANS: HOURS_TO_RADIANS,
        HOURS_TO_DEGREES: HOURS_TO_DEGREES,
        DEGREES_TO_HOURS: DEGREES_TO_HOURS,
        SQRT_HALF: SQRT_HALF,
        EPSILON1: EPSILON1,
        EPSILON2: EPSILON2,
        EPSILON3: EPSILON3,
        EPSILON4: EPSILON4,
        EPSILON5: EPSILON5,
        EPSILON6: EPSILON6,
        EPSILON7: EPSILON7,
        EPSILON8: EPSILON8,
        EPSILON9: EPSILON9,
        EPSILON10: EPSILON10,
        EPSILON11: EPSILON11,
        EPSILON12: EPSILON12,
        EPSILON13: EPSILON13,
        EPSILON14: EPSILON14,
        EPSILON15: EPSILON15,
        EPSILON16: EPSILON16,
        EPSILON17: EPSILON17,
        EPSILON18: EPSILON18,
        EPSILON19: EPSILON19,
        EPSILON20: EPSILON20,
        log: log,
        clamp: clamp,
        DEG2RAD: DEG2RAD,
        RAD2DEG: RAD2DEG,
        isPowerOfTwo: isPowerOfTwo,
        nextHighestPowerOfTwo: nextHighestPowerOfTwo,
        randomi: randomi,
        random: random,
        degToDec: degToDec,
        mod: mod,
        zeroTwoPI: zeroTwoPI,
        step: step,
        frac: frac,
        log2: log2,
        exp2: exp2,
        pow2i: pow2i,
        slice: slice,
        lerp: lerp,
        cube: cube,
        square: square,
        bezier1v: bezier1v,
        bezier3v: bezier3v,
        rev: rev,
        norm_lon: norm_lon,
        negativePItoPI: negativePItoPI,
        solve_iteration_fixed: solve_iteration_fixed,
        solve_iteration: solve_iteration
    });

    /**
     * @module og/LonLat
     */

    const HALF_PI$1 = Math.PI * 0.5;
    const INV_PI_BY_180$1 = 180.0 / Math.PI;
    const INV_PI_BY_360 = INV_PI_BY_180$1 * 2.0;
    const PI_BY_360$1 = Math.PI / 360.0;
    const INV_PI_BY_180_HALF_PI = INV_PI_BY_180$1 * HALF_PI$1;

    /**
     * Represents a geographical point with a certain latitude, longitude and height.
     * @class
     * @param {number} [lon] - Longitude.
     * @param {number} [lat] - Latitude.
     * @param {number} [height] - Height over the surface.
     */
    class LonLat {
        /**
         * @param {number} [lon] - Longitude.
         * @param {number} [lat] - Latitude.
         * @param {number} [height] - Height over the surface.
         */
        constructor(lon = 0 , lat = 0, height = 0) {
            /**
             * Longitude.
             * @public
             * @type {number}
             */
            this.lon = lon;

            /**
             * Latitude.
             * @public
             * @type {number}
             */
            this.lat = lat;

            /**
             * Height.
             * @public
             * @type {number}
             */
            this.height = height;
        }

        isZero() {
            return this.lon === 0.0 && this.lat === 0.0 && this.height === 0.0;
        }

        /**
         * Creates coordinates array.
         * @static
         * @param{Array.<Array<number>>} arr - Coordinates array data. (exactly 3 entries)
         * @return{Array.<LonLat>} the same coordinates array but each element is LonLat instance.
         */
        static join(arr) {
            var res = [];
            for (var i = 0; i < arr.length; i++) {
                var ai = arr[i];
                res[i] = new LonLat(ai[0], ai[1], ai[2]);
            }
            return res;
        }

        /**
         * Creates an object by coordinate array.
         * @static
         * @param {Array.<number>} arr - Coordiante array, where first is longitude, second is latitude and third is a height. (exactly 3 entries)
         * @returns {LonLat} -
         */
        static createFromArray(arr) {
            return new LonLat(arr[0], arr[1], arr[2]);
        }

        /**
         * Converts degrees to mercator coordinates.
         * @static
         * @param {number} lon - Degrees longitude.
         * @param {number} lat - Degrees latitude.
         * @param {number} [height] - Height.
         * @returns {LonLat} -
         */
        static forwardMercator(lon, lat, height) {
            return new LonLat(
                lon * POLE_BY_180,
                Math.log(Math.tan((90.0 + lat) * PI_BY_360$1)) * POLE_BY_PI,
                height
            );
        }

        /**
         * Converts mercator to degrees coordinates.
         * @static
         * @param {number} x - Mercator longitude.
         * @param {number} y - Mercator latitude.
         * @param {number} [height] - Height.
         * @returns {LonLat} -
         */
        static inverseMercator(x, y, height = 0) {
            return new LonLat(
                x * INV_POLE_BY_180,
                INV_PI_BY_360 * Math.atan(Math.exp(y * PI_BY_POLE)) - INV_PI_BY_180_HALF_PI,
                height
            );
        }

        /**
         * Sets coordinates.
         * @public
         * @param {number} [lon] - Longitude.
         * @param {number} [lat] - Latitude.
         * @param {number} [height] - Height.
         * @returns {LonLat} -
         */
        set(lon = 0, lat = 0, height = 0) {
            this.lon = lon;
            this.lat = lat;
            this.height = height;
            return this;
        }

        /**
         * Copy coordinates.
         * @public
         * @param {LonLat} [lonLat] - Coordinates to copy.
         * @returns {LonLat} -
         */
        copy(lonLat) {
            this.lon = lonLat.lon;
            this.lat = lonLat.lat;
            this.height = lonLat.height;
            return this;
        }

        /**
         * Clone the coordiante.
         * @public
         * @returns {LonLat} -
         */
        clone() {
            return new LonLat(this.lon, this.lat, this.height);
        }

        /**
         * Converts to mercator coordinates.
         * @public
         * @returns {LonLat} -
         */
        forwardMercator() {
            return LonLat.forwardMercator(this.lon, this.lat, this.height);
        }

        forwardMercatorEPS01() {
            var lat = this.lat;
            if (lat > 89.9) {
                lat = 89.9;
            } else if (lat < -89.9) {
                lat = -89.9;
            }
            return new LonLat(
                this.lon * POLE_BY_180,
                Math.log(Math.tan((90.0 + lat) * PI_BY_360$1)) * POLE_BY_PI
            );
        }

        /**
         * Converts from mercator coordinates.
         * @public
         * @returns {LonLat} -
         */
        inverseMercator() {
            return LonLat.inverseMercator(this.lon, this.lat, this.height);
        }

        /**
         * Compares coordinates.
         * @public
         * @param {LonLat} b - Coordinate to compare with.
         * @returns {boolean} -
         */
        equal(b) {
            if (b.height) {
                return this.lon === b.lon && this.lat === b.lat && this.height === b.height;
            } else {
                return this.lon === b.lon && this.lat === b.lat;
            }
        }
    }

    /**
     * @module og/mercator
     */

    /**
     * Mercator size.
     * @const
     * @type {number}
     */
    const POLE = 20037508.34;

    const POLE2 = POLE * 2.0;

    const PI_BY_POLE = Math.PI / POLE;

    const POLE_BY_PI = POLE / Math.PI;

    const HALF_PI = Math.PI * 0.5;

    const POLE_BY_180 = POLE / 180.0;

    const INV_POLE_BY_180 = 180.0 / POLE;

    const PI_BY_360 = Math.PI / 360.0;

    const PI_BY_180 = Math.PI / 180.0;

    const INV_PI_BY_180 = 180.0 / Math.PI;

    /**
     * Double mercator size.
     * @const
     * @type {number}
     */
    const POLE_DOUBLE = 2.0 * POLE;

    /**
     * One by mercator double size.
     * @const
     * @type {number}
     */
    const ONE_BY_POLE_DOUBLE = 1.0 / POLE_DOUBLE;

    function forward(lonLat) {
        return new LonLat(lonLat.lon * POLE / 180.0, Math.log(Math.tan((90.0 + lonLat.lat) * PI_BY_360)) * POLE_BY_PI, lonLat.height);
    }

    /**
     * Converts degrees longitude to mercator coordinate.
     * @function
     * @param {number} lon - Degrees geodetic longitude.
     * @returns {number} -
     */
    function forward_lon(lon) {
        return lon * POLE / 180.0;
    }

    /**
     * Converts degrees latitude to mercator coordinate.
     * @function
     * @param {number} lat - Degrees geodetic latitude.
     * @returns {number} -
     */
    function forward_lat(lat) {
        return Math.log(Math.tan((90.0 + lat) * PI_BY_360)) * POLE_BY_PI;
    }

    /**
     * Converts mercator longitude to degrees coordinate.
     * @function
     * @param {number} lon - Mercator longitude.
     * @returns {number} -
     */
    function inverse_lon(lon) {
        return 180 * lon / POLE;
    }

    /**
     * Converts mercator latitude to degrees coordinate.
     * @function
     * @param {number} lon - Mercator latitude.
     * @returns {number} -
     */
    function inverse_lat(lat) {
        return INV_PI_BY_180 * (2.0 * Math.atan(Math.exp(lat * PI_BY_POLE)) - HALF_PI);
    }

    /**
     * Returns mercator map tile grid horizontal coordinate index by geodetic 
     * longitude and zoom level. Where top left corner of the grid is 0 coordinate index.
     * @function
     * @param {number} lon - Geodetic degrees longitude.
     * @param {number} zoom - Zoom level.
     * @returns {number}
     */
    function getTileX(lon, zoom) {
        return Math.floor((lon + 180) / 360.0 * Math.pow(2, zoom));
    }

    /**
     * Returns mercator map tile grid vertical coordinate index by geodetic 
     * latitude and zoom level. Where top left corner of the grid is 0 coordinate index.
     * @function
     * @param {number} lat - Geodetic degrees latitude.
     * @param {number} zoom - Zoom level.
     * @returns {number}
     */
    function getTileY(lat, zoom) {
        return Math.floor((1.0 - Math.log(Math.tan(lat * PI_BY_180) + 1.0 / Math.cos(lat * PI_BY_180)) / Math.PI) * 0.5 * Math.pow(2, zoom));
    }

    /**
     * Converts geodetic coordinate array to mercator coordinate array.
     * @function
     * @param {Array.<LonLat>} lonLatArr - LonLat array to convert.
     * @returns {Array.<LonLat>}
     */
    function forwardArray(lonlatArr) {
        var res = [];
        for (var i = 0; i < lonlatArr.length; i++) {
            res.push(lonlatArr[i].forwardMercator());
        }
        return res;
    }

    function getTileExtent(x, y, z) {
        let size = POLE2 / Math.pow(2, z),
            sw = new LonLat(-POLE + x * size, POLE - y * size - size);
        return new Extent(sw, new LonLat(sw.lon + size, sw.lat + size));
    }

    /**
     * Max mercator latitude.
     * @const
     * @type {number}
     */
    const MAX_LAT = inverse_lat(POLE);

    /**
     * Min mercator latitude.
     * @const
     * @type {number}
     */
    const MIN_LAT = -MAX_LAT;

    var mercator = /*#__PURE__*/Object.freeze({
        __proto__: null,
        POLE: POLE,
        POLE2: POLE2,
        PI_BY_POLE: PI_BY_POLE,
        POLE_BY_PI: POLE_BY_PI,
        POLE_BY_180: POLE_BY_180,
        INV_POLE_BY_180: INV_POLE_BY_180,
        POLE_DOUBLE: POLE_DOUBLE,
        ONE_BY_POLE_DOUBLE: ONE_BY_POLE_DOUBLE,
        forward: forward,
        forward_lon: forward_lon,
        forward_lat: forward_lat,
        inverse_lon: inverse_lon,
        inverse_lat: inverse_lat,
        getTileX: getTileX,
        getTileY: getTileY,
        forwardArray: forwardArray,
        getTileExtent: getTileExtent,
        MAX_LAT: MAX_LAT,
        MIN_LAT: MIN_LAT
    });

    /**
     * @module og/Extent
     */

    /**
     * Represents geographical coordinates extent.
     * @class
     * @param {LonLat} [sw] - South West extent corner coordiantes.
     * @param {LonLat} [ne] - North East extent corner coordiantes.
     */
    class Extent {
        /**
         * @param {LonLat} [sw] - South West extent corner coordiantes.
         * @param {LonLat} [ne] - North East extent corner coordiantes.
         */
        constructor(sw = new LonLat(), ne = new LonLat()) {
            /**
             * @public
             */
            this.southWest = sw;
            /**
             * @public
             */
            this.northEast = ne;
        }

        /**
         * Whole mercator extent.
         * @const
         */
        static get FULL_MERC() {
            return new Extent(LonLat.SW_MERC, LonLat.NE_MERC);
        }

        /**
         * Degrees extent from north mercator limit to north pole.
         * @const
         */
        static get NORTH_POLE_DEG() {
            return new Extent(LonLat.NW_MERC_DEG, new LonLat(180.0, 90.0));
        }

        /**
         * Degrees extent from south pole to south mercator limit.
         * @const
         */
        static get SOUTH_POLE_DEG() {
            return new Extent(new LonLat(-180.0, -90.0), LonLat.SE_MERC_DEG);
        }

        /**
         * Creates extent instance from values in array.
         * @static
         * @param {Array.<number>} arr - South west and north east longitude and latidudes packed in array. (exactly 4 entries)
         * @return {Extent} Extent object.
         */
        static createFromArray(arr) {
            return new Extent(new LonLat(arr[0], arr[1]), new LonLat(arr[2], arr[3]));
        }

        /**
         * Creates bound extent instance by coordinate array.
         * @static
         * @param {Array.<LonLat>} arr - Coordinate array.
         * @return {Extent} Extent object.
         */
        static createByCoordinates(arr) {
            let lonmin = MAX,
                lonmax = MIN,
                latmin = MAX,
                latmax = MIN;
            for (let i = 0; i < arr.length; i++) {
                const vi = arr[i];
                if (vi.lon < lonmin) lonmin = vi.lon;
                if (vi.lon > lonmax) lonmax = vi.lon;
                if (vi.lat < latmin) latmin = vi.lat;
                if (vi.lat > latmax) latmax = vi.lat;
            }
            return new Extent(new LonLat(lonmin, latmin), new LonLat(lonmax, latmax));
        }

        /**
         * Creates bound extent instance by coordinate array.
         * @static
         * @param {Array.<Array<number>>} arr - Coordinate array. (exactly 2 entries)
         * @return {Extent} Extent object.
         */
        static createByCoordinatesArr(arr) {
            let lonmin = MAX,
                lonmax = MIN,
                latmin = MAX,
                latmax = MIN;
            for (let i = 0; i < arr.length; i++) {
                const vi = arr[i];
                if (vi[0] < lonmin) lonmin = vi[0];
                if (vi[0] > lonmax) lonmax = vi[0];
                if (vi[1] < latmin) latmin = vi[1];
                if (vi[1] > latmax) latmax = vi[1];
            }
            return new Extent(new LonLat(lonmin, latmin), new LonLat(lonmax, latmax));
        }

        /**
         * Creates extent by meractor grid tile coordinates.
         * @static
         * @param {number} x -
         * @param {number} y -
         * @param {number} z -
         * @param {number} width -
         * @param {number} height -
         * @returns {Extent} -
         */
        static fromTile(x, y, z, width, height) {
            width = width || POLE_DOUBLE;
            height = height || POLE_DOUBLE;
            const H = Math.pow(2, z),
                W = Math.pow(2, z),
                lnSize = width / W,
                ltSize = height / H;

            const left = -width * 0.5 + x * lnSize,
                top = height * 0.5 - y * ltSize,
                bottom = top - ltSize,
                right = left + lnSize;

            return new Extent(new LonLat(left, bottom), new LonLat(right, top));
        }

        /**
         * Sets current bounding extent object by coordinate array.
         * @public
         * @param {Array.<LonLat>} arr - Coordinate array.
         * @return {Extent} Current extent.
         */
        setByCoordinates(arr) {
            let lonmin = MAX,
                lonmax = MIN,
                latmin = MAX,
                latmax = MIN;
            for (let i = 0; i < arr.length; i++) {
                const vi = arr[i];
                if (vi.lon < lonmin) lonmin = vi.lon;
                if (vi.lon > lonmax) lonmax = vi.lon;
                if (vi.lat < latmin) latmin = vi.lat;
                if (vi.lat > latmax) latmax = vi.lat;
            }
            this.southWest.lon = lonmin;
            this.southWest.lat = latmin;
            this.northEast.lon = lonmax;
            this.northEast.lat = latmax;
            return this;
        }

        /**
         * Determines if point inside extent.
         * @public
         * @param {LonLat} lonlat - Coordinate point.
         * @return {boolean} Returns true if point inside extent.
         */
        isInside(lonlat) {
            const sw = this.southWest,
                ne = this.northEast;
            return (
                lonlat.lon >= sw.lon &&
                lonlat.lon <= ne.lon &&
                lonlat.lat >= sw.lat &&
                lonlat.lat <= ne.lat
            );
        }

        /**
         * Returns true if two extent overlap each other.
         * @public
         * @param {Extent} e - Another extent.
         * @return {boolean} -
         */
        overlaps(e) {
            const sw = this.southWest,
                ne = this.northEast;
            return (
                sw.lon <= e.northEast.lon &&
                ne.lon >= e.southWest.lon &&
                sw.lat <= e.northEast.lat &&
                ne.lat >= e.southWest.lat
            );
        }

        /**
         * Gets extent width.
         * @public
         * @return {number} Extent width.
         */
        getWidth() {
            return this.northEast.lon - this.southWest.lon;
        }

        /**
         * Gets extent height.
         * @public
         * @return {number} Extent height.
         */
        getHeight() {
            return this.northEast.lat - this.southWest.lat;
        }

        /**
         * Creates clone instance of the current extent.
         * @public
         * @return {Extent} Extent clone.
         */
        clone() {
            return new Extent(this.southWest.clone(), this.northEast.clone());
        }

        /**
         * Gets the center coordinate of the extent.
         * @public
         * @return {number} Center coordinate.
         */
        getCenter() {
            const sw = this.southWest,
                ne = this.northEast;
            return new LonLat(sw.lon + (ne.lon - sw.lon) * 0.5, sw.lat + (ne.lat - sw.lat) * 0.5);
        }

        /**
         * @public
         */
        getNorthWest() {
            return new LonLat(this.southWest.lon, this.northEast.lat);
        }

        /**
         * @public
         */
        getNorthEast() {
            return new LonLat(this.northEast.lon, this.northEast.lat);
        }

        getSouthWest() {
            return new LonLat(this.southWest.lon, this.southWest.lat);
        }

        /**
         * @public
         */
        getSouthEast() {
            return new LonLat(this.northEast.lon, this.southWest.lat);
        }

        /**
         * @public
         */
        getNorth() {
            return this.northEast.lat;
        }

        getEast() {
            return this.northEast.lon;
        }

        /**
         * @public
         */
        getWest() {
            return this.southWest.lon;
        }

        /**
         * @public
         */
        getSouth() {
            return this.southWest.lat;
        }

        /**
         * Returns extents are equals.
         * @param {Extent} extent - Extent.
         * @returns {boolean} -
         */
        equals(extent) {
            return (
                this.southWest.lon === extent.southWest.lon &&
                this.southWest.lat === extent.southWest.lat &&
                this.northEast.lon === extent.northEast.lon &&
                this.northEast.lat === extent.northEast.lat
            );
        }

        /**
         * Converts extent coordinates to mercator projection coordinates.
         * @public
         * @return {Extent} New instance of the current extent.
         */
        forwardMercator() {
            return new Extent(this.southWest.forwardMercator(), this.northEast.forwardMercator());
        }

        /**
         * Converts extent coordinates from mercator projection to degrees.
         * @public
         * @return {Extent} New instance of the current extent.
         */
        inverseMercator() {
            return new Extent(this.southWest.inverseMercator(), this.northEast.inverseMercator());
        }

        /**
         * Gets cartesian bounding bounds of the current ellipsoid.
         * @public
         * @param {Ellipsoid} ellipsoid - Ellipsoid.
         * @return {Array.<number>} Cartesian 3d coordinate array. (exactly 6 entries)
         */
        getCartesianBounds(ellipsoid) {
            let xmin = MAX,
                xmax = MIN,
                ymin = MAX,
                ymax = MIN,
                zmin = MAX,
                zmax = MIN;

            const v = [
                new LonLat(this.southWest.lon, this.southWest.lat),
                new LonLat(this.southWest.lon, this.northEast.lat),
                new LonLat(this.northEast.lon, this.northEast.lat),
                new LonLat(this.northEast.lon, this.southWest.lat)
            ];

            for (let i = 0; i < v.length; i++) {
                const coord = ellipsoid.lonLatToCartesian(v[i]);
                const x = coord.x,
                    y = coord.y,
                    z = coord.z;
                if (x < xmin) xmin = x;
                if (x > xmax) xmax = x;
                if (y < ymin) ymin = y;
                if (y > ymax) ymax = y;
                if (z < zmin) zmin = z;
                if (z > zmax) zmax = z;
            }

            return [xmin, ymin, zmin, xmax, ymax, zmax];
        }

        toString() {
            return (
                `[${this.southWest.lon.toFixed(5)}, ${this.southWest.lat.toFixed(5)}, ${this.northEast.lon.toFixed(5)}, ${this.northEast.lat.toFixed(5)}]`
            );
        }
    }

    /**
     * @module og/math/Vec4
     */

    /**
     * Class represents a 4d vector.
     * @class
     * @param {number} [x] - First value.
     * @param {number} [y] - Second value.
     * @param {number} [z] - Third value.
     * @param {number} [w] - Fourth value.
     */
    class Vec4 {
        constructor(x = 0.0, y = 0.0, z = 0.0, w = 0.0) {
            /**
             * @public
             * @type {number}
             */
            this.x = x || 0.0;

            /**
             * @public
             * @type {number}
             */
            this.y = y || 0.0;

            /**
             * @public
             * @type {number}
             */
            this.z = z || 0.0;

            /**
             * @public
             * @type {number}
             */
            this.w = w || 0.0;
        }

        /**
         * Identity vector [0,0,0,1].
         * @const
         * @type {Vec4}
         */
        static get identity() {
            return new Vec4(0, 0, 0, 1);
        }

        /**
         * Creates 4d vector from array.
         * @function
         * @param {Array.<number>} - (exactly 4 entries)
         * @returns {Vec4}
         */
        static fromVec(arr) {
            return new Vec4(arr[0], arr[1], arr[2], arr[3]);
        }

        /**
         * Converts to 3d vector, without fourth value.
         * @public
         * @returns {Vec3}
         */
        toVec3() {
            return new Vec3(this.x, this.y, this.z);
        }

        /**
         * Returns clone vector.
         * @public
         * @returns {Vec4}
         */
        clone() {
            return new Vec4(this.x, this.y, this.z, this.w);
        }

        /**
         * Compares with vector. Returns true if it equals another.
         * @public
         * @param {Vec4} p - Vector to compare.
         * @returns {boolean}
         */
        equal(v) {
            return this.x === v.x && this.y === v.y && this.z === v.z && this.w === v.w;
        }

        /**
         * Copy input vector's values.
         * @param {Vec4} v - Vector to copy.
         * @returns {Vec4}
         */
        copy(v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            this.w = v.w;
            return this;
        }

        /**
         * Converts vector to a number array.
         * @public
         * @returns {Array.<number>} - (exactly 4 entries)
         * @deprecated
         */
        toVec() {
            return [this.x, this.y, this.z, this.w];
        }

        /**
         * Converts vector to a number array.
         * @public
         * @returns {Array.<number>} - (exactly 4 entries)
         */
        toArray() {
            return [this.x, this.y, this.z, this.w];
        }

        /**
         * Sets vector's values.
         * @public
         * @param {number} x - Value X.
         * @param {number} y - Value Y.
         * @param {number} z - Value Z.
         * @param {number} w - Value W.
         * @returns {Vec4}
         */
        set(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        }

        /**
         * Adds vector to the current.
         * @public
         * @param {Vec4}
         * @returns {Vec4}
         */
        addA(v) {
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            this.w += v.w;
            return this;
        }

        /**
         * Subtract vector from the current.
         * @public
         * @param {Vec4} v - Subtract vector.
         * @returns {Vec4}
         */
        subA(v) {
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            this.w -= v.w;
            return this;
        }

        /**
         * Scale current vector.
         * @public
         * @param {number} scale - Scale value.
         * @returns {Vec4}
         */
        scale(scale) {
            this.x *= scale;
            this.y *= scale;
            this.z *= scale;
            this.w *= scale;
            return this;
        }

        /**
         * Makes vector affinity. Thereby fourh component becomes to 1.0.
         * @public
         * @returns {Vec4}
         */
        affinity() {
            var iw = 1 / this.w;
            this.x *= iw;
            this.y *= iw;
            this.z *= iw;
            this.w = 1.0;
            return this;
        }

        /**
         * Scale current vector to another instance.
         * @public
         * @param {number} scale - Scale value.
         * @returns {Vec3}
         */
        scaleTo(scale) {
            return new Vec4(this.x * scale, this.y * scale, this.z * scale, this.w * scale);
        }

        /**
         * Vector's edge function that returns vector where each component is 0.0 if it's smaller then edge and otherwise 1.0.
         * @public
         * @returns {Vec4}
         */
        getStep(edge) {
            return new Vec4(
                this.x < edge ? 0.0 : 1.0,
                this.y < edge ? 0.0 : 1.0,
                this.z < edge ? 0.0 : 1.0,
                this.w < edge ? 0.0 : 1.0
            );
        }

        /**
         * The vector fract function returns the vector of fractional parts of each value, i.e. x minus floor(x).
         * @public
         * @returns {Vec4}
         */
        getFrac(v) {
            return new Vec4(frac(v.x), frac(v.y), frac(v.z), frac(v.w));
        }

        /**
         * Gets vectors dot production.
         * @public
         * @param {math.Vec4} v - Another vector.
         * @returns {number} - Dot product.
         */
        dot(v) {
            return v.x * this.x + v.y * this.y + v.z * this.z + v.w * this.w;
        }

        /**
         * Returns true if vector's values are zero.
         * @public
         * @returns {boolean} -
         */
        isZero() {
            return !(this.x || this.y || this.z || this.w);
        }
    }

    /**
     * Class represents a 4x4 matrix.
     * @class
     */
    class Mat4 {
        constructor() {
            /**
             * A 4x4 matrix, indexable as a column-major order array.
             * @public
             * @type {Array.<number>}
             */
            this._m = new Array(16);
        }

        /**
         * Returns identity matrix instance.
         * @static
         * @returns {Mat4} -
         */
        static identity() {
            var res = new Mat4();
            res._m[0] = 1;
            res._m[1] = 0;
            res._m[2] = 0;
            res._m[3] = 0;
            res._m[4] = 0;
            res._m[5] = 1;
            res._m[6] = 0;
            res._m[7] = 0;
            res._m[8] = 0;
            res._m[9] = 0;
            res._m[10] = 1;
            res._m[11] = 0;
            res._m[12] = 0;
            res._m[13] = 0;
            res._m[14] = 0;
            res._m[15] = 1;
            return res;
        }

        /**
         * Sets column-major order array matrix.
         * @public
         * @param {Array.<number>} m - Matrix array.
         * @returns {Mat4} -
         */
        set(m) {
            this._m[0] = m[0];
            this._m[1] = m[1];
            this._m[2] = m[2];
            this._m[3] = m[3];
            this._m[4] = m[4];
            this._m[5] = m[5];
            this._m[6] = m[6];
            this._m[7] = m[7];
            this._m[8] = m[8];
            this._m[9] = m[9];
            this._m[10] = m[10];
            this._m[11] = m[11];
            this._m[12] = m[12];
            this._m[13] = m[13];
            this._m[14] = m[14];
            this._m[15] = m[15];
            return this;
        }

        /**
         * Duplicates a Matrix3 instance.
         * @public
         * @returns {Mat4} -
         */
        clone() {
            var res = new Mat4();
            res.set(this);
            return res;
        }

        /**
         * Copy matrix.
         * @public
         * @param {Mat3} a - Matrix to copy.
         */
        copy(a) {
            this.set(a._m);
        }

        /**
         * Converts to 3x3 matrix.
         * @public
         * @returns {Mat3} -
         */
        toMatrix3() {
            var res = new Mat3();
            var a = this._m,
                b = res._m;
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = a[4];
            b[4] = a[5];
            b[5] = a[6];
            b[6] = a[8];
            b[7] = a[9];
            b[8] = a[10];
            return res;
        }

        /**
         * Multiply to 3d vector.
         * @public
         * @param {Vec3} p - 3d vector.
         * @returns {Vec3} -
         */
        mulVec3(p) {
            var d = p.x,
                e = p.y,
                g = p.z;
            return new Vec3(
                this._m[0] * d + this._m[4] * e + this._m[8] * g + this._m[12],
                this._m[1] * d + this._m[5] * e + this._m[9] * g + this._m[13],
                this._m[2] * d + this._m[6] * e + this._m[10] * g + this._m[14]
            );
        }

        /**
         * Multiply to 4d vector.
         * @public
         * @param {Vec4} p - 4d vector.
         * @returns {Vec4} -
         */
        mulVec4(p) {
            var d = p.x,
                e = p.y,
                g = p.z,
                f = p.w;
            return new Vec4(
                this._m[0] * d + this._m[4] * e + this._m[8] * g + this._m[12] * f,
                this._m[1] * d + this._m[5] * e + this._m[9] * g + this._m[13] * f,
                this._m[2] * d + this._m[6] * e + this._m[10] * g + this._m[14] * f,
                this._m[3] * d + this._m[7] * e + this._m[11] * g + this._m[15] * f
            );
        }

        /**
         * Creates an inversed 3x3 matrix of the current.
         * @public
         * @returns {Mat3} -
         */
        toInverseMatrix3() {
            var a = this._m;
            var c = a[0],
                d = a[1],
                e = a[2],
                g = a[4],
                f = a[5],
                h = a[6],
                i = a[8],
                j = a[9],
                k = a[10],
                l = k * f - h * j,
                o = -k * g + h * i,
                m = j * g - f * i,
                n = c * l + d * o + e * m;

            if (!n) {
                return null;
            }

            n = 1 / n;

            var res = new Mat3();
            res._m[0] = l * n;
            res._m[1] = (-k * d + e * j) * n;
            res._m[2] = (h * d - e * f) * n;
            res._m[3] = o * n;
            res._m[4] = (k * c - e * i) * n;
            res._m[5] = (-h * c + e * g) * n;
            res._m[6] = m * n;
            res._m[7] = (-j * c + d * i) * n;
            res._m[8] = (f * c - d * g) * n;
            return res;
        }

        /**
         * Creates an inversed matrix of the current.
         * @public
         * @returns {Mat4} -
         */
        inverseTo(res) {
            var c = this._m[0],
                d = this._m[1],
                e = this._m[2],
                g = this._m[3],
                f = this._m[4],
                h = this._m[5],
                i = this._m[6],
                j = this._m[7],
                k = this._m[8],
                l = this._m[9],
                o = this._m[10],
                m = this._m[11],
                n = this._m[12],
                p = this._m[13],
                r = this._m[14],
                s = this._m[15],
                A = c * h - d * f,
                B = c * i - e * f,
                t = c * j - g * f,
                u = d * i - e * h,
                v = d * j - g * h,
                w = e * j - g * i,
                x = k * p - l * n,
                y = k * r - o * n,
                z = k * s - m * n,
                C = l * r - o * p,
                D = l * s - m * p,
                E = o * s - m * r,
                q = 1 / (A * E - B * D + t * C + u * z - v * y + w * x);

            res = res || new Mat4();

            res._m[0] = (h * E - i * D + j * C) * q;
            res._m[1] = (-d * E + e * D - g * C) * q;
            res._m[2] = (p * w - r * v + s * u) * q;
            res._m[3] = (-l * w + o * v - m * u) * q;
            res._m[4] = (-f * E + i * z - j * y) * q;
            res._m[5] = (c * E - e * z + g * y) * q;
            res._m[6] = (-n * w + r * t - s * B) * q;
            res._m[7] = (k * w - o * t + m * B) * q;
            res._m[8] = (f * D - h * z + j * x) * q;
            res._m[9] = (-c * D + d * z - g * x) * q;
            res._m[10] = (n * v - p * t + s * A) * q;
            res._m[11] = (-k * v + l * t - m * A) * q;
            res._m[12] = (-f * C + h * y - i * x) * q;
            res._m[13] = (c * C - d * y + e * x) * q;
            res._m[14] = (-n * u + p * B - r * A) * q;
            res._m[15] = (k * u - l * B + o * A) * q;
            return res;
        }

        /**
         * Creates a trasposed matrix of the current.
         * @public
         * @returns {Mat4} -
         */
        transposeTo() {
            var res = new Mat4();
            res._m[0] = this._m[0];
            res._m[1] = this._m[4];
            res._m[2] = this._m[8];
            res._m[3] = this._m[12];
            res._m[4] = this._m[1];
            res._m[5] = this._m[5];
            res._m[6] = this._m[9];
            res._m[7] = this._m[13];
            res._m[8] = this._m[2];
            res._m[9] = this._m[6];
            res._m[10] = this._m[10];
            res._m[11] = this._m[14];
            res._m[12] = this._m[3];
            res._m[13] = this._m[7];
            res._m[14] = this._m[11];
            res._m[15] = this._m[15];
            return res;
        }

        /**
         * Sets matrix to identity.
         * @public
         * @returns {Mat4} -
         */
        setIdentity() {
            this._m[0] = 1;
            this._m[1] = 0;
            this._m[2] = 0;
            this._m[3] = 0;
            this._m[4] = 0;
            this._m[5] = 1;
            this._m[6] = 0;
            this._m[7] = 0;
            this._m[8] = 0;
            this._m[9] = 0;
            this._m[10] = 1;
            this._m[11] = 0;
            this._m[12] = 0;
            this._m[13] = 0;
            this._m[14] = 0;
            this._m[15] = 1;
            return this;
        }

        /**
         * Computes the product of two matrices.
         * @public
         * @param {Mat4} mx - Matrix to multiply.
         * @returns {Mat4} -
         */
        mul(mx) {
            let d = this._m[0],
                e = this._m[1],
                g = this._m[2],
                f = this._m[3],
                h = this._m[4],
                i = this._m[5],
                j = this._m[6],
                k = this._m[7],
                l = this._m[8],
                o = this._m[9],
                m = this._m[10],
                n = this._m[11],
                p = this._m[12],
                r = this._m[13],
                s = this._m[14],
                a = this._m[15];

            let A = mx._m[0],
                B = mx._m[1],
                t = mx._m[2],
                u = mx._m[3],
                v = mx._m[4],
                w = mx._m[5],
                x = mx._m[6],
                y = mx._m[7],
                z = mx._m[8],
                C = mx._m[9],
                D = mx._m[10],
                E = mx._m[11],
                q = mx._m[12],
                F = mx._m[13],
                G = mx._m[14],
                b = mx._m[15];

            var res = new Mat4();
            res._m[0] = A * d + B * h + t * l + u * p;
            res._m[1] = A * e + B * i + t * o + u * r;
            res._m[2] = A * g + B * j + t * m + u * s;
            res._m[3] = A * f + B * k + t * n + u * a;
            res._m[4] = v * d + w * h + x * l + y * p;
            res._m[5] = v * e + w * i + x * o + y * r;
            res._m[6] = v * g + w * j + x * m + y * s;
            res._m[7] = v * f + w * k + x * n + y * a;
            res._m[8] = z * d + C * h + D * l + E * p;
            res._m[9] = z * e + C * i + D * o + E * r;
            res._m[10] = z * g + C * j + D * m + E * s;
            res._m[11] = z * f + C * k + D * n + E * a;
            res._m[12] = q * d + F * h + G * l + b * p;
            res._m[13] = q * e + F * i + G * o + b * r;
            res._m[14] = q * g + F * j + G * m + b * s;
            res._m[15] = q * f + F * k + G * n + b * a;
            return res;
        }

        /**
         * Add translation vector to the current matrix.
         * @public
         * @param {Vec3} v - Translate vector.
         * @returns {Mat4} -
         */
        translate(v) {
            var d = v.x,
                e = v.y,
                b = v.z;
            var a = this._m;
            a[12] = a[0] * d + a[4] * e + a[8] * b + a[12];
            a[13] = a[1] * d + a[5] * e + a[9] * b + a[13];
            a[14] = a[2] * d + a[6] * e + a[10] * b + a[14];
            a[15] = a[3] * d + a[7] * e + a[11] * b + a[15];
            return this;
        }

        /**
         * Sets translation matrix to the position.
         * @public
         * @param {Vec3} v - Translate to position.
         * @returns {Mat4} -
         */
        translateToPosition(v) {
            var a = this._m;
            a[12] = v.x;
            a[13] = v.y;
            a[14] = v.z;
            return this;
        }

        /**
         * Rotate currrent matrix around the aligned axis and angle.
         * @public
         * @param {Vec3} u - Aligned axis.
         * @param {number} angle - Aligned axis angle in radians.
         * @returns {Mat4} -
         * @todo: OPTIMIZE: reveal multiplication
         */
        rotate(u, angle) {
            var c = Math.cos(angle),
                s = Math.sin(angle);
            var rot = new Mat4();
            var mx = rot._m;
            mx[0] = c + (1 - c) * u.x * u.x;
            mx[1] = (1 - c) * u.y * u.x - s * u.z;
            mx[2] = (1 - c) * u.z * u.x + s * u.y;
            mx[3] = 0;
            mx[4] = (1 - c) * u.x * u.y + s * u.z;
            mx[5] = c + (1 - c) * u.y * u.y;
            mx[6] = (1 - c) * u.z * u.y - s * u.x;
            mx[7] = 0;
            mx[8] = (1 - c) * u.x * u.z - s * u.y;
            mx[9] = (1 - c) * u.y * u.z + s * u.x;
            mx[10] = c + (1 - c) * u.z * u.z;
            mx[11] = 0;
            mx[12] = 0;
            mx[13] = 0;
            mx[14] = 0;
            mx[15] = 1;
            return this.mul(rot);
        }

        /**
         * Sets current rotation matrix around the aligned axis and angle.
         * @public
         * @param {Vec3} u - Aligned axis.
         * @param {number} angle - Aligned axis angle in radians.
         * @returns {Mat4} -
         */
        setRotation(u, angle) {
            var c = Math.cos(angle),
                s = Math.sin(angle);
            var mx = this._m;
            mx[0] = c + (1 - c) * u.x * u.x;
            mx[1] = (1 - c) * u.y * u.x - s * u.z;
            mx[2] = (1 - c) * u.z * u.x + s * u.y;
            mx[3] = 0;
            mx[4] = (1 - c) * u.x * u.y + s * u.z;
            mx[5] = c + (1 - c) * u.y * u.y;
            mx[6] = (1 - c) * u.z * u.y - s * u.x;
            mx[7] = 0;
            mx[8] = (1 - c) * u.x * u.z - s * u.y;
            mx[9] = (1 - c) * u.y * u.z + s * u.x;
            mx[10] = c + (1 - c) * u.z * u.z;
            mx[11] = 0;
            mx[12] = 0;
            mx[13] = 0;
            mx[14] = 0;
            mx[15] = 1;
            return this;
        }

        /**
         * Gets the rotation matrix from one vector to another.
         * @public
         * @param {Vec3} a - Firtst vector.
         * @param {Vec3} b - Second vector.
         * @returns {Mat4} -
         */
        rotateBetweenVectors(a, b) {
            var q = Quat.getRotationBetweenVectors(a, b);
            return q.getMat4();
        }

        /**
         * Scale current matrix to the vector values.
         * @public
         * @param {Vec3} v - Scale vector.
         * @returns {Mat4} -
         */
        scale(v) {
            var mx = this._m;
            mx[0] = mx[0] * v.x;
            mx[1] = mx[1] * v.x;
            mx[2] = mx[2] * v.x;
            mx[3] = mx[3] * v.x;
            mx[4] = mx[4] * v.y;
            mx[5] = mx[5] * v.y;
            mx[6] = mx[6] * v.y;
            mx[7] = mx[7] * v.y;
            mx[8] = mx[8] * v.z;
            mx[9] = mx[9] * v.z;
            mx[10] = mx[10] * v.z;
            mx[11] = mx[11] * v.z;
            return this;
        }

        /**
         * Sets perspective projection matrix frustum values.
         * @public
         * @param {number} left -
         * @param {number} right -
         * @param {number} bottom -
         * @param {number} top -
         * @param {number} near -
         * @param {number} far -
         * @returns {Mat4} -
         */
        setPerspective(left, right, bottom, top, near, far) {
            var h = right - left,
                i = top - bottom,
                j = far - near;
            this._m[0] = (near * 2) / h;
            this._m[1] = 0;
            this._m[2] = 0;
            this._m[3] = 0;
            this._m[4] = 0;
            this._m[5] = (near * 2) / i;
            this._m[6] = 0;
            this._m[7] = 0;
            this._m[8] = (right + left) / h;
            this._m[9] = (top + bottom) / i;
            this._m[10] = -(far + near) / j;
            this._m[11] = -1;
            this._m[12] = 0;
            this._m[13] = 0;
            this._m[14] = -(far * near * 2) / j;
            this._m[15] = 0;
            return this;
        }

        /**
         * Creates current orthographic projection matrix.
         * @public
         * @param {number} left -
         * @param {number} right -
         * @param {number} bottom -
         * @param {number} top -
         * @param {number} near -
         * @param {number} far -
         * @return {Mat4} -
         */
        setOrtho(left, right, bottom, top, near, far) {
            var lr = 1.0 / (left - right),
                bt = 1.0 / (bottom - top),
                nf = 1.0 / (near - far),
                m = this._m;

            m[0] = -2.0 * lr;
            m[1] = 0;
            m[2] = 0;
            m[3] = 0;
            m[4] = 0;
            m[5] = -2.0 * bt;
            m[6] = 0;
            m[7] = 0;
            m[8] = 0;
            m[9] = 0;
            m[10] = 2.0 * nf;
            m[11] = 0;
            m[12] = (left + right) * lr;
            m[13] = (top + bottom) * bt;
            m[14] = (far + near) * nf;
            m[15] = 1.0;
            return this;
        }

        /**
         * Sets current rotation matrix by euler's angles.
         * @public
         * @param {number} ax - Rotation angle in radians arond X axis.
         * @param {number} ay - Rotation angle in radians arond Y axis.
         * @param {number} az - Rotation angle in radians arond Z axis.
         * @returns {Mat4} -
         */
        eulerToMatrix(ax, ay, az) {
            var a = Math.cos(ax),
                b = Math.sin(ax),
                c = Math.cos(ay),
                d = Math.sin(ay),
                e = Math.cos(az),
                f = Math.sin(az);

            var ad = a * d,
                bd = b * d;

            var mat = this._m;

            mat[0] = c * e;
            mat[1] = -c * f;
            mat[2] = -d;
            mat[4] = -bd * e + a * f;
            mat[5] = bd * f + a * e;
            mat[6] = -b * c;
            mat[8] = ad * e + b * f;
            mat[9] = -ad * f + b * e;
            mat[10] = a * c;
            mat[3] = mat[7] = mat[11] = mat[12] = mat[13] = mat[14] = 0;
            mat[15] = 1;

            return this;
        }
    }

    /**
     * @module og/math/Mat3
     */

    /**
     * Class represents a 3x3 matrix.
     * @class
     */
    class Mat3 {
        constructor() {
            /**
             * A 3x3 matrix, indexable as a column-major order array.
             * @public
             * @type {Array.<number>}
             */
            this._m = new Array(9);
        }

        /**
         * Sets column-major order array matrix.
         * @public
         * @param {Array.<number>} m - Matrix array.
         * @returns {Mat3}
         */
        set(m) {
            this._m[0] = m[0];
            this._m[1] = m[1];
            this._m[2] = m[2];
            this._m[3] = m[3];
            this._m[4] = m[4];
            this._m[5] = m[5];
            this._m[6] = m[6];
            this._m[7] = m[7];
            this._m[8] = m[8];
            return this;
        }

        /**
         * Duplicates a Mat3 instance.
         * @public
         * @returns {Mat3}
         */
        clone() {
            var res = new Mat3();
            res.set(this);
            return res;
        }

        /**
         * Copy matrix.
         * @public
         * @param {Mat3} a - Matrix to copy.
         * @returns {Mat3}
         */
        copy(a) {
            return this.set(a._m);
        }

        /**
         * Creates trasposed matrix from the current.
         * @public
         * @returns {Mat3}
         */
        transposeTo() {
            var res = new Mat3();
            var m = this._m;
            res._m[0] = m[0];
            res._m[1] = m[3];
            res._m[2] = m[6];
            res._m[3] = m[1];
            res._m[4] = m[4];
            res._m[5] = m[7];
            res._m[6] = m[2];
            res._m[7] = m[5];
            res._m[8] = m[8];
            return res;
        }

        /**
         * Sets matrix to identity.
         * @public
         * @returns {Mat3}
         */
        setIdentity() {
            this._m[0] = 1;
            this._m[1] = 0;
            this._m[2] = 0;
            this._m[3] = 0;
            this._m[4] = 1;
            this._m[5] = 0;
            this._m[6] = 0;
            this._m[7] = 0;
            this._m[8] = 1;
            return this;
        }

        /**
         * Multiply to 3d vector.
         * @public
         * @params {Vec3} p - 3d vector.
         * @returns {Vec3}
         */
        mulVec(p) {
            var d = p.x,
                e = p.y,
                g = p.z;
            var m = this._m;
            return new Vec3(
                m[0] * d + m[3] * e + m[6] * g,
                m[1] * d + m[4] * e + m[7] * g,
                m[2] * d + m[5] * e + m[8] * g
            );
        }

        /**
         * Converts to 4x4 matrix.
         * @public
         * @returns {Mat4}
         */
        toMatrix4() {
            var res = new Mat4();
            var b = res._m;
            var a = this._m;
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = 0;
            b[4] = a[3];
            b[5] = a[4];
            b[6] = a[5];
            b[7] = 0;
            b[8] = a[6];
            b[9] = a[7];
            b[10] = a[8];
            b[11] = 0;
            b[12] = 0;
            b[13] = 0;
            b[14] = 0;
            b[15] = 1;
            return res;
        }
    }

    /**
     * A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space.
     * @constructor
     * @param {Number} [x=0.0] The X component.
     * @param {Number} [y=0.0] The Y component.
     * @param {Number} [z=0.0] The Z component.
     * @param {Number} [w=0.0] The W component.
     */
    class Quat {
        /**
         * @param {Number} [x=0.0] The X component.
         * @param {Number} [y=0.0] The Y component.
         * @param {Number} [z=0.0] The Z component.
         * @param {Number} [w=0.0] The W component.
         */
        constructor(x = 0.0, y = 0.0, z = 0.0, w = 0.0) {
            /**
             * The X component.
             * @public
             * @type {Number}
             * @default 0.0
             */
            this.x = x || 0.0;

            /**
             * The Y component.
             * @public
             * @type {Number}
             * @default 0.0
             */
            this.y = y || 0.0;

            /**
             * The Z component.
             * @public
             * @type {Number}
             * @default 0.0
             */
            this.z = z || 0.0;

            /**
             * The W component.
             * @public
             * @type {Number}
             * @default 0.0
             */
            this.w = w || 0.0;
        }

        /**
         * Identity Quat.
         * @const
         * @type {Quat}
         */
        static get IDENTITY() {
            return new Quat(0.0, 0.0, 0.0, 1.0);
        }

        /**
         * Returns a Quat represents rotation around X axis.
         * @static
         * @param {number} a - The angle in radians to rotate around the axis.
         * @returns {Quat} -
         */
        static xRotation(a) {
            a *= 0.5;
            return new Quat(Math.sin(a), 0.0, 0.0, Math.cos(a));
        }

        /**
         * Returns a Quat represents rotation around Y axis.
         * @static
         * @param {number} a - The angle in radians to rotate around the axis.
         * @returns {Quat} -
         */
        static yRotation(a) {
            a *= 0.5;
            return new Quat(0.0, Math.sin(a), 0.0, Math.cos(a));
        }

        /**
         * Returns a Quat represents rotation around Z axis.
         * @static
         * @param {number} a - The angle in radians to rotate around the axis.
         * @returns {Quat} -
         */
        static zRotation(a) {
            a *= 0.5;
            return new Quat(0.0, 0.0, Math.sin(a), Math.cos(a));
        }

        /**
         * Computes a Quat representing a rotation around an axis.
         * @static
         * @param {Vec3} axis - The axis of rotation.
         * @param {number} [angle=0.0] The angle in radians to rotate around the axis.
         * @returns {Quat} -
         */
        static axisAngleToQuat(axis, angle) {
            angle = angle || 0.0;
            var v = axis.normal();
            var half_angle = angle * 0.5;
            var sin_a = Math.sin(half_angle);
            return new Quat(v.x * sin_a, v.y * sin_a, v.z * sin_a, Math.cos(half_angle));
        }

        /**
         * Computes a rotation from the given heading and up vector.
         * @static
         * @param {Vec3} forward - Heading target coordinates.
         * @param {Vec3} up - Up vector.
         * @returns {Quat} -
         */
        static getLookRotation(forward, up) {
            var f = forward.normal().negate();
            var s = up.cross(f).normalize();
            var u = f.cross(s);

            var z = 1.0 + s.x + u.y + f.z;

            if (z > 0.000001) {
                let fd = 1.0 / (2.0 * Math.sqrt(z));
                return new Quat((f.y - u.z) * fd, (s.z - f.x) * fd, (u.x - s.y) * fd, 0.25 / fd);
            }

            if (s.x > u.y && s.x > f.z) {
                let fd = 1.0 / (2.0 * Math.sqrt(1.0 + s.x - u.y - f.z));
                return new Quat(0.25 / fd, (u.x + s.y) * fd, (s.z + f.x) * fd, (f.y - u.z) * fd);
            }

            if (u.y > f.z) {
                let fd = 1.0 / (2.0 * Math.sqrt(1.0 + u.y - s.x - f.z));
                return new Quat((u.x + s.y) * fd, 0.25 / fd, (f.y + u.z) * fd, (s.z - f.x) * fd);
            }

            let fd = 1.0 / (2.0 * Math.sqrt(1.0 + f.z - s.x - u.y));
            return new Quat((s.z + f.x) * fd, (f.y + u.z) * fd, 0.25 / fd, (u.x - s.y) * fd);
        }

        /**
         * Computes a Quat from from source point heading to the destination point.
         * @static
         * @param {Vec3} sourcePoint - Source coordinate.
         * @param {Vec3} destPoint - Destination coordinate.
         * @returns {Quat} -
         */
        static getLookAtSourceDest(sourcePoint, destPoint) {
            var forwardVector = destPoint.subA(sourcePoint).normalize();
            var dot = Vec3.FORWARD.dot(forwardVector);
            if (Math.abs(dot - -1.0) < 0.000001) {
                return Quat.axisAngleToQuat(Vec3.UP, Math.PI);
            }
            if (Math.abs(dot - 1.0) < 0.000001) {
                return new Quat(0.0, 0.0, 0.0, 1.0);
            }
            var rotAngle = Math.acos(dot);
            var rotAxis = Vec3.FORWARD.cross(forwardVector).normalize();
            return Quat.axisAngleToQuat(rotAxis, rotAngle);
        }

        /**
         * Compute rotation between two vectors.
         * @static
         * @param {Vec3} u - First vector.
         * @param {Vec3} v - Second vector.
         * @returns {Quat} -
         */
        static getRotationBetweenVectors(u, v) {
            var w = u.cross(v);
            var q = new Quat(w.x, w.y, w.z, 1.0 + u.dot(v));
            return q.normalize();
        }

        /**
         * Compute rotation between two vectors.
         * @static
         * @param {Vec3} u - First vector.
         * @param {Vec3} v - Second vector.
         * @param {Quat} res
         * @returns {Quat} -
         */
        static getRotationBetweenVectorsRes(u, v, res) {
            var w = u.cross(v);
            res.set(w.x, w.y, w.z, 1.0 + u.dot(v));
            return res.normalize();
        }

        /**
         * Compute rotation between two vectors with around vector up
         * for exactly opposite vectors. If vectors exaclty in the same
         * direction than returns identity Quat.
         * @static
         * @param {Vec3} source - First vector.
         * @param {Vec3} dest - Second vector.
         * @param {Vec3} up - Up vector.
         * @returns {Quat} -
         */
        static getRotationBetweenVectorsUp(source, dest, up) {
            var dot = source.dot(dest);
            if (Math.abs(dot + 1.0) < 0.000001) {
                // vector source and dest point exactly in the opposite direction,
                // so it is a 180 degrees turn around the up-axis
                return Quat.axisAngleToQuat(up, Math.PI);
            }
            if (Math.abs(dot - 1.0) < 0.000001) {
                // vector source and dest point exactly in the same direction
                // so we return the identity Quat
                return new Quat(0, 0, 0, 1);
            }
            var rotAngle = Math.acos(dot);
            var rotAxis = source.cross(dest).normalize();
            return Quat.axisAngleToQuat(rotAxis, rotAngle);
        }

        /**
         * Returns true if the components are zero.
         * @public
         * @param {Quat} q - Quat to subtract.
         * @returns {Quat} -
         */
        isZero() {
            return this.x === 0.0 && this.y === 0.0 && this.z === 0.0 && this.w === 0.0;
        }

        /**
         * Clear Quat. Sets zeroes.
         * @public
         * @returns {Quat} -
         */
        clear() {
            this.x = this.y = this.z = this.w = 0;
            return this;
        }

        /**
         * Sets Quat values.
         * @public
         * @param {Number} [x=0.0] The X component.
         * @param {Number} [y=0.0] The Y component.
         * @param {Number} [z=0.0] The Z component.
         * @param {Number} [w=0.0] The W component.
         * @returns {Quat} -
         */
        set(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        }

        /**
         * Copy Quat values.
         * @public
         * @param {Quat} q - Copy Quat.
         * @returns {Quat} -
         */
        copy(q) {
            this.x = q.x;
            this.y = q.y;
            this.z = q.z;
            this.w = q.w;
            return this;
        }

        /**
         * Set current Quat instance to identity Quat.
         * @public
         * @returns {Quat} -
         */
        setIdentity() {
            this.x = 0.0;
            this.y = 0.0;
            this.z = 0.0;
            this.w = 1.0;
            return this;
        }

        /**
         * Duplicates a Quat instance.
         * @public
         * @returns {Quat} -
         */
        clone() {
            return new Quat(this.x, this.y, this.z, this.w);
        }

        /**
         * Computes the componentwise sum of two Quats.
         * @public
         * @param {Quat} q - Quat to add.
         * @returns {Quat} -
         */
        add(q) {
            return new Quat(this.x + q.x, this.y + q.y, this.z + q.z, this.w + q.w);
        }

        /**
         * Computes the componentwise difference of two Quats.
         * @public
         * @param {Quat} q - Quat to subtract.
         * @returns {Quat} -
         */
        sub(q) {
            return new Quat(this.x - q.x, this.y - q.y, this.z - q.z, this.w - q.w);
        }

        /**
         * Multiplies the provided Quat componentwise by the provided scalar.
         * @public
         * @param {Number} scale - The scalar to multiply with.
         * @returns {Quat} -
         */
        scaleTo(scale) {
            return new Quat(this.x * scale, this.y * scale, this.z * scale, this.w * scale);
        }

        /**
         * Multiplies the provided Quat componentwise.
         * @public
         * @param {Number} scale - The scalar to multiply with.
         * @returns {Quat} -
         */
        scale(scale) {
            this.x *= scale;
            this.y *= scale;
            this.z *= scale;
            this.w *= scale;
            return this;
        }

        /**
         * Converts Quat values to array.
         * @public
         * @returns {Array.<number>} - (exactly 4 entries)
         */
        toVec() {
            return [this.x, this.y, this.z, this.w];
        }

        /**
         * Sets current quaternion by spherical coordinates.
         * @public
         * @param {number} lat - Latitude.
         * @param {number} lon - Longitude.
         * @param {number} angle - Angle in radians.
         * @returns {Quat} -
         */
        setFromSphericalCoords(lat, lon, angle) {
            var sin_a = Math.sin(angle / 2);
            var cos_a = Math.cos(angle / 2);
            var sin_lat = Math.sin(lat);
            var cos_lat = Math.cos(lat);
            var sin_long = Math.sin(lon);
            var cos_long = Math.cos(lon);
            this.x = sin_a * cos_lat * sin_long;
            this.y = sin_a * sin_lat;
            this.z = sin_a * sin_lat * cos_long;
            this.w = cos_a;
            return this;
        }

        /**
         * Sets rotation with the given heading and up vectors.
         * @static
         * @param {Vec3} forward - Heading target coordinates.
         * @param {Vec3} up - Up vector.
         * @returns {Quat} -
         */
        setLookRotation(forward, up) {
            var f = forward.normal().negate();
            var s = up.cross(f).normalize();
            var u = f.cross(s);

            var z = 1.0 + s.x + u.y + f.z;

            if (z > 0.000001) {
                let fd = 1.0 / (2.0 * Math.sqrt(z));
                this.x = (f.y - u.z) * fd;
                this.y = (s.z - f.x) * fd;
                this.z = (u.x - s.y) * fd;
                this.w = 0.25 / fd;
            } else if (s.x > u.y && s.x > f.z) {
                let fd = 1.0 / (2.0 * Math.sqrt(1.0 + s.x - u.y - f.z));
                this.x = 0.25 / fd;
                this.y = (u.x + s.y) * fd;
                this.z = (s.z + f.x) * fd;
                this.w = (f.y - u.z) * fd;
            } else if (u.y > f.z) {
                let fd = 1.0 / (2.0 * Math.sqrt(1.0 + u.y - s.x - f.z));
                this.x = (u.x + s.y) * fd;
                this.y = 0.25 / fd;
                this.z = (f.y + u.z) * fd;
                this.w = (s.z - f.x) * fd;
            } else {
                let fd = 1.0 / (2.0 * Math.sqrt(1.0 + f.z - s.x - u.y));
                this.x = (s.z + f.x) * fd;
                this.y = (f.y + u.z) * fd;
                this.z = 0.25 / fd;
                this.w = (u.x - s.y) * fd;
            }

            return this;
        }

        /**
         * Gets spherical coordinates.
         * @public
         * @returns {Object} Returns object with latitude, longitude and alpha.
         */
        toSphericalCoords() {
            var cos_a = this.w;
            var sin_a = Math.sqrt(1.0 - cos_a * cos_a);
            // var angle = Math.acos(cos_a) * 2;
            if (Math.abs(sin_a) < 0.0005) {
                sin_a = 1;
            }
            var tx = this.x / sin_a;
            var ty = this.y / sin_a;
            var tz = this.z / sin_a;

            var lon,
                lat = -Math.asin(ty);
            if (tx * tx + tz * tz < 0.0005) {
                lon = 0;
            } else {
                lon = Math.atan2(tx, tz);
            }
            if (lon < 0) {
                lon += 360.0;
            }

            return { lat: lat, lon: lon, alpha: Math.acos(cos_a) };
        }

        /**
         * Sets current Quat representing a rotation around an axis.
         * @public
         * @param {Vec3} axis - The axis of rotation.
         * @param {number} angle The angle in radians to rotate around the axis.
         * @returns {Quat} -
         */
        setFromAxisAngle(axis, angle) {
            var v = axis.normal();
            var half_angle = angle * 0.5;
            var sin_a = Math.sin(half_angle);
            this.set(v.x * sin_a, v.y * sin_a, v.z * sin_a, Math.cos(half_angle));
            return this;
        }

        /**
         * Returns axis and angle of the current Quat.
         * @public
         * @returns {Object} -
         */
        getAxisAngle() {
            let x = this.x,
                y = this.y,
                z = this.z,
                w = this.w;
            var vl = Math.sqrt(x * x + y * y + z * z);
            var axis, angle;
            if (vl > 0.0000001) {
                var ivl = 1.0 / vl;
                axis = new Vec3(x * ivl, y * ivl, z * ivl);
                if (w < 0) {
                    angle = 2.0 * Math.atan2(-vl, -w); // -PI,0
                } else {
                    angle = 2.0 * Math.atan2(vl, w); // 0,PI
                }
            } else {
                axis = new Vec3(0, 0, 0);
                angle = 0;
            }
            return { axis: axis, angle: angle };
        }

        /**
         * Sets current Quat by Euler's angles.
         * @public
         * @param {number} pitch - Pitch angle in degrees.
         * @param {number} yaw - Yaw angle in degrees.
         * @param {number} roll - Roll angle in degrees.
         * @returns {Quat} -
         */
        setFromEulerAngles(pitch, yaw, roll) {
            var ex = pitch * RADIANS_HALF,
                ey = yaw * RADIANS_HALF,
                ez = roll * RADIANS_HALF;

            var cr = Math.cos(ex),
                cp = Math.cos(ey),
                cy = Math.cos(ez);

            var sr = Math.sin(ex),
                sp = Math.sin(ey),
                sy = Math.sin(ez);

            var cpcy = cp * cy,
                spsy = sp * sy;

            this.w = cr * cpcy + sr * spsy;
            this.x = sr * cpcy - cr * spsy;
            this.y = cr * sp * cy + sr * cp * sy;
            this.z = cr * cp * sy - sr * sp * cy;

            return this.normalize();
        }

        /**
         * Returns Euler's angles of the current Quat.
         * @public
         * @returns {Object} -
         */
        getEulerAngles() {
            let x = this.x,
                y = this.y,
                z = this.z,
                w = this.w;

            let sqy = y * y;

            let roll = Math.atan2(2.0 * (w * x + y * z), 1.0 - 2.0 * (x * x + sqy));

            let a = w * y - z * x;

            if (a < -1.0) {
                a = -1.0;
            } else if (a > 1.0) {
                a = 1.0;
            }
            let pitch = Math.asin(2.0 * a);

            let yaw = Math.atan2(2.0 * (w * z + x * y), 1.0 - 2.0 * (sqy + z * z));

            return { roll, pitch, yaw };
        }

        /**
         * Computes a Quat from the provided 4x4 matrix instance.
         * @public
         * @param {Mat4} m - The rotation matrix.
         * @returns {Quat} -
         */
        setFromMatrix4(m) {
            var tr,
                s,
                q = [];
            var i, j, k;
            m = m._m;

            var nxt = [1, 2, 0];

            tr = m[0] + m[5] + m[10];

            if (tr > 0.0) {
                s = Math.sqrt(tr + 1.0);
                this.w = s / 2.0;
                s = 0.5 / s;
                this.x = (m[6] - m[9]) * s;
                this.y = (m[8] - m[2]) * s;
                this.z = (m[1] - m[4]) * s;
            } else {
                i = 0;
                if (m[5] > m[0]) i = 1;
                if (m[10] > m[i * 5]) i = 2;
                j = nxt[i];
                k = nxt[j];

                s = Math.sqrt(m[i * 5] - (m[j * 5] + m[k * 5]) + 1.0);

                q[i] = s * 0.5;

                if (s !== 0.0) s = 0.5 / s;

                q[3] = (m[j * 4 + k] - m[k * 4 + j]) * s;
                q[j] = (m[i * 4 + j] + m[j * 4 + i]) * s;
                q[k] = (m[i * 4 + k] + m[k * 4 + i]) * s;

                this.x = q[0];
                this.y = q[1];
                this.z = q[2];
                this.w = q[3];
            }
            return this;
        }

        /**
         * Converts current Quat to the rotation 4x4 matrix.
         * @public
         * @returns {Mat4} -
         */
        getMat4(out) {
            var xs = this.x + this.x;
            var ys = this.y + this.y;
            var zs = this.z + this.z;
            var wx = this.w * xs;
            var wy = this.w * ys;
            var wz = this.w * zs;
            var xx = this.x * xs;
            var xy = this.x * ys;
            var xz = this.x * zs;
            var yy = this.y * ys;
            var yz = this.y * zs;
            var zz = this.z * zs;
            var m = out || new Mat4();
            return m.set([
                1 - (yy + zz),
                xy - wz,
                xz + wy,
                0,
                xy + wz,
                1 - (xx + zz),
                yz - wx,
                0,
                xz - wy,
                yz + wx,
                1 - (xx + yy),
                0,
                0,
                0,
                0,
                1
            ]);
        }

        /**
         * Converts current Quat to the rotation 3x3 matrix.
         * @public
         * @returns {Mat3} -
         * @todo NOT TESTED
         */
        getMat3() {
            var m = new Mat3();
            var mx = m._m;
            var c = this.x,
                d = this.y,
                e = this.z,
                g = this.w,
                f = c + c,
                h = d + d,
                i = e + e,
                j = c * f,
                k = c * h;

            c = c * i;

            var l = d * h;

            d = d * i;
            e = e * i;
            f = g * f;
            h = g * h;
            g = g * i;

            mx[0] = 1 - (l + e);
            mx[1] = k - g;
            mx[2] = c + h;
            mx[3] = k + g;
            mx[4] = 1 - (j + e);
            mx[5] = d - f;
            mx[6] = c - h;
            mx[7] = d + f;
            mx[8] = 1 - (j + l);

            return m;
        }

        /**
         * Returns quatrenion and vector production.
         * @public
         * @param {Vec3} v - 3d Vector.
         * @returns {Vec3} -
         */
        mulVec3(v) {
            // t = 2 * cross(q.xyz, v)
            // v' = v + q.w * t + cross(q.xyz, t)

            var d = v.x,
                e = v.y,
                g = v.z;

            var b = this.x,
                f = this.y,
                h = this.z,
                a = this.w;

            var i = a * d + f * g - h * e,
                j = a * e + h * d - b * g,
                k = a * g + b * e - f * d;

            d = -b * d - f * e - h * g;

            return new Vec3(
                i * a + d * -b + j * -h - k * -f,
                j * a + d * -f + k * -b - i * -h,
                k * a + d * -h + i * -f - j * -b
            );
        }

        /**
         * Computes the product of two Quats.
         * @public
         * @param {Quat} q - Quat to multiply.
         * @returns {Quat} -
         */
        mul(q) {
            var d = this.x,
                e = this.y,
                g = this.z,
                a = this.w;
            var f = q.x,
                h = q.y,
                i = q.z,
                b = q.w;
            return new Quat(
                d * b + a * f + e * i - g * h,
                e * b + a * h + g * f - d * i,
                g * b + a * i + d * h - e * f,
                a * b - d * f - e * h - g * i
            );
        }

        /**
         * Computes the product of two Quats.
         * @public
         * @param {Quat} q - Quat to multiply.
         * @returns {Quat} -
         */
        mulA(q) {
            var d = this.x,
                e = this.y,
                g = this.z,
                a = this.w;
            var f = q.x,
                h = q.y,
                i = q.z,
                b = q.w;
            this.x = d * b + a * f + e * i - g * h;
            this.y = e * b + a * h + g * f - d * i;
            this.z = g * b + a * i + d * h - e * f;
            this.w = a * b - d * f - e * h - g * i;
            return this;
        }

        /**
         * Gets the conjugate of the Quat.
         * @public
         * @returns {Quat} -
         */
        conjugate() {
            return new Quat(-this.x, -this.y, -this.z, this.w);
        }

        /**
         * Computes the inverse of the Quat.
         * @public
         * @returns {Quat} -
         */
        inverse() {
            var n = 1 / this.magnitude2();
            return new Quat(-this.x * n, -this.y * n, -this.z * n, this.w * n);
        }

        /**
         * Computes a magnitude of the Quat.
         * @public
         * @returns {number} -
         */
        magnitude() {
            var b = this.x,
                c = this.y,
                d = this.z,
                a = this.w;
            return Math.sqrt(b * b + c * c + d * d + a * a);
        }

        /**
         * Computes a squared magnitude of the Quat.
         * @public
         * @returns {number} -
         */
        magnitude2() {
            var b = this.x,
                c = this.y,
                d = this.z,
                a = this.w;
            return b * b + c * c + d * d + a * a;
        }

        /**
         * Computes the dot (scalar) product of two Quats.
         * @public
         * @param {Quat} q - Second quatrnion.
         * @returns {number} -
         */
        dot(q) {
            return this.x * q.x + this.y * q.y + this.z * q.z;
        }

        /**
         * Current Quat normalization.
         * @public
         * @returns {Quat} -
         */
        normalize() {
            var c = this.x,
                d = this.y,
                e = this.z,
                g = this.w,
                f = Math.sqrt(c * c + d * d + e * e + g * g);
            if (f === 0.0) {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.w = 0;
                return this;
            }
            f = 1 / f;
            this.x = c * f;
            this.y = d * f;
            this.z = e * f;
            this.w = g * f;
            return this;
        }

        /**
         * Compares two Quats.
         * @public
         * @param {Quat} q - Second quatrnion.
         * @returns {Boolean} -
         */
        isEqual(q) {
            var matching = this.dot(q);
            if (Math.abs(matching - 1.0) < 0.001) {
                return true;
            }
            return false;
        }

        /**
         * Performs a spherical linear interpolation between two Quats.
         * @public
         * @param {Quat} b - The end rotation Quat.
         * @param {number} t - interpolation amount between the two Quats.
         * @returns {Quat} -
         */
        slerp(b, t) {
            var ax = this.x,
                ay = this.y,
                az = this.z,
                aw = this.w,
                bx = b.x,
                by = b.y,
                bz = b.z,
                bw = b.w;

            var omega, cosom, sinom, scale0, scale1;

            cosom = ax * bx + ay * by + az * bz + aw * bw;

            if (cosom < 0.0) {
                cosom = -cosom;
                bx = -bx;
                by = -by;
                bz = -bz;
                bw = -bw;
            }

            if (1.0 - cosom > 0.000001) {
                omega = Math.acos(cosom);
                sinom = Math.sin(omega);
                scale0 = Math.sin((1.0 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
            } else {
                scale0 = 1.0 - t;
                scale1 = t;
            }

            return new Quat(
                scale0 * ax + scale1 * bx,
                scale0 * ay + scale1 * by,
                scale0 * az + scale1 * bz,
                scale0 * aw + scale1 * bw
            );
        }

        /**
         * Returns a roll angle in radians.
         * @public
         * @param {Boolean} [reprojectAxis] -
         * @returns {Number} -
         */
        getRoll(reprojectAxis) {
            var x = this.x,
                y = this.y,
                z = this.z,
                w = this.w;
            if (reprojectAxis) {
                var fTy = 2.0 * y;
                var fTz = 2.0 * z;
                var fTwz = fTz * w;
                var fTxy = fTy * x;
                var fTyy = fTy * y;
                var fTzz = fTz * z;
                return Math.atan2(fTxy + fTwz, 1.0 - (fTyy + fTzz));
            } else {
                return Math.atan2(2 * (x * y + w * z), w * w + x * x - y * y - z * z);
            }
        }

        /**
         * Returns a pitch angle in radians.
         * @public
         * @param {Boolean} [reprojectAxis] -
         * @returns {number} -
         */
        getPitch(reprojectAxis) {
            var x = this.x,
                y = this.y,
                z = this.z,
                w = this.w;
            if (reprojectAxis) {
                var fTx = 2.0 * x;
                var fTz = 2.0 * z;
                var fTwx = fTx * w;
                var fTxx = fTx * x;
                var fTyz = fTz * y;
                var fTzz = fTz * z;
                return Math.atan2(fTyz + fTwx, 1.0 - (fTxx + fTzz));
            } else {
                return Math.atan2(2 * (y * z + w * x), w * w - x * x - y * y + z * z);
            }
        }

        /**
         * Returns a yaw angle in radians.
         * @public
         * @param {Boolean} [reprojectAxis] -
         * @returns {number} -
         */
        getYaw(reprojectAxis = false) {
            var x = this.x,
                y = this.y,
                z = this.z,
                w = this.w;
            if (reprojectAxis) {
                var fTx = 2.0 * x;
                var fTy = 2.0 * y;
                var fTz = 2.0 * z;
                var fTwy = fTy * w;
                var fTxx = fTx * x;
                var fTxz = fTz * x;
                var fTyy = fTy * y;
                return Math.atan2(fTxz + fTwy, 1.0 - (fTxx + fTyy));
            } else {
                return Math.asin(-2 * (x * z - w * y));
            }
        }
    }

    /**
     * @module og/math/Vec3
     */

    /**
     * Class represents a 3d vector.
     * @class
     * @param {number} [x] - First value.
     * @param {number} [y] - Second value.
     * @param {number} [z] - Third value.
     */
    class Vec3 {
        constructor(x = 0.0, y = 0.0, z = 0.0) {
            /**
             * @public
             * @type {number}
             */
            this.x = x || 0.0;

            /**
             * @public
             * @type {number}
             */
            this.y = y || 0.0;

            /**
             * @public
             * @type {number}
             */
            this.z = z || 0.0;
        }

        /** @const */
        static get UP() {
            return new Vec3(0, 1, 0);
        }
        /** @const */
        static get DOWN() {
            return new Vec3(0, -1, 0);
        }
        /** @const */
        static get RIGHT() {
            return new Vec3(1, 0, 0);
        }
        /** @const */
        static get LEFT() {
            return new Vec3(-1, 0, 0);
        }
        /** @const */
        static get FORWARD() {
            return new Vec3(0, 0, -1);
        }
        /** @const */
        static get BACKWARD() {
            return new Vec3(0, 0, 1);
        }
        /** @const */
        static get ZERO() {
            return new Vec3();
        }
        /** @const */
        static get UNIT_X() {
            return new Vec3(1, 0, 0);
        }
        /** @const */
        static get UNIT_Y() {
            return new Vec3(0, 1, 0);
        }
        /** @const */
        static get UNIT_Z() {
            return new Vec3(0, 0, 1);
        }

        /**
         * Separate 63 bit Vec3 to two Vec3 32 bit float values.
         * @function
         * @param {number} value - Double type value.
         * @param {Vec3} high - Out vector high values.
         * @param {Vec3} low - Out vector low values.
         * @returns {Array.<number>} Encoded array. (exactly 2 entries)
         */
        static doubleToTwoFloats(v, high, low) {
            let x = v.x,
                y = v.y,
                z = v.z;

            if (x >= 0.0) {
                let doubleHigh = Math.floor(x / 65536.0) * 65536.0;
                high.x = Math.fround(doubleHigh);
                low.x = Math.fround(x - doubleHigh);
            } else {
                let doubleHigh = Math.floor(-x / 65536.0) * 65536.0;
                high.x = Math.fround(-doubleHigh);
                low.x = Math.fround(x + doubleHigh);
            }

            if (y >= 0.0) {
                let doubleHigh = Math.floor(y / 65536.0) * 65536.0;
                high.y = Math.fround(doubleHigh);
                low.y = Math.fround(y - doubleHigh);
            } else {
                let doubleHigh = Math.floor(-y / 65536.0) * 65536.0;
                high.y = Math.fround(-doubleHigh);
                low.y = Math.fround(y + doubleHigh);
            }

            if (z >= 0.0) {
                let doubleHigh = Math.floor(z / 65536.0) * 65536.0;
                high.z = Math.fround(doubleHigh);
                low.z = Math.fround(z - doubleHigh);
            } else {
                let doubleHigh = Math.floor(-z / 65536.0) * 65536.0;
                high.z = Math.fround(-doubleHigh);
                low.z = Math.fround(z + doubleHigh);
            }
        }

        /**
         * Separate 63 bit Vec3 to two Vec3 32 bit float values.
         * @function
         * @param {number} value - Double type value.
         * @param {Float32Array} high - Out vector high values.
         * @param {Float32Array} low - Out vector low values.
         * @returns {Array.<number>} Encoded array. (exactly 2 entries)
         */
        static doubleToTwoFloat32Array(v, high, low) {
            let x = v.x,
                y = v.y,
                z = v.z;

            if (x >= 0.0) {
                let doubleHigh = Math.floor(x / 65536.0) * 65536.0;
                high[0] = Math.fround(doubleHigh);
                low[0] = Math.fround(x - doubleHigh);
            } else {
                let doubleHigh = Math.floor(-x / 65536.0) * 65536.0;
                high[0] = Math.fround(-doubleHigh);
                low[0] = Math.fround(x + doubleHigh);
            }

            if (y >= 0.0) {
                let doubleHigh = Math.floor(y / 65536.0) * 65536.0;
                high[1] = Math.fround(doubleHigh);
                low[1] = Math.fround(y - doubleHigh);
            } else {
                let doubleHigh = Math.floor(-y / 65536.0) * 65536.0;
                high[1] = Math.fround(-doubleHigh);
                low[1] = Math.fround(y + doubleHigh);
            }

            if (z >= 0.0) {
                let doubleHigh = Math.floor(z / 65536.0) * 65536.0;
                high[2] = Math.fround(doubleHigh);
                low[2] = Math.fround(z - doubleHigh);
            } else {
                let doubleHigh = Math.floor(-z / 65536.0) * 65536.0;
                high[2] = Math.fround(-doubleHigh);
                low[2] = Math.fround(z + doubleHigh);
            }
        }

        /**
         * Creates 3d vector from array.
         * @function
         * @param {Array.<number>} arr - Input array (exactly 3 entries)
         * @returns {Vec3} -
         */
        static fromVec(arr) {
            return new Vec3(arr[0], arr[1], arr[2]);
        }

        /**
         * Gets angle between two vectors.
         * @static
         * @param {Vec3} a - First vector.
         * @param {Vec3} b - Second vector.
         * @returns {number} -
         */
        static angle(a, b) {
            return Math.acos(a.dot(b) / Math.sqrt(a.length2() * b.length2()));
        }

        /**
         * Returns two vectors linear interpolation.
         * @static
         * @param {Vec3} v1 - Start vector.
         * @param {Vec3} v2 - End vector.
         * @param {number} l - Interpolate value.
         * @returns {Vec3} -
         */
        static lerp(v1, v2, l) {
            return new Vec3(v1.x + (v2.x - v1.x) * l, v1.y + (v2.y - v1.y) * l, v1.z + (v2.z - v1.z) * l);
        }

        /**
         * Returns summary vector.
         * @static
         * @param {Vec3} a - First vector.
         * @param {Vec3} b - Second vector.
         * @returns {Vec3} - Summary vector.
         */
        static add(a, b) {
            var res = new Vec3(a.x, a.y, a.z);
            res.addA(b);
            return res;
        }

        /**
         * Returns two vectors subtraction.
         * @static
         * @param {Vec3} a - First vector.
         * @param {Vec3} b - Second vector.
         * @returns {Vec3} - Vectors subtraction.
         */
        static sub(a, b) {
            var res = new Vec3(a.x, a.y, a.z);
            res.subA(b);
            return res;
        }

        /**
         * Returns scaled vector.
         * @static
         * @param {Vec3} a - Input vector.
         * @param {number} scale - Scale value.
         * @returns {Vec3} -
         */
        static scale(a, scale) {
            var res = new Vec3(a.x, a.y, a.z);
            res.scale(scale);
            return res;
        }

        /**
         * Returns two vectors production.
         * @static
         * @param {Vec3} a - First vector.
         * @param {Vec3} b - Second vector.
         * @returns {Vec3} -
         */
        static mul(a, b) {
            var res = new Vec3(a.x, a.y, a.z);
            res.mulA(b);
            return res;
        }

        /**
         * Returns true if two vectors are non collinear.
         * @public
         * @param {Vec3} a - First vector.
         * @param {Vec3} b - Second vector.
         * @returns {Vec3} -
         */
        static noncollinear(a, b) {
            return a.y * b.z - a.z * b.y || a.z * b.x - a.x * b.z || a.x * b.y - a.y * b.z;
        }

        /**
         * Get projection of the vector to plane where n - normal to the plane.
         * @static
         * @param {Vec3} b - Vector to project.
         * @param {Vec3} n - Plane normal.
         * @param {Vec3} [def] - Default value for non existed result.
         * @returns {Vec3} -
         */
        static proj_b_to_plane(b, n, def) {
            var res = b.sub(n.scaleTo(n.dot(b) / n.dot(n)));
            if (def && res.isZero()) {
                return new Vec3(def.x, def.y, def.z);
            }
            return res;
        }

        /**
         * Get projection of the first vector to the second.
         * @static
         * @param {Vec3} b - First vector.
         * @param {Vec3} a - Second vector.
         * @returns {Vec3} -
         */
        static proj_b_to_a(b, a) {
            return a.scaleTo(a.dot(b) / a.dot(a));
        }

        /**
         * Makes vectors normalized and orthogonal to each other.
         * Normalizes normal. Normalizes tangent and makes sure it is orthogonal to normal (that is, angle between them is 90 degrees).
         * @static
         * @param {Vec3} normal - Normal vector.
         * @param {Vec3} tangent - Tangent vector.
         * @returns {Vec3} -
         */
        static orthoNormalize(normal, tangent) {
            normal = normal.normal();
            normal.scale(tangent.dot(normal));
            return tangent.subA(normal).normalize();
        }

        /**
         * Returns vector components division product one to another.
         * @static
         * @param {Vec3} a - First vector.
         * @param {Vec3} b - Second vector.
         * @returns {Vec3} -
         */
        static div(a, b) {
            var res = new Vec3(a.x, a.y, a.z);
            res.divA(b);
            return res;
        }

        /**
         * Converts to 4d vector, Fourth value is 1.0.
         * @public
         * @returns {Vec4} -
         */
        toVec4() {
            return new Vec4(this.x, this.y, this.z, 1.0);
        }

        /**
         * Returns clone vector.
         * @public
         * @returns {Vec3} -
         */
        clone() {
            return new Vec3(this.x, this.y, this.z);
        }

        /**
         * Converts vector to text string.
         * @public
         * @returns {string} -
         */
        toString() {
            return "(" + this.x + "," + this.y + "," + this.z + ")";
        }

        /**
         * Returns true if vector's values are zero.
         * @public
         * @returns {boolean} -
         */
        isZero() {
            return !(this.x || this.y || this.z);
        }

        /**
         * Get projection of the first vector to the second.
         * @static
         * @param {Vec3} a - Project vector.
         * @returns {Vec3} -
         */
        projToVec(a) {
            return a.scaleTo(a.dot(this) / a.dot(a));
        }

        /**
         * Compares with vector. Returns true if it equals another.
         * @public
         * @param {Vec3} p - Vector to compare.
         * @returns {boolean} -
         */
        equal(p) {
            return this.x === p.x && this.y === p.y && this.z === p.z;
        }

        /**
         * Copy input vector's values.
         * @param {Vec3} point3 - Vector to copy.
         * @returns {Vec3} -
         */
        copy(point3) {
            this.x = point3.x;
            this.y = point3.y;
            this.z = point3.z;
            return this;
        }

        /**
         * Gets vector's length.
         * @public
         * @returns {number} -
         */
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }

        /**
         * Returns squared vector's length.
         * @public
         * @returns {number} -
         */
        length2() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        }

        /**
         * Converts vector's values to a quaternion object.
         * @public
         * @returns {Quat} -
         */
        getQuat() {
            return new Quat(this.x, this.y, this.z);
        }

        /**
         * Adds vector to the current.
         * @public
         * @param {Vec3} point3 - Point to add.
         * @returns {Vec3} -
         */
        addA(point3) {
            this.x += point3.x;
            this.y += point3.y;
            this.z += point3.z;
            return this;
        }

        /**
         * Gets two vectors summarization.
         * @public
         * @param {Vec3} point3 - Vector to add.
         * @returns {Vec3} Returns a sum vector.
         */
        add(point3) {
            return new Vec3(this.x + point3.x, this.y + point3.y, this.z + point3.z);
        }

        /**
         * Subtract vector from the current.
         * @public
         * @param {Vec3} point3 - Subtract vector.
         * @returns {Vec3} -
         */
        subA(point3) {
            this.x -= point3.x;
            this.y -= point3.y;
            this.z -= point3.z;
            return this;
        }

        /**
         * Gets vector subtraction.
         * @public
         * @param {Vec3} point3 - Subtract vector.
         * @return {Vec3} Returns new instance of a subtraction
         */
        sub(point3) {
            return new Vec3(this.x - point3.x, this.y - point3.y, this.z - point3.z);
        }

        /**
         * Scale current vector.
         * @public
         * @param {number} scale - Scale value.
         * @returns {Vec3} -
         */
        scale(scale) {
            this.x *= scale;
            this.y *= scale;
            this.z *= scale;
            return this;
        }

        /**
         * Scale current vector to another instance.
         * @public
         * @param {number} scale - Scale value.
         * @returns {Vec3} -
         */
        scaleTo(scale) {
            return new Vec3(this.x * scale, this.y * scale, this.z * scale);
        }

        /**
         * Multiply current vector object to another and store result in the current instance.
         * @public
         * @param {Vec3} vec - Multiply vector.
         * @returns {Vec3} -
         */
        mulA(vec) {
            this.x *= vec.x;
            this.y *= vec.y;
            this.z *= vec.z;
            return this;
        }

        /**
         * Multiply current vector object to another and returns new vector instance.
         * @public
         * @param {Vec3} vec - Multiply vector.
         * @returns {Vec3} -
         */
        mul(vec) {
            return new Vec3(this.x * vec.x, this.y * vec.y, this.z * vec.z);
        }

        /**
         * Divide current vector's components to another. Results stores in the current vector object.
         * @public
         * @param {Vec3} vec - Div vector.
         * @returns {Vec3} -
         */
        divA(vec) {
            this.x /= vec.x;
            this.y /= vec.y;
            this.z /= vec.z;
            return this;
        }

        /**
         * Divide current vector's components to another and returns new vector instance.
         * @public
         * @param {Vec3} vec - Div vector.
         * @returns {Vec3} -
         */
        div(vec) {
            return new Vec3(this.x / vec.x, this.y / vec.y, this.z / vec.z);
        }

        /**
         * Gets vectors dot production.
         * @public
         * @param {Vec3} point3 - Another vector.
         * @returns {number} -
         */
        dot(point3) {
            return point3.x * this.x + point3.y * this.y + point3.z * this.z;
        }

        /**
         * Gets vectors dot production.
         * @public
         * @param {Array.<number>} arr - Array vector. (exactly 3 entries)
         * @returns {number} -
         */
        dotArr(arr) {
            return arr[0] * this.x + arr[1] * this.y + arr[2] * this.z;
        }

        /**
         * Gets vectors cross production.
         * @public
         * @param {Vec3} point3 - Another vector.
         * @returns {Vec3} -
         */
        cross(point3) {
            return new Vec3(
                this.y * point3.z - this.z * point3.y,
                this.z * point3.x - this.x * point3.z,
                this.x * point3.y - this.y * point3.x
            );
        }

        /**
         * Sets vector to zero.
         * @public
         * @returns {Vec3} -
         */
        clear() {
            this.x = this.y = this.z = 0;
            return this;
        }

        /**
         * Returns normalized vector.
         * @public
         * @returns {Vec3} -
         */
        getNormal() {
            var res = new Vec3();
            res.copy(this);

            var length = 1.0 / res.length();

            res.x *= length;
            res.y *= length;
            res.z *= length;

            return res;
        }

        /**
         * Returns normalized vector.
         * @deprecated
         * @public
         * @returns {Vec3} -
         */
        normal() {
            var res = new Vec3();
            res.copy(this);

            var length = 1.0 / res.length();

            res.x *= length;
            res.y *= length;
            res.z *= length;

            return res;
        }

        /**
         * Returns normalized negate vector.
         * @public
         * @returns {Vec3} -
         */
        normalNegate() {
            var res = new Vec3();
            res.copy(this);

            var length = -1.0 / res.length();

            res.x *= length;
            res.y *= length;
            res.z *= length;

            return res;
        }

        /**
         * Returns normalized negate scale vector.
         * @public
         * @returns {Vec3} -
         */
        normalNegateScale(scale) {
            var res = new Vec3();
            res.copy(this);

            var length = -scale / res.length();

            res.x *= length;
            res.y *= length;
            res.z *= length;

            return res;
        }

        /**
         * Returns normalized scale vector.
         * @public
         * @returns {Vec3} -
         */
        normalScale(scale) {
            var res = new Vec3();
            res.copy(this);

            var length = scale / res.length();

            res.x *= length;
            res.y *= length;
            res.z *= length;

            return res;
        }

        /**
         * Normalize current vector.
         * @public
         * @returns {Vec3} -
         */
        normalize() {
            var length = 1.0 / this.length();

            this.x *= length;
            this.y *= length;
            this.z *= length;

            return this;
        }

        /**
         * Converts vector to a number array.
         * @public
         * @returns {Array.<number>} - (exactly 3 entries)
         * @deprecated
         */
        toVec() {
            return [this.x, this.y, this.z];
        }

        /**
         * Converts vector to a number array.
         * @public
         * @returns {Array.<number>} - (exactly 3 entries)
         */
        toArray() {
            return [this.x, this.y, this.z];
        }

        /**
         * Gets distance to point.
         * @public
         * @param {Vec3} point3 - Distant point.
         * @returns {number} -
         */
        distance(point3) {
            let dx = this.x - point3.x,
                dy = this.y - point3.y,
                dz = this.z - point3.z;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }

        /**
         * Gets square distance to point.
         * @public
         * @param {Vec3} point3 - Distant point.
         * @returns {number} -
         */
        distance2(point3) {
            let dx = this.x - point3.x,
                dy = this.y - point3.y,
                dz = this.z - point3.z;
            return dx * dx + dy * dy + dz * dz;
        }

        /**
         * Sets vector's values.
         * @public
         * @param {number} x - Value X.
         * @param {number} y - Value Y.
         * @param {number} z - Value Z.
         * @returns {Vec3} -
         */
        set(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        }

        /**
         * Negate current vector.
         * @public
         * @returns {Vec3} -
         */
        negate() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this;
        }

        /**
         * Negate current vector to another instance.
         * @public
         * @returns {Vec3} -
         */
        negateTo() {
            return new Vec3(-this.x, -this.y, -this.z);
        }

        /**
         * Gets projected point coordinates of the current vector on the ray.
         * @public
         * @param {Vec3} pos - Ray position.
         * @param {Vec3} direction - Ray direction.
         * @returns {Vec3} -
         */
        projToRay(pos, direction) {
            var v = Vec3.proj_b_to_a(Vec3.sub(this, pos), direction);
            v.addA(pos);
            return v;
        }

        /**
         * Gets angle between two vectors.
         * @public
         * @param {Vec3} a - Another vector.
         * @returns {number} -
         */
        angle(a) {
            return Vec3.angle(this, a);
        }

        /**
         * Returns two vectors linear interpolation.
         * @public
         * @param {Vec3} v2 - End vector.
         * @param {number} l - Interpolate value.
         * @returns {Vec3} -
         */
        lerp(v2, l) {
            return new Vec3(
                this.x + (v2.x - this.x) * l,
                this.y + (v2.y - this.y) * l,
                this.z + (v2.z - this.z) * l
            );
        }

        /**
         * Returns vector interpolation by v(t) = v1 * t + v2 * (1 - t)
         * @public
         * @param {Vec3} v2 - End vector.
         * @param {number} t - Interpolate value.
         * @returns {Vec3} -
         */
        smerp(v2, t) {
            var one_d = 1 - t;
            return new Vec3(
                this.x * t + v2.x * one_d,
                this.y * t + v2.y * one_d,
                this.z * t + v2.z * one_d
            );
        }

        static get LERP_DELTA() {
            return 1e-6;
        }

        /**
         * Spherically interpolates between two vectors.
         * Interpolates between current and v2 vector by amount t. The difference between this and linear interpolation (aka, "lerp") is that
         * the vectors are treated as directions rather than points in space. The direction of the returned vector is interpolated
         * by the angle and its magnitude is interpolated between the magnitudes of from and to.
         * @public
         * @param {Vec3} v2 -
         * @param {number} t - The parameter t is clamped to the range [0, 1].
         * @returns {Vec3} -
         */
        slerp(v2, t) {
            var res = new Vec3();

            if (t <= 0.0) {
                res.copy(this);
                return;
            } else if (t >= 1.0) {
                res.copy(v2);
                return;
            }

            var omega, sinom, scale0, scale1;
            var cosom = this.dot(v2);

            if (1.0 - cosom > Vec3.LERP_DELTA) {
                omega = Math.acos(cosom);
                sinom = Math.sin(omega);
                scale0 = Math.sin((1.0 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
            } else {
                scale0 = 1.0 - t;
                scale1 = t;
            }

            return Vec3.add(this.scaleTo(scale0), v2.scale(scale1));
        }

        /**
         * Gets the shortest arc quaternion to rotate this vector to the destination vector.
         * @param {Vec3} dest -
         * @param {Vec3} fallbackAxis -
         * @returns {Quat} -
         * @todo: TEST IT!
         */
        getRotationTo(dest, fallbackAxis) {
            // Based on Stan Melax's article in Game Programming Gems
            // Copy, since cannot modify local
            let v0 = this.clone();
            let v1 = dest.clone();
            v0.normalize();
            v1.normalize();

            let d = v0.dot(v1);
            // If dot == 1, vectors are the same
            if (d >= 1.0) {
                return Quat.IDENTITY.clone();
            }

            if (d < 1e-6 - 1.0) {
                if (!fallbackAxis.isEqual(Vec3.ZERO)) {
                    // rotate 180 degrees about the fallback axis
                    return Quat.axisAngleToQuat(Math.PI, fallbackAxis);
                } else {
                    // Generate an axis
                    let axis = Vec3.UNIT_X.cross(v0);
                    if (axis.isZero()) {
                        // pick another if colinear
                        axis = Vec3.UNIT_Y.cross(v0);
                    }
                    axis.normalize();
                    return Quat.axisAngleToQuat(Math.PI, axis);
                }
            } else {
                let s = Math.sqrt((1 + d) * 2);
                let invs = 1.0 / s;

                let c = v0.cross(v1);

                let q = new Quat(c.x * invs, c.y * invs, c.z * invs, s * 0.5);
                q.normalise();
                return q;
            }
        }
    }

    /**
     * @module og/math/Vec2
     */

    /**
     * Class represents a 3d vector.
     * @class
     * @param {number} [x] - First value.
     * @param {number} [y] - Second value.
     */
    class Vec2 {
        constructor(x = 0.0, y = 0.0) {
            /**
             * @public
             * @type {number}
             */
            this.x = x || 0.0;

            /**
             * @public
             * @type {number}
             */
            this.y = y || 0.0;
        }
        /** @const */
        static get UP() {
            return new Vec2(0, 1);
        }
        /** @const */
        static get DOWN() {
            return new Vec2(0, -1);
        }
        /** @const */
        static get RIGHT() {
            return new Vec2(1, 0);
        }
        /** @const */
        static get LEFT() {
            return new Vec2(-1, 0);
        }
        /** @const */
        static get ZERO() {
            return new Vec2();
        }

        /**
         * Returns summary vector.
         * @static
         * @param {math.Vec2} a - First vector.
         * @param {math.Vec2} b - Second vector.
         * @returns {math.Vec2} - Summary vector.
         */
        static add(a, b) {
            var res = new Vec2(a.x, a.y);
            res.addA(b);
            return res;
        }

        /**
         * Returns two vectors subtraction.
         * @static
         * @param {math.Vec2} a - First vector.
         * @param {math.Vec2} b - Second vector.
         * @returns {math.Vec2} - Vectors subtraction.
         */
        static sub(a, b) {
            var res = new Vec2(a.x, a.y);
            res.subA(b);
            return res;
        }

        /**
         * Returns scaled vector.
         * @static
         * @param {math.Vec2} a - Input vector.
         * @param {number} scale - Scale value.
         * @returns {math.Vec2}
         */
        static scale(a, scale) {
            var res = new Vec2(a.x, a.y);
            res.scale(scale);
            return res;
        }

        /**
         * Returns two vectors production.
         * @static
         * @param {math.Vec2} a - First vector.
         * @param {math.Vec2} b - Second vector.
         * @returns {math.Vec2}
         */
        static mul(a, b) {
            var res = new Vec2(a.x, a.y);
            res.mulA(b);
            return res;
        }

        /**
         * Returns vector components division product one to another.
         * @static
         * @param {math.Vec2} a - First vector.
         * @param {math.Vec2} b - Second vector.
         * @returns {math.Vec2}
         */
        static div(a, b) {
            var res = new Vec2(a.x, a.y);
            res.divA(b);
            return res;
        }

        /**
         * Get projection of the first vector to the second.
         * @static
         * @param {math.Vec2} b - First vector.
         * @param {math.Vec2} a - Second vector.
         * @returns {math.Vec2}
         */
        static proj_b_to_a(b, a) {
            return a.scaleTo(a.dot(b) / a.dot(a));
        }

        /**
         * Gets angle between two vectors.
         * @static
         * @param {math.Vec2} a - First vector.
         * @param {math.Vec2} b - Second vector.
         * @returns {number}
         */
        static angle(a, b) {
            return Math.acos(a.dot(b) / Math.sqrt(a.length2() * b.length2()));
        }

        /**
         * Makes vectors normalized and orthogonal to each other.
         * @static
         * @param {math.Vec2} normal - Normal vector.
         * @param {math.Vec2} tangent - Tangent vector.
         * @returns {math.Vec2}
         */
        static orthoNormalize(normal, tangent) {
            normal = normal.norm();
            normal.scale(tangent.dot(normal));
            return tangent.sub(normal).normalize();
        }

        /**
         * Converts to 3d vector, third value is 0.0.
         * @public
         * @returns {Vec3}
         */
        toVector3() {
            return new Vec3(this.x, this.y, 0);
        }

        /**
         * Returns clone vector.
         * @public
         * @returns {math.Vec2}
         */
        clone() {
            return new Vec2(this.x, this.y);
        }

        /**
         * Compares with vector. Returns true if it equals another.
         * @public
         * @param {math.Vec2} p - Vector to compare.
         * @returns {boolean}
         */
        equal(p) {
            return this.x === p.x && this.y === p.y;
        }

        /**
         * Copy input vector's values.
         * @param {math.Vec2} point2 - Vector to copy.
         * @returns {math.Vec2}
         */
        copy(point2) {
            this.x = point2.x;
            this.y = point2.y;
            return this;
        }

        /**
         * Gets vector's length.
         * @public
         * @returns {number}
         */
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }

        /**
         * Returns squared vector's length.
         * @public
         * @returns {number}
         */
        length2() {
            return this.x * this.x + this.y * this.y;
        }

        /**
         * Adds vector to the current.
         * @public
         * @param {math.Vec2}
         * @returns {math.Vec2}
         */
        addA(v) {
            this.x += v.x;
            this.y += v.y;
            return this;
        }

        /**
         * Summarize two vectors.
         * @public
         * @param {math.Vec2}
         * @returns {math.Vec2}
         */
        add(v) {
            return new Vec2(this.x + v.x, this.y + v.y);
        }

        /**
         * Subtract vector from the current where results saved on the current instance.
         * @public
         * @param {math.Vec2} v - Subtract vector.
         * @returns {math.Vec2}
         */
        subA(v) {
            this.x -= v.x;
            this.y -= v.y;
            return this;
        }

        /**
         * Subtract vector from the current.
         * @public
         * @param {math.Vec2} v - Subtract vector.
         * @returns {math.Vec2}
         */
        sub(v) {
            return new Vec2(this.x - v.x, this.y - v.y);
        }

        /**
         * Scale current vector.
         * @public
         * @param {number} scale - Scale value.
         * @returns {math.Vec2}
         */
        scale(scale) {
            this.x *= scale;
            this.y *= scale;
            return this;
        }

        /**
         * Scale current vector to another instance.
         * @public
         * @param {number} scale - Scale value.
         * @returns {math.Vec2}
         */
        scaleTo(scale) {
            return new Vec2(this.x * scale, this.y * scale);
        }

        /**
         * Multiply current vector object to another and store result in the current instance.
         * @public
         * @param {math.Vec2} vec - Multiply vector.
         * @returns {math.Vec2}
         */
        mulA(vec) {
            this.x *= vec.x;
            this.y *= vec.y;
            return this;
        }

        /**
         * Multiply current vector object to another and returns new vector instance.
         * @public
         * @param {math.Vec2} vec - Multiply vector.
         * @returns {math.Vec2}
         */
        mul(vec) {
            return new Vec2(this.x * vec.x, this.y * vec.y);
        }

        /**
         * Divide current vector's components to another. Results stores in the current vector object.
         * @public
         * @param {math.Vec2}
         * @returns {math.Vec2}
         */
        divA(vec) {
            this.x /= vec.x;
            this.y /= vec.y;
            return this;
        }

        /**
         * Gets vectors dot production.
         * @public
         * @param {math.Vec2} v - Another vector.
         * @returns {number}
         */
        dot(v) {
            return v.x * this.x + v.y * this.y;
        }

        /**
         * Gets vectors dot production.
         * @public
         * @param {Array.<number>} arr - Array vector. (exactly 2 entries)
         * @returns {number}
         */
        dotArr(arr) {
            return arr[0] * this.x + arr[1] * this.y;
        }

        /**
         * Gets vectors cross production.
         * @public
         * @param {math.Vec2} v - Another vector.
         * @returns {math.Vec2}
         */
        cross(v) {
            return this.x * v.y - this.y * v.x;
        }

        /**
         * Sets vector to zero.
         * @public
         * @returns {math.Vec2}
         */
        clear() {
            this.x = this.y = 0;
            return this;
        }

        /**
         * Returns normalized vector.
         * @public
         * @returns {math.Vec2}
         */
        normal() {
            var res = new Vec2();
            res.copy(this);

            var length = 1.0 / res.length();

            res.x *= length;
            res.y *= length;

            return res;
        }

        /**
         * Normalize current vector.
         * @public
         * @returns {math.Vec2}
         */
        normalize() {
            var length = 1.0 / this.length();

            this.x *= length;
            this.y *= length;

            return this;
        }

        /**
         * Converts vector to a number array.
         * @public
         * @returns {Array.<number>} - (exactly 2 entries)
         */
        toVec() {
            return [this.x, this.y];
        }

        /**
         * Gets distance to point.
         * @public
         * @param {math.Vec2} p - Distant point.
         * @returns {number}
         */
        distance(p) {
            var vec = Vec2.sub(this, p);
            return vec.length();
        }

        /**
         * Sets vector's values.
         * @public
         * @param {number} x - Value X.
         * @param {number} y - Value Y.
         * @returns {math.Vec2}
         */
        set(x, y) {
            this.x = x;
            this.y = y;
            return this;
        }

        /**
         * Negate current vector.
         * @public
         * @returns {math.Vec2}
         */
        negate() {
            this.x = -this.x;
            this.y = -this.y;
            return this;
        }

        /**
         * Negate current vector to another instance.
         * @public
         * @returns {math.Vec2}
         */
        negateTo() {
            return new Vec2(-this.x, -this.y);
        }

        /**
         * Gets projected point coordinates of the current vector on the ray.
         * @public
         * @param {math.Vec2} pos - Ray position.
         * @param {math.Vec2} direction - Ray direction.
         * @returns {math.Vec2}
         */
        projToRay(pos, direction) {
            var v = Vec2.proj_b_to_a(Vec2.sub(this, pos), direction);
            v.add(pos);
            return v;
        }

        /**
         * Gets angle between two vectors.
         * @public
         * @param {math.Vec2} a - Another vector.
         * @returns {number}
         */
        angle(a) {
            return Vec2.angle(this, a);
        }

        /**
         * Returns two vectors linear interpolation.
         * @public
         * @param {math.Vec2} v2 - End vector.
         * @param {number} l - Interpolate value.
         * @returns {math.Vec2}
         */
        lerp(v1, v2, l) {
            var res = Vec2.clone(this);
            if (l <= 0.0) {
                res.copy(v1);
            } else if (l >= 1.0) {
                res.copy(v2);
            } else {
                res = Vec2.add(v1, Vec2.sub(v2, v1).scale(l));
            }
            return res;
        }

        static get LERP_DELTA() {
            return 1e-6;
        }

        /**
         * Spherically interpolates between two vectors.
         * Interpolates between current and v2 vector by amount t. The difference between this and linear interpolation (aka, "lerp") is that
         * the vectors are treated as directions rather than points in space. The direction of the returned vector is interpolated
         * by the angle and its magnitude is interpolated between the magnitudes of from and to.
         * @public
         * @param {math.Vec2} v2 -
         * @param {number} t - The parameter t is clamped to the range [0, 1].
         * @returns {math.Vec2}
         */
        slerp(v2, t) {
            var res = new Vec2();

            if (t <= 0.0) {
                res.copy(this);
                return;
            } else if (t >= 1.0) {
                res.copy(v2);
                return;
            }

            var omega, sinom, scale0, scale1;
            var cosom = this.dot(v2);

            if (1.0 - cosom > Vec2.LERP_DELTA) {
                omega = Math.acos(cosom);
                sinom = Math.sin(omega);
                scale0 = Math.sin((1.0 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
            } else {
                scale0 = 1.0 - t;
                scale1 = t;
            }

            return Vec2.add(this.scale(scale0), v2.scale(scale1));
        }
    }

    /**
     * @module og/utils/shared
     */

    function getDefault(param, def) {
        return param != undefined ? param : def;
    }

    function isEmpty(v) {
        return v == null;
    }

    let _stampCounter = 0;

    function stamp(obj) {
        var stamp = obj._openglobus_id;
        if (!stamp) {
            stamp = obj._openglobus_id = ++_stampCounter;
        }
        return stamp;
    }

    function isString(s) {
        return typeof s === "string" || s instanceof String;
    }

    /**
     * Synchronous text file loading. Returns file text.
     * @param {string} fileUrl - File name path.
     * @returns {string} -
     */
    function readTextFile(fileUrl) {
        var res = "";

        ajax.request(fileUrl, {
            async: false,
            success: function (data) {
                res = data;
            }
        });

        return res;
    }

    /**
     * Convert html color string to the RGBA number vector.
     * @param {string} htmlColor - HTML string("#C6C6C6" or "#EF5" or "rgb(8,8,8)" or "rgba(8,8,8)") color.
     * @param {number} [opacity] - Opacity for the output vector.
     * @returns {math.Vec4} -
     */
    function htmlColorToRgba(htmlColor, opacity) {
        var hColor = colorTable[htmlColor];
        if (hColor) {
            htmlColor = hColor;
        }

        if (htmlColor[0] === "#") {
            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            var hex = htmlColor.replace(shorthandRegex, function (m, r, g, b) {
                return r + r + g + g + b + b;
            });
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return new Vec4(
                parseInt(result[1], 16) / 255,
                parseInt(result[2], 16) / 255,
                parseInt(result[3], 16) / 255,
                isEmpty(opacity) ? 1.0 : opacity
            );
        } else {
            if (isEmpty(opacity)) {
                opacity = 1.0;
            }
            var m = htmlColor.split(",");
            return new Vec4(
                parseInt(m[0].split("(")[1]) / 255,
                parseInt(m[1]) / 255,
                parseInt(m[2]) / 255,
                !isEmpty(m[3]) ? parseFloat(m[3]) : opacity
            );
        }
    }

    function htmlColorToFloat32Array(htmlColor, opacity) {
        let c = htmlColorToRgba(htmlColor, opacity);
        return new Float32Array([c.x, c.y, c.z, c.w]);
    }

    /**
     * Convert html color string to the RGB number vector.
     * @param {string} htmlColor - HTML string("#C6C6C6" or "#EF5" or "rgb(8,8,8)" or "rgba(8,8,8)") color.
     * @param {number} [opacity] - Opacity for the output vector.
     * @returns {Vec3} -
     */
    function htmlColorToRgb(htmlColor) {
        var hColor = colorTable[htmlColor];
        if (hColor) {
            htmlColor = hColor;
        }

        if (htmlColor[0] === "#") {
            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            var hex = htmlColor.replace(shorthandRegex, function (m, r, g, b) {
                return r + r + g + g + b + b;
            });
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return new Vec4(
                parseInt(result[1], 16) / 255,
                parseInt(result[2], 16) / 255,
                parseInt(result[3], 16) / 255
            );
        } else {
            var m = htmlColor.split(",");
            return new Vec3(
                parseInt(m[0].split("(")[1]) / 255,
                parseInt(m[1]) / 255,
                parseInt(m[2]) / 255
            );
        }
    }

    /**
     * Replace template substrings between '{' and '}' tokens.
     * @param {string} template - String with templates in "{" and "}"
     * @param {Object} params - Template named object with subsrtings.
     * @returns {string} -
     *
     * @example <caption>Example from og.terrain that replaces tile indexes in url:</caption>
     * var substrings = {
     *       "x": 12,
     *       "y": 15,
     *       "z": 8
     * }
     * 26th July 2022 - Robert PASTOR
     * og.utils.stringTemplate("http://earth3.openglobus.org/{z}/{y}/{x}.ddm", substrins);
     * //returns http://earth3.openglobus.org/8/15/12.ddm
     */
    function stringTemplate(template, params) {
    	if ( typeof template == 'undefined' ) {
    		return ""
    	} else {
    		return template.replace(/{[^{}]+}/g, function (key) {
    			return params[key.replace(/[{}]+/g, "")] || "";
    		});
    	}
    }

    function getHTML(template, params) {
        return stringTemplate(template, params);
    }

    function parseHTML(htmlStr) {
        var p = document.createElement("div");
        p.innerHTML = htmlStr;
        var domArr = [];
        for (var i = 0; i < p.childNodes.length; i++) {
            domArr.push(p.childNodes[i]);
            p.removeChild(p.childNodes[i]);
        }
        return domArr;
    }

    function print2d(id, text, x, y) {
        var el = document.getElementById(id);
        if (!el) {
            el = document.createElement("div");
            el.id = id;
            el.classList.add("defaultText");
            document.body.appendChild(el);
        }
        el.innerHTML = text;
        el.style.left = x;
        el.style.top = y;
    }

    function defaultString(str, def) {
        return str ? str.trim().toLowerCase() : def;
    }

    function createVector3(v, def) {
        if (v) {
            if (v instanceof Vec3) {
                return v.clone();
            } else if (v instanceof Array) {
                return Vec3.fromVec(v);
            }
        } else if (def) {
            return def;
        }
        return new Vec3();
    }

    function createVector4(v, def) {
        if (v) {
            if (v instanceof Vec4) {
                return v.clone();
            } else if (v instanceof Array) {
                return Vec4.fromVec(v);
            }
        } else if (def) {
            return def;
        }
        return new Vec4();
    }

    function createColorRGBA(c, def) {
        if (c) {
            if (isString(c)) {
                return htmlColorToRgba(c);
            } else if (c instanceof Array) {
                return Vec4.fromVec(c);
            } else if (c instanceof Vec4) {
                return c.clone();
            }
        } else if (def) {
            return def;
        }
        return new Vec4(1.0, 1.0, 1.0, 1.0);
    }

    function createColorRGB(c, def) {
        if (c) {
            if (isString(c)) {
                return htmlColorToRgb(c);
            } else if (c instanceof Array) {
                return Vec3.fromVec(c);
            } else if (c instanceof Vec3) {
                return c.clone();
            }
        } else if (def) {
            return def;
        }
        return new Vec3(1.0, 1.0, 1.0);
    }

    function createExtent(e, def) {
        if (e) {
            if (e instanceof Array) {
                return new Extent(createLonLat(e[0]), createLonLat(e[1]));
            } else if (e instanceof Extent) {
                return e.clone();
            }
        } else if (def) {
            return def;
        }
        return new Extent();
    }

    function createLonLat(l, def = null) {
        if (l) {
            if (l instanceof Array) {
                return new LonLat(l[0], l[1], l[2]);
            } else if (l instanceof LonLat) {
                return l.clone();
            }
        } else if (def) {
            return def;
        }
        return new LonLat();
    }

    function binarySearchFast(arr, x) {
        let start = 0,
            end = arr.length - 1;
        while (start <= end) {
            let k = Math.floor((start + end) * 0.5);
            if (arr[k] === x) {
                return k;
            } else if (arr[k] < x) {
                start = k + 1;
            } else {
                end = k - 1;
            }
        }
        return -1;
    }

    /**
     * Finds an item in a sorted array.
     * @param {Array} ar The sorted array to search.
     * @param {Object} el The item to find in the array.
     * @param {utils.binarySearch~compare_fn} compare_fn comparator The function to use to compare the item to
     *        elements in the array.
     * @returns {Number} a negative number  if a is less than b; 0 if a is equal to b;a positive number of a is greater than b.
     *
     * @example
     * // Create a comparator function to search through an array of numbers.
     * function comparator(a, b) {
     *     return a - b;
     * };
     * var numbers = [0, 2, 4, 6, 8];
     * var index = og.utils.binarySearch(numbers, 6, comparator); // 3
     */
    function binarySearch(ar, el, compare_fn) {
        var m = 0;
        var n = ar.length - 1;
        while (m <= n) {
            var k = (n + m) >> 1;
            var cmp = compare_fn(el, ar[k], k);
            if (cmp > 0) {
                m = k + 1;
            } else if (cmp < 0) {
                n = k - 1;
            } else {
                return k;
            }
        }
        return -m - 1;
    }

    /**
     * Binary insertion that uses binarySearch algorithm.
     * @param {Array} ar - The sorted array to insert.
     * @param {Object} el - The item to insert.
     * @param {utils.binarySearch~compare_fn} compare_fn - comparator The function to use to compare the item to
     *        elements in the array.
     * @returns {Number} Array index position in which item inserted in.
     */
    function binaryInsert(ar, el, compare_fn) {
        var i = binarySearch(ar, el, compare_fn);
        if (i < 0) {
            i = ~i;
        }
        ar.splice(i, 0, el);
        return i;
    }

    /**
     * Returns two segment lines intersection coordinate.
     * @static
     * @param {math.Vec2} start1 - First line first coordinate.
     * @param {math.Vec2} end1 - First line second coordinate.
     * @param {math.Vec2} start2 - Second line first coordinate.
     * @param {math.Vec2} end2 - Second line second coordinate.
     * @param {boolean} [isSegment] - Lines are segments.
     * @return {math.Vec2} - Intersection coordinate.
     */
    function getLinesIntersection2v(start1, end1, start2, end2, isSegment) {
        var dir1 = end1.sub(start1);
        var dir2 = end2.sub(start2);

        var a1 = -dir1.y;
        var b1 = +dir1.x;
        var d1 = -(a1 * start1.x + b1 * start1.y);

        var a2 = -dir2.y;
        var b2 = +dir2.x;
        var d2 = -(a2 * start2.x + b2 * start2.y);

        var seg1_line2_start = a2 * start1.x + b2 * start1.y + d2;
        var seg1_line2_end = a2 * end1.x + b2 * end1.y + d2;

        var seg2_line1_start = a1 * start2.x + b1 * start2.y + d1;
        var seg2_line1_end = a1 * end2.x + b1 * end2.y + d1;

        if (
            isSegment &&
            (seg1_line2_start * seg1_line2_end > 0 || seg2_line1_start * seg2_line1_end > 0)
        ) {
            return null;
        }

        var u = seg1_line2_start / (seg1_line2_start - seg1_line2_end);

        return new Vec2(start1.x + u * dir1.x, start1.y + u * dir1.y);
    }

    /**
     * Returns two segment lines intersection coordinate.
     * @static
     * @param {math.Vec2} start1 - First line first coordinate.
     * @param {math.Vec2} end1 - First line second coordinate.
     * @param {math.Vec2} start2 - Second line first coordinate.
     * @param {math.Vec2} end2 - Second line second coordinate.
     * @param {boolean} [isSegment] - Lines are segments.
     * @return {math.Vec2} - Intersection coordinate.
     */
    function getLinesIntersectionLonLat(start1, end1, start2, end2, isSegment) {
        var dir1 = new LonLat(end1.lon - start1.lon, end1.lat - start1.lat);
        var dir2 = new LonLat(end2.lon - start2.lon, end2.lat - start2.lat);

        var a1 = -dir1.lat;
        var b1 = +dir1.lon;
        var d1 = -(a1 * start1.lon + b1 * start1.lat);

        var a2 = -dir2.lat;
        var b2 = +dir2.lon;
        var d2 = -(a2 * start2.lon + b2 * start2.lat);

        var seg1_line2_start = a2 * start1.lon + b2 * start1.lat + d2;
        var seg1_line2_end = a2 * end1.lon + b2 * end1.lat + d2;

        var seg2_line1_start = a1 * start2.lon + b1 * start2.lat + d1;
        var seg2_line1_end = a1 * end2.lon + b1 * end2.lat + d1;

        if (
            isSegment &&
            (seg1_line2_start * seg1_line2_end > 0 || seg2_line1_start * seg2_line1_end > 0)
        ) {
            return null;
        }

        var u = seg1_line2_start / (seg1_line2_start - seg1_line2_end);

        return new LonLat(start1.lon + u * dir1.lon, start1.lat + u * dir1.lat);
    }

    /**
     * Converts XML to JSON
     * @static
     * @param {Object} xml - Xml object
     * @return {Object} - Json converted object.
     */
    function xmlToJson(xml) {
        // Create the return object
        var obj = {};

        if (xml.nodeType === 1) {
            // element
            // do attributes
            if (xml.attributes.length > 0) {
                obj["@attributes"] = {};
                for (var j = 0; j < xml.attributes.length; j++) {
                    var attribute = xml.attributes.item(j);
                    obj["@attributes"][attribute.nodeName] = attribute.nodeValue;
                }
            }
        } else if (xml.nodeType === 3) {
            // text
            obj = xml.nodeValue;
        }

        // do children
        if (xml.hasChildNodes()) {
            for (var i = 0; i < xml.childNodes.length; i++) {
                var item = xml.childNodes.item(i);
                var nodeName = item.nodeName;
                if (typeof obj[nodeName] === "undefined") {
                    obj[nodeName] = xmlToJson(item);
                } else {
                    if (typeof obj[nodeName].push === "undefined") {
                        var old = obj[nodeName];
                        obj[nodeName] = [];
                        obj[nodeName].push(old);
                    }
                    obj[nodeName].push(xmlToJson(item));
                }
            }
        }
        return obj;
    }

    const castType = {
        string: function (v) {
            return isEmpty(v) ? v : v.toString();
        },

        date: function (v) {
            return isEmpty(v) ? v : new Date(v * 1000);
        },

        datetime: function (v) {
            return isEmpty(v) ? v : new Date(v * 1000);
        },

        time: function (v) {
            return isEmpty(v) ? v : parseInt(v);
        },

        integer: function (v) {
            return isEmpty(v) ? v : parseInt(v);
        },

        float: function (v) {
            return isEmpty(v) ? v : parseFloat(v);
        },

        boolean: function (str) {
            if (str === null) {
                return str;
            }

            if (typeof str === "boolean") {
                if (str === true) {
                    return true;
                }
                return false;
            }
            if (typeof str === "string") {
                if (str === "") {
                    return false;
                }
                str = str.replace(/^\s+|\s+$/g, "");
                if (str.toLowerCase() === "true" || str.toLowerCase() === "yes") {
                    return true;
                }
                str = str.replace(/,/g, ".");
                str = str.replace(/^\s*\-\s*/g, "-");
            }
            if (!isNaN(str)) {
                return parseFloat(str) !== 0;
            }
            return false;
        }
    };

    function base64toBlob(base64Data, contentType) {
        contentType = contentType || "";
        var sliceSize = 1024;
        var byteCharacters = atob(base64Data);
        var bytesLength = byteCharacters.length;
        var slicesCount = Math.ceil(bytesLength / sliceSize);
        var byteArrays = new Array(slicesCount);

        for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
            var begin = sliceIndex * sliceSize;
            var end = Math.min(begin + sliceSize, bytesLength);

            var bytes = new Array(end - begin);
            for (var offset = begin, i = 0; offset < end; ++i, ++offset) {
                bytes[i] = byteCharacters[offset].charCodeAt(0);
            }
            byteArrays[sliceIndex] = new Uint8Array(bytes);
        }
        return new Blob(byteArrays, { type: contentType });
    }

    function base64StringToBlog(string) {
        let block = string.split(";");
        let contentType = block[0].split(":")[1];
        let data = block[1].split(",")[1];

        return base64toBlob(data, contentType);
    }

    ///**
    // *
    // * @param {LonLat} p
    // * @param {LonLat} v1
    // * @param {LonLat} v2
    // * @param {LonLat} v3
    // * @param {Array<Number>} res
    // */
    //export function cartesianToBarycentricLonLat(p, v1, v2, v3, res) {

    //    const y2y3 = v2.lat - v3.lat,
    //        x3x2 = v3.lon - v2.lon,
    //        x1x3 = v1.lon - v3.lon,
    //        y1y3 = v1.lat - v3.lat,
    //        y3y1 = v3.lat - v1.lat,
    //        xx3 = p.lon - v3.lon,
    //        yy3 = p.lat - v3.lat;

    //    const d = y2y3 * x1x3 + x3x2 * y1y3,
    //        lambda1 = (y2y3 * xx3 + x3x2 * yy3) / d,
    //        lambda2 = (y3y1 * xx3 + x1x3 * yy3) / d;

    //    res[0] = lambda1;
    //    res[1] = lambda2;
    //    res[2] = 1 - lambda1 - lambda2;

    //    return 0 <= res[0] && res[0] <= 1 && 0 <= lambda1 && lambda1 <= 1 && 0 <= lambda2 && lambda2 <= 1;
    //};

    /**
     * Callback throttling
     * @param {any} func
     * @param {Number} limit
     * @param {Number} skip
     */
    function throttle(func, limit, skip) {
        let lastFunc;
        let lastRan;
        return function () {
            const context = this;
            const args = arguments;
            if (!lastRan) {
                func.apply(context, args);
                lastRan = Date.now();
            } else {
                if (skip) {
                    clearTimeout(lastFunc);
                }
                lastFunc = setTimeout(function () {
                    if (Date.now() - lastRan >= limit) {
                        func.apply(context, args);
                        lastRan = Date.now();
                    }
                }, limit - (Date.now() - lastRan));
            }
        };
    }

    /**
     *
     * y2-----Q12--------------Q22---
     * |       |     |          |
     * |       |     |          |
     * y-------|-----P----------|----
     * |       |     |          |
     * |       |     |          |
     * |       |     |          |
     * |       |     |          |
     * |       |     |          |
     * y1-----Q11----|---------Q21---
     *         |     |          |
     *         |     |          |
     *         x1    x          x2
     *
     *
     * @param {Number} x -
     * @param {Number} y -
     * @param {Number} fQ11 -
     * @param {Number} fQ21 -
     * @param {Number} fQ12 -
     * @param {Number} fQ22 -
     * @param {Number} [x1=0.0] -
     * @param {Number} [x2=1.0] -
     * @param {Number} [y1=0.0] -
     * @param {Number} [y2=1.0] -
     */
    function blerp(x, y, fQ11, fQ21, fQ12, fQ22, x1 = 0.0, x2 = 1.0, y1 = 0.0, y2 = 1.0) {
        return (
            (fQ11 * (x2 - x) * (y2 - y) +
                fQ21 * (x - x1) * (y2 - y) +
                fQ12 * (x2 - x) * (y - y1) +
                fQ22 * (x - x1) * (y - y1)) /
            ((x2 - x1) * (y2 - y1))
        );
    }

    function blerp2(x, y, fQ11, fQ21, fQ12, fQ22) {
        return (
            fQ11 * (1.0 - x) * (1.0 - y) + fQ21 * x * (1.0 - y) + fQ12 * (1.0 - x) * y + fQ22 * x * y
        );
    }

    function extractElevationTiles$1(rgbaData, outCurrenElevations, outChildrenElevations) {
        let destSize = Math.sqrt(outCurrenElevations.length) - 1;
        let destSizeOne = destSize + 1;
        let sourceSize = Math.sqrt(rgbaData.length / 4);
        let dt = sourceSize / destSize;

        let rightHeigh = 0,
            bottomHeigh = 0;

        for (
            let k = 0, currIndex = 0, sourceDataLength = rgbaData.length / 4;
            k < sourceDataLength;
            k++
        ) {
            let height = rgbaData[k * 4];

            let i = Math.floor(k / sourceSize),
                j = k % sourceSize;

            let tileX = Math.floor(j / destSize),
                tileY = Math.floor(i / destSize);

            let destArr = outChildrenElevations[tileY][tileX];

            let ii = i % destSize,
                jj = j % destSize;

            let destIndex = (ii + tileY) * destSizeOne + jj + tileX;

            destArr[destIndex] = height;

            if ((i + tileY) % dt === 0 && (j + tileX) % dt === 0) {
                outCurrenElevations[currIndex++] = height;
            }

            if ((j + 1) % destSize === 0 && j !== sourceSize - 1) {
                //current tile
                rightHeigh = rgbaData[(k + 1) * 4];
                let middleHeight = (height + rightHeigh) * 0.5;
                destIndex = (ii + tileY) * destSizeOne + jj + 1;
                destArr[destIndex] = middleHeight;

                if ((i + tileY) % dt === 0) {
                    outCurrenElevations[currIndex++] = middleHeight;
                }

                //next right tile
                let rightindex = (ii + tileY) * destSizeOne + ((jj + 1) % destSize);
                outChildrenElevations[tileY][tileX + 1][rightindex] = middleHeight;
            }

            if ((i + 1) % destSize === 0 && i !== sourceSize - 1) {
                //current tile
                bottomHeigh = rgbaData[(k + sourceSize) * 4];
                let middleHeight = (height + bottomHeigh) * 0.5;
                destIndex = (ii + 1) * destSizeOne + jj + tileX;
                destArr[destIndex] = middleHeight;

                if ((j + tileX) % dt === 0) {
                    outCurrenElevations[currIndex++] = middleHeight;
                }

                //next bottom tile
                let bottomindex = ((ii + 1) % destSize) * destSizeOne + jj + tileX;
                outChildrenElevations[tileY + 1][tileX][bottomindex] = middleHeight;
            }

            if (
                (j + 1) % destSize === 0 &&
                j !== sourceSize - 1 &&
                (i + 1) % destSize === 0 &&
                i !== sourceSize - 1
            ) {
                //current tile
                let rightBottomHeight = rgbaData[(k + sourceSize + 1) * 4];
                let middleHeight = (height + rightHeigh + bottomHeigh + rightBottomHeight) * 0.25;
                destIndex = (ii + 1) * destSizeOne + (jj + 1);
                destArr[destIndex] = middleHeight;

                outCurrenElevations[currIndex++] = middleHeight;

                //next right tile
                let rightindex = (ii + 1) * destSizeOne;
                outChildrenElevations[tileY][tileX + 1][rightindex] = middleHeight;

                //next bottom tile
                let bottomindex = destSize;
                outChildrenElevations[tileY + 1][tileX][bottomindex] = middleHeight;

                //next right bottom tile
                let rightBottomindex = 0;
                outChildrenElevations[tileY + 1][tileX + 1][rightBottomindex] = middleHeight;
            }
        }
    }

    /**
     * Concatenates two the same type arrays
     * @param {TypedArray} a
     * @param {TypedArray} b
     */
    function concatTypedArrays(a, b) {
        var c = new a.constructor(a.length + b.length);
        c.set(a, 0);
        c.set(b, a.length);
        return c;
    }

    /**
     * Concatenates two the same  arrays
     * @param {TypedArray | Array} a
     * @param {TypedArray | Array} b
     */
    function concatArrays(a = [], b) {
        if (ArrayBuffer.isView(a)) {
            return concatTypedArrays(a, b);
        } else {
            for (var i = 0; i < b.length; i++) {
                a.push(b[i]);
            }
            return a;
        }
    }

    /**
     * Convert simple array to typed
     * @param arr {Array}
     * @param ctor {Float32ArrayConstructor}
     * @returns {TypedArray}
     */
    function makeArrayTyped(arr, ctor = Float32Array) {
        if (!ArrayBuffer.isView(arr)) {
            const typedArr = new ctor(arr.length);
            typedArr.set(arr, 0);
            return typedArr;
        } else {
            return arr;
        }
    }

    /**
     * Convert typed array to array
     * @param arr {TypedArray}
     * @returns {Array}
     */
    function makeArray(arr) {
        if (ArrayBuffer.isView(arr)) {
            return Array.from(arr);
        } else {
            return arr;
        }
    }

    /**
     *
     * @param {TypedArray | Array} arr
     * @param {Number} starting
     * @param {Number} deleteCount
     * @param {Array} elements
     */

    function spliceArray(arr, starting, deleteCount, elements) {
        if (ArrayBuffer.isView(arr)) {
            return spliceTypedArray(arr, starting, deleteCount, elements);
        } else {
            arr.splice(starting, deleteCount);
            return arr;
        }
    }

    /**
     *
     * @param {TypedArray} arr
     * @param {Number} starting
     * @param {Number} deleteCount
     * @param {Array} elements
     */
    function spliceTypedArray(arr, starting, deleteCount, elements = []) {
        if (arr.length === 0) {
            return arr;
        }
        const newSize = arr.length - deleteCount + elements.length;
        const splicedArray = new arr.constructor(newSize);
        splicedArray.set(arr.subarray(0, starting));
        splicedArray.set(elements, starting);
        splicedArray.set(arr.subarray(starting + deleteCount), starting + elements.length);
        return splicedArray;
    }

    /**
     * Returns triangle coordinate array from inside of the source triangle array.
     * @static
     * @param {Array.<number>} sourceArr - Source array
     * @param {number} gridSize - Source array square matrix size
     * @param {number} i0 - First row index source array matrix
     * @param {number} j0 - First column index
     * @param {number} size - Square matrix result size.
     * @return{Array.<number>} Triangle coordinates array from the source array.
     * @TODO: optimization
     */
    function getMatrixSubArray(sourceArr, gridSize, i0, j0, size) {
        const size_1 = size + 1;
        const i0size = i0 + size_1;
        const j0size = j0 + size_1;

        var res = new Float64Array(size_1 * size_1 * 3);

        var vInd = 0;
        for (var i = i0; i < i0size; i++) {
            for (var j = j0; j < j0size; j++) {
                var ind = 3 * (i * (gridSize + 1) + j);

                res[vInd++] = sourceArr[ind];
                res[vInd++] = sourceArr[ind + 1];
                res[vInd++] = sourceArr[ind + 2];
            }
        }
        return res;
    }

    /**
     * Returns two float32 triangle coordinate arrays from inside of the source triangle array.
     * @static
     * @param {Array.<number>} sourceArr - Source array
     * @param {number} gridSize - Source array square matrix size
     * @param {number} i0 - First row index source array matrix
     * @param {number} j0 - First column index
     * @param {number} size - Square matrix result size.
     * @param {object} outBounds - Output bounds.
     * @return{Array.<number>} Triangle coordinates array from the source array.
     * @TODO: optimization
     */
    function getMatrixSubArrayBoundsExt(
        sourceArr,
        sourceArrHigh,
        sourceArrLow,
        noDataVertices,
        gridSize,
        i0,
        j0,
        size,
        outArr,
        outArrHigh,
        outArrLow,
        outBounds,
        outNoDataVertices
    ) {
        const i0size = i0 + size + 1;
        const j0size = j0 + size + 1;
        gridSize += 1;
        var vInd = 0,
            nInd = 0;
        for (var i = i0; i < i0size; i++) {
            for (var j = j0; j < j0size; j++) {
                let indBy3 = i * gridSize + j,
                    ind = 3 * indBy3;

                let x = sourceArr[ind],
                    y = sourceArr[ind + 1],
                    z = sourceArr[ind + 2];

                if (!noDataVertices || noDataVertices[indBy3] === 0) {
                    if (x < outBounds.xmin) outBounds.xmin = x;
                    if (x > outBounds.xmax) outBounds.xmax = x;
                    if (y < outBounds.ymin) outBounds.ymin = y;
                    if (y > outBounds.ymax) outBounds.ymax = y;
                    if (z < outBounds.zmin) outBounds.zmin = z;
                    if (z > outBounds.zmax) outBounds.zmax = z;
                } else {
                    outNoDataVertices[nInd] = 1;
                }

                nInd++;

                outArr[vInd] = x;
                outArrLow[vInd] = sourceArrLow[ind];
                outArrHigh[vInd++] = sourceArrHigh[ind];

                outArr[vInd] = y;
                outArrLow[vInd] = sourceArrLow[ind + 1];
                outArrHigh[vInd++] = sourceArrHigh[ind + 1];

                outArr[vInd] = z;
                outArrLow[vInd] = sourceArrLow[ind + 2];
                outArrHigh[vInd++] = sourceArrHigh[ind + 2];
            }
        }
    }

    function cloneArray(items) {
        return items.map((item) => (Array.isArray(item) ? cloneArray(item) : item));
    }

    /**
     * Returns true if the object pointer is undefined.
     * @function
     * @param {Object} obj - Object pointer.
     * @returns {boolean} Returns true if object is undefined.
     */
    function isUndef(obj) {
        return obj === void 0;
    }

    var shared = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getDefault: getDefault,
        isEmpty: isEmpty,
        stamp: stamp,
        isString: isString,
        readTextFile: readTextFile,
        htmlColorToRgba: htmlColorToRgba,
        htmlColorToFloat32Array: htmlColorToFloat32Array,
        htmlColorToRgb: htmlColorToRgb,
        stringTemplate: stringTemplate,
        getHTML: getHTML,
        parseHTML: parseHTML,
        print2d: print2d,
        defaultString: defaultString,
        createVector3: createVector3,
        createVector4: createVector4,
        createColorRGBA: createColorRGBA,
        createColorRGB: createColorRGB,
        createExtent: createExtent,
        createLonLat: createLonLat,
        binarySearchFast: binarySearchFast,
        binarySearch: binarySearch,
        binaryInsert: binaryInsert,
        getLinesIntersection2v: getLinesIntersection2v,
        getLinesIntersectionLonLat: getLinesIntersectionLonLat,
        xmlToJson: xmlToJson,
        castType: castType,
        base64toBlob: base64toBlob,
        base64StringToBlog: base64StringToBlog,
        throttle: throttle,
        blerp: blerp,
        blerp2: blerp2,
        extractElevationTiles: extractElevationTiles$1,
        concatTypedArrays: concatTypedArrays,
        concatArrays: concatArrays,
        makeArrayTyped: makeArrayTyped,
        makeArray: makeArray,
        spliceArray: spliceArray,
        spliceTypedArray: spliceTypedArray,
        getMatrixSubArray: getMatrixSubArray,
        getMatrixSubArrayBoundsExt: getMatrixSubArrayBoundsExt,
        cloneArray: cloneArray,
        isUndef: isUndef
    });

    /**
     * @module og/astro/jd
     */

    /**
     * Seconds in millisecond.
     * @const
     * @default
     */
    const SECONDS_PER_MILLISECOND = 0.001;

    /**
     * Milliseconds in second.
     * @const
     * @default
     */
    const MILLISECONDS_PER_SECOND = 1000.0;

    /**
     * Seconds in minute.
     * @const
     * @default
     */
    const SECONDS_PER_MINUTE = 60.0;

    /**
     * One by seconds in minute.
     * @const
     * @default
     */
    const ONE_BY_SECONDS_PER_MINUTE = 1.0 / SECONDS_PER_MINUTE;

    /**
     * Minutes in hour.
     * @const
     * @default
     */
    const MINUTES_PER_HOUR = 60.0;

    /**
     * Hours in day.
     * @const
     * @default
     */
    const HOURS_PER_DAY = 24.0;

    /**
     * One by hours in day.
     * @const
     * @default
     */
    const ONE_BY_HOURS_PER_DAY = 1.0 / HOURS_PER_DAY;

    /**
     * Seconds in hour.
     * @const
     * @default
     */
    const SECONDS_PER_HOUR = 3600.0;

    /**
     * One by seconds in hour.
     * @const
     * @default
     */
    const ONE_BY_SECONDS_PER_HOUR = 1.0 / SECONDS_PER_HOUR;

    /**
     * Seconds in 12 hours.
     * @const
     * @default
     */
    const SECONDS_PER_12_HOURS = 12.0 * SECONDS_PER_HOUR;

    /**
     * Minutes in day.
     * @const
     * @default
     */
    const MINUTES_PER_DAY = 1440.0;

    /**
     * One by minutes in day.
     * @const
     * @default
     */
    const ONE_BY_MINUTES_PER_DAY = 1.0 / MINUTES_PER_DAY;

    /**
     * Seconds in day.
     * @const
     * @default
     */
    const SECONDS_PER_DAY = 86400.0;

    /**
     * Milliseconds in day.
     * @const
     * @default
     */
    const MILLISECONDS_PER_DAY = 86400000.0;

    /**
     * One by milliseconds in day.
     * @const
     * @default
     */
    const ONE_BY_MILLISECONDS_PER_DAY = 1.0 / MILLISECONDS_PER_DAY;

    /**
     * One by seconds in day.
     * @const
     * @default
     */
    const ONE_BY_SECONDS_PER_DAY = 1.0 / SECONDS_PER_DAY;

    /**
     * Days in julian century.
     * @const
     * @default
     */
    const DAYS_PER_JULIAN_CENTURY = 36525.0;

    /**
     * Days in julian year.
     * @const
     * @default
     */
    const DAYS_PER_JULIAN_YEAR = 365.25;

    /**
     * Seconds in picosecond.
     * @const
     * @default
     */
    const PICOSECOND = 0.000000001;

    /**
     * Modified julian date difference.
     * @const
     * @default
     */
    const MODIFIED_JULIAN_DATE_DIFFERENCE = 2400000.5;

    /**
     * Julian date of 2000 year. Epoch.
     * @const
     * @default
     */
    const J2000 = 2451545.0;

    /**
     * Returns julian days from Epoch.
     * @param {number} jd - Julian date.
     * @returns {number} Days from epoch
     */
    function T(jd) {
        return (jd - J2000) / DAYS_PER_JULIAN_CENTURY;
    }

    /**
     * Gets the date's julian day.
     * @param {number} year - Year.
     * @param {number} month - Month.
     * @param {number} day - Day.
     * @returns {Number} Day number
     */
    function getDayNumber(year, month, day) {
        var a = ((month - 14) / 12) | 0;
        var b = year + 4800 + a;
        return (
            (((1461 * b) / 4) | 0) +
            (((367 * (month - 2 - 12 * a)) / 12) | 0) -
            (((3 * (((b + 100) / 100) | 0)) / 4) | 0) +
            day -
            32075
        );
    }

    /**
     * Converts javascript date to the universal(UTC) julian date.
     * @param {Date} date - Date.
     * @returns {number} UTC julian date
     */
    function DateToUTC(date) {
        var dayNumber = getDayNumber(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate());

        var hour = date.getUTCHours() - 12;
        if (hour < 0) {
            hour += 24;
        }

        var secondsOfDay =
            date.getUTCSeconds() +
            hour * SECONDS_PER_HOUR +
            date.getUTCMinutes() * SECONDS_PER_MINUTE +
            date.getUTCMilliseconds() * SECONDS_PER_MILLISECOND;

        if (secondsOfDay >= SECONDS_PER_12_HOURS) {
            dayNumber--;
        }

        var extraDays = (secondsOfDay * ONE_BY_SECONDS_PER_DAY) | 0;
        dayNumber += extraDays;
        secondsOfDay -= SECONDS_PER_DAY * extraDays;

        if (secondsOfDay < 0) {
            dayNumber--;
            secondsOfDay += SECONDS_PER_DAY;
        }

        return dayNumber + secondsOfDay * ONE_BY_SECONDS_PER_DAY;
    }

    /**
     * Converts javascript date to the atomic(TAI) julian date.
     * @param {Date} date - Date.
     * @returns {number} TAI julian date
     */
    function DateToTAI(date) {
        return UTCtoTAI(DateToUTC(date));
    }

    /**
     * Converts coordinated universal(UTC) julian date to atomic(TAI) julian date.
     * @param {number} jd - UTC julian date.
     * @returns {number} TAI julian date
     */
    function UTCtoTAI(jd) {
        var leapSeconds = leapSecondsTable;

        var index = binarySearch(leapSeconds, jd, function (a, b) {
            return a - b.jd;
        });

        if (index < 0) {
            index = ~index;
        }

        if (index >= leapSeconds.length) {
            index = leapSeconds.length - 1;
        }

        var offset = leapSeconds[index].leapSeconds;

        if (index !== 0) {
            if ((leapSeconds[index].jd - jd) * SECONDS_PER_DAY > offset) {
                offset = leapSeconds[index - 1].leapSeconds;
            }
        }

        return jd + offset * ONE_BY_SECONDS_PER_DAY;
    }

    /**
     * Converts atomic julian date(TAI) to the coordinated universal(UTC) julian date.
     * @param {number} tai - TAI julian date.
     * @returns {number} UTC julian date
     */
    function TAItoUTC(tai) {
        var leapSeconds = leapSecondsTable;
        var index = binarySearch(leapSeconds, tai, function (a, b) {
            return a - b.jd;
        });

        if (index < 0) {
            index = ~index;
        }

        if (index >= leapSeconds.length) {
            return tai - leapSeconds[index - 1].leapSeconds * ONE_BY_SECONDS_PER_DAY;
        }

        if (index === 0) {
            return tai - leapSeconds[0].leapSeconds * ONE_BY_SECONDS_PER_DAY;
        }

        var diff = (leapSeconds[index].jd - tai) * SECONDS_PER_DAY;

        if (diff === 0) {
            return tai - leapSeconds[index].leapSeconds * ONE_BY_SECONDS_PER_DAY;
        }

        if (diff <= 1.0) {
            return null;
        }

        return tai - leapSeconds[index - 1].leapSeconds * ONE_BY_SECONDS_PER_DAY;
    }

    /**
     * Converts UTC julian date to the javascript date object.
     * @param {number} utc - UTC julian date.
     * @returns {Date} JavaScript Date object
     */
    function UTCtoDate(utc) {
        var julianDayNumber = utc | 0;
        var secondsOfDay = (utc - julianDayNumber) * SECONDS_PER_DAY;

        if (secondsOfDay >= SECONDS_PER_12_HOURS) {
            julianDayNumber++;
        }

        var L = (julianDayNumber + 68569) | 0;
        var N = ((4 * L) / 146097) | 0;
        L = (L - (((146097 * N + 3) / 4) | 0)) | 0;
        var I = ((4000 * (L + 1)) / 1461001) | 0;
        L = (L - (((1461 * I) / 4) | 0) + 31) | 0;
        var J = ((80 * L) / 2447) | 0;
        var day = (L - (((2447 * J) / 80) | 0)) | 0;
        L = (J / 11) | 0;
        var month = (J + 2 - 12 * L) | 0;
        var year = (100 * (N - 49) + I + L) | 0;

        var hour = (secondsOfDay * ONE_BY_SECONDS_PER_HOUR) | 0;
        var remainingSeconds = secondsOfDay - hour * SECONDS_PER_HOUR;
        var minute = (remainingSeconds * ONE_BY_SECONDS_PER_MINUTE) | 0;
        remainingSeconds = remainingSeconds - minute * SECONDS_PER_MINUTE;
        var second = remainingSeconds | 0;
        var millisecond = ((remainingSeconds - second) * MILLISECONDS_PER_SECOND) | 0;

        hour += 12;
        if (hour > 23) {
            hour -= 24;
        }

        return new Date(Date.UTC(year, month - 1, day, hour, minute, second, millisecond));
    }

    /**
     * Converts TAI julian date to the javascript date object.
     * @param {number} tai - TAI julian date.
     * @returns {Date} JavaScript Date object
     */
    function TAItoDate(tai) {
        var utc = TAItoUTC(tai);
        if (!utc) {
            utc = TAItoUTC(addSeconds(tai, -1));
            console.warn("TAItoDate:336 - can't conv utc.");
        }

        return UTCtoDate(utc);
    }

    /**
     * Adds milliseconds to the julian date.
     * @param {number} jd - Julian date.
     * @param {number} milliseconds - Milliseconds to add.
     * @returns {number} Julian date
     */
    function addMilliseconds(jd, milliseconds) {
        return jd + milliseconds * ONE_BY_MILLISECONDS_PER_DAY;
    }

    /**
     * Adds seconds to the julian date.
     * @param {number} jd - Julian date.
     * @param {number} seconds - Seconds to add.
     * @returns {number} Julian date
     */
    function addSeconds(jd, seconds) {
        return jd + seconds * ONE_BY_SECONDS_PER_DAY;
    }

    /**
     * Adds hours to the julian date.
     * @param {number} jd - Julian date.
     * @param {number} hours - Hours to add.
     * @returns {number} Julian date
     */
    function addHours(jd, hours) {
        return jd + hours * ONE_BY_HOURS_PER_DAY;
    }

    /**
     * Adds minutes to the julian date.
     * @param {number} jd - Julian date.
     * @param {number} minutes - Minutes to add.
     * @returns {number} Julian date
     */
    function addMinutes(jd, minutes) {
        return jd + minutes * MINUTES_PER_DAY;
    }

    /**
     * Adds days to the julian date.
     * @param {number} jd - Julian date.
     * @param {number} days - Days to add.
     * @returns {number} Julian date
     */
    function addDays(jd, days) {
        return jd + days;
    }

    /**
     * Gets milliseconds of a julian date.
     * @param {number} js - julian date.
     * @returns {number} Milliseconds
     */
    function getMilliseconds(jd) {
        var s = jd - (jd | 0);
        s *= SECONDS_PER_DAY;
        return ((s - (s | 0)) * MILLISECONDS_PER_SECOND) | 0;
    }

    /**
     * Gets seconds of a julian date.
     * @param {number} js - julian date.
     * @returns {number} Seconds
     */
    function getSeconds(jd) {
        var s = jd - (jd | 0);
        return s * SECONDS_PER_DAY;
    }

    /**
     * Gets hours of a julian date.
     * @param {number} js - julian date.
     * @returns {number} Hours
     */
    function getHours(jd) {
        var julianDayNumber = jd | 0;
        var secondsOfDay = (jd - julianDayNumber) * SECONDS_PER_DAY;

        var hour = (secondsOfDay * ONE_BY_SECONDS_PER_HOUR) | 0;
        var remainingSeconds = secondsOfDay - hour * SECONDS_PER_HOUR;
        var minute = (remainingSeconds * ONE_BY_SECONDS_PER_MINUTE) | 0;
        remainingSeconds = remainingSeconds - minute * SECONDS_PER_MINUTE;
        var second = remainingSeconds | 0;
        var millisecond = ((remainingSeconds - second) * MILLISECONDS_PER_SECOND) | 0;

        hour += 12 + minute / 60 + second / 3600 + millisecond / 1000;
        if (hour > 23) {
            hour -= 24;
        }

        return hour;
    }

    /**
     * Gets minutes of a julian date.
     * @param {number} js - julian date.
     * @returns {number} Minutes
     */
    function getMinutes(jd) {
        var s = jd - (jd | 0);
        return (s * MINUTES_PER_DAY) | 0;
    }

    /**
     * Gets days of a julian date.
     * @param {number} js - julian date.
     * @returns {number} Days
     */
    function getDays(jd) {
        return jd | 0;
    }

    /**
     * Returns days in seconds.
     * @param {number} s - Seconds.
     * @returns {number} Days
     */
    function secondsToDays(s) {
        return s * ONE_BY_SECONDS_PER_DAY;
    }

    /**
     * Returns seconds in days.
     * @param {number} d - Days.
     * @returns {number} Seconds
     */
    function daysToSeconds(d) {
        return d * SECONDS_PER_DAY;
    }

    function __ls(jd, leapSeconds) {
        return {
            jd: jd,
            leapSeconds: leapSeconds
        };
    }

    const leapSecondsTable = [
        __ls(2441317.5, 10.0), // 1972-01-01T00:00:00.000Z
        __ls(2441499.5, 11.0), // 1972-07-01T00:00:00.000Z
        __ls(2441683.5, 12.0), // 1973-01-01T00:00:00.000Z
        __ls(2442048.5, 13.0), // 1974-01-01T00:00:00.000Z
        __ls(2442413.5, 14.0), // 1975-01-01T00:00:00.000Z
        __ls(2442778.5, 15.0), // 1976-01-01T00:00:00.000Z
        __ls(2443144.5, 16.0), // 1977-01-01T00:00:00.000Z
        __ls(2443509.5, 17.0), // 1978-01-01T00:00:00.000Z
        __ls(2443874.5, 18.0), // 1979-01-01T00:00:00.000Z
        __ls(2444239.5, 19.0), // 1980-01-01T00:00:00.000Z
        __ls(2444786.5, 20.0), // 1981-07-01T00:00:00.000Z
        __ls(2445151.5, 21.0), // 1982-07-01T00:00:00.000Z
        __ls(2445516.5, 22.0), // 1983-01-01T00:00:00.000Z
        __ls(2446247.5, 23.0), // 1985-07-01T00:00:00.000Z
        __ls(2447161.5, 24.0), // 1988-01-01T00:00:00.000Z
        __ls(2447892.5, 25.0), // 1990-01-01T00:00:00.000Z
        __ls(2448257.5, 26.0), // 1991-01-01T00:00:00.000Z
        __ls(2448804.5, 27.0), // 1992-07-01T00:00:00.000Z
        __ls(2449169.5, 28.0), // 1993-07-01T00:00:00.000Z
        __ls(2449534.5, 29.0), // 1994-07-01T00:00:00.000Z
        __ls(2450083.5, 30.0), // 1996-01-01T00:00:00.000Z
        __ls(2450630.5, 31.0), // 1997-07-01T00:00:00.000Z
        __ls(2451179.5, 32.0), // 1999-01-01T00:00:00.000Z
        __ls(2453736.5, 33.0), // 2006-01-01T00:00:00.000Z
        __ls(2454832.5, 34.0), // 2009-01-01T00:00:00.000Z
        __ls(2456109.5, 35.0), // 2012-07-01T00:00:00.000Z
        __ls(2457204.5, 36.0) // 2015-07-01T00:00:00.000Z
    ];

    const J2000TAI = UTCtoTAI(J2000);

    var jd = /*#__PURE__*/Object.freeze({
        __proto__: null,
        SECONDS_PER_MILLISECOND: SECONDS_PER_MILLISECOND,
        MILLISECONDS_PER_SECOND: MILLISECONDS_PER_SECOND,
        SECONDS_PER_MINUTE: SECONDS_PER_MINUTE,
        ONE_BY_SECONDS_PER_MINUTE: ONE_BY_SECONDS_PER_MINUTE,
        MINUTES_PER_HOUR: MINUTES_PER_HOUR,
        HOURS_PER_DAY: HOURS_PER_DAY,
        ONE_BY_HOURS_PER_DAY: ONE_BY_HOURS_PER_DAY,
        SECONDS_PER_HOUR: SECONDS_PER_HOUR,
        ONE_BY_SECONDS_PER_HOUR: ONE_BY_SECONDS_PER_HOUR,
        SECONDS_PER_12_HOURS: SECONDS_PER_12_HOURS,
        MINUTES_PER_DAY: MINUTES_PER_DAY,
        ONE_BY_MINUTES_PER_DAY: ONE_BY_MINUTES_PER_DAY,
        SECONDS_PER_DAY: SECONDS_PER_DAY,
        MILLISECONDS_PER_DAY: MILLISECONDS_PER_DAY,
        ONE_BY_MILLISECONDS_PER_DAY: ONE_BY_MILLISECONDS_PER_DAY,
        ONE_BY_SECONDS_PER_DAY: ONE_BY_SECONDS_PER_DAY,
        DAYS_PER_JULIAN_CENTURY: DAYS_PER_JULIAN_CENTURY,
        DAYS_PER_JULIAN_YEAR: DAYS_PER_JULIAN_YEAR,
        PICOSECOND: PICOSECOND,
        MODIFIED_JULIAN_DATE_DIFFERENCE: MODIFIED_JULIAN_DATE_DIFFERENCE,
        J2000: J2000,
        T: T,
        getDayNumber: getDayNumber,
        DateToUTC: DateToUTC,
        DateToTAI: DateToTAI,
        UTCtoTAI: UTCtoTAI,
        TAItoUTC: TAItoUTC,
        UTCtoDate: UTCtoDate,
        TAItoDate: TAItoDate,
        addMilliseconds: addMilliseconds,
        addSeconds: addSeconds,
        addHours: addHours,
        addMinutes: addMinutes,
        addDays: addDays,
        getMilliseconds: getMilliseconds,
        getSeconds: getSeconds,
        getHours: getHours,
        getMinutes: getMinutes,
        getDays: getDays,
        secondsToDays: secondsToDays,
        daysToSeconds: daysToSeconds,
        J2000TAI: J2000TAI
    });

    /**
     * @module og/control/Control
     */

    /**
     * Base control class for implementing renderer controls.
     * All other controls extend from this class.
     * @class
     * @param {Object} [options] - Control activation options:
     * @param {Boolean} [options.autoActivated=true] - If true - calls initialize function after the renderer assigning.
     */
    class Control$1 {
        /**
         * @param {Object} [options] - Control activation options:
         */
        constructor(options) {
            options = options || {};

            this._id = Control$1.__staticCounter++;

            this._name = options.name || "_control_" + this._id;

            /**
             * Control initialized.
             * @protected
             * @type {Boolean}
             */
            this._initialized = false;

            /**
             * Assigned renderer.
             * @public
             * @type {Renderer}
             */
            this.renderer = null;

            /**
             * Auto activation flag.
             * @public
             * @type {Boolean}
             */
            this.autoActivate = options.autoActivate != undefined ? options.autoActivate : true;

            /**
             * Control activity.
             * @protected
             * @type {Boolean}
             */
            this._active = false;
        }

        static get __staticCounter() {
            if (!this.__counter && this.__counter !== 0) {
                this.__counter = 0;
            }
            return this.__counter;
        }

        static set __staticCounter(n) {
            this.__counter = n;
        }

        /**
         * Returns control name.
         * @public
         * @virtual
         */
        get name() {
            return this._name;
        }

        /**
         * Control initialization function have to be overriden.
         * @public
         * @virtual
         */
        oninit() {}

        /**
         * Control renderer assigning function have to be overriden.
         * @public
         * @virtual
         */
        onadd() {}

        /**
         * Control remove function have to be overriden.
         * @public
         * @virtual
         */
        onremove() {}

        /**
         * Control activation function have to be overriden.
         * @public
         * @virtual
         */
        onactivate() {}

        /**
         * Control deactivation function have to be overriden.
         * @public
         * @virtual
         */
        ondeactivate() {}

        /**
         * Assign renderer to the control.
         * @public
         * @type {Renderer}
         */
        addTo(renderer) {
            if (renderer) {
                this.renderer = renderer;
                renderer.controls[this.name] = this;
                this.onadd && this.onadd();
                if (this.autoActivate) {
                    this._initialized = true;
                    this.oninit && this.oninit();
                    this._active = true;
                }
            }
        }

        /**
         * Assign renderer to the control.
         * @public
         */
        remove() {
            this.onremove && this.onremove();

            let r = this.renderer,
                n = this.name;

            if (!r) return;

            let c = r.controls[n];

            if (c) {
                if (this.isEqual(c)) {
                    r.controls[n] = null;
                    delete r.controls[n];
                }
            }

            this.renderer = null;
            this._active = false;
            this._initialized = false;
        }

        /**
         * Activate control.
         * @public
         */
        activate() {
            if (!this._initialized) {
                this._initialized = true;
                this.oninit && this.oninit();
            }
            this._active = true;
            this.onactivate && this.onactivate();
        }

        /**
         * Deactivate control.
         * @public
         */
        deactivate() {
            this._active = false;
            this.ondeactivate && this.ondeactivate();
        }

        /**
         * Is control active.
         * @public
         */
        isActive() {
            return this._active;
        }

        isEqual(control) {
            return control._id === this._id;
        }
    }

    let svg = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   viewBox="0 0 110.6 110.3"
   version="1.1"
   id="svg21"
   sodipodi:docname="aaa.svg"
   inkscape:version="0.92.3 (2405546, 2018-03-11)">
  <metadata
     id="metadata11">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <defs
     id="defs25" />
  <sodipodi:namedview
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1"
     objecttolerance="10"
     gridtolerance="10"
     guidetolerance="10"
     inkscape:pageopacity="0"
     inkscape:pageshadow="2"
     inkscape:window-width="1920"
     inkscape:window-height="1001"
     id="namedview23"
     showgrid="false"
     inkscape:zoom="9.4900968"
     inkscape:cx="28.376998"
     inkscape:cy="60.17054"
     inkscape:window-x="-9"
     inkscape:window-y="-9"
     inkscape:window-maximized="1"
     inkscape:current-layer="svg21" />
  <g
     id="Layer_2"
     data-name="Layer 2"
     transform="matrix(1,0,0,-1,0,110.3)">
    <g
       id="Слой_1"
       data-name="Слой 1">
      <g
         id="_Group_"
         data-name="&lt;Group&gt;">
        <g
           id="_Group_7"
           data-name="&lt;Group&gt;">
          <polygon
             id="_Path_7"
             data-name="&lt;Path&gt;"
             points="55.2,97.6 55.3,97.4 55.3,97.6 55.3,97.2 65.3,55.1 55.3,55.1 55.2,55.1 45.3,55.1 55.2,97.2 "
             style="fill:#ff2b45" />
          <polygon
             id="_Path_8"
             data-name="&lt;Path&gt;"
             points="55.3,12.7 55.3,12.9 55.2,12.7 55.2,13.1 45.3,55.1 55.2,55.1 55.3,55.1 65.3,55.1 55.3,13.1 "
             style="fill:#cecece;" />
        </g>
      </g>
    </g>
  </g>
</svg>`;

    /**
     * Planet compass button
     * @class
     * @extends {Control}
     * @params {Object} [options] - Control options.
     */
    class CompassButton extends Control$1 {
        /**
         *
         * @params {Object} [options] - Control options.
         */
        constructor(options) {
            super(options);

            options = options || {};

            this.planet = null;

            this.compassSvg = options.compassSvg || svg;

            this._heading = null;

            this._svg = null;
        }

        oninit() {
            var btnEl = parseHTML(`<div class="og-compass-button">${this.compassSvg}</div>`)[0];

            this._svg = btnEl.querySelector("svg");

            this.renderer.div.appendChild(btnEl);

            btnEl.addEventListener("click", (e) => this._onClick());

            this.renderer.events.on("draw", this._draw, this);
        }

        _onClick() {
            let c = this.planet.getCartesianFromPixelTerrain(this.renderer.handler.getCenter());
            if (c) {
                this.planet.flyCartesian(
                    c.normal().scaleTo(c.length() + c.distance(this.planet.camera.eye)),
                    null,
                    null,
                    0,
                    null,
                    null,
                    () => {
                        this.planet.camera.look(c);
                    }
                );
            } else {
                this.planet.flyCartesian(this.planet.camera.eye);
            }
        }

        _draw(e) {
            this.setHeading(e.activeCamera.getHeading());
        }

        setHeading(heading) {
            if (this._heading !== heading) {
                this._heading = heading;
                this._svg.style.transform = `rotateZ(${-heading}deg)`;
            }
        }
    }

    /**
     * @module og/control/DebugInfo
     */

    /**
     * Debug information
     * @class
     * @extends {Control}
     * @param {Object} [options] - Control options.
     */
    class DebugInfo extends Control$1 {
        /**
         * @param {Object} [options] - Control options.
         */
        constructor(options) {
            options = options || {};
            if (!options.name || options.name === "") {
                options.name = "DebugInfo";
            }
            super(options);
            this.el = null;
            this._watch = options.watch || [];
        }

        addWatches(watches) {
            for (var i = 0; i < watches.length; i++) {
                this.addWatch(watches[i]);
            }
        }

        addWatch(watch) {
            this._watch.push(watch);
            let watchEl = document.createElement("div");
            watchEl.classList.add("og-watch-line");
            watchEl.innerHTML =
                '<div class="og-watch-label">' +
                watch.label +
                '</div><div class="og-watch-value"></div>';
            watch.valEl = watchEl.querySelector(".og-watch-value");
            this.el.appendChild(watchEl);
        }

        oninit() {
            this.el = document.createElement("div");
            this.el.className = "og-debug-info";
            var temp = this._watch;
            this._watch = [];
            for (var i = 0; i < temp.length; i++) {
                this.addWatch(temp[i]);
            }
            this.renderer.div.appendChild(this.el);
            this.renderer.events.on("draw", this._frame, this);

            let p = this.planet;

            if (p) {
                this.addWatches([
                    {
                        label: "Nodes count",
                        frame: () => p._renderedNodes.length
                    },
                    {
                        label: "createdNodes",
                        frame: () => p._createdNodesCount
                    },
                    {
                        label: "indexesCache",
                        frame: () => p._indexesCacheToRemoveCounter
                    },
                    {
                        label: "distBeforeMemClear",
                        frame: () => Math.round(p._distBeforeMemClear)
                    },
                    {
                        label: "maxZoom/minZoom",
                        frame: () => p.maxCurrZoom + " / " + p.minCurrZoom
                    },
                    {
                        label: "viewExtent",
                        frame: () => p.getViewExtent().toString()
                    },
                    {
                        label: "height/alt (km)",
                        frame: () =>
                            `<div style="width:190px">${(p.camera._lonLat.height / 1000.0).toFixed(2) +
                        " / " +
                        (p.camera.getAltitude() / 1000.0).toFixed(2)
                        }</div>`
                    },
                    {
                        label: "cam.slope",
                        frame: () => p.camera.slope.toFixed(3)
                    },
                    {
                        label: "lodSize",
                        frame: () => Math.round(p.lodSize)
                    },
                    {
                        label: "deltaTime/FPS",
                        frame: () =>
                            `<div style="width:70px"><div style="width:20px; float: left;">${Math.round(
                            p.renderer.handler.deltaTime
                        )}</div> <div style="float: left">${Math.round(
                            1000.0 / p.renderer.handler.deltaTime
                        )}</div></div>`
                    },
                    {
                        label: "-------------------------"
                    },
                    {
                        label: "_renderCompleted / renderCompletedActivated",
                        frame: () => `${p._renderCompleted} / ${p._renderCompletedActivated}`
                    },
                    {
                        label: "_terrainCompleted / terrainCompletedActivated",
                        frame: () => `${p._terrainCompleted} / ${p._terrainCompletedActivated}`
                    },
                    {
                        label: "PlainWorker",
                        frame: () => p._plainSegmentWorker._pendingQueue.length
                    },
                    {
                        label: "TileLoader",
                        frame: () => p._tileLoader._loading + " " + p._tileLoader._queue.length
                    },
                    {
                        label: "TerrainLoader",
                        frame: () => {
                            if (p.terrain && p.terrain._loader) {
                                return (
                                    p.terrain._loader._loading + " " + p.terrain._loader._queue.length
                                );
                            }
                            return "";
                        }
                    },
                    {
                        label: "TerrainWorker",
                        frame: () => p._terrainWorker._pendingQueue.length
                    },
                    {
                        label: "NormalMapCreator",
                        frame: () => p._normalMapCreator._queue.length
                    }
                ]);
            }
        }

        _frame() {
            for (var i = 0; i < this._watch.length; i++) {
                var w = this._watch[i];
                w.valEl.innerHTML = w.frame ? w.frame() : "";
            }
        }
    }

    /**
     * @module og/bv/Sphere
     */

    /**
     * Bounding sphere class.
     * @class
     * @param {Number} [radius] - Bounding sphere radius.
     * @param {Vec3} [center] - Bounding sphere coordiantes.
     */
    class Sphere$1 {
        /**
         *
         * @param {number} radius
         * @param {Vec3} center
         */
        constructor(radius = 0, center = Vec3.ZERO) {
            /**
             * Sphere radius.
             * @public
             * @type {Number}
             */
            this.radius = radius;

            /**
             * Sphere coordiantes.
             * @public
             * @type {Vec3}
             */
            this.center = center ? center.clone() : new Vec3();
        }

        /**
         * Sets bounding sphere coordinates by the bounds array.
         * @param {Array.<number>} bounds - Bounds is an array where [minX, minY, minZ, maxX, maxY, maxZ]
         */
        setFromBounds(bounds) {
            let m = new Vec3(bounds[0], bounds[1], bounds[2]);
            this.center.set(
                m.x + (bounds[3] - m.x) * 0.5,
                m.y + (bounds[3] - m.y) * 0.5,
                m.z + (bounds[5] - m.z) * 0.5
            );
            this.radius = this.center.distance(m);
        }

        /**
         * Sets bounding sphere coordiantes by ellipsoid geodetic extend.
         * @param {Ellipsoid} ellipsoid - Ellipsoid.
         * @param {Extent} extent - Geodetic extent.
         */
        setFromExtent(ellipsoid, extent) {
            this.setFromBounds(extent.getCartesianBounds(ellipsoid));
        }
    }

    /**
     * @module og/math/Ray
     */

    /**
     * Represents a ray that extends infinitely from the provided origin in the provided direction.
     * @class
     * @param {Vec3} origin - The origin of the ray.
     * @param {Vec3} direction - The direction of the ray.
     */
    class Ray$1 {
        constructor(origin = Vec3.ZERO, direction = Vec3.ZERO) {
            /**
             * The origin of the ray.
             * @public
             * @type {Vec3}
             */
            this.origin = origin || new Vec3();

            /**
             * The direction of the ray.
             * @public
             * @type {Vec3}
             */
            this.direction = direction || new Vec3();
        }

        /** @const */
        static get OUTSIDE() {
            return 0;
        }

        /** @const */
        static get INSIDE() {
            return 1;
        }
        /** @const */
        static get INPLANE() {
            return 2;
        }
        /** @const */
        static get AWAY() {
            return 3;
        }

        /**
         * Sets a ray parameters.
         * @public
         * @param {Vec3} origin - The origin of the ray.
         * @param {Vec3} direction - The direction of the ray.
         * @returns {Ray}
         */
        set(origin, direction) {
            this.origin = origin;
            this.direction = direction;
            return this;
        }

        /**
         * Computes the point along the ray on the distance.
         * @public
         * @param {number} distance - Point distance.
         * @returns {Vec3}
         */
        getPoint(distance) {
            return Vec3.add(this.origin, this.direction.scaleTo(distance));
        }

        /**
         * Returns ray hit a triange result.
         * @public
         * @param {Vec3} v0 - First triangle corner coordinate.
         * @param {Vec3} v1 - Second triangle corner coordinate.
         * @param {Vec3} v2 - Third triangle corner coordinate.
         * @param {Vec3} res - Hit point object pointer that stores hit result.
         * @returns {number} - Hit code, could 0 - og.Ray.OUTSIDE, 1 - og.Ray.INSIDE,
         *      2 - og.Ray.INPLANE and 3 - og.Ray.AWAY(ray goes away from triangle).
         */
        hitTriangle(v0, v1, v2, res) {
            var u = v1.sub(v0);
            var v = v2.sub(v0);
            var n = u.cross(v);

            var w0 = this.origin.sub(v0);
            var a = -n.dot(w0);
            var b = n.dot(this.direction);

            // ray is  parallel to triangle plane
            if (Math.abs(b) < EPSILON10) {
                if (a === 0) {
                    res.copy(this.origin);
                    // ray lies in triangle plane
                    return Ray$1.INPLANE;
                } else {
                    // ray disjoint from plane
                    return Ray$1.OUTSIDE;
                }
            }

            var r = a / b;

            // intersect point of ray and plane
            res.copy(this.origin.add(this.direction.scaleTo(r)));

            // ray goes away from triangle
            if (r < 0.0) {
                return Ray$1.AWAY;
            }

            // is res point inside the triangle?
            var uu = u.dot(u);
            var uv = u.dot(v);
            var vv = v.dot(v);
            var w = res.sub(v0);
            var wu = w.dot(u);
            var wv = w.dot(v);
            var D = uv * uv - uu * vv;

            var s = (uv * wv - vv * wu) / D;
            if (s < 0.0 || s > 1.0) {
                return Ray$1.OUTSIDE;
            }

            var t = (uv * wu - uu * wv) / D;
            if (t < 0.0 || s + t > 1.0) {
                return Ray$1.OUTSIDE;
            }

            return Ray$1.INSIDE;
        }

        /**
         * Gets a ray hit a plane result. If the ray cross the plane returns 1 - og.Ray.INSIDE otherwise returns 0 - og.Ray.OUTSIDE.
         * @public
         * @param {Vec3} v0 - First plane point.
         * @param {Vec3} v1 - Second plane point.
         * @param {Vec3} v2 - Third plane point.
         * @param {Vec3} res - Hit point object pointer that stores hit result.
         * @returns {number}
         */
        hitPlane(v0, v1, v2, res) {
            var u = Vec3.sub(v1, v0);
            var v = Vec3.sub(v2, v0);
            var n = u.cross(v);

            var w0 = Vec3.sub(this.origin, v0);
            var a = -n.dot(w0);
            var b = n.dot(this.direction);

            // ray is  parallel to the plane
            if (Math.abs(b) < EPSILON10) {
                if (a === 0) {
                    return Ray$1.OUTSIDE;
                }
            }

            var r = a / b;

            if (r < 0) {
                return Ray$1.OUTSIDE;
            }

            var d = this.direction.scaleTo(r);

            // intersect point of ray and plane
            res.x = this.origin.x + d.x;
            res.y = this.origin.y + d.y;
            res.z = this.origin.z + d.z;

            return Ray$1.INSIDE;
        }

        /**
         * Returns a ray hit sphere coordiante. If there isn't hit returns null.
         * @public
         * @param {Sphere} sphere - Sphere object.
         * @returns {Vec3}
         */
        hitSphere(sphere) {
            var r = sphere.radius,
                c = sphere.center,
                o = this.origin,
                d = this.direction;
            var vpc = Vec3.sub(c, o);
            if (vpc.dot(d) < 0) {
                var l = vpc.length();
                if (l > r) {
                    return null;
                } else if (l === r) {
                    return o.clone();
                }
                let pc = c.projToRay(o, vpc);
                var lc = Vec3.sub(pc, c).length();
                let dist = Math.sqrt(r * r - lc * lc);
                let di1 = dist - Vec3.sub(pc, o).length();
                let intersection = Vec3.add(o, d.scaleTo(di1));
                return intersection;
            } else {
                let pc = c.projToRay(o, d);
                var cpcl = Vec3.sub(c, pc).length();
                if (cpcl > sphere.radius) {
                    return null;
                } else {
                    let dist = Math.sqrt(r * r - cpcl * cpcl);
                    let di1;
                    pc.subA(o);
                    if (vpc.length() > r) {
                        di1 = pc.length() - dist;
                    } else {
                        di1 = pc.length() + dist;
                    }
                    let intersection = Vec3.add(o, d.scaleTo(di1));
                    return intersection;
                }
            }
        }

        hitBox(box) {
            //
            // TODO
            //
        }
    }

    class Touch$1 {
        constructor() {
            this.x = 0;
            this.y = 0;
            this.prev_x = 0;
            this.prev_y = 0;
            this.grabbedPoint = new Vec3();
            this.grabbedSpheroid = new Sphere$1();
            this.dX = function () {
                return this.x - this.prev_x;
            };
            this.dY = function () {
                return this.y - this.prev_y;
            };
        }
    }

    class EarthNavigation extends Control$1 {
        constructor(options) {
            super(options);

            this.grabbedPoint = new Vec3();
            this.grabbedDir = new Vec3();
            this.inertia = 0.007;
            this.grabbedSpheroid = new Sphere$1();
            this.planet = null;
            this._vRot = new Quat();
            this._hRot = new Quat();
            this._a = 0.0;
            this.scaleRot = 0;
            this.currState = 0;

            this.positionState = [
                { h: 17119745.303455353, max: 0.98, min: -0.98 },
                { h: 6866011, max: 0.98, min: -0.98 },
                { h: 3000000, max: 0.98, min: -0.98 },
                { h: 1000000, max: 0.98, min: -0.98 },
                { h: 500000, max: 0.98, min: -0.98 }
            ];

            this.touches = [new Touch$1(), new Touch$1()];
        }

        switchZoomState(wheelDelta) {
            this.stopRotation();

            if (wheelDelta > 0) {
                this.currState++;
            } else {
                this.currState--;
            }

            if (this.currState <= 0) this.currState = 0;

            if (this.currState >= this.positionState.length) {
                this.currState = this.positionState.length - 1;
            }

            this.planet.stopFlying();

            var ll = this.renderer.activeCamera._lonLat;

            this.planet.flyLonLat(new LonLat(ll.lon, ll.lat, this.positionState[this.currState].h));
        }

        onMouseWheel(event) {
            this.switchZoomState(event.wheelDelta);
        }

        oninit() {
            this.activate();
        }

        onactivate() {
            this.planet = this.renderer.renderNodes.Earth;

            this.renderer.events.on("mousewheel", this.onMouseWheel, this);
            this.renderer.events.on("lhold", this.onMouseLeftButtonDown, this);
            this.renderer.events.on("ldown", this.onMouseLeftButtonClick, this);
            this.renderer.events.on("lup", this.onMouseLeftButtonUp, this);

            this.renderer.events.on("touchstart", this.onTouchStart, this);
            this.renderer.events.on("touchend", this.onTouchEnd, this);
            this.renderer.events.on("touchmove", this.onTouchMove, this);

            this.renderer.events.on("draw", this.onDraw, this);
        }

        onTouchStart(e) {
            if (e.sys.touches.length == 1) {
                var t = this.touches[0];

                t.x = e.sys.touches.item(0).pageX - e.sys.offsetLeft;
                t.y = e.sys.touches.item(0).pageY - e.sys.offsetTop;
                t.prev_x = e.sys.touches.item(0).pageX - e.sys.offsetLeft;
                t.prev_y = e.sys.touches.item(0).pageY - e.sys.offsetTop;

                t.grabbedPoint = this.planet.getCartesianFromPixelTerrain(t, true);

                if (t.grabbedPoint) {
                    t.grabbedSpheroid.radius = t.grabbedPoint.length();
                    this.stopRotation();
                }
            }
        }

        onTouchEnd(e) {
            if (e.sys.touches.length == 0) {
                this.scaleRot = 1;

                if (
                    Math.abs(this.touches[0].x - this.touches[0].prev_x) < 3 &&
                    Math.abs(this.touches[0].y - this.touches[0].prev_y) < 3
                )
                    this.stopRotation();
            }
        }

        onTouchMove(e) {
            if (e.sys.touches.length == 1) {
                var cam = this.renderer.activeCamera;

                var t = this.touches[0];

                t.prev_x = t.x;
                t.prev_y = t.y;
                t.x = e.sys.touches.item(0).pageX - e.sys.offsetLeft;
                t.y = e.sys.touches.item(0).pageY - e.sys.offsetTop;

                if (!t.grabbedPoint) return;

                var direction = cam.unproject(t.x, t.y);
                var targetPoint = new Ray$1(cam.eye, direction).hitSphere(t.grabbedSpheroid);

                if (targetPoint) {
                    this._a =
                        Math.acos(t.grabbedPoint.y / t.grabbedSpheroid.radius) -
                        Math.acos(targetPoint.y / t.grabbedSpheroid.radius);
                    this._vRot = Quat.axisAngleToQuat(cam._u, this._a);
                    this._hRot = Quat.getRotationBetweenVectors(
                        new Vec3(targetPoint.x, 0.0, targetPoint.z).normal(),
                        new Vec3(t.grabbedPoint.x, 0.0, t.grabbedPoint.z).normal()
                    );
                    var rot = this._hRot.mul(this._vRot);

                    var state = this.positionState[this.currState];
                    var lim = rot.mulVec3(cam.eye).normal().dot(Vec3.UP);
                    if (lim > state.max || lim < state.min) {
                        rot = Quat.yRotation(rot.getYaw());
                    }

                    cam.set(rot.mulVec3(cam.eye), Vec3.ZERO, Vec3.UP);
                    cam.update();
                }
            }
        }

        onMouseLeftButtonClick(e) {
            this.renderer.handler.gl.canvas.classList.add("ogGrabbingPoiner");
            this.grabbedPoint = this.planet.getCartesianFromMouseTerrain(true);
            this.grabbedDir.copy(e.direction);
            if (this.grabbedPoint) {
                this.grabbedSpheroid.radius = this.grabbedPoint.length();
                this.stopRotation();
            }
        }

        stopRotation() {
            this.scaleRot = 0.0;
            this._a = 0.0;
            this._vRot.clear();
            this._hRot.clear();
        }

        onMouseLeftButtonUp(e) {
            this.scaleRot = 1;
            this.renderer.handler.gl.canvas.classList.remove("ogGrabbingPoiner");

            if (Math.abs(e.x - e.prev_x) < 3 && Math.abs(e.y - e.prev_y) < 3) this.stopRotation();
        }

        onMouseLeftButtonDown(e) {
            var cam = this.renderer.activeCamera;

            if (!this.grabbedPoint || cam.isFlying()) return;

            if (this.renderer.events.mouseState.moving) {
                var targetPoint = new Ray$1(cam.eye, e.direction).hitSphere(this.grabbedSpheroid);

                if (targetPoint) {

                    this._a = Math.acos(this.grabbedPoint.y / this.grabbedSpheroid.radius) -
                        Math.acos(targetPoint.y / this.grabbedSpheroid.radius);

                    let rot = this._vRot = Quat.axisAngleToQuat(cam._u, this._a);

                    cam.set(rot.mulVec3(cam.eye), Vec3.ZERO, rot.mulVec3(cam.getUp()));
                    //cam.update();

                    this._hRot = Quat.getRotationBetweenVectors(
                        new Vec3(targetPoint.x, 0.0, targetPoint.z).normal(),
                        new Vec3(this.grabbedPoint.x, 0.0, this.grabbedPoint.z).normal()
                    );

                    rot = this._hRot;

                    //var state = this.positionState[this.currState];
                    //var lim = cam.eye.normal().dot(Vec3.UP);

                    //if (lim > state.max || lim < state.min) {
                    //    rot = Quat.yRotation(rot.getYaw());
                        cam.set(rot.mulVec3(cam.eye), Vec3.ZERO, rot.mulVec3(cam.getUp()));
                        cam.update();
                    //}
                }
            } else {
                this.scaleRot = 0;
            }
        }

        onDraw(e) {
            var r = this.renderer;
            var cam = r.activeCamera;

            if (r.events.mouseState.leftButtonDown || !this.scaleRot || cam.isFlying()) return;

            this.scaleRot -= this.inertia;
            if (this.scaleRot <= 0) {
                this.scaleRot = 0;
            } else {
                this._vRot = Quat.axisAngleToQuat(cam._u, this._a);
                var rot = this._vRot.mul(this._hRot);

                var lim = rot.mulVec3(cam.eye).normal().dot(Vec3.UP);

                var state = this.positionState[this.currState];

                if (lim > state.max || lim < state.min) {
                    rot = Quat.yRotation(rot.getYaw());
                }

                r.controlsBag.scaleRot = this.scaleRot;
                rot = rot
                    .slerp(Quat.IDENTITY, 1 - this.scaleRot * this.scaleRot * this.scaleRot)
                    .normalize();
                if (!(rot.x || rot.y || rot.z)) {
                    this.scaleRot = 0;
                }

                cam.set(rot.mulVec3(cam.eye), Vec3.ZERO, Vec3.UP);
                cam.update();
            }
        }
    }

    const ELL = 0;
    const MSL = 1;
    const GND = 2;

    const heightMode = {
        "ell": ELL,
        "msl": MSL,
        "gnd": GND
    };

    const KM_to_M = 1000.0;
    const M_to_KM = 1.0 / KM_to_M;
    const FT_to_M = 0.3048;
    const M_to_FT = 1.0 / FT_to_M;
    const MS_to_KMH = 3.6;
    const KMH_to_MS = 1.0 / MS_to_KMH;
    const MS_to_FTS = 3.28084;
    const FT_to_KM = FT_to_M * M_to_KM;
    const KM_to_FT = 1.0 / FT_to_KM;

    const m = 0;
    const km = 1;
    const ft = 2;
    const s = 3;
    const h = 4;
    const ms = 5;
    const kmh = 6;
    const fts = 7;

    const DEFAULT_NAN = "--";

    const _abbr = ["m", "km", "ft", "s", "h", "m/s", "km/h", "ft/s"];

    const _tenth = [0, 2, 0, 0, 0, 0, 0, 0];

    let _convFn = [];

    _convFn[m] = [];
    _convFn[m][m] = (v) => v;
    _convFn[m][km] = (v) => v * M_to_KM;
    _convFn[m][ft] = (v) => v * M_to_FT;

    _convFn[ft] = [];
    _convFn[ft][m] = (v) => v * FT_to_M;
    _convFn[ft][km] = (v) => v * FT_to_KM;
    _convFn[ft][ft] = (v) => v;

    _convFn[km] = [];
    _convFn[km][m] = (v) => v * KM_to_M;
    _convFn[km][km] = (v) => v;
    _convFn[km][ft] = (v) => v * KM_to_FT;

    _convFn[ms] = [];
    _convFn[ms][ms] = (v) => v;
    _convFn[ms][kmh] = (v) => v * MS_to_KMH;
    _convFn[ms][fts] = (v) => v * MS_to_FTS;

    _convFn[kmh] = [];
    _convFn[kmh][ms] = (v) => v * KMH_to_MS;
    _convFn[kmh][kmh] = (v) => v;
    //_convFn[kmh][fts] = (v) => v * KMH_to_FTS;

    function convert(from, to, val) {
        return _convFn[from][to](val);
    }

    function convertExt(isNotNaN, unitFrom, unitTo, val, fixed) {
        if (isNotNaN) {
            return convert(unitFrom, unitTo, val).toFixed(fixed || _tenth[unitTo]);
        }
        return DEFAULT_NAN;
    }

    function toString(u) {
        return _abbr[u];
    }

    var units = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ELL: ELL,
        MSL: MSL,
        GND: GND,
        heightMode: heightMode,
        m: m,
        km: km,
        ft: ft,
        s: s,
        h: h,
        ms: ms,
        kmh: kmh,
        fts: fts,
        _tenth: _tenth,
        convert: convert,
        convertExt: convertExt,
        toString: toString
    });

    const DECIMAL_TEMPLATE =
        `<div class="og-lat-side"></div><div class="og-lat-val"></div>
    <div class="og-lon-side"></div><div class="og-lon-val"></div>
    <div class="og-height"></div>
    <div class="og-units-height"></div>`;

    const DEGREE_TEMPLATE =
        `<div class="og-lat-side"></div><div class="og-lat-val"></div>
    <div class="og-lon-side"></div><div class="og-lon-val"></div>
    <div class="og-height"></div>
    <div class="og-units-height"></div>`;

    const CENTER_SVG = '<svg width="12" height="12"><g><path stroke-width="1" stroke-opacity="1" d="M6 0L6 12M0 6L12 6" stroke="#337ab7"></path></g></svg>';

    const TYPE_HTML = [DECIMAL_TEMPLATE, DEGREE_TEMPLATE];

    /**
     * Control displays mouse or screen center Earth coordinates.
     * @class
     * @extends {og.control.Control}
     * @param {Object} [options] - Options:
     * @param {Boolean} [options.center] - Earth coordiantes by screen center otherwise mouse pointer. False is default.
     * @param {Boolean} [options.type] - Coordinates shown: 0 - is decimal degrees, 1 - degrees, 2 - mercator geodetic coordinates.
     */
    class EarthCoordinates extends Control$1 {
        constructor(options) {
            super(options);

            options = options || {};

            /**
             * Display type.
             * @private
             * @type {Boolean}
             */
            this._type = options.type || 0;

            this._TYPE_FUNC = [this._SHOW_DECIMAL, this._SHOW_DEGREE];

            this._showFn = null;

            /**
             * Current position.
             * @public
             * @type {og.Vec3}
             */
            this._lonLat = new LonLat();

            this._latSideEl = null;
            this._lonSideEl = null;
            this._latValEl = null;
            this._lonValEl = null;
            this._heightEl = null;

            this._altUnitVal = options.altitudeUnit || "m";
            this._heightModeVal = options.heightMode || "ell";

            this._altUnit = units[this._altUnitVal];
            this._heightMode = heightMode[this._heightModeVal];

            this._centerMode = options.centerMode || false;
        }

        _SHOW_DECIMAL(ll) {
            if (ll) {
                let lat = ll.lat,
                    lon = ll.lon;

                if (lat >= 0) {
                    this._latSideEl.innerHTML = 'N';
                } else {
                    this._latSideEl.innerHTML = 'S';
                }

                if (lon >= 0) {
                    this._lonSideEl.innerHTML = 'E';
                } else {
                    this._lonSideEl.innerHTML = 'W';
                }

                this._latValEl.innerHTML = Math.abs(lat).toFixed(5) + '°';
                this._lonValEl.innerHTML = Math.abs(lon).toFixed(5) + '°';
            }
        }

        _SHOW_DEGREE(ll) {
            if (ll) {
                let lat = ll.lat,
                    lon = ll.lon;

                if (lat >= 0) {
                    this._latSideEl.innerHTML = 'N';
                } else {
                    this._latSideEl.innerHTML = 'S';
                }

                if (lon >= 0) {
                    this._lonSideEl.innerHTML = 'E';
                } else {
                    this._lonSideEl.innerHTML = 'W';
                }

                let t = 0;

                let deg = lat < 0 ? Math.ceil(lat) : Math.floor(lat);
                let min = Math.floor(t = Math.abs((lat - deg)) * 60);
                let sec = Math.floor((t - min) * 6000) / 100.0;
                this._latValEl.innerHTML = Math.abs(deg) + '°' + min + "'" + sec.toFixed(0) + '"';

                deg = lon < 0 ? Math.ceil(lon) : Math.floor(lon);
                min = Math.floor(t = Math.abs((lon - deg)) * 60);
                sec = Math.floor((t - min) * 6000) / 100.0;
                this._lonValEl.innerHTML = Math.abs(deg) + '°' + min + "'" + sec.toFixed(0) + '"';
            }
        }

        _createCenterEl() {
            let el = document.createElement('div');
            el.className = 'og-center-icon';
            el.innerHTML = CENTER_SVG;
            return el;
        }

        _updateUnits() {
            this._heightMode = heightMode[this._heightModeVal];
            this._altUnit = units[this._altUnitVal];
            this._el.querySelector(".og-units-height").innerHTML = toString(this._altUnit);
            this._showHeight();
        }

        _refreshCoordinates() {

            if (this._type >= this._TYPE_FUNC.length) {
                this._type = 0;
            }

            this._el.innerHTML = TYPE_HTML[this._type];

            this._latSideEl = this._el.querySelector(".og-lat-side");
            this._lonSideEl = this._el.querySelector(".og-lon-side");
            this._latValEl = this._el.querySelector(".og-lat-val");
            this._lonValEl = this._el.querySelector(".og-lon-val");
            this._heightEl = this._el.querySelector(".og-height");

            this._showFn = this._TYPE_FUNC[this._type];
            this._showFn(this._lonLat);
        }

        oninit() {
            this._el = document.createElement('div');
            this._el.classList.add("og-coordinates");

            this.renderer.div.appendChild(this._el);

            this._el.addEventListener("click", () => {
                this._type++;
                this._refreshCoordinates();
                this._updateUnits();
                this._showHeight();
            });

            if (this._centerMode) {
                this.renderer.div.appendChild(this._createCenterEl());
                this.renderer.activeCamera.events.on("moveend", this._grabCoordinates, this);
                this.renderer.activeCamera.events.on("moveend", throttle((e) => this._showHeight(), 400, true), this);
            } else {
                this.renderer.events.on("mousemove", this._grabCoordinates, this);
                this.renderer.events.on("mousestop", throttle((e) => this._showHeight(), 400, true), this);
            }

            this._refreshCoordinates();

            this._updateUnits();
        }

        _grabCoordinates(px) {
            let scrPx;
            let r = this.renderer;
            if (this._centerMode) {
                scrPx = r.handler.getCenter();
            } else {
                scrPx = px;
            }
            this._lonLat = this.planet.getLonLatFromPixelTerrain(scrPx);
            this._showFn(this._lonLat);
        }

        async _showHeight() {
            if (this._lonLat) {
                let alt = 0;
                this._heightEl.style.opacity = 0.7;
                if (this._heightMode === heightMode.ell) {
                    alt = await this.planet.getHeightAboveELL(this._lonLat);
                    alt = convertExt(true, m, this._altUnit, alt);
                } else if (this._heightMode === heightMode.msl) {
                    alt = await this.planet.getHeightDefault(this._lonLat);
                    alt = convertExt(true, m, this._altUnit, alt);
                }
                this._heightEl.style.opacity = 1.0;
                this._heightEl.innerHTML = alt.toString();
            }
        }
    }

    /**
     * @module og/Events
     */

    /**
     * Base events class to handle custom events.
     * @class
     */
    class Events {
        /**
         *
         * @param {Array.<string>} [eventNames] - Event names that could be dispatched.
         * @param {*} [sender]
         */
        constructor(eventNames, sender) {
            /**
             * Registered event names.
             * @protected
             * @type {Array.<string>}
             */
            this._eventNames = [];

            eventNames && this.registerNames(eventNames);

            this._sender = sender || this;

            /**
             * Stop propagation flag
             * @protected
             * @type {boolean}
             */
            this._stopPropagation = false;

            this._stampCache = {};

            this.__id = Events._staticCounter++;
        }

        static get _staticCounter() {
            if (!this.__counter__ && this.__counter__ !== 0) {
                this.__counter__ = 0;
            }
            return this.__counter__;
        }

        static set _staticCounter(n) {
            this.__counter__ = n;
        }

        bindSender(sender) {
            this._sender = sender || this;
        }

        /**
         * Function that creates event object properties that would be dispatched.
         * @public
         * @param {Array.<string>} eventNames - Specified event names list.
         */
        registerNames(eventNames) {
            for (var i = 0; i < eventNames.length; i++) {
                this[eventNames[i]] = { active: true, handlers: [] };
                this._eventNames.push(eventNames[i]);
            }
        }

        _getStamp(name, id, ogid) {
            return `${name}_${id}_${ogid}`;
        }

        /**
         * Returns true if event callback has stamped.
         * @protected
         * @param {Object} name - Event identifier.
         * @param {Object} obj - Event callback.
         * @return {boolean} -
         */
        _stamp(name, obj) {
            var ogid = stamp(obj);

            var st = this._getStamp(name, this.__id, ogid);

            if (!this._stampCache[st]) {
                this._stampCache[st] = ogid;
                return true;
            }

            return false;
        }

        /**
         * Attach listener.
         * @public
         * @param {string} name - Event name to listen.
         * @param {eventCallback} callback - Event callback function.
         * @param {Object} sender - Event callback function owner.
         */
        on(name, callback, sender, priority = 0) {
            if (this._stamp(name, callback)) {
                if (this[name]) {
                    let c = callback.bind(sender || this._sender);
                    c._openglobus_id = callback._openglobus_id;
                    c._openglobus_priority = priority;
                    binaryInsert(this[name].handlers, c, (a, b) => {
                        return b._openglobus_priority - a._openglobus_priority;
                    });
                }
            }
        }

        /**
         * Stop listening event name with specified callback function.
         * @public
         * @param {string} name - Event name.
         * @param {eventCallback} callback - Attached  event callback.
         */
        off(name, callback) {
            if (callback) {
                var st = this._getStamp(name, this.__id, callback._openglobus_id);
                if (callback._openglobus_id && this._stampCache[st]) {
                    var h = this[name].handlers;
                    var i = h.length;
                    var indexToRemove = -1;
                    while (i--) {
                        var hi = h[i];
                        if (hi._openglobus_id === callback._openglobus_id) {
                            indexToRemove = i;
                            break;
                        }
                    }

                    if (indexToRemove !== -1) {
                        h.splice(indexToRemove, 1);
                        this._stampCache[st] = undefined;
                        delete this._stampCache[st];
                    }
                }
            }
        }

        /**
         * Dispatch event.
         * @public
         * @param {Object} event - Event instance property that created by event name.
         * @param {Object} [obj] - Event object.
         */
        dispatch(event, ...args) {
            let result = true;
            if (event && event.active && !this._stopPropagation) {
                let h = event.handlers.slice(0),
                    i = h.length;
                while (i--) {
                    if (h[i](...args) === false) {
                        result = false;
                    }
                }
            }
            this._stopPropagation = false;
            return result;
        }

        /**
         * Brakes events propagation.
         * @public
         */
        stopPropagation() {
            this._stopPropagation = true;
        }

        /**
         * Removes all events.
         * @public
         */
        clear() {
            for (var i = 0; i < this._eventNames.length; i++) {
                var e = this[this._eventNames[i]];
                e.handlers.length = 0;
                e.handlers = [];
            }
            this._eventNames.length = 0;
            this._eventNames = [];
        }
    }

    /**
     * @module og/layer/Material
     */

    class Material {
        /**
         *
         * @param {*} segment
         * @param {*} layer
         */
        constructor(segment, layer) {
            this.segment = segment;
            this.layer = layer;
            this.isReady = false;
            this.isLoading = false;
            this.texture = null;
            this.pickingMask = null;
            //this.image = null;
            this.textureExists = false;
            this.appliedNodeId = 0;
            this.texOffset = [0.0, 0.0, 1.0, 1.0];
            this.loadingAttempts = 0;

            // vector data
            this._updateTexture = null;
            this._updatePickingMask = null;
            this.pickingReady = false;
        }

        ///**
        // * @param {*} layer
        // */
        //assignLayer(layer) {
        //    this.layer = layer;
        //}

        /**
         *
         */
        abortLoading() {
            this.layer.abortMaterialLoading(this);
        }

        _createTexture(img) {
            return this.layer.createTexture(img, this.layer._internalFormat);
        }

        /**
         *
         * @param {*} img
         */
        applyImage(img) {
            if (this.segment.initialized) {
                this._updateTexture = null;
                //this.image = img;
                this.texture = this._createTexture(img);
                this.appliedNodeId = this.segment.node.nodeId;
                this.isReady = true;
                this.pickingReady = true;
                this.textureExists = true;
                this.isLoading = false;
                this.texOffset = [0.0, 0.0, 1.0, 1.0];
            }
        }

        /**
         *
         * @param {*} texture
         * @param {*} pickingMask
         */
        applyTexture(texture, pickingMask) {
            if (this.segment.initialized) {
                this.texture = texture;
                this._updateTexture = null;
                this.pickingMask = pickingMask || null;
                this._updatePickingMask = null;
                this.isReady = true;
                this.pickingReady = true;
                this.textureExists = true;
                this.isLoading = false;
                this.appliedNodeId = this.segment.node.nodeId;
                this.texOffset = [0.0, 0.0, 1.0, 1.0];
            }
        }

        /**
         *
         */
        textureNotExists() {
            if (this.segment.initialized) {
                this.pickingReady = true;
                this.isLoading = false;
                this.isReady = true;
                this.textureExists = false;
            }
        }

        /**
         *
         */
        clear() {
            this.loadingAttempts = 0;
            this.layer.clearMaterial(this);
        }
    }

    /**
     * @module og/layer/Layer
     */

    const FADING_FACTOR = 0.29;

    /**
     * @classdesc
     * Base class; normally only used for creating subclasses and not instantiated in apps.
     * A visual representation of raster or vector map data well known as a layer.
     * @class
     * @param {String} [name="noname"] - Layer name.
     * @param {Object} [options] - Layer options:
     * @param {number} [options.opacity=1.0] - Layer opacity.
     * @param {number} [options.minZoom=0] - Minimal visibility zoom level.
     * @param {number} [options.maxZoom=0] - Maximal visibility zoom level.
     * @param {string} [options.attribution] - Layer attribution that displayed in the attribution area on the screen.
     * @param {boolean} [options.isBaseLayer=false] - This is a base layer.
     * @param {boolean} [options.visibility=true] - Layer visibility.
     * @param {boolean} [options.isSRGB=false] - Layer image webgl nternal format.
     * @param {Extent} [options.extent=[[-180.0, -90.0], [180.0, 90.0]]] - Visible extent.
     * @param {string} [options.textureFilter="anisotropic"] - Image texture filter. Available values: "nearest", "linear", "mipmap" and "anisotropic".
     *
     * @fires og.Layer#visibilitychange
     * @fires og.Layer#add
     * @fires og.Layer#remove
     * @fires og.layer.Layer#mousemove
     * @fires og.layer.Layer#mouseenter
     * @fires og.layer.Layer#mouseleave
     * @fires og.layer.Layer#lclick
     * @fires og.layer.Layer#rclick
     * @fires og.layer.Layer#mclick
     * @fires og.layer.Layer#ldblclick
     * @fires og.layer.Layer#rdblclick
     * @fires og.layer.Layer#mdblclick
     * @fires og.layer.Layer#lup
     * @fires og.layer.Layer#rup
     * @fires og.layer.Layer#mup
     * @fires og.layer.Layer#ldown
     * @fires og.layer.Layer#rdown
     * @fires og.layer.Layer#mdown
     * @fires og.layer.Layer#lhold
     * @fires og.layer.Layer#rhold
     * @fires og.layer.Layer#mhold
     * @fires og.layer.Layer#mousewheel
     * @fires og.layer.Layer#touchmove
     * @fires og.layer.Layer#touchstart
     * @fires og.layer.Layer#touchend
     * @fires og.layer.Layer#doubletouch
     */
    class Layer$1 {
        constructor(name, options = {}) {
            /**
             * Layer user name.
             * @public
             * @type {string}
             */
            this.name = name || "noname";

            this._labelMaxLetters = options.labelMaxLetters;

            this.displayInLayerSwitcher =
                options.displayInLayerSwitcher !== undefined ? options.displayInLayerSwitcher : true;

            this._hasImageryTiles = true;

            /**
             * Layer global opacity.
             * @public
             * @type {number}
             */
            this._opacity = options.opacity || 1.0;

            /**
             * Minimal zoom level when layer is visibile.
             * @public
             * @type {number}
             */
            this.minZoom = options.minZoom || 0;

            /**
             * Maximal zoom level when layer is visibile.
             * @public
             * @type {number}
             */
            this.maxZoom = options.maxZoom || 50;

            /**
             * Planet node.
             * @protected
             * @type {Planet}
             */
            this._planet = null;

            /**
             * Unic identifier.
             * @protected
             * @type {number}
             */
            this._id = Layer$1.__layersCounter++;

            /**
             * Layer attribution.
             * @protected
             * @type {string}
             */
            this._attribution = options.attribution || "";

            /**
             * Layer z-index.
             * @protected
             * @type {number}
             */
            this._zIndex = options.zIndex || 0;

            /**
             * Base layer type flag.
             * @protected
             * @type {boolean}
             */
            this._isBaseLayer = options.isBaseLayer || false;

            this._defaultTextures = options.defaultTextures || [null, null];

            /**
             * Layer visibility.
             * @protected
             * @type {boolean}
             */
            this._visibility = options.visibility !== undefined ? options.visibility : true;

            this._fading = options.fading || false;

            this._fadingFactor = FADING_FACTOR;

            if (this._fading) {
                this._fadingOpacity = this._visibility ? this._opacity : 0.0;
            } else {
                this._fadingOpacity = this._opacity;
            }

            /**
             * Height over the ground.
             * @protected
             * @type {number}
             */
            this._height = options.height || 0;

            /**
             * Visible degrees extent.
             * @protected
             * @type {Extent}
             */
            this._extent = null;

            this.createTexture = null;

            this._textureFilter = options.textureFilter ? options.textureFilter.trim().toUpperCase() : "MIPMAP";

            this._isSRGB = options.isSRGB != undefined ? options.isSRGB : false;

            this._internalFormat = null;

            /**
             * Visible mercator extent.
             * @protected
             * @type {Extent}
             */
            this._extentMerc = null;

            // Setting the extent up
            this.setExtent(
                createExtent(
                    options.extent,
                    new Extent(new LonLat(-180, -90), new LonLat(180, 90))
                )
            );

            /**
             * Layer picking color. Assign when added to the planet.
             * @protected
             * @type {Vec3}
             */
            this._pickingColor = new Vec3();

            this._pickingEnabled = options.pickingEnabled !== undefined ? options.pickingEnabled : true;

            this._isPreloadDone = false;

            this._preLoadZoomLevels = options.preLoadZoomLevels || [0, 1];

            /**
             * Events handler.
             * @public
             * @type {Events}
             */
            this.events = new Events(EVENT_NAMES$8, this);
        }

        static getTMS(x, y, z) {
            return {
                x: x,
                y: (1 << z) - y - 1,
                z: z
            };
        }

        static getTileIndex(...arr) {
            return arr.join("_");
        }

        static get __layersCounter() {
            if (!this.__lcounter && this.__lcounter !== 0) {
                this.__lcounter = 0;
            }
            return this.__lcounter;
        }

        static set __layersCounter(n) {
            this.__lcounter = n;
        }

        get instanceName() {
            return "Layer";
        }

        get rendererEvents() {
            return this.events;
        }

        set opacity(opacity) {
            if (this._fading) {
                if (opacity > this._opacity) {
                    this._fadingFactor = (opacity - this._opacity) / 2.8;
                } else if (opacity < this._opacity) {
                    this._fadingFactor = (opacity - this._opacity) / 2.8;
                }
            } else {
                this._fadingOpacity = opacity;
            }
            this._opacity = opacity;
        }

        get opacity() {
            return this._opacity;
        }

        set pickingEnabled(picking) {
            this._pickingEnabled = picking ? 1.0 : 0.0;
        }

        get pickingEnabled() {
            return !!this._pickingEnabled;
        }

        /**
         * Returns true if a layer has imagery tiles.
         * @public
         * @virtual
         * @returns {boolean} - Imagery tiles flag.
         */
        hasImageryTiles() {
            return this._hasImageryTiles;
        }

        /**
         * Gets layer identifier.
         * @public
         * @returns {string} - Layer object id.
         */
        getID() {
            return this._id;
        }

        /**
         * Compares layers instances.
         * @public
         * @param {Layer} layer - Layer instance to compare.
         * @returns {boolean} - Returns true if the layers is the same instance of the input.
         */
        isEqual(layer) {
            return layer._id === this._id;
        }

        /**
         * Assign the planet.
         * @protected
         * @virtual
         * @param {Planet} planet - Planet render node.
         */
        _assignPlanet(planet) {
            // TODO: webgl1
            if (this._isSRGB) {
                this._internalFormat = planet.renderer.handler.gl.SRGB8_ALPHA8;
            } else {
                this._internalFormat = planet.renderer.handler.gl.RGBA8;
            }

            this.createTexture = planet.renderer.handler.createTexture[this._textureFilter];

            planet.layers.push(this);
            this._planet = planet;
            this.events.on("visibilitychange", planet._onLayerVisibilityChanged, planet);
            if (this._isBaseLayer && this._visibility) {
                planet.setBaseLayer(this);
            }

            if (this._visibility && this.hasImageryTiles()) {
                this._preLoad();
            }

            planet.events.dispatch(planet.events.layeradd, this);
            this.events.dispatch(this.events.add, planet);
            planet.updateVisibleLayers();
            this._bindPicking();
        }

        /**
         * Assign picking color to the layer.
         * @protected
         * @virtual
         */
        _bindPicking() {
            this._planet && this._planet.renderer.assignPickingColor(this);
        }

        /**
         * Adds layer to the planet.
         * @public
         * @param {Planet} planet - Adds layer to the planet.
         */
        addTo(planet) {
            if (!this._planet) {
                this._assignPlanet(planet);
            }
            return this;
        }

        /**
         * Removes from planet.
         * @public
         * @returns {Layer} -This layer.
         */
        remove() {
            var p = this._planet;
            if (p) {
                for (var i = 0; i < p.layers.length; i++) {
                    if (this.isEqual(p.layers[i])) {
                        p.renderer.clearPickingColor(this);
                        p.layers.splice(i, 1);
                        p.updateVisibleLayers();
                        this.clear();
                        p.events.dispatch(p.events.layerremove, this);
                        this.events.dispatch(this.events.remove, p);
                        this._planet = null;
                        return this;
                    }
                }
            }
            return this;
        }

        /**
         * Clears layer material.
         * @virtual
         */
        clear() {
            if (this._planet) {
                this._planet._clearLayerMaterial(this);
                this._internalFormat = null;
                this.createTexture = null;
            }
        }

        /**
         * Returns planet instance.
         * @virtual
         */
        get planet() {
            return this._planet;
        }

        /**
         * Sets layer attribution text.
         * @public
         * @param {string} html - HTML code that represents layer attribution, it could be just a text.
         */
        setAttribution(html) {
            if (this._attribution !== html) {
                this._attribution = html;
                this._planet && this._planet.updateAttributionsList();
            }
        }

        /**
         * Sets height over the ground.
         * @public
         * @param {number} height - Layer height.
         */
        setHeight(height) {
            this._height = height;
            this._planet && this._planet.updateVisibleLayers();
        }

        /**
         * Gets layer height.
         * @public
         * @returns {number} -
         */
        getHeight() {
            return this._height;
        }

        /**
         * Sets z-index.
         * @public
         * @param {number} zIndex - Layer z-index.
         */
        setZIndex(zIndex) {
            this._zIndex = zIndex;
            this._planet && this._planet.updateVisibleLayers();
        }

        /**
         * Gets z-index.
         * @public
         * @returns {number} -
         */
        getZIndex() {
            return this._zIndex;
        }

        /**
         * Set zIndex to the maximal value depend on other layers on the planet.
         * @public
         */
        bringToFront() {
            if (this._planet) {
                var vl = this._planet.visibleTileLayers;
                var l = vl[vl.length - 1];
                if (!l.isEqual(this)) {
                    this.setZIndex(l.getZIndex() + 1);
                }
            }
        }

        /**
         * Returns true if the layer is a base.
         * @public
         * @returns {boolean} - Base layer flag.
         */
        isBaseLayer() {
            return this._isBaseLayer;
        }

        /**
         * Sets base layer type true.
         * @public
         * @param {boolean} flag - Base layer flag.
         */
        setBaseLayer(flag) {
            this._isBaseLayer = flag;
            if (this._planet) {
                if (!flag && this.isEqual(this._planet.baseLayer)) {
                    this._planet.baseLayer = null;
                }
                this._planet.updateVisibleLayers();
            }
        }

        /**
         * Sets layer visibility.
         * @public
         * @virtual
         * @param {boolean} visibility - Layer visibility.
         */
        setVisibility(visibility) {
            if (visibility !== this._visibility) {
                this._visibility = visibility;
                if (this._planet) {
                    if (this._isBaseLayer && visibility) {
                        this._planet.setBaseLayer(this);
                    }
                    this._planet.updateVisibleLayers();
                    if (visibility && !this._isPreloadDone && !this.isVector) {
                        this._isPreloadDone = true;
                        this._preLoad();
                    }
                }
                this.events.dispatch(this.events.visibilitychange, this);
            }
        }

        _forceMaterialApply(segment) {
            let pm = segment.materials,
                m = pm[this._id];

            if (!m) {
                m = pm[this._id] = this.createMaterial(segment);
            }

            if (!m.isReady) {
                this._planet._renderCompleted = false;
            }

            this.applyMaterial(m);
        }

        _preLoadRecursive(node, maxZoom) {
            if (node.segment.tileZoom > maxZoom) {
                return;
            }
            if (this._preLoadZoomLevels.includes(node.segment.tileZoom)) {
                this._forceMaterialApply(node.segment);
            }

            for (let i = 0, len = node.nodes.length; i < len; i++) {
                if (node.nodes[i]) {
                    this._preLoadRecursive(node.nodes[i], maxZoom);
                }
            }
        }

        _preLoad() {
            if (this._planet && this._preLoadZoomLevels.length) {

                let p = this._planet,
                    maxZoom = Math.max(...this._preLoadZoomLevels);

                this._preLoadRecursive(p._quadTreeSouth, maxZoom);
                this._preLoadRecursive(p._quadTreeNorth, maxZoom);
                this._preLoadRecursive(p._quadTree, maxZoom);
            }
        }

        /**
         * Gets layer visibility.
         * @public
         * @returns {boolean} - Layer visibility.
         */
        getVisibility() {
            return this._visibility;
        }

        /**
         * Sets visible geographical extent.
         * @public
         * @param {Extent} extent - Layer visible geographical extent.
         */
        setExtent(extent) {
            var sw = extent.southWest.clone(),
                ne = extent.northEast.clone();
            if (sw.lat < MIN_LAT) {
                sw.lat = MIN_LAT;
            }
            if (ne.lat > MAX_LAT) {
                ne.lat = MAX_LAT;
            }
            this._extent = extent.clone();
            this._extentMerc = new Extent(sw.forwardMercator(), ne.forwardMercator());
            this._correctFullExtent();
        }

        /**
         * Gets layer extent.
         * @public
         * @return {Extent} - Layer geodetic extent.
         */
        getExtent() {
            return this._extent;
        }

        /**
         * Special correction of the whole globe extent.
         * @protected
         */
        _correctFullExtent() {
            // var e = this._extent,
            //    em = this._extentMerc;
            // var ENLARGE_MERCATOR_LON = og.mercator.POLE + 50000;
            // var ENLARGE_MERCATOR_LAT = og.mercator.POLE + 50000;
            // if (e.northEast.lat === 90.0) {
            //    em.northEast.lat = ENLARGE_MERCATOR_LAT;
            // }
            // if (e.northEast.lon === 180.0) {
            //    em.northEast.lon = ENLARGE_MERCATOR_LON;
            // }
            // if (e.southWest.lat === -90.0) {
            //    em.southWest.lat = -ENLARGE_MERCATOR_LAT;
            // }
            // if (e.southWest.lon === -180.0) {
            //    em.southWest.lon = -ENLARGE_MERCATOR_LON;
            // }
        }

        _refreshFadingOpacity() {
            var p = this._planet;
            if (
                this._visibility &&
                p._viewExtent &&
                p._viewExtent.overlaps(this._extent) &&
                p.maxCurrZoom >= this.minZoom &&
                p.minCurrZoom <= this.maxZoom
            ) {
                this._fadingOpacity += this._fadingFactor;

                if (
                    (this._fadingFactor > 0.0 && this._fadingOpacity > this._opacity) ||
                    (this._fadingFactor < 0.0 && this._fadingOpacity < this._opacity)
                ) {
                    this._fadingOpacity = this._opacity;
                }
                return false;
            } else {
                this._fadingOpacity -= FADING_FACTOR;

                if (this._fadingOpacity < 0.0) {
                    this._fadingOpacity = 0.0;
                    return !this._visibility;
                }
            }
        }

        createMaterial(segment) {
            return new Material(segment, this);
        }
    }

    const EVENT_NAMES$8 = [
        /**
         * Triggered when layer visibilty chanched.
         * @event og.Layer#visibilitychange
         */
        "visibilitychange",

        /**
         * Triggered when layer has added to the planet.
         * @event og.Layer#add
         */
        "add",

        /**
         * Triggered when layer has removed from the planet.
         * @event og.Layer#remove
         */
        "remove",

        /**
         * Triggered when mouse moves over the layer.
         * @event og.Layer#mousemove
         */
        "mousemove",

        /**
         * Triggered when mouse has entered over the layer.
         * @event og.Layer#mouseenter
         */
        "mouseenter",

        /**
         * Triggered when mouse leaves the layer.
         * @event og.Layer#mouseenter
         */
        "mouseleave",

        /**
         * Mouse left button clicked.
         * @event og.Layer#lclick
         */
        "lclick",

        /**
         * Mouse right button clicked.
         * @event og.Layer#rclick
         */
        "rclick",

        /**
         * Mouse right button clicked.
         * @event og.Layer#mclick
         */
        "mclick",

        /**
         * Mouse left button double click.
         * @event og.Layer#ldblclick
         */
        "ldblclick",

        /**
         * Mouse right button double click.
         * @event og.Layer#rdblclick
         */
        "rdblclick",

        /**
         * Mouse middle button double click.
         * @event og.Layer#mdblclick
         */
        "mdblclick",

        /**
         * Mouse left button up(stop pressing).
         * @event og.Layer#lup
         */
        "lup",

        /**
         * Mouse right button up(stop pressing).
         * @event og.Layer#rup
         */
        "rup",

        /**
         * Mouse middle button up(stop pressing).
         * @event og.Layer#mup
         */
        "mup",

        /**
         * Mouse left button is just pressed down(start pressing).
         * @event og.Layer#ldown
         */
        "ldown",

        /**
         * Mouse right button is just pressed down(start pressing).
         * @event og.Layer#rdown
         */
        "rdown",

        /**
         * Mouse middle button is just pressed down(start pressing).
         * @event og.Layer#mdown
         */
        "mdown",

        /**
         * Mouse left button is pressing.
         * @event og.Layer#lhold
         */
        "lhold",

        /**
         * Mouse right button is pressing.
         * @event og.Layer#rhold
         */
        "rhold",

        /**
         * Mouse middle button is pressing.
         * @event og.Layer#mhold
         */
        "mhold",

        /**
         * Mouse wheel is rotated.
         * @event og.Layer#mousewheel
         */
        "mousewheel",

        /**
         * Triggered when touching moves over the layer.
         * @event og.Layer#touchmove
         */
        "touchmove",

        /**
         * Triggered when layer begins to touch.
         * @event og.Layer#touchstart
         */
        "touchstart",

        /**
         * Triggered when layer has finished touching.
         * @event og.Layer#touchend
         */
        "touchend",

        /**
         * Triggered layer has double touched.
         * @event og.Layer#doubletouch
         */
        "doubletouch",

        /**
         * Triggered when touching leaves layer borders.
         * @event og.Layer#touchleave
         */
        "touchleave",

        /**
         * Triggered when touch enters over the layer.
         * @event og.Layer#touchenter
         */
        "touchenter"
    ];

    /**
     * @module og/layer/BaseGeoImage
     */

    /**
     * BaseGeoImage layer represents square imagery layer that could be an static image, or animated video or webgl buffer object displayed on the globe.
     * @class
     * @extends {Layer}
     */
    class BaseGeoImage extends Layer$1 {
        constructor(name, options) {
            super(name, options);

            this._projType = 0;

            this._frameWidth = 256;
            this._frameHeight = 256;

            this._sourceReady = false;
            this._sourceTexture = null;
            this._materialTexture = null;

            this._gridBuffer = null;
            this._extentWgs84Params = null;

            this._refreshFrame = true;
            this._frameCreated = false;
            this._sourceCreated = false;

            this._animate = false;
            this._ready = false;
            this._creationProceeding = false;
            this._isRendering = false;

            this._extentWgs84 = new Extent();
            this._cornersWgs84 = null;

            this.rendering = null;

            options.corners && this.setCorners(options.corners);
        }

        get instanceName() {
            return "BaseGeoImage";
        }

        /**
         * Gets corners coordinates.
         * @public
         * @return {Array.<LonLat>} - (exactly 4 entries)
         */
        getCornersLonLat() {
            var c = this._cornersWgs84;
            return [
                new LonLat(c[0].lon, c[0].lat),
                new LonLat(c[1].lon, c[1].lat),
                new LonLat(c[2].lon, c[2].lat),
                new LonLat(c[3].lon, c[3].lat)
            ];
        }

        /**
         * Gets corners coordinates.
         * @public
         * @return {Array.<Array<number>>} - (exactly 3 entries)
         */
        getCorners() {
            var c = this._cornersWgs84;
            return [
                [c[0].lon, c[0].lat],
                [c[1].lon, c[1].lat],
                [c[2].lon, c[2].lat],
                [c[3].lon, c[3].lat]
            ];
        }

        /**
         * Sets geoImage geographical corners coordinates.
         * @public
         * @param {Array.<Array.<number>>} corners - GeoImage corners coordinates. Where first coordinate (exactly 3 entries)
         * coincedents to the left top image corner, secont to the right top image corner, third to the right bottom
         * and fourth - left bottom image corner.
         */
        setCorners(corners) {
            this.setCornersLonLat(LonLat.join(corners));
        }

        /**
         * Sets geoImage geographical corners coordinates.
         * @public
         * @param {Array.<LonLat>} corners - GeoImage corners coordinates. Where first coordinate
         * coincedents to the left top image corner, secont to the right top image corner, third to the right bottom
         * and fourth - left bottom image corner. (exactly 4 entries)
         */
        setCornersLonLat(corners) {
            this._refreshFrame = true;
            this._cornersWgs84 = [
                corners[0].clone(),
                corners[1].clone(),
                corners[2].clone(),
                corners[3].clone()
            ] || [0, 0, 0, 0];

            for (var i = 0; i < this._cornersWgs84.length; i++) {
                if (this._cornersWgs84[i].lat >= 89.9) {
                    this._cornersWgs84[i].lat = 89.9;
                }
                if (this._cornersWgs84[i].lat <= -89.9) {
                    this._cornersWgs84[i].lat = -89.9;
                }
            }
            this._extent.setByCoordinates(this._cornersWgs84);

            var me = this._extent;
            if (me.southWest.lat > MAX_LAT || me.northEast.lat < MIN_LAT) {
                this._projType = 0;
                this.rendering = this._renderingProjType0;
            } else {
                this._projType = 1;
                this.rendering = this._renderingProjType1;
            }

            if (this._ready && !this._creationProceeding) {
                this._planet._geoImageCreator.add(this);
            }
        }

        /**
         * Creates geoImage frame.
         * @protected
         */
        _createFrame() {
            this._extentWgs84 = this._extent.clone();

            this._cornersMerc = [
                this._cornersWgs84[0].forwardMercatorEPS01(),
                this._cornersWgs84[1].forwardMercatorEPS01(),
                this._cornersWgs84[2].forwardMercatorEPS01(),
                this._cornersWgs84[3].forwardMercatorEPS01()
            ];

            this._extentMerc = new Extent(
                this._extentWgs84.southWest.forwardMercatorEPS01(),
                this._extentWgs84.northEast.forwardMercatorEPS01()
            );

            if (this._projType === 0) {
                this._extentWgs84Params = [
                    this._extentWgs84.southWest.lon,
                    this._extentWgs84.southWest.lat,
                    2.0 / this._extentWgs84.getWidth(),
                    2.0 / this._extentWgs84.getHeight()
                ];
            } else {
                this._extentMercParams = [
                    this._extentMerc.southWest.lon,
                    this._extentMerc.southWest.lat,
                    2.0 / this._extentMerc.getWidth(),
                    2.0 / this._extentMerc.getHeight()
                ];
            }

            // creates material frame textures
            if (this._planet) {
                var p = this._planet,
                    h = p.renderer.handler,
                    gl = h.gl;

                gl.deleteTexture(this._materialTexture);
                this._materialTexture = h.createEmptyTexture_l(this._frameWidth, this._frameHeight);

                this._gridBuffer = this._planet._geoImageCreator.createGridBuffer(
                    this._cornersWgs84,
                    this._projType
                );

                this._refreshFrame = false;
            }
        }

        /**
         * @virtual
         * @param {Material} material - GeoImage material.
         */
        abortMaterialLoading(material) {
            this._creationProceeding = false;
            material.isLoading = false;
            material.isReady = false;
        }

        /**
         * Clear layer material.
         * @virtual
         */
        clear() {
            var p = this._planet;

            if (p) {
                var gl = p.renderer.handler.gl;
                this._creationProceeding && p._geoImageCreator.remove(this);
                p._clearLayerMaterial(this);

                gl.deleteBuffer(this._gridBuffer);

                gl.deleteTexture(this._sourceTexture);
                !this._materialTexture.default && gl.deleteTexture(this._materialTexture);
            }

            this._sourceTexture = null;
            this._materialTexture = null;

            this._gridBuffer = null;

            this._refreshFrame = true;
            this._sourceCreated = false;

            this._ready = false;
            this._creationProceeding = false;
        }

        /**
         * Sets layer visibility.
         * @public
         * @virtual
         * @param {boolean} visibility - GeoImage visibility.
         */
        setVisibility(visibility) {
            if (visibility !== this._visibility) {
                super.setVisibility(visibility);

                // remove from creator
                if (visibility) {
                    this._sourceReady && this._planet._geoImageCreator.add(this);
                } else {
                    this._sourceReady && this._planet._geoImageCreator.remove(this);
                }
            }
        }

        /**
         * @virtual
         * @protected
         * @param {Material} material - GeoImage material.
         */
        clearMaterial(material) {
            material.image = null;
            material.texture = null;
            material.isLoading = false;
            material.isReady = false;
        }

        /**
         * @virtual
         * @protected
         * @param {Material} material - GeoImage material.
         * @returns {Array<number> } -
         */
        applyMaterial(material) {
            var segment = material.segment;

            if (this._ready) {
                material.applyTexture(this._materialTexture);
            } else {
                material.texture = this._planet.transparentTexture;
                !this._creationProceeding && this.loadMaterial(material);
            }

            var v0s, v0t;
            if (this._projType === 0) {
                v0s = this._extentWgs84;
                v0t = segment._extent;
            } else {
                v0s = this._extentMerc;
                v0t = segment.getExtentMerc();
            }

            var sSize_x = v0s.northEast.lon - v0s.southWest.lon;
            var sSize_y = v0s.northEast.lat - v0s.southWest.lat;
            var dV0s_x = (v0t.southWest.lon - v0s.southWest.lon) / sSize_x;
            var dV0s_y = (v0s.northEast.lat - v0t.northEast.lat) / sSize_y;
            var dSize_x = (v0t.northEast.lon - v0t.southWest.lon) / sSize_x;
            var dSize_y = (v0t.northEast.lat - v0t.southWest.lat) / sSize_y;
            return [dV0s_x, dV0s_y, dSize_x, dSize_y];
        }

        /**
         * Gets frame width size in pixels.
         * @public
         * @returns {Number} Frame width.
         */
        get getFrameWidth() {
            return this._frameWidth;
        }

        /**
         * Gets frame height size in pixels.
         * @public
         * @returns {Number} Frame height.
         */
        get getFrameHeight() {
            return this._frameHeight;
        }
    }

    /**
     * @module og/control/GeoImageDragControl
     */

    class GeoImageDragControl extends Control$1 {
        constructor(options) {
            super(options);

            options = options || {};

            this._cornerIndex = -1;
            this._catchCorner = false;

        }

        oninit() {
            let p = this.planet;

            p.events.on('layeradd', function (e) {
                this._bindLayer(e);
            }, this);

            for (let i = 0; i < p.layers.length; i++) {
                if (p.layers[i] instanceof BaseGeoImage) {
                    this._bindLayer(p.layers[i]);
                }
            }
        }

        _bindLayer(layer) {
            if (layer instanceof BaseGeoImage) {

                var p = this.planet;

                layer.events.on('mousemove', function (ms) {
                    if (this._active) {
                        if (this._catchCorner) {
                            var corners = layer.getCornersLonLat();
                            corners[this._cornerIndex] = p.getLonLatFromPixelTerrain(ms, true);
                            layer.setCornersLonLat(corners);
                        } else {
                            this._cornerIndex = -1;
                            for (var i = 0; i < layer._cornersWgs84.length; i++) {
                                var ground = p.getLonLatFromPixelTerrain(ms, true);
                                if (ground && p.ellipsoid.getGreatCircleDistance(layer._cornersWgs84[i], ground) / p.getDistanceFromPixel(ms, true) <= 0.05) {
                                    this._cornerIndex = i;
                                    break;
                                }
                            }
                        }
                    }
                }, this);

                layer.events.on('ldown', function (ms) {
                    if (this._active && this._cornerIndex != -1) {
                        this._catchCorner = true;
                        ms.renderer.controls.mouseNavigation.deactivate();
                    }
                }, this);

                layer.events.on('lup', function (ms) {
                    if (this._active) {
                        this._catchCorner = false;
                        ms.renderer.controls.mouseNavigation.activate();
                    }
                }, this);
            }
        }
    }

    /**
     * @module og/input/input
     */

    const input = {
        KEY_CTRL: 17,
        KEY_ALT: 18,
        KEY_SHIFT: 16,
        KEY_SPACE: 32,
        KEY_PGUP: 33,
        KEY_PGDN: 34,
        KEY_LEFT: 37,
        KEY_UP: 38,
        KEY_RIGHT: 39,
        KEY_DOWN: 40,
        KEY_PRINTSCREEN: 44,
        KEY_EQUALS: 61,
        KEY_A: 65,
        KEY_C: 67,
        KEY_D: 68,
        KEY_E: 69,
        KEY_F: 70,
        KEY_H: 72,
        KEY_I: 73,
        KEY_K: 75,
        KEY_L: 76,
        KEY_N: 78,
        KEY_O: 79,
        KEY_P: 80,
        KEY_Q: 81,
        KEY_R: 82,
        KEY_S: 83,
        KEY_V: 86,
        KEY_W: 87,
        KEY_X: 88,
        KEY_Z: 90,
        KEY_PLUS: 107,
        KEY_F1: 112,
        KEY_MINUS: 173,
        KEY_APOSTROPHE: 192,
        MB_LEFT: 0,
        MB_RIGHT: 2,
        MB_MIDDLE: 1
    };

    /**
     * @module og/control/KeyboardNavigation
     */

    /**
     * Planet camera keyboard navigation. Use W,S,A,D and left shift key for fly around a planet.
     * @class
     * @extends {Control}
     * @param {Object} [options] - Control options.
     */

    class KeyboardNavigation extends Control$1 {
        constructor(options) {
            options = options || {};
            super(options);
            this.step = options.step || 250;
        }

        oninit() {
            this.renderer.events.on("keypress", input.KEY_PGUP, this.onCameraMoveForward, this);
            this.renderer.events.on("keypress", input.KEY_PGDN, this.onCameraMoveBackward, this);
            this.renderer.events.on("keypress", input.KEY_PLUS, this.onCameraMoveForward, this);
            this.renderer.events.on("keypress", input.KEY_EQUALS, this.onCameraMoveForward, this);
            this.renderer.events.on("keypress", input.KEY_MINUS, this.onCameraMoveBackward, this);
            this.renderer.events.on("keypress", input.KEY_W, this.onCameraMoveForward, this);
            this.renderer.events.on("keypress", input.KEY_S, this.onCameraMoveBackward, this);
            this.renderer.events.on("keypress", input.KEY_A, this.onCameraStrifeLeft, this);
            this.renderer.events.on("keypress", input.KEY_D, this.onCameraStrifeRight, this);
            this.renderer.events.on("keypress", input.KEY_UP, this.onCameraLookUp, this);
            this.renderer.events.on("keypress", input.KEY_DOWN, this.onCameraLookDown, this);
            this.renderer.events.on("keypress", input.KEY_LEFT, this.onCameraLookLeft, this);
            this.renderer.events.on("keypress", input.KEY_RIGHT, this.onCameraLookRight, this);
            this.renderer.events.on("keypress", input.KEY_Q, this.onCameraRollLeft, this);
            this.renderer.events.on("keypress", input.KEY_E, this.onCameraRollRight, this);
            this.renderer.events.on("keypress", input.KEY_N, this.onCameraRollNorth, this);
        }

        onCameraMoveForward(event) {
            var cam = this.renderer.activeCamera;
            cam.slide(0, 0, -cam._lonLat.height / this.step);
            cam.checkTerrainCollision();
            cam.update();
        }

        onCameraMoveBackward(event) {
            var cam = this.renderer.activeCamera;
            cam.slide(0, 0, cam._lonLat.height / this.step);
            cam.checkTerrainCollision();
            cam.update();
        }

        onCameraStrifeLeft(event) {
            var cam = this.renderer.activeCamera;
            cam.slide(-cam._lonLat.height / this.step, 0, 0);
            cam.checkTerrainCollision();
            cam.update();
        }

        onCameraStrifeRight(event) {
            var cam = this.renderer.activeCamera;
            cam.slide(cam._lonLat.height / this.step, 0, 0);
            cam.checkTerrainCollision();
            cam.update();
        }

        onCameraLookUp(event) {
            var cam = this.renderer.activeCamera;
            if (this.renderer.events.isKeyPressed(input.KEY_SHIFT)) {
                cam.pitch(15 / this.renderer.handler.deltaTime);
            } else {
                cam.rotateVertical((cam._lonLat.height / 3000000) * RADIANS, Vec3.ZERO);
            }
            cam.update();
        }

        onCameraLookDown(event) {
            var cam = this.renderer.activeCamera;
            if (this.renderer.events.isKeyPressed(input.KEY_SHIFT)) {
                cam.pitch(-15 / this.renderer.handler.deltaTime);
            } else {
                cam.rotateVertical((-cam._lonLat.height / 3000000) * RADIANS, Vec3.ZERO);
            }
            cam.update();
        }

        onCameraLookLeft(event) {
            var cam = this.renderer.activeCamera;
            if (this.renderer.events.isKeyPressed(input.KEY_SHIFT)) {
                cam.roll(15 / this.renderer.handler.deltaTime);
            } else {
                cam.rotateHorizontal((cam._lonLat.height / 3000000) * RADIANS, Vec3.ZERO);
            }
            cam.update();
        }

        onCameraLookRight(event) {
            var cam = this.renderer.activeCamera;
            if (this.renderer.events.isKeyPressed(input.KEY_SHIFT)) {
                cam.roll(-15 / this.renderer.handler.deltaTime);
            } else {
                cam.rotateHorizontal((-cam._lonLat.height / 3000000) * RADIANS, Vec3.ZERO);
            }
            cam.update();
        }

        onCameraTurnLeft(event) {
            var cam = this.renderer.activeCamera;
            if (this.renderer.events.isKeyPressed(input.KEY_SHIFT)) {
                cam.yaw(15 / this.renderer.handler.deltaTime);
            } else {
                cam.rotateHorizontal((cam._lonLat.height / 3000000) * RADIANS, false, Vec3.ZERO);
            }
            cam.update();
        }

        onCameraTurnRight(event) {
            var cam = this.renderer.activeCamera;
            if (this.renderer.events.isKeyPressed(input.KEY_SHIFT)) {
                cam.yaw(-15 / this.renderer.handler.deltaTime);
            } else {
                cam.rotateHorizontal((-cam._lonLat.height / 3000000) * RADIANS, false, Vec3.ZERO);
            }
            cam.update();
        }

        // from CompassButton._onClick()
        onCameraRollNorth(event) {
          let c = this.planet.getCartesianFromPixelTerrain(this.renderer.handler.getCenter());
          if (c) {
            this.planet.flyCartesian(
              c.normal().scaleTo(c.length() + c.distance(this.planet.camera.eye)),
              null,
              null,
              0,
              null,
              null,
              () => {
                this.planet.camera.look(c);
              }
              );
          } else {
            this.planet.flyCartesian(this.planet.camera.eye);
          }
        }

        onCameraRollLeft(event) {
            this.renderer.activeCamera.roll(-15 / this.renderer.handler.deltaTime);
            this.renderer.activeCamera.update();
        }

        onCameraRollRight(event) {
            this.renderer.activeCamera.roll(15 / this.renderer.handler.deltaTime);
            this.renderer.activeCamera.update();
        }
    }

    /**
     * @module og/control/LayerSwitcher
     */

    /**
     * Simple(OpenLayers like)layer switcher, includes base layers, overlays, geo images etc. groups.
     * @class
     * @extends {Control}
     * @param {Object} [options] - Control options.
     */
    class LayerSwitcher extends Control$1 {
        constructor(options) {
            super(options);

            this.dialog = null;
            this.baseLayersDiv = null;
            this.overlaysDiv = null;
            this._id = LayerSwitcher.numSwitches++;
        }

        static get numSwitches() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set numSwitches(n) {
            this._counter = n;
        }

        oninit() {
            this.planet.events.on("layeradd", this.onLayerAdded, this);
            this.planet.events.on("layerremove", this.onLayerRemoved, this);
            this.createSwitcher();
            this.createDialog();
        }

        onLayerAdded(layer) {
            if (layer.displayInLayerSwitcher) {
                if (layer.isBaseLayer()) {
                    this.addSwitcher("radio", layer, this.baseLayersDiv);
                } else {
                    this.addSwitcher("checkbox", layer, this.overlaysDiv, this._id);
                }
            }
        }

        onLayerRemoved(layer) {
            layer._removeCallback();
            layer._removeCallback = null;
        }

        addSwitcher(type, obj, container, id = "") {
            var lineDiv = document.createElement("div");

            var that = this;
            var center = document.createElement("div");
            center.classList.add("ogViewExtentBtn");
            center.onclick = function () {
                that.planet.flyExtent(obj.getExtent());
            };

            var inp = document.createElement("input");
            inp.type = type;
            inp.name = "ogBaseLayerRadiosId" + (id || "");
            inp.checked = obj.getVisibility();
            inp.className = "ogLayerSwitcherInput";
            inp.onclick = function () {
                obj.setVisibility(this.checked);
            };

            obj.events &&
                obj.events.on("visibilitychange", function (e) {
                    inp.checked = e.getVisibility();
                });

            var lbl = document.createElement("label");
            lbl.className = "ogLayerSwitcherLabel";
            lbl.innerHTML = (obj.name || obj.src || "noname") + "</br>";

            obj._removeCallback = function () {
                container.removeChild(lineDiv);
            };

            lineDiv.appendChild(center);
            lineDiv.appendChild(inp);
            lineDiv.appendChild(lbl);

            container.appendChild(lineDiv);
        }

        createBaseLayersContainer() {
            var layersDiv = document.createElement("div");
            layersDiv.className = "layersDiv";
            this.dialog.appendChild(layersDiv);

            var baseLayersLbl = document.createElement("div");
            baseLayersLbl.className = "layersDiv";
            baseLayersLbl.innerHTML = "Base Layer";
            layersDiv.appendChild(baseLayersLbl);

            this.baseLayersDiv = document.createElement("div");
            layersDiv.appendChild(this.baseLayersDiv);
        }

        createOverlaysContainer() {
            var overlaysDiv = document.createElement("div");
            overlaysDiv.className = "layersDiv";
            this.dialog.appendChild(overlaysDiv);

            var overlaysLbl = document.createElement("div");
            overlaysLbl.className = "layersDiv";
            overlaysLbl.innerHTML = "Overlays";
            overlaysDiv.appendChild(overlaysLbl);

            this.overlaysDiv = document.createElement("div");
            overlaysDiv.appendChild(this.overlaysDiv);
        }

        createDialog() {
            this.dialog = document.createElement("div");
            this.dialog.id = "ogLayerSwitcherDialog";
            this.dialog.className = "displayNone";
            this.renderer.div.appendChild(this.dialog);

            this.createBaseLayersContainer();
            this.createOverlaysContainer();

            if (this.planet) {
                for (var i = 0; i < this.planet.layers.length; i++) {
                    this.onLayerAdded(this.planet.layers[i]);
                }
            }
        }

        createSwitcher() {
            var button = document.createElement("div");
            button.className = "ogLayerSwitcherButton";
            button.id = "ogLayerSwitcherButtonMaximize";
            var that = this;
            button.onclick = function (e) {
                if (this.id === "ogLayerSwitcherButtonMaximize") {
                    this.id = "ogLayerSwitcherButtonMinimize";
                    that.dialog.className = "displayBlock";
                } else {
                    this.id = "ogLayerSwitcherButtonMaximize";
                    that.dialog.className = "displayNone";
                }
            };
            this.renderer.div.appendChild(button);
        }
    }

    /**
     * @module og/Lock
     */

    class Lock {

        constructor() {
            this._lock = 0;
        }

        lock(key) {
            this._lock |= (1 << key._id);
        }

        free(key) {
            this._lock &= ~(1 << key._id);
        }

        isFree() {
            return this._lock === 0;
        }

        isLocked() {
            return this._lock !== 0;
        }
    }

    class Key {

        static get _staticCounter() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set _staticCounter(n) {
            this._counter = n;
        }

        constructor() {
            this._id = Key._staticCounter++;
        }
    }

    /**
     * @module og/control/MouseNavigation
     */

    /**
     * Mouse planet camera dragging control.
     * @class
     * @extends {Control}
     * @param {Object} [options] - Control options.
     */
    class MouseNavigation extends Control$1 {
        constructor(options) {
            super(options);

            this._name = "mouseNavigation";

            options = options || {};

            this.grabbedPoint = new Vec3();
            this._eye0 = new Vec3();
            this.pointOnEarth = new Vec3();
            this.earthUp = new Vec3();
            this.inertia = 0.007;
            this.grabbedSpheroid = new Sphere$1();
            this.planet = null;
            this.qRot = new Quat();
            this.scaleRot = 0.0;

            this.distDiff = 0.3;
            this.stepsCount = 8;
            this.stepsForward = null;
            this.stepIndex = 0;

            this._lmbDoubleClickActive = true;

            this.minSlope = options.minSlope || 0.1;

            this._wheelDirection = +1;

            this._keyLock = new Key();
        }

        static getMovePointsFromPixelTerrain(cam, planet, stepsCount, delta, point, forward, dir) {
            var steps = [];

            var eye = cam.eye.clone(),
                n = cam._b.clone(),
                u = cam._r.clone(),
                v = cam._u.clone();

            var a = planet.getCartesianFromPixelTerrain(point, true);

            if (!a) {
                a = planet.getCartesianFromPixelTerrain(planet.renderer.handler.getCenter(), true);
            }

            if (a) {
                if (!dir) {
                    dir = Vec3.sub(a, cam.eye).normalize();
                }

                var d = (delta * cam.eye.distance(a)) / stepsCount;

                if (forward) {
                    d = -1.25 * d;
                } else {
                    d *= 2;
                }

                var scaled_n = n.scaleTo(d);

                let slope = dir.dot(cam.eye.normal().negate());

                if (slope >= 0.1) {
                    var grabbedSpheroid = new Sphere$1();
                    grabbedSpheroid.radius = a.length();

                    var rotArr = [],
                        eyeArr = [];

                    var breaked = false;
                    for (var i = 0; i < stepsCount; i++) {
                        eye.addA(scaled_n);
                        var b = new Ray$1(eye, dir).hitSphere(grabbedSpheroid);
                        eyeArr[i] = eye.clone();
                        if (b) {
                            rotArr[i] = new Mat4().rotateBetweenVectors(a.normal(), b.normal());
                        } else {
                            breaked = true;
                            break;
                        }
                    }

                    if (!breaked) {
                        for (let i = 0; i < stepsCount; i++) {
                            var rot = rotArr[i];
                            steps[i] = {};
                            steps[i].eye = rot.mulVec3(eyeArr[i]);
                            steps[i].v = rot.mulVec3(v);
                            steps[i].u = rot.mulVec3(u);
                            steps[i].n = rot.mulVec3(n);
                        }
                    } else {
                        eye = cam.eye.clone();
                        for (let i = 0; i < stepsCount; i++) {
                            steps[i] = {};
                            steps[i].eye = eye.addA(scaled_n).clone();
                            steps[i].v = v;
                            steps[i].u = u;
                            steps[i].n = n;
                        }
                    }
                } else {
                    for (let i = 0; i < stepsCount; i++) {
                        steps[i] = {};
                        steps[i].eye = eye.addA(dir.scaleTo(-d)).clone();
                        steps[i].v = v;
                        steps[i].u = u;
                        steps[i].n = n;
                    }
                }

                return steps;
            }
        }

        onactivate() {
            this.renderer.events.on("mousewheel", this.onMouseWheel, this);
            this.renderer.events.on("lhold", this.onMouseLeftButtonDown, this);
            this.renderer.events.on("rhold", this.onMouseRightButtonDown, this);
            this.renderer.events.on("ldown", this.onMouseLeftButtonClick, this);
            this.renderer.events.on("lup", this.onMouseLeftButtonUp, this);
            this.renderer.events.on("rdown", this.onMouseRightButtonClick, this);
            this.renderer.events.on("draw", this.onDraw, this, -1000);
            this.renderer.events.on("mousemove", this.onMouseMove, this);
            this.renderer.events.on("mouseleave", this.onMouseLeave, this);
            this.renderer.events.on("mouseenter", this.onMouseEnter, this);

            if (this._lmbDoubleClickActive) {
                this.renderer.events.on("ldblclick", this.onMouseLeftButtonDoubleClick, this);
            }
        }

        ondeactivate() {
            this.renderer.events.off("mousewheel", this.onMouseWheel);
            this.renderer.events.off("lhold", this.onMouseLeftButtonDown);
            this.renderer.events.off("rhold", this.onMouseRightButtonDown);
            this.renderer.events.off("ldown", this.onMouseLeftButtonClick);
            this.renderer.events.off("lup", this.onMouseLeftButtonUp);
            this.renderer.events.off("rdown", this.onMouseRightButtonClick);
            this.renderer.events.off("draw", this.onDraw);
            this.renderer.events.off("ldblclick", this.onMouseLeftButtonDoubleClick);
            this.renderer.events.off("mouseleave", this.onMouseLeave);
            this.renderer.events.off("mouseenter", this.onMouseEnter);
        }

        activateDoubleClickZoom() {
            if (!this._lmbDoubleClickActive) {
                this._lmbDoubleClickActive = true;
                this.renderer.events.on("ldblclick", this.onMouseLeftButtonDoubleClick, this);
            }
        }

        deactivateDoubleClickZoom() {
            if (this._lmbDoubleClickActive) {
                this._lmbDoubleClickActive = false;
                this.renderer.events.off("ldblclick", this.onMouseLeftButtonDoubleClick);
            }
        }

        onMouseEnter(e) {
            const renderEvents = this.renderer.events;
            if (renderEvents.isKeyPressed(input.KEY_ALT)) {
                renderEvents.releaseKeys();
            }

            renderEvents.updateButtonsStates(e.buttons);
            if (renderEvents.mouseState.leftButtonDown) {
                this.renderer.handler.canvas.classList.add("ogGrabbingPoiner");
            } else {
                this.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
            }
        }

        onMouseLeave(e) {
            if (this.renderer.events.mouseState.leftButtonDown) {
                this.scaleRot = 0;
            }
            this.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
        }

        onMouseWheel(event) {
            if (this.stepIndex) {
                return;
            }

            this.planet.stopFlying();

            this.stopRotation();

            this._deactivate = true;

            this.planet.layerLock.lock(this._keyLock);
            //this.planet.terrainLock.lock(this._keyLock);
            this.planet._normalMapCreator.lock(this._keyLock);

            var ms = this.renderer.events.mouseState;
            this.stepsForward = MouseNavigation.getMovePointsFromPixelTerrain(
                this.renderer.activeCamera,
                this.planet,
                this.stepsCount,
                this.distDiff,
                ms,
                event.wheelDelta > 0,
                ms.direction
            );

            this._wheelDirection = event.wheelDelta;

            if (this.stepsForward) {
                this.stepIndex = this.stepsCount;
            }
        }

        oninit() {
            this.activate();

            this.renderer.events.on("keyfree", input.KEY_ALT, this.onShiftFree, this);
            this.renderer.events.on("keyfree", input.KEY_PRINTSCREEN, this.onShiftFree, this);
        }

        onMouseLeftButtonDoubleClick() {
            this.planet.stopFlying();
            this.stopRotation();
            var p = this.planet.getCartesianFromPixelTerrain(this.renderer.events.mouseState);
            if (p) {
                var cam = this.renderer.activeCamera;
                let maxAlt = cam.maxAltitude + this.planet.ellipsoid._b;
                let minAlt = cam.minAltitude + this.planet.ellipsoid._b;
                const camAlt = cam.eye.length();
                var g = this.planet.ellipsoid.cartesianToLonLat(p);
                if (camAlt > maxAlt || camAlt < minAlt) {
                    this.planet.flyLonLat(new LonLat(g.lon, g.lat));
                    return;
                }

                if (this.renderer.events.isKeyPressed(input.KEY_ALT)) {
                    this.planet.flyLonLat(
                        new LonLat(g.lon, g.lat, cam.eye.distance(p) * 2.0)
                    );
                } else {
                    this.planet.flyLonLat(
                        new LonLat(g.lon, g.lat, cam.eye.distance(p) * 0.57)
                    );
                }
            }
        }

        onMouseLeftButtonClick() {
            if (this._active) {
                this.renderer.handler.canvas.classList.add("ogGrabbingPoiner");
                this.grabbedPoint = this.planet.getCartesianFromMouseTerrain();
                if (this.grabbedPoint) {
                    this._eye0.copy(this.renderer.activeCamera.eye);
                    this.grabbedSpheroid.radius = this.grabbedPoint.length();
                    this.stopRotation();
                }
            }
        }

        stopRotation() {
            this.qRot.clear();
            this.planet.layerLock.free(this._keyLock);
            this.planet.terrainLock.free(this._keyLock);
            this.planet._normalMapCreator.free(this._keyLock);
        }

        onMouseLeftButtonUp(e) {
            this.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
            if (e.x === e.prev_x && e.y === e.prev_y) {
                this.scaleRot = 0.0;
            }
        }

        onMouseLeftButtonDown(e) {
            if (this._active) {
                if (!this.grabbedPoint) {
                    return;
                }

                this.planet.stopFlying();

                if (this.renderer.events.mouseState.moving) {
                    var cam = this.renderer.activeCamera;

                    if (cam.slope > 0.2) {
                        var targetPoint = new Ray$1(cam.eye, e.direction).hitSphere(this.grabbedSpheroid);
                        if (targetPoint) {
                            this.scaleRot = 1.0;
                            this.qRot = Quat.getRotationBetweenVectors(
                                targetPoint.normal(),
                                this.grabbedPoint.normal()
                            );
                            var rot = this.qRot;
                            cam.eye = rot.mulVec3(cam.eye);
                            cam._u = rot.mulVec3(cam._u);
                            cam._r = rot.mulVec3(cam._r);
                            cam._b = rot.mulVec3(cam._b);

                            cam.checkTerrainCollision();

                            cam.update();
                        }
                    } else {
                        var p0 = this.grabbedPoint,
                            p1 = Vec3.add(p0, cam._r),
                            p2 = Vec3.add(p0, p0.normal());

                        var px = new Vec3();
                        if (new Ray$1(cam.eye, e.direction).hitPlane(p0, p1, p2, px) === Ray$1.INSIDE) {
                            cam.eye = this._eye0.addA(px.subA(p0).negate());

                            cam.checkTerrainCollision();

                            cam.update();
                        }
                    }
                }
            }
        }

        onMouseRightButtonClick(e) {
            this.stopRotation();
            this.planet.stopFlying();
            this.pointOnEarth = this.planet.getCartesianFromPixelTerrain(e);
            if (this.pointOnEarth) {
                this.earthUp = this.pointOnEarth.normal();
            }
        }

        onMouseRightButtonDown(e) {
            var cam = this.renderer.activeCamera;

            if (this.pointOnEarth && this.renderer.events.mouseState.moving) {
                this.renderer.controlsBag.scaleRot = 1.0;
                var l = (0.5 / cam.eye.distance(this.pointOnEarth)) * cam._lonLat.height * RADIANS;
                if (l > 0.007) l = 0.007;
                cam.rotateHorizontal(l * (e.x - e.prev_x), false, this.pointOnEarth, this.earthUp);

                cam.rotateVertical(l * (e.y - e.prev_y), this.pointOnEarth, this.minSlope);

                cam.checkTerrainCollision();

                cam.update();
            }
        }

        onShiftFree() {
            this._shiftBusy = false;
        }

        onMouseMove(e) {
            if (this._active && this.renderer.events.isKeyPressed(input.KEY_ALT)) {
                if (!this._shiftBusy) {
                    this._shiftBusy = true;
                    this.onMouseRightButtonClick(e);
                }

                this.onMouseRightButtonDown(e);
            }
        }

        onDraw(e) {
            if (this._active) {
                var r = this.renderer;
                var cam = r.activeCamera;
                var prevEye = cam.eye.clone();

                if (this.stepIndex) {
                    r.controlsBag.scaleRot = 1.0;
                    var sf = this.stepsForward[this.stepsCount - this.stepIndex--];

                    let maxAlt = cam.maxAltitude + this.planet.ellipsoid._b;
                    let minAlt = cam.minAltitude + this.planet.ellipsoid._b;
                    const camAlt = sf.eye.length();
                    if (camAlt > maxAlt || camAlt < minAlt && this._wheelDirection > 0) {
                        this._wheelDirection = +1;
                        return;
                    }

                    cam.eye = sf.eye;
                    cam._u = sf.v;
                    cam._r = sf.u;
                    cam._b = sf.n;

                    cam.checkTerrainCollision();

                    cam.update();
                } else {
                    if (this._deactivate) {
                        this._deactivate = false;

                        this.planet.layerLock.free(this._keyLock);
                        this.planet.terrainLock.free(this._keyLock);
                        this.planet._normalMapCreator.free(this._keyLock);
                    }
                }

                if (r.events.mouseState.leftButtonDown || !this.scaleRot) {
                    return;
                }

                this.scaleRot -= this.inertia;
                if (this.scaleRot <= 0.0) {
                    this.scaleRot = 0.0;
                } else {
                    r.controlsBag.scaleRot = this.scaleRot;
                    var rot = this.qRot
                        .slerp(Quat.IDENTITY, 1.0 - this.scaleRot * this.scaleRot * this.scaleRot)
                        .normalize();
                    if (!(rot.x || rot.y || rot.z)) {
                        this.scaleRot = 0.0;
                    }
                    cam.eye = rot.mulVec3(cam.eye);
                    cam._u = rot.mulVec3(cam._u);
                    cam._r = rot.mulVec3(cam._r);
                    cam._b = rot.mulVec3(cam._b);

                    cam.checkTerrainCollision();

                    cam.update();
                }

                if (cam.eye.distance(prevEye) / cam._terrainAltitude > 0.01) {
                    this.planet.layerLock.lock(this._keyLock);
                    this.planet.terrainLock.lock(this._keyLock);
                    this.planet._normalMapCreator.lock(this._keyLock);
                } else {
                    this.planet.layerLock.free(this._keyLock);
                    this.planet.terrainLock.free(this._keyLock);
                    this.planet._normalMapCreator.free(this._keyLock);
                }
            }
        }
    }

    /**
     * @module og/control/ToggleWireframe
     */

    /**
     * Planet GL draw mode(TRIANGLE_STRIP/LINE_STRING) changer.
     * @class
     * @extends {Control}
     * @param {Object} [options] - Control options.
     */
    class ToggleWireframe extends Control$1 {
        constructor(options = {}) {
            super(options);
            this._isActive = options.isActive || false;
        }

        oninit() {
            this.renderer.events.on("charkeypress", input.KEY_X, this.toogleWireframe, this);
            if (this._isActive) {
                this.planet.setDrawMode(this.renderer.handler.gl.LINE_STRIP);
            }
        }

        toogleWireframe(e) {
            if (this.planet.drawMode === this.renderer.handler.gl.LINE_STRIP) {
                this.planet.setDrawMode(this.renderer.handler.gl.TRIANGLE_STRIP);
            } else {
                this.planet.setDrawMode(this.renderer.handler.gl.LINE_STRIP);
            }
        }
    }

    /**
     * @module og/control/TouchNavigation
     */

    class Touch {
        constructor() {
            this.x = 0;
            this.y = 0;
            this.prev_x = 0;
            this.prev_y = 0;
            this.grabbedPoint = new Vec3();
            this.grabbedSpheroid = new Sphere$1();
            this.dX = function () {
                return this.x - this.prev_x;
            };
            this.dY = function () {
                return this.y - this.prev_y;
            };
        }
    }

    /**
     * Touch pad planet camera dragging control.
     * @class
     * @extends {Control}
     * @param {Object} [options] - Control options.
     */
    class TouchNavigation extends Control$1 {
        constructor(options) {
            super(options);

            this._name = "touchNavigation";

            this.grabbedPoint = new Vec3();
            this.inertia = 0.007;
            this.grabbedSpheroid = new Sphere$1();
            this.planet = null;
            this.qRot = new Quat();
            this.scaleRot = 0;
            this.rot = 1;
            this._eye0 = new Vec3();

            this.stepsCount = 5;
            this.stepsForward = null;
            this.stepIndex = 0;

            this.pointOnEarth = null;
            this.earthUp = null;

            this.touches = [new Touch(), new Touch()];

            this._keyLock = new Key();
        }

        oninit() {
            this.renderer.events.on("touchstart", this.onTouchStart, this);
            this.renderer.events.on("touchend", this.onTouchEnd, this);
            this.renderer.events.on("doubletouch", this.onDoubleTouch, this);
            this.renderer.events.on("touchcancel", this.onTouchCancel, this);
            this.renderer.events.on("touchmove", this.onTouchMove, this);
            this.renderer.events.on("draw", this.onDraw, this);
        }

        onTouchStart(e) {
            this._touching = true;

            if (e.sys.touches.length === 2) {
                var t0 = this.touches[0],
                    t1 = this.touches[1];

                t0.x = e.sys.touches.item(0).clientX - e.sys.offsetLeft;
                t0.y = e.sys.touches.item(0).clientY - e.sys.offsetTop;
                t0.prev_x = e.sys.touches.item(0).clientX - e.sys.offsetLeft;
                t0.prev_y = e.sys.touches.item(0).clientY - e.sys.offsetTop;
                t0.grabbedPoint = this.planet.getCartesianFromPixelTerrain(e, true);

                t1.x = e.sys.touches.item(1).clientX - e.sys.offsetLeft;
                t1.y = e.sys.touches.item(1).clientY - e.sys.offsetTop;
                t1.prev_x = e.sys.touches.item(1).clientX - e.sys.offsetLeft;
                t1.prev_y = e.sys.touches.item(1).clientY - e.sys.offsetTop;
                t1.grabbedPoint = this.planet.getCartesianFromPixelTerrain(e, true);

                // this.planet._viewChanged = true;
                this.pointOnEarth = this.planet.getCartesianFromPixelTerrain(
                    this.renderer.handler.getCenter(),
                    true
                );

                if (this.pointOnEarth) {
                    this.earthUp = this.pointOnEarth.normal();
                }

                if (t0.grabbedPoint && t1.grabbedPoint) {
                    t0.grabbedSpheroid.radius = t0.grabbedPoint.length();
                    t1.grabbedSpheroid.radius = t1.grabbedPoint.length();
                    this.stopRotation();
                }
            } else if (e.sys.touches.length === 1) {
                this._startTouchOne(e);
            }
        }

        _startTouchOne(e) {
            var t = this.touches[0];

            t.x = e.sys.touches.item(0).clientX - e.sys.offsetLeft;
            t.y = e.sys.touches.item(0).clientY - e.sys.offsetTop;
            t.prev_x = e.sys.touches.item(0).clientX - e.sys.offsetLeft;
            t.prev_y = e.sys.touches.item(0).clientY - e.sys.offsetTop;

            t.grabbedPoint = this.planet.getCartesianFromPixelTerrain(e, true);
            this._eye0.copy(this.renderer.activeCamera.eye);

            if (t.grabbedPoint) {
                t.grabbedSpheroid.radius = t.grabbedPoint.length();
                this.stopRotation();
            }
        }

        stopRotation() {
            this.qRot.clear();
            this.planet.layerLock.free(this._keyLock);
            this.planet.terrainLock.free(this._keyLock);
            this.planet._normalMapCreator.free(this._keyLock);
        }

        onDoubleTouch(e) {
            if (this.stepIndex) {
                return;
            }

            this.planet.stopFlying();
            this.stopRotation();

            var p = this.planet.getCartesianFromPixelTerrain(e);
            if (p) {
                var g = this.planet.ellipsoid.cartesianToLonLat(p);
                this.planet.flyLonLat(
                    new LonLat(g.lon, g.lat, this.renderer.activeCamera.eye.distance(p) * 0.57)
                );
            }
        }

        onTouchEnd(e) {
            if (e.sys.touches.length === 0) {
                this._touching = false;
            }

            if (e.sys.touches.length === 1) {
                this._startTouchOne(e);
            }

            if (
                Math.abs(this.touches[0].x - this.touches[0].prev_x) < 3 &&
                Math.abs(this.touches[0].y - this.touches[0].prev_y) < 3
            ) {
                this.scaleRot = 0;
            }
        }

        onTouchCancel(e) {}

        onTouchMove(e) {
            var cam = this.renderer.activeCamera;

            if (e.sys.touches.length === 2) {
                this.renderer.controlsBag.scaleRot = 1;

                var t0 = this.touches[0],
                    t1 = this.touches[1];

                if (!t0.grabbedPoint || !t1.grabbedPoint) {
                    return;
                }

                this.planet.stopFlying();

                t0.prev_x = t0.x;
                t0.prev_y = t0.y;
                t0.x = e.sys.touches.item(0).clientX - e.sys.offsetLeft;
                t0.y = e.sys.touches.item(0).clientY - e.sys.offsetTop;

                t1.prev_x = t1.x;
                t1.prev_y = t1.y;
                t1.x = e.sys.touches.item(1).clientX - e.sys.offsetLeft;
                t1.y = e.sys.touches.item(1).clientY - e.sys.offsetTop;

                // distance = Math.sqrt((t0.prev_x-t1.prev_x)**2+(t0.prev_y-t1.prev_y)**2) - Math.sqrt((t0.x-t1.x)**2 + (t0.y-t1.y)**2))
                // distance < 0 --> zoomIn; distance > 0 --> zoomOut
                var t0t1Distance = Math.abs(t0.prev_x - t1.prev_x) + Math.abs(t0.prev_y - t1.prev_y)  - (Math.abs(t0.x - t1.x)  + Math.abs(t0.y - t1.y));
                var _move = 0;
                if (t0t1Distance < 0) {
                    _move = 1;
                }
                if (t0t1Distance > 0) {
                    _move = -1;
                }
                if (_move !== 0) {
                    let pos = this.planet.getCartesianFromPixelTerrain(e);
                    if (pos) {
                        let d = cam.eye.distance(pos) * 0.075;
                        cam.eye.addA(cam.getForward().scale(_move * d));
                        cam.checkTerrainCollision();
                        cam.update();
                    }
                }

                if (
                    (t0.dY() > 0 && t1.dY() > 0) ||
                    (t0.dY() < 0 && t1.dY() < 0) ||
                    (t0.dX() > 0 && t1.dX() > 0) ||
                    (t0.dX() < 0 && t1.dX() < 0)
                ) {
                    var l =
                        (0.5 / cam.eye.distance(this.pointOnEarth)) * cam._lonLat.height * RADIANS;
                    if (l > 0.007) l = 0.007;
                    cam.rotateHorizontal(l * t0.dX(), false, this.pointOnEarth, this.earthUp);
                    cam.rotateVertical(l * t0.dY(), this.pointOnEarth, true);
                    cam.checkTerrainCollision();
                    cam.update();
                }

                this.scaleRot = 0;
            } else if (e.sys.touches.length === 1) {
                var t = this.touches[0];

                t.prev_x = t.x;
                t.prev_y = t.y;
                t.x = e.sys.touches.item(0).clientX - e.sys.offsetLeft;
                t.y = e.sys.touches.item(0).clientY - e.sys.offsetTop;

                if (!t.grabbedPoint) {
                    return;
                }

                this.planet.stopFlying();

                var direction = e.direction;
                var targetPoint = new Ray$1(cam.eye, direction).hitSphere(t.grabbedSpheroid);

                if (targetPoint) {
                    if (cam.slope > 0.2) {
                        this.qRot = Quat.getRotationBetweenVectors(
                            targetPoint.normal(),
                            t.grabbedPoint.normal()
                        );
                        var rot = this.qRot;
                        cam.eye = rot.mulVec3(cam.eye);
                        cam._r = rot.mulVec3(cam._r);
                        cam._u = rot.mulVec3(cam._u);
                        cam._b = rot.mulVec3(cam._b);
                        cam.checkTerrainCollision();
                        cam.update();
                        this.scaleRot = 1;
                    } else {
                        var p0 = t.grabbedPoint,
                            p1 = Vec3.add(p0, cam._u),
                            p2 = Vec3.add(p0, p0.normal());
                        var dir = cam.unproject(t.x, t.y);
                        var px = new Vec3();
                        if (new Ray$1(cam.eye, dir).hitPlane(p0, p1, p2, px) === Ray$1.INSIDE) {
                            cam.eye = this._eye0.addA(px.subA(p0).negate());
                            cam.checkTerrainCollision();
                            cam.update();
                            this.scaleRot = 0;
                        }
                    }
                }
            }
        }

        onDraw(e) {
            this.renderer.controlsBag.scaleRot = this.scaleRot;

            if (this._touching) {
                return;
            }

            var r = this.renderer;
            var cam = r.activeCamera;
            var prevEye = cam.eye.clone();

            if (this.stepIndex) {
                r.controlsBag.scaleRot = 1;
                var sf = this.stepsForward[this.stepsCount - this.stepIndex--];
                cam.eye = sf.eye;
                cam._r = sf.v;
                cam._u = sf.u;
                cam._b = sf.n;
                cam.checkTerrainCollision();
                cam.update();
            }

            if (r.events.mouseState.leftButtonDown || !this.scaleRot) {
                return;
            }

            this.scaleRot -= this.inertia;
            if (this.scaleRot <= 0) {
                this.scaleRot = 0;
            } else {
                r.controlsBag.scaleRot = this.scaleRot;
                var rot = this.qRot
                    .slerp(Quat.IDENTITY, 1 - this.scaleRot * this.scaleRot * this.scaleRot)
                    .normalize();
                if (!(rot.x || rot.y || rot.z)) {
                    this.scaleRot = 0;
                }
                cam.eye = rot.mulVec3(cam.eye);
                cam._r = rot.mulVec3(cam._r);
                cam._u = rot.mulVec3(cam._u);
                cam._b = rot.mulVec3(cam._b);
                cam.checkTerrainCollision();
                cam.update();
            }

            if (cam.eye.distance(prevEye) / cam._terrainAltitude > 0.01) {
                this.planet.layerLock.lock(this._keyLock);
                this.planet.terrainLock.lock(this._keyLock);
                this.planet._normalMapCreator.lock(this._keyLock);
            } else {
                this.planet.layerLock.free(this._keyLock);
                this.planet.terrainLock.free(this._keyLock);
                this.planet._normalMapCreator.free(this._keyLock);
            }
        }
    }

    /**
     * Simple keyboard camera navigation with W,S,A,D and shift keys to fly around the scene.
     * @class
     * @extends {Control}
     * @param {Object} [options] - Control options.
     */
    class SimpleNavigation extends Control$1 {
        constructor(options) {
            options = options || {};
            super(options);

            this.camera = null;
            this.speed = options.speed || 1.0;
        }

        onactivate() {}

        ondeactivate() {}

        oninit() {
            this.camera = this.renderer.activeCamera;
            this.renderer.events.on("keypress", input.KEY_W, this.onCameraMoveForward, this);
            this.renderer.events.on("keypress", input.KEY_S, this.onCameraMoveBackward, this);
            this.renderer.events.on("keypress", input.KEY_A, this.onCameraStrifeLeft, this);
            this.renderer.events.on("keypress", input.KEY_D, this.onCameraStrifeRight, this);
            this.renderer.events.on("keypress", input.KEY_UP, this.onCameraLookUp, this);
            this.renderer.events.on("keypress", input.KEY_DOWN, this.onCameraLookDown, this);
            this.renderer.events.on("keypress", input.KEY_LEFT, this.onCameraTurnLeft, this);
            this.renderer.events.on("keypress", input.KEY_RIGHT, this.onCameraTurnRight, this);
            this.renderer.events.on("keypress", input.KEY_Q, this.onCameraRollLeft, this);
            this.renderer.events.on("keypress", input.KEY_E, this.onCameraRollRight, this);
        }

        onCameraMoveForward() {
            if (this._active) {
                var camera = this.camera;
                camera.slide(0, 0, -this.speed);
                camera.update();
            }
        }

        onCameraMoveBackward() {
            if (this._active) {
                var camera = this.camera;
                camera.slide(0, 0, this.speed);
                camera.update();
            }
        }

        onCameraStrifeLeft() {
            if (this._active) {
                var camera = this.camera;
                camera.slide(-this.speed, 0, 0);
                camera.update();
            }
        }

        onCameraStrifeRight() {
            if (this._active) {
                var camera = this.camera;
                camera.slide(this.speed, 0, 0);
                camera.update();
            }
        }

        onCameraLookUp() {
            if (this._active) {
                var cam = this.camera;
                cam.pitch(0.5);
                cam.update();
            }
        }

        onCameraLookDown() {
            if (this._active) {
                var cam = this.camera;
                cam.pitch(-0.5);
                cam.update();
            }
        }

        onCameraTurnLeft() {
            if (this._active) {
                var cam = this.camera;
                cam.yaw(0.5);
                cam.update();
            }
        }

        onCameraTurnRight() {
            if (this._active) {
                var cam = this.camera;
                cam.yaw(-0.5);
                cam.update();
            }
        }

        onCameraRollLeft() {
            if (this._active) {
                var cam = this.camera;
                cam.roll(-0.5);
                cam.update();
            }
        }

        onCameraRollRight() {
            if (this._active) {
                var cam = this.camera;
                cam.roll(0.5);
                cam.update();
            }
        }
    }

    /**
     * @module og/control/ShowFps
     */

    /**
     * Frame per second(FPS) display control.
     * @class
     * @extends {Control}
     * @param {Object} [options] - Control options.
     */
    class ShowFps extends Control$1 {
        constructor(options) {
            super(options);
        }

        oninit() {
            var d = document.createElement("div");
            d.className = "defaultText ";
            d.id = "ogShowFpsControl";
            document.body.appendChild(d);
            this.renderer.events.on("draw", this._draw, this);
        }

        _draw() {
            print2d(
                "ogShowFpsControl",
                (1000.0 / this.renderer.handler.deltaTime).toFixed(1),
                this.renderer.handler.canvas.clientWidth - 60,
                0
            );
        }
    }

    /**
     * Angle between J2000 mean equator and the ecliptic plane.
     * 23 deg 26' 21".448 (Seidelmann, _Explanatory Supplement to the
     * Astronomical Almanac_ (1992), eqn 3.222-1.
     * @const
     * @type{Number}
     */
    const J2000_OBLIQUITY = 23.4392911;

    /**
     * IAU 1976 value
     * @const
     * @type{Number}
     */
    const AU_TO_METERS = 1.4959787e11;

    /**
     * @module og/astro/earth
     */

    /**
     * Returns Sun position in the geocentric coordinate system by the time.
     * @param {Number} jDate - Julian date time.
     * @returns {Vec3} - Sun geocentric coordinates.
     */
    function getSunPosition(jDate) {
        // http://stjarnhimlen.se/comp/tutorial.html
        // a  Mean distance, or semi-major axis
        // e  Eccentricity
        // T  Time at perihelion

        // q  Perihelion distance  = a * (1 - e)
        // Q  Aphelion distance    = a * (1 + e)

        // i  Inclination, i.e. the "tilt" of the orbit relative to the
        //    ecliptic.  The inclination varies from 0 to 180 degrees. If
        //    the inclination is larger than 90 degrees, the planet is in
        //    a retrogade orbit, i.e. it moves "backwards".  The most
        //    well-known celestial body with retrogade motion is Comet Halley.

        // N  (usually written as "Capital Omega") Longitude of Ascending
        //    Node. This is the angle, along the ecliptic, from the Vernal
        //    Point to the Ascending Node, which is the intersection between
        //    the orbit and the ecliptic, where the planet moves from south
        //    of to north of the ecliptic, i.e. from negative to positive
        //    latitudes.

        // w  (usually written as "small Omega") The angle from the Ascending
        //    node to the Perihelion, along the orbit.

        // P  Orbital period       = 365.256898326 * a**1.5/sqrt(1+m) days,
        //    where m = the mass of the planet in solar masses (0 for
        //    comets and asteroids). sqrt() is the square root function.

        // n  Daily motion         = 360_deg / P    degrees/day

        // t  Some epoch as a day count, e.g. Julian Day Number. The Time
        //    at Perihelion, T, should then be expressed as the same day count.

        // t - T   Time since Perihelion, usually in days

        // M  Mean Anomaly         = n * (t - T)  =  (t - T) * 360_deg / P
        //    Mean Anomaly is 0 at perihelion and 180 degrees at aphelion

        // L  Mean Longitude       = M + w + N

        // E  Eccentric anomaly, defined by Kepler's equation:   M = E - e * sin(E)
        //    An auxiliary angle to compute the position in an elliptic orbit

        // v  True anomaly: the angle from perihelion to the planet, as seen
        //    from the Sun

        // r  Heliocentric distance: the planet's distance from the Sun.

        // x,y,z  Rectangular coordinates. Used e.g. when a heliocentric
        //        position (seen from the Sun) should be converted to a
        //        corresponding geocentric position (seen from the Earth).

        var d = jDate - J2000;

        var w = 282.9404 + 4.70935e-5 * d; // longitude of perihelion
        // var a = 1.000000; // mean distance, a.u.
        var e = 0.016709 - 1.151e-9 * d; // eccentricity
        var M = rev(356.047 + 0.9856002585 * d); // mean anomaly

        var oblecl = J2000_OBLIQUITY - 3.563e-7 * d; // obliquity of the ecliptic

        // var L = math.rev(w + M); // Sun's mean longitude

        var E =
            M + DEGREES * e * Math.sin(M * RADIANS) * (1 + e * Math.cos(M * RADIANS)); // eccentric anomaly

        // Sun rectangular coordiantes, where the X axis points towards the perihelion
        var x = Math.cos(E * RADIANS) - e;
        var y = Math.sin(E * RADIANS) * Math.sqrt(1 - e * e);

        var r = Math.sqrt(x * x + y * y); // distance
        var v = Math.atan2(y, x) * DEGREES; // true anomaly

        var lon = rev(v + w); // longitude of the Sun

        // the Sun's ecliptic rectangular coordinates
        x = r * Math.cos(lon * RADIANS);
        y = r * Math.sin(lon * RADIANS);

        // We use oblecl, and rotate these coordinates
        var xequat = x;
        var yequat = y * Math.cos(oblecl * RADIANS);
        var zequat = y * Math.sin(oblecl * RADIANS);

        var theta = TWO_PI * ((d * 24.0) / 23.9344694 - 259.853 / 360.0); // Siderial spin time

        return Quat.yRotation(-theta).mulVec3(
            new Vec3(
                -yequat * AU_TO_METERS,
                zequat * AU_TO_METERS,
                -xequat * AU_TO_METERS
            )
        );

        // Convert to RA and Decl
        // var RA = Math.atan2(yequat, xequat) * math.DEGREES;
        // var Decl = Math.atan2(zequat, Math.sqrt(xequat * xequat + yequat * yequat)) * math.DEGREES;
    }

    /**
     * @module og/light/LightSource
     */

    /**
     * Represents basic light source.
     * @class
     * @param {string} [name] - Light source name.
     * @param {Object} [params] - Light parameters:
     * @param {Vec3} [params.position] - Light source position if it is a point light, otherwise it is a light direction vector.
     * @param {Vec3} [params.ambient]  - Ambient RGB color.
     * @param {Vec3} [params.diffuse]  - Diffuse RGB color.
     * @param {Vec3} [params.specular]  - Specular RGB color.
     * @param {number} [params.shininess]  - Specular shininess.
     */
    class LightSource {
        static get _staticCounter() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set _staticCounter(n) {
            this._counter = n;
        }

        constructor(name, params) {
            params = params || {};

            /**
             * Light name.
             * @protected
             * @type {string}
             */
            this._name = name || "light_" + LightSource._staticCounter++;

            /**
             * Render node where light is shines.
             * @protected
             * @type {RenderNode}
             */
            this._renderNode = null;

            /**
             * Light position.
             * @protected
             * @type {Vec3}
             */
            this._position = params.position || new Vec3();

            /**
             * True if the light is directional.
             * @public
             * @type {boolean}
             */
            this.directional = params.derectional != undefined ? params.derectional : true;

            /**
             * Ambient color.
             * @protected
             * @type {Vec3}
             */
            this._ambient = params.ambient || new Vec3();

            /**
             * Diffuse color.
             * @protected
             * @type {Vec3}
             */
            this._diffuse = params.diffuse || new Vec3(0.8, 0.8, 0.8);

            /**
             * Specular color.
             * @protected
             * @type {Vec3}
             */
            this._specular = params.specular || new Vec3(0.18, 0.18, 0.18);

            /**
             * Shininess.
             * @protected
             * @type {number}
             */
            this._shininess = params.shininess != undefined ? params.shininess : 3.3;

            /**
             * Light activity.
             * @protected
             * @type {boolean}
             */
            this._active = true;

            this._tempAmbient = this._ambient.clone();
            this._tempDiffuse = this._diffuse.clone();
            this._tempSpecular = this._specular.clone();
            this._tempShininess = this._shininess;
        }

        /**
         * Creates clone of the current light object.
         * @todo: TODO
         * @public
         * @returns {LightSource}
         */
        clone() {
            // TODO
        }

        /**
         * Set light activity. If activity is false the light doesn't shine.
         * @public
         * @param {boolean} active - Light activity.
         */
        setActive(active) {
            if (active && !this._active) {
                var rn = this._renderNode;
                if (rn) {
                    var index = rn._lightsNames.indexOf(this._name);
                    this._shininess = rn._lightsParamsf[index] = this._tempShininess;
                    if (index != -1) {
                        index *= 9;
                        this._ambient.x = rn._lightsParamsv[index] = this._tempAmbient.x;
                        this._ambient.y = rn._lightsParamsv[index + 1] = this._tempAmbient.y;
                        this._ambient.z = rn._lightsParamsv[index + 2] = this._tempAmbient.z;
                        this._diffuse.x = rn._lightsParamsv[index + 3] = this._tempDiffuse.x;
                        this._diffuse.y = rn._lightsParamsv[index + 4] = this._tempDiffuse.y;
                        this._diffuse.z = rn._lightsParamsv[index + 5] = this._tempDiffuse.z;
                        this._specular.x = rn._lightsParamsv[index + 6] = this._tempSpecular.x;
                        this._specular.y = rn._lightsParamsv[index + 7] = this._tempSpecular.y;
                        this._specular.z = rn._lightsParamsv[index + 8] = this._tempSpecular.z;
                    }
                }
                this._active = true;
            } else if (!active && this._active) {
                this._tempAmbient = this._ambient.clone();
                this._tempDiffuse = this._diffuse.clone();
                this._tempSpecular = this._specular.clone();
                this._tempShininess = this._shininess;
                this.setBlack();
                this._active = false;
            }
        }

        /**
         * Gets light activity.
         * @public
         * @returns {boolean}
         */
        isActive() {
            return this._active;
        }

        /**
         * Set light source position, or if it is a directional type sets light direction vector.
         * @public
         * @param {Vec3} position - Light position or direction vector.
         * @returns {LightSource}
         */
        setPosition3v(position) {
            this._position.x = position.x;
            this._position.y = position.y;
            this._position.z = position.z;
            return this;
        }

        /**
         * Set light source position, or if it is a directional type sets light direction vector.
         * @public
         * @param {Vec3} position - Light position or direction vector.
         * @returns {LightSource}
         */
        setPosition(x, y, z) {
            this._position.x = x;
            this._position.y = y;
            this._position.z = z;
            return this;
        }

        /**
         * Returns light source position, or if it is a directional type sets light direction vector.
         * @public
         * @returns {Vec3} - Light source position/direction.
         */
        getPosition() {
            return this._position.clone();
        }

        /**
         * Set ambient color.
         * @public
         * @param {Vec3} rgb - Ambient color.
         * @returns {LightSource}
         */
        setAmbient3v(rgb) {
            return this.setAmbient(rgb.x, rgb.y, rgb.z);
        }

        /**
         * Set diffuse color.
         * @public
         * @param {Vec3} rgb - Diffuse color.
         * @returns {LightSource}
         */
        setDiffuse3v(rgb) {
            return this.setDiffuse(rgb.x, rgb.y, rgb.z);
        }

        /**
         * Set specular color.
         * @public
         * @param {Vec3} rgb - Specular color.
         * @returns {LightSource}
         */
        setSpecular3v(rgb) {
            return this.setSpecular(rgb.x, rgb.y, rgb.z);
        }

        /**
         * Set ambient color.
         * @public
         * @param {Vec3} rgb - Ambient color.
         * @returns {LightSource}
         */
        setAmbient(r, g, b) {
            this._ambient.set(r, g, b);
            var rn = this._renderNode;
            if (rn) {
                var index = 9 * rn._lightsNames.indexOf(this._name);
                if (index != -1) {
                    rn._lightsParamsv[index] = r;
                    rn._lightsParamsv[index + 1] = g;
                    rn._lightsParamsv[index + 2] = b;
                }
            }
            return this;
        }

        /**
         * Set diffuse color.
         * @public
         * @returns {LightSource}
         */
        setDiffuse(r, g, b) {
            this._diffuse.set(r, g, b);
            var rn = this._renderNode;
            if (rn) {
                var index = 9 * rn._lightsNames.indexOf(this._name);
                if (index != -1) {
                    rn._lightsParamsv[index + 3] = r;
                    rn._lightsParamsv[index + 4] = g;
                    rn._lightsParamsv[index + 5] = b;
                }
            }
            return this;
        }

        /**
         * Set specular color.
         * @public
         * @returns {LightSource}
         */
        setSpecular(r, g, b) {
            this._specular.set(r, g, b);
            var rn = this._renderNode;
            if (rn) {
                var index = 9 * rn._lightsNames.indexOf(this._name);
                if (index != -1) {
                    rn._lightsParamsv[index + 6] = r;
                    rn._lightsParamsv[index + 7] = g;
                    rn._lightsParamsv[index + 8] = b;
                }
            }
            return this;
        }

        /**
         * Set material shininess.
         * @public
         * @returns {LightSource}
         */
        setShininess(shininess) {
            this._shininess = shininess;
            var rn = this._renderNode;
            if (rn) {
                var index = rn._lightsNames.indexOf(this._name);
                if (index != -1) {
                    rn._lightsParamsf[index] = shininess;
                }
            }
            return this;
        }

        /**
         * Sets light to black.
         * @public
         * @returns {LightSource}
         */
        setBlack() {
            this._ambient.clear();
            this._diffuse.clear();
            this._specular.clear();
            this._shininess = 0;
            var rn = this._renderNode;
            if (rn) {
                var index = 9 * rn._lightsNames.indexOf(this._name);
                if (index != -1) {
                    rn._lightsParamsv[index] =
                        rn._lightsParamsv[index + 1] =
                        rn._lightsParamsv[index + 2] =
                        rn._lightsParamsv[index + 3] =
                        rn._lightsParamsv[index + 4] =
                        rn._lightsParamsv[index + 5] =
                        rn._lightsParamsv[index + 6] =
                        rn._lightsParamsv[index + 7] =
                        rn._lightsParamsv[index + 8] =
                            0;
                }
            }
            return this;
        }

        /**
         * Adds current light to the render node scene.
         * @public
         * @param {RenderNode} renderNode - Render node scene.
         * @returns {LightSource}
         */
        addTo(renderNode) {
            this._renderNode = renderNode;
            renderNode._lights.push(this);
            renderNode._lightsNames.push(this._name);
            renderNode._lightsParamsf.push(this._shininess);
            renderNode._lightsParamsv.push.apply(renderNode._lightsParamsv, this._ambient.toVec());
            renderNode._lightsParamsv.push.apply(renderNode._lightsParamsv, this._diffuse.toVec());
            renderNode._lightsParamsv.push.apply(renderNode._lightsParamsv, this._specular.toVec());
            return this;
        }

        /**
         * Removes from render node scene.
         * @public
         */
        remove() {
            var rn = this.renderNode;
            if (rn) {
                var li = rn.getLightById(this._name);
                if (li != -1) {
                    rn._lights.splice(li, 1);
                    rn._lightsNames.splice(li, 1);
                    rn._lightsParamsf.splice(li, 1);
                    rn._lightsParamsv.splice(li, 9);
                }
            }
            this._renderNode = null;
        }
    }

    /**
     * @module og/control/Sun
     */

    const ACTIVATION_HEIGHT = 12079000.0;
    /**
     * Real Sun geocentric position control that place the Sun on the right place by the Earth.
     * @class
     * @extends {Control}
     * @param {Object} [options] - Control options.
     */
    class Sun extends Control$1 {
        constructor(options) {
            super(options);

            this._name = "sun";

            options = options || {};

            /**
             * Earth planet node.
             * @public
             * @type {Planet}
             */
            this.planet = null;

            /**
             * Sunlight position placed in the camera eye.
             * @private
             * @type {boolean}
             */
            // this._isCameraSunlight = false;

            this.offsetVertical = options.offsetVertical || -5000000;

            this.offsetHorizontal = options.offsetHorizontal || 5000000;

            /**
             * Light source.
             * @public
             * @type {LightSource}
             */
            this.sunlight = null;

            /**
             * Current frame handler clock date and time.
             * @private
             * @type {Number}
             */
            this._currDate = 0;

            /**
             * Previous frame handler clock date and time.
             * @private
             * @type {Number}
             */
            this._prevDate = 0;

            this._clockPtr = null;

            this._lightOn = false;

            this._stopped = options.stopped || false;
        }

        oninit() {
            this.planet.lightEnabled = true;

            // sunlight initialization
            this.sunlight = new LightSource("Sun", {
                ambient: new Vec3(0.15, 0.15, 0.25),
                diffuse: new Vec3(0.9, 0.9, 0.8),
                specular: new Vec3(0.1, 0.1, 0.06),
                shininess: 110
            });
            this.sunlight.addTo(this.planet);

            this.renderer.events.on("draw", this._draw, this);

            if (!this._clockPtr) {
                this._clockPtr = this.renderer.handler.defaultClock;
            }
        }

        stop() {
            this._stopped = true;
        }

        onactivate() {
            this._stopped = false;
        }

        bindClock(clock) {
            this._clockPtr = clock;
        }

        _draw() {
            this._currDate = this._clockPtr.currentDate;
            if (!this._stopped) {
                var cam = this.renderer.activeCamera;
                if (cam.getHeight() < ACTIVATION_HEIGHT || !this._active) {
                    this._lightOn = true;
                    this._f = 1;
                    var n = cam.eye.normal(),
                        u = cam.getForward();

                    u.scale(Math.sign(cam._u.dot(n))); // up

                    if (cam.slope > 0.99) {
                        u = cam._u;
                    }

                    var tu = Vec3.proj_b_to_plane(u, n, u).normalize().scale(this.offsetVertical);
                    var tr = Vec3.proj_b_to_plane(cam._r, n, cam._r)
                        .normalize()
                        .scale(this.offsetHorizontal); // right
                    var d = tu.add(tr);
                    var pos = cam.eye.add(d);
                    if (this._k > 0) {
                        this._k -= 0.01;
                        let rot = Quat.getRotationBetweenVectors(
                            this.sunlight._position.normal(),
                            pos.normal()
                        );
                        let r = rot.slerp(Quat.IDENTITY, this._k).normalize();
                        this.sunlight.setPosition3v(r.mulVec3(this.sunlight._position));
                    } else {
                        this.sunlight.setPosition3v(pos);
                    }
                } else {
                    this._k = 1;
                    if (this._f > 0) {
                        this._f -= 0.01;
                        let rot = Quat.getRotationBetweenVectors(
                            this.sunlight._position.normal(),
                            getSunPosition(this._currDate).normal()
                        );
                        let r = rot.slerp(Quat.IDENTITY, this._f).normalize();
                        this.sunlight.setPosition3v(r.mulVec3(this.sunlight._position));
                    } else {
                        if (
                            (Math.abs(this._currDate - this._prevDate) > 0.00034 && this._active) ||
                            this._lightOn
                        ) {
                            this._lightOn = false;
                            this._prevDate = this._currDate;
                            this.sunlight.setPosition3v(getSunPosition(this._currDate));
                            this._f = 0;
                        }
                    }
                }
            } else {
                this.sunlight.setPosition3v(getSunPosition(this._currDate));
            }
        }
    }

    /**
     * @module og/control/ZoomControl
     */

    /**
     * Planet zoom buttons control.
     * @class
     * @extends {Control}
     * @params {Object} [options] - Control options.
     */
    class ZoomControl extends Control$1 {
        constructor(options) {
            super(options);

            this._keyLock = new Key();

            this.planet = null;

            this._move = 0;
        }

        oninit() {
            var zoomDiv = document.createElement("div"),
                btnZoomIn = document.createElement("button"),
                btnZoomOut = document.createElement("button");

            zoomDiv.className = "ogZoomControl";
            btnZoomIn.className = "ogZoomButton ogZoomIn";
            btnZoomOut.className = "ogZoomButton ogZoomOut";

            zoomDiv.appendChild(btnZoomIn);
            zoomDiv.appendChild(btnZoomOut);

            this.renderer.div.appendChild(zoomDiv);

            btnZoomIn.addEventListener("mousedown", (e) => this.zoomIn());
            btnZoomIn.addEventListener("mouseup", (e) => this.stopZoom());

            btnZoomOut.addEventListener("mousedown", (e) => this.zoomOut());
            btnZoomOut.addEventListener("mouseup", (e) => this.stopZoom());

            btnZoomIn.addEventListener("touchstart", (e) => {
                e.preventDefault();
                this.zoomIn();
            });
            btnZoomIn.addEventListener("touchend", (e) => {
                e.preventDefault();
                this.stopZoom();
            });
            btnZoomIn.addEventListener("touchcancel", (e) => {
                e.preventDefault();
                this.stopZoom();
            });

            btnZoomOut.addEventListener("touchstart", (e) => {
                e.preventDefault();
                this.zoomOut();
            });
            btnZoomOut.addEventListener("touchend", (e) => {
                e.preventDefault();
                this.stopZoom();
            });
            btnZoomOut.addEventListener("touchcancel", (e) => {
                e.preventDefault();
                this.stopZoom();
            });

            this.renderer.events.on("draw", this._draw, this);
        }

        /**
         * Planet zoom in.
         * @public
         */
        zoomIn() {
            this.planet.layerLock.lock(this._keyLock);
            this.planet.terrainLock.lock(this._keyLock);
            this.planet._normalMapCreator.lock(this._keyLock);

            this._targetPoint = this.renderer.getCenter();

            this._move = 1;
        }

        /**
         * Planet zoom out.
         * @public
         */
        zoomOut() {
            this.planet.layerLock.lock(this._keyLock);
            this.planet.terrainLock.lock(this._keyLock);
            this.planet._normalMapCreator.lock(this._keyLock);

            this._targetPoint = this.renderer.getCenter();
            this._move = -1;
        }

        stopZoom() {
            this._move = 0;

            this.planet.layerLock.free(this._keyLock);
            this.planet.terrainLock.free(this._keyLock);
            this.planet._normalMapCreator.free(this._keyLock);
        }

        _draw(e) {
            var cam = this.renderer.activeCamera;

            if (this._move !== 0) {
                let pos = this.planet.getCartesianFromPixelTerrain(e);
                if (pos) {
                    let d = cam.eye.distance(pos) * 0.035;
                    cam.eye.addA(cam.getForward().scale(this._move * d));
                    cam.checkTerrainCollision();
                    cam.update();
                }
            }
        }
    }

    /**
     * @module og/control/MouseWheelZoomControl
     */

    /**
     * Planet zoom buttons control.
     * @class
     * @extends {Control}
     * @params {Object} [options] - Control options.
     */
    class MouseWheelZoomControl extends Control$1 {
        constructor(options) {
            super(options);

            this._name = "MouseWheelZoomControl";

            options = options || {};

            this.grabbedPoint = new Vec3();
            this._eye0 = new Vec3();
            this.pointOnEarth = new Vec3();
            this.earthUp = new Vec3();
            this.inertia = 0.007;
            this.grabbedSpheroid = new Sphere$1();
            this.planet = null;
            this.qRot = new Quat();
            this.scaleRot = 0.0;

            this.distDiff = 0.3;
            this.stepsCount = 8;
            this.stepsForward = null;
            this.stepIndex = 0;

            this._lmbDoubleClickActive = true;

            this.minSlope = options.minSlope || 0.1;

            this._keyLock = new Key();
        }

        oninit() {
            var zoomDiv = document.createElement("div"),
                btnZoomIn = document.createElement("button"),
                btnZoomOut = document.createElement("button");

            zoomDiv.className = "ogZoomControl";
            btnZoomIn.className = "ogZoomButton ogZoomIn";
            btnZoomOut.className = "ogZoomButton ogZoomOut";

            zoomDiv.appendChild(btnZoomIn);
            zoomDiv.appendChild(btnZoomOut);

            this.renderer.div.appendChild(zoomDiv);

            btnZoomIn.addEventListener("mousedown", (e) => this.zoomIn());
            btnZoomIn.addEventListener("mouseup", (e) => this.stopZoom());

            btnZoomOut.addEventListener("mousedown", (e) => this.zoomOut());
            btnZoomOut.addEventListener("mouseup", (e) => this.stopZoom());

            btnZoomIn.addEventListener("touchstart", (e) => {
                e.preventDefault();
                this.zoomIn();
            });
            btnZoomIn.addEventListener("touchend", (e) => {
                e.preventDefault();
                this.stopZoom();
            });
            btnZoomIn.addEventListener("touchcancel", (e) => {
                e.preventDefault();
                this.stopZoom();
            });

            btnZoomOut.addEventListener("touchstart", (e) => {
                e.preventDefault();
                this.zoomOut();
            });
            btnZoomOut.addEventListener("touchend", (e) => {
                e.preventDefault();
                this.stopZoom();
            });
            btnZoomOut.addEventListener("touchcancel", (e) => {
                e.preventDefault();
                this.stopZoom();
            });

            this.renderer.events.on("draw", this._draw, this);
        }

        /**
         * Planet zoom in.
         * @public
         */
        zoomIn() {
            if (this.stepIndex) {
                return;
            }

            this.planet.stopFlying();

            this.stopRotation();

            this._deactivate = true;

            this.planet.layerLock.lock(this._keyLock);
            this.planet.terrainLock.lock(this._keyLock);
            this.planet._normalMapCreator.lock(this._keyLock);

            this.stepsForward = MouseNavigation.getMovePointsFromPixelTerrain(
                this.renderer.activeCamera,
                this.planet,
                this.stepsCount,
                this.distDiff,
                this.renderer.handler.getCenter(),
                true,
               null
            );
            if (this.stepsForward) {
                this.stepIndex = this.stepsCount;
            }
        }

        /**
         * Planet zoom out.
         * @public
         */
        zoomOut() {
            if (this.stepIndex) {
                return;
            }

            this.planet.stopFlying();

            this.stopRotation();

            this._deactivate = true;

            this.planet.layerLock.lock(this._keyLock);
            this.planet.terrainLock.lock(this._keyLock);
            this.planet._normalMapCreator.lock(this._keyLock);
            
            this.stepsForward = MouseNavigation.getMovePointsFromPixelTerrain(
                this.renderer.activeCamera,
                this.planet,
                this.stepsCount,
                this.distDiff,
                this.renderer.handler.getCenter(),
                false,
               null
            );
            if (this.stepsForward) {
                this.stepIndex = this.stepsCount;
            }
        }

        stopRotation() {
            this.qRot.clear();
            this.planet.layerLock.free(this._keyLock);
            this.planet.terrainLock.free(this._keyLock);
            this.planet._normalMapCreator.free(this._keyLock);
        }

        stopZoom() {
            this._move = 0;

            this.planet.layerLock.free(this._keyLock);
            this.planet.terrainLock.free(this._keyLock);
            this.planet._normalMapCreator.free(this._keyLock);
        }

        _draw(e) {
            if (this._active) {
                var r = this.renderer;
                var cam = r.activeCamera;
                var prevEye = cam.eye.clone();

                if (this.stepIndex) {
                    r.controlsBag.scaleRot = 1.0;
                    var sf = this.stepsForward[this.stepsCount - this.stepIndex--];

                    let maxAlt = cam.maxAltitude + this.planet.ellipsoid._a;
                    let minAlt = cam.minAltitude + this.planet.ellipsoid._a;
                    const camAlt = sf.eye.length();
                    if (camAlt > maxAlt || camAlt < minAlt) {
                        return;
                    }

                    cam.eye = sf.eye;
                    cam._u = sf.v;
                    cam._r = sf.u;
                    cam._b = sf.n;

                    cam.checkTerrainCollision();

                    cam.update();
                } else {
                    if (this._deactivate) {
                        this._deactivate = false;

                        this.planet.layerLock.free(this._keyLock);
                        this.planet.terrainLock.free(this._keyLock);
                        this.planet._normalMapCreator.free(this._keyLock);
                    }
                }

                if (r.events.mouseState.leftButtonDown || !this.scaleRot) {
                    return;
                }

                this.scaleRot -= this.inertia;
                if (this.scaleRot <= 0.0) {
                    this.scaleRot = 0.0;
                } else {
                    r.controlsBag.scaleRot = this.scaleRot;
                    var rot = this.qRot
                        .slerp(Quat.IDENTITY, 1.0 - this.scaleRot * this.scaleRot * this.scaleRot)
                        .normalize();
                    if (!(rot.x || rot.y || rot.z)) {
                        this.scaleRot = 0.0;
                    }
                    cam.eye = rot.mulVec3(cam.eye);
                    cam._u = rot.mulVec3(cam._u);
                    cam._r = rot.mulVec3(cam._r);
                    cam._b = rot.mulVec3(cam._b);

                    cam.checkTerrainCollision();

                    cam.update();
                }

                if (cam.eye.distance(prevEye) / cam._terrainAltitude > 0.01) {
                    this.planet.layerLock.lock(this._keyLock);
                    this.planet.terrainLock.lock(this._keyLock);
                    this.planet._normalMapCreator.lock(this._keyLock);
                } else {
                    this.planet.layerLock.free(this._keyLock);
                    this.planet.terrainLock.free(this._keyLock);
                    this.planet._normalMapCreator.free(this._keyLock);
                }
            }
        }
    }

    /**
     * @module og/control/Lighting
     */

    const TEMPLATE$2 = `<div class="og-lighing">

       <div class="og-screen-options">

         <div class="og-option">
          <div class="og-caption">Lighting enabled<input type="checkbox" id="lighting" name="light"/></div>
         </div>

         <div class="og-option">
            <div class="og-caption">Gamma</div>
            <div class="og-slider">
                <input type="range" id="gamma" name="gamma" value="0.0" min="0.0" max="5.0" step="0.01" />
            </div>
            <div class="og-value gamma"></div>
         </div>
         <div class="og-option">
            <div class="og-caption">Exposure</div>
            <div class="og-slider">
                <input type="range" id="exposure" name="exposure" value="0.0" min="0.0" max="12.0" step="0.01" />
            </div>
            <div class="og-value exposure"></div>
         </div>
       </div>      
      
       <div class="og-color-options">
         <div class="og-caption">Ambient</div>
         <div class="og-option">
            <div class="og-label">R</div>
            <div class="og-slider">
                <input type="range" id="ambient-r" name="ambient-r" value="0.0" min="0.0" max="2.0" step="0.01" />
            </div>
            <div class="og-value ambient-r"></div>
         </div>
         <div class="og-option">
            <div class="og-label">G</div>
            <div class="og-slider">
                <input type="range" id="ambient-g" name="ambient-g" value="0.0" min="0.0" max="2.0" step="0.01" />
            </div>
            <div class="og-value ambient-g"></div>
         </div>
         <div class="og-option">
            <div class="og-label">B</div>
            <div class="og-slider">
                <input type="range" id="ambient-b" name="ambient-b" value="0.0" min="0.0" max="2.0" step="0.01" />
            </div>
            <div class="og-value ambient-b"></div>
         </div>

         <div class="og-caption">Diffuse</div>
         <div class="og-option">
            <div class="og-label">R</div>
            <div class="og-slider">
                <input type="range" id="diffuse-r" name="diffuse-r" value="0.0" min="0.0" max="2.0" step="0.01" />
            </div>
            <div class="og-value diffuse-r"></div>
         </div>
         <div class="og-option">
            <div class="og-label">G</div>
            <div class="og-slider">
                <input type="range" id="diffuse-g" name="diffuse-g" value="0.0" min="0.0" max="2.0" step="0.01" />
            </div>
            <div class="og-value diffuse-g"></div>
         </div>
         <div class="og-option">
            <div class="og-label">B</div>
            <div class="og-slider">
                <input type="range" id="diffuse-b" name="diffuse-b" value="0.0" min="0.0" max="2.0" step="0.01" />
            </div>
            <div class="og-value diffuse-b"></div>
         </div>


         <div class="og-caption">Specular</div>
         <div class="og-option">
            <div class="og-label">R</div>
            <div class="og-slider">
                <input type="range" id="specular-r" name="specular-r" value="0.0" min="0.0" max="1.0" step="0.0001" />
            </div>
            <div class="og-value specular-r"></div>
         </div>
         <div class="og-option">
            <div class="og-label">G</div>
            <div class="og-slider">
                <input type="range" id="specular-g" name="specular-g" value="0.0" min="0.0" max="1.0" step="0.0001" />
            </div>
            <div class="og-value specular-g"></div>
         </div>
         <div class="og-option">
            <div class="og-label">B</div>
            <div class="og-slider">
                <input type="range" id="specular-b" name="specular-b" value="0.0" min="0.0" max="1.0" step="0.0001" />
            </div>
            <div class="og-value specular-b"></div>
         </div>

         <div class="og-caption">Shininess</div>
         <div class="og-option" style="margin-left: 8px;">
            <div class="og-slider">
                <input type="range" id="shininess" name="shininess" value="0.0" min="0.0" max="1000.0" step="0.1" />
            </div>
            <div class="og-value shininess"></div>
         </div>
       </div>

       <div class="og-layers">
         <div class="og-caption">Select layer:</div>
         <select id="layers"></select>
       </div>

        <div class="og-caption">Opacity</div>
            <div class="og-option">
            <div class="og-label">A</div>
            <div class="og-slider">
                <input type="range" id="opacity" name="opacity" value="0.0" min="0.0" max="2.0" step="0.01" />
            </div>
            <div class="og-value opacity"></div>
        </div>

    </div>`;

    /**
     * Helps to setup lighting.
     * @class
     * @extends {Control}
     * @param {Object} [options] -
     */
    class Lighting extends Control$1 {
        constructor(options = {}) {
            super(options);

            this._selectedLayer = null;
        }

        bindLayer(layer) {
            this._selectedLayer = layer;

            document.getElementById("opacity").value = layer.opacity;
            document.querySelector(".og-value.opacity").innerHTML = layer.opacity.toString();
        }

        oninit() {
            var panel = parseHTML(TEMPLATE$2);
            document.body.appendChild(panel[0]);

            var _this = this;

            document.getElementById("lighting").checked = this.planet.lightEnabled;

            document.getElementById("lighting").addEventListener("change", (e) => {
                _this.planet.lightEnabled = e.target.checked;
            });

            document.getElementById("layers").addEventListener("change", (e) => {
                //this._selectedLayer = _this.planet.getLayerByName(e.target.value);
                this.bindLayer(_this.planet.getLayerByName(e.target.value));
            });

            document.getElementById("gamma").addEventListener("input", function (e) {
                _this.planet.renderer.gamma = Number(this.value);
                document.querySelector(".og-value.gamma").innerHTML = this.value;
            });
            document.getElementById("exposure").addEventListener("input", function (e) {
                _this.planet.renderer.exposure = Number(this.value);
                document.querySelector(".og-value.exposure").innerHTML = this.value;
            });

            document.querySelector(".og-value.gamma").innerHTML = this.planet.renderer.gamma.toString();
            document.querySelector(".og-value.exposure").innerHTML =
                this.planet.renderer.exposure.toString();

            document.getElementById("gamma").value = this.planet.renderer.gamma;
            document.getElementById("exposure").value = this.planet.renderer.exposure;

            document.getElementById("opacity").addEventListener("input", function (e) {
                if (_this._selectedLayer) {
                    _this._selectedLayer.opacity = Number(this.value);
                }
                document.querySelector(".og-value.opacity").innerHTML = this.value;
            });

            document.getElementById("ambient-r").addEventListener("input", function (e) {
                _this.planet._ambient[0] = Number(this.value);
                document.querySelector(".og-value.ambient-r").innerHTML = this.value;
            });
            document.getElementById("ambient-g").addEventListener("input", function (e) {
                _this.planet._ambient[1] = Number(this.value);
                document.querySelector(".og-value.ambient-g").innerHTML = this.value;
            });
            document.getElementById("ambient-b").addEventListener("input", function (e) {
                _this.planet._ambient[2] = Number(this.value);
                document.querySelector(".og-value.ambient-b").innerHTML = this.value;
            });

            document.getElementById("diffuse-r").addEventListener("input", function (e) {
                _this.planet._diffuse[0] = Number(this.value);
                document.querySelector(".og-value.diffuse-r").innerHTML = this.value;
            });
            document.getElementById("diffuse-g").addEventListener("input", function (e) {
                _this.planet._diffuse[1] = Number(this.value);
                document.querySelector(".og-value.diffuse-g").innerHTML = this.value;
            });
            document.getElementById("diffuse-b").addEventListener("input", function (e) {
                _this.planet._diffuse[2] = Number(this.value);
                document.querySelector(".og-value.diffuse-b").innerHTML = this.value;
            });

            document.getElementById("specular-r").addEventListener("input", function (e) {
                _this.planet._specular[0] = Number(this.value);
                document.querySelector(".og-value.specular-r").innerHTML = this.value;
            });
            document.getElementById("specular-g").addEventListener("input", function (e) {
                _this.planet._specular[1] = Number(this.value);
                document.querySelector(".og-value.specular-g").innerHTML = this.value;
            });
            document.getElementById("specular-b").addEventListener("input", function (e) {
                _this.planet._specular[2] = Number(this.value);
                document.querySelector(".og-value.specular-b").innerHTML = this.value;
            });

            document.getElementById("shininess").addEventListener("input", function (e) {
                _this.planet._specular[3] = Number(this.value);
                document.querySelector(".og-value.shininess").innerHTML = this.value;
            });

            if (this.planet) {
                this.planet.events.on("layeradd", this._onLayerAdd, this);
                this.planet.events.on("layerremove", this._onLayerRemove, this);

                document.getElementById("ambient-r").value = this.planet._ambient[0];
                document.getElementById("ambient-g").value = this.planet._ambient[1];
                document.getElementById("ambient-b").value = this.planet._ambient[2];

                document.getElementById("diffuse-r").value = this.planet._diffuse[0];
                document.getElementById("diffuse-g").value = this.planet._diffuse[1];
                document.getElementById("diffuse-b").value = this.planet._diffuse[2];

                document.getElementById("specular-r").value = this.planet._specular[0];
                document.getElementById("specular-g").value = this.planet._specular[1];
                document.getElementById("specular-b").value = this.planet._specular[2];
                document.getElementById("shininess").value = this.planet._specular[3];

                document.querySelector(".og-value.ambient-r").innerHTML = this.planet._ambient[0].toString();
                document.querySelector(".og-value.ambient-g").innerHTML = this.planet._ambient[1].toString();
                document.querySelector(".og-value.ambient-b").innerHTML = this.planet._ambient[2].toString();

                document.querySelector(".og-value.diffuse-r").innerHTML = this.planet._diffuse[0].toString();
                document.querySelector(".og-value.diffuse-g").innerHTML = this.planet._diffuse[1].toString();
                document.querySelector(".og-value.diffuse-b").innerHTML = this.planet._diffuse[2].toString();

                document.querySelector(".og-value.specular-r").innerHTML = this.planet._specular[0].toString();
                document.querySelector(".og-value.specular-g").innerHTML = this.planet._specular[1].toString();
                document.querySelector(".og-value.specular-b").innerHTML = this.planet._specular[2].toString();
                document.querySelector(".og-value.shininess").innerHTML = this.planet._specular[3].toString();
            }

            this._fetchLayers();
        }

        _fetchLayers() {
            if (this.planet) {
                for (var i = 0; i < this.planet.layers.length; i++) {
                    this._onLayerAdd(this.planet.layers[i]);
                }
            }
        }

        _onLayerAdd(e) {
            this.bindLayer(e);
            let opt = document.createElement("option");
            opt.value = e.name;
            opt.innerHTML = e.name;
            document.getElementById("layers").appendChild(opt);
            document.getElementById("layers").value = e.name;
        }

        _onLayerRemove(e) { }
    }

    var control = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Control: Control$1,
        CompassButton: CompassButton,
        DebugInfo: DebugInfo,
        EarthNavigation: EarthNavigation,
        EarthCoordinates: EarthCoordinates,
        GeoImageDragControl: GeoImageDragControl,
        KeyboardNavigation: KeyboardNavigation,
        LayerSwitcher: LayerSwitcher,
        MouseNavigation: MouseNavigation,
        ToggleWireframe: ToggleWireframe,
        TouchNavigation: TouchNavigation,
        SimpleNavigation: SimpleNavigation,
        ShowFps: ShowFps,
        Sun: Sun,
        ZoomControl: ZoomControl,
        MouseWheelZoomControl: MouseWheelZoomControl,
        Lighting: Lighting
    });

    const VISIBLE_DISTANCE = 3570.0;
    const MAX_RENDERED_NODES = 1000;

    const NW = 0;
    const NE = 1;
    const SW = 2;
    const SE = 3;

    const N = 0;
    const E = 1;
    const S = 2;
    const W = 3;

    const NOTRENDERING = 0;
    const RENDERING = 1;
    const WALKTHROUGH = 2;

    /**
     * World opposite side table.
     */
    const OPSIDE = [S, W, N, E];

    /**
     * First index is {N,E,S,W} and second is {NW,NE,SW,SE}
     */
    const NEIGHBOUR = [
        [-1, -1, NW, NE],
        [NE, -1, SE, -1],
        [SW, SE, -1, -1],
        [-1, NW, -1, SW]
    ];

    /**
     * Neighbor's oposite part. For example oposite side
     * on the east neighbor side is: [S][SE] = NE
     */
    const OPPART = [
        [SW, SE, NW, NE],
        [NE, NW, SE, SW],
        [SW, SE, NW, NE],
        [NE, NW, SE, SW]
    ];

    /**
     * First index is {NW,NE,SW,SE}, another one is {N,E,S,W}
     */
    const COMSIDE = [
        [true, false, false, true],
        [true, true, false, false],
        [false, false, true, true],
        [false, true, true, false]
    ];

    /**
     * Gets segment part left to right or up to downo ffset against neighbour side.
     * Where 0 - no offset 1 - half segment size offset.
     */
    const PARTOFFSET = [
        /*     N  E  S  W */
        /*NW*/ [0, 1, 0, 0],
        /*NE*/ [1, 0, 0, 0],
        /*SW*/ [0, 1, 0, 1],
        /*SE*/ [1, 1, 1, 1]
    ];

    /**
     * @module og/layer/CanvasTiles
     */

    /**
     * Maximum tiles per frame.
     * @const
     * @type {number}
     */

    const EVENT_NAMES$7 = [
        /**
         * Triggered when current tile image has loaded before rendereing.
         * @event og.layer.CanvasTiles#load
         */
        "load",

        /**
         * Triggered when all tiles have loaded or loading has stopped.
         * @event og.layer.CanvasTiles#loadend
         */
        "loadend"
    ];

    /**
     * Layer used to rendering each tile as a separate canvas object.
     * @class
     * @extends {Layer}
     * //TODO: make asynchronous handler.
     * @param {String} [name="noname"] - Layer name.
     * @param {Object} options:
     * @param {number} [options.opacity=1.0] - Layer opacity.
     * @param {number} [options.minZoom=0] - Minimal visibility zoom level.
     * @param {number} [options.maxZoom=0] - Maximal visibility zoom level.
     * @param {string} [options.attribution] - Layer attribution that displayed in the attribution area on the screen.
     * @param {boolean} [options.isBaseLayer=false] - Base layer flag.
     * @param {boolean} [options.visibility=true] - Layer visibility.
     * @param {layer.CanvasTiles~drawTileCallback} [options.drawTile] - Draw tile callback.
     * @fires og.layer.CanvasTiles#load
     * @fires og.layer.CanvasTiles#loadend
     */
    class CanvasTiles extends Layer$1 {
        constructor(name, options) {
            options = options || {};

            super(name, options);

            this.events.registerNames(EVENT_NAMES$7);

            /**
             * Current creating tiles couter.
             * @protected
             * @type {number}
             */
            this._counter = 0;

            /**
             * Tile pending queue that waiting for create.
             * @protected
             * @type {Array.<planetSegment.Material>}
             */
            this._pendingsQueue = []; // new og.QueueArray();

            /**
             * Draw tile callback.
             * @type {layer.CanvasTiles~drawTileCallback}
             * @public
             */
            this.drawTile = options.drawTile || null;
        }

        get instanceName() {
            return "CanvasTiles";
        }

        /**
         * Abort loading tiles.
         * @public
         */
        abortLoading() {
            var q = this._pendingsQueue;
            for (var i = q._shiftIndex + 1; i < q._popIndex + 1; i++) {
                if (q._array[i]) {
                    this.abortMaterialLoading(q._array[i]);
                }
            }
            this._pendingsQueue = [];
            // this._pendingsQueue.clear();
        }

        /**
         * Sets layer visibility.
         * @public
         * @param {boolean} visibility - Layer visibility.
         */
        setVisibility(visibility) {
            if (visibility !== this._visibility) {
                super.setVisibility(visibility);

                if (!visibility) {
                    this.abortLoading();
                }
            }
        }

        /**
         * Start to load tile material.
         * @public
         * @virtual
         * @param {Material} material -
         */
        loadMaterial(material) {
            var seg = material.segment;

            if (this._isBaseLayer) {
                material.texture = seg._isNorth
                    ? seg.planet.solidTextureOne
                    : seg.planet.solidTextureTwo;
            } else {
                material.texture = seg.planet.transparentTexture;
            }

            if (this._planet.layerLock.isFree() || material.segment.tileZoom < 2) {
                material.isReady = false;
                material.isLoading = true;
                if (CanvasTiles.__requestsCounter >= CanvasTiles.MAX_REQUESTS && this._counter) {
                    this._pendingsQueue.push(material);
                } else {
                    this._exec(material);
                }
            }
        }

        /**
         * Loads material image and apply it to the planet segment.
         * @protected
         * @param {Material} material - Loads material image.
         */
        _exec(material) {
            CanvasTiles.__requestsCounter++;
            this._counter++;
            var that = this;
            if (this.drawTile) {
                /**
                 * Tile custom draw function.
                 * @callback og.layer.CanvasTiles~drawTileCallback
                 * @param {Material} material
                 * @param {applyCanvasCallback} applyCanvasCallback
                 */
                var e = that.events.load;
                if (e.handlers.length) {
                    that.events.dispatch(e, material);
                }
                requestAnimationFrame(() => {
                    that.drawTile(
                        material,
                        /**
                         * Apply canvas.
                         * @callback applyCanvasCallback
                         * @param {Object} canvas -
                         */
                        function (canvas) {
                            that._counter--;
                            CanvasTiles.__requestsCounter--;
                            if (material.isLoading) {
                                material.applyImage(canvas);
                            }
                            that._dequeueRequest();
                        }
                    );
                });
            } else {
                material.textureNotExists();
            }
        }

        /**
         * Abort exact material loading.
         * @public
         * @param {Material} material - Segment material.
         */
        abortMaterialLoading(material) {
            if (material.isLoading && material.image) {
                material.image.src = "";
                this._counter--;
                CanvasTiles.__requestsCounter--;
                this._dequeueRequest();
            }
            material.isLoading = false;
            material.isReady = false;
        }

        _dequeueRequest() {
            if (this._pendingsQueue.length) {
                if (CanvasTiles.__requestsCounter < CanvasTiles.MAX_REQUESTS) {
                    var pmat = this._whilePendings();
                    if (pmat) {
                        this._exec(pmat);
                    }
                }
            } else if (this._counter === 0 && this._planet._terrainCompletedActivated) {
                this.events.dispatch(this.events.loadend);
            }
        }

        _whilePendings() {
            while (this._pendingsQueue.length) {
                var pmat = this._pendingsQueue.pop();
                if (pmat.segment.node) {
                    if (
                        pmat.segment.initialized &&
                        pmat.segment.node.getState() === RENDERING
                    ) {
                        return pmat;
                    }
                    pmat.isLoading = false;
                }
            }
            return null;
        }

        applyMaterial(material) {
            if (material.isReady) {
                return [0, 0, 1, 1];
            } else {

                var segment = material.segment;
                var pn = segment.node,
                    notEmpty = false;

                if (segment.passReady && !material.isLoading) {
                    this.loadMaterial(material);
                }

                var mId = this._id;
                var psegm = material;
                while (pn.parentNode) {
                    pn = pn.parentNode;
                    psegm = pn.segment.materials[mId];
                    if (psegm && psegm.isReady) {
                        notEmpty = true;
                        break;
                    }
                }

                if (notEmpty) {
                    material.appliedNodeId = pn.nodeId;
                    material.texture = psegm.texture;
                    var dZ2 = 1.0 / (2 << (segment.tileZoom - pn.segment.tileZoom - 1));
                    return [
                        segment.tileX * dZ2 - pn.segment.tileX,
                        segment.tileY * dZ2 - pn.segment.tileY,
                        dZ2,
                        dZ2
                    ];
                } else {
                    material.texture = segment.planet.transparentTexture;
                    return [0, 0, 1, 1];
                }
            }
        }

        clearMaterial(material) {
            if (material.isReady) {
                material.isReady = false;

                !material.texture.default &&
                    material.segment.handler.gl.deleteTexture(material.texture);

                material.texture = null;
            }

            this.abortMaterialLoading(material);

            material.isLoading = false;
            material.textureExists = false;

            if (material.image) {
                material.image.src = "";
                material.image = null;
            }
        }
    }

    /**
     * @module og/layer/GeoImage
     */

    /**
     * Used to load and display a single image over specific corner coordinates on the globe, implements og.layer.BaseGeoImage interface.
     * @class
     * @extends {BaseGeoImage}
     */
    class GeoImage extends BaseGeoImage {
        constructor(name, options) {
            super(name, options);

            /**
             * Image object.
             * @private
             * @type {Image}
             */
            this._image = options.image || null;

            /**
             * Image source url path.
             * @private
             * @type {String}
             */
            this._src = options.src || null;
        }

        get instanceName() {
            return "GeoImage";
        }

        /**
         * Sets image source url path.
         * @public
         * @param {String} srs - Image url path.
         */
        setSrc(src) {
            this._planet && this._planet._geoImageCreator.remove(this);
            this._src = src;
            this._sourceReady = false;
        }

        /**
         * Sets image object.
         * @public
         * @param {Image} image - Image object.
         */
        setImage(image) {
            this._planet && this._planet._geoImageCreator.remove(this);
            this._image = image;
            this._src = image.src;
            this._sourceReady = false;
        }

        /**
         * Creates source gl texture.
         * @virtual
         * @protected
         */
        _createSourceTexture() {
            if (!this._sourceCreated) {
                this._sourceTexture = this._planet.renderer.handler.createTexture_n(this._image);
                this._sourceCreated = true;
            }
        }

        /**
         * @private
         * @param {Image} img
         */
        _onLoad(img) {
            this._frameWidth = img.width;
            this._frameHeight = img.height;
            this._sourceReady = true;
            this._planet._geoImageCreator.add(this);
        }

        /**
         * Loads planet segment material. In this case - GeoImage source image.
         * @virtual
         * @public
         * @param {Material} material - GeoImage planet material.
         */
        loadMaterial(material) {
            material.isLoading = true;
            this._creationProceeding = true;
            if (!this._sourceReady && this._src) {
                if (this._image) {
                    if (this._image.complete) {
                        this._onLoad(this._image);
                    } else if (this._image.src) {
                        let that = this;
                        this._image.addEventListener("load", function (e) {
                            that._onLoad(this);
                        });
                    }
                } else {
                    let that = this;
                    this._image = new Image();
                    this._image.addEventListener("load", function (e) {
                        that._onLoad(this);
                    });
                    this._image.src = this._src;
                }
            } else {
                this._planet._geoImageCreator.add(this);
            }
        }

        /**
         * @virtual
         * @param {Material} material - GeoImage material.
         */
        abortMaterialLoading(material) {
            this._image && (this._image.src = "");
            this._creationProceeding = false;
            material.isLoading = false;
            material.isReady = false;
        }

        _renderingProjType1() {
            var p = this._planet,
                h = p.renderer.handler,
                gl = h.gl,
                creator = p._geoImageCreator;

            this._refreshFrame && this._createFrame();
            this._createSourceTexture();

            var f = creator._framebuffer;
            f.setSize(this._frameWidth, this._frameHeight);
            f.activate();

            h.programs.geoImageTransform.activate();
            var sh = h.programs.geoImageTransform._program;
            var sha = sh.attributes,
                shu = sh.uniforms;

            gl.disable(gl.CULL_FACE);

            f.bindOutputTexture(this._materialTexture);
            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.bindBuffer(gl.ARRAY_BUFFER, creator._texCoordsBuffer);

            gl.vertexAttribPointer(sha.texCoords, 2, gl.UNSIGNED_SHORT, true, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._gridBuffer);
            gl.vertexAttribPointer(sha.corners, this._gridBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.uniform4fv(shu.extentParams, this._extentMercParams);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this._sourceTexture);
            gl.uniform1i(shu.sourceTexture, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, creator._indexBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP, creator._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
            f.deactivate();

            gl.enable(gl.CULL_FACE);

            this._ready = true;

            this._creationProceeding = false;
        }

        _renderingProjType0() {
            var p = this._planet,
                h = p.renderer.handler,
                gl = h.gl,
                creator = p._geoImageCreator;

            this._refreshFrame && this._createFrame();
            this._createSourceTexture();

            var f = creator._framebuffer;
            f.setSize(this._frameWidth, this._frameHeight);
            f.activate();

            h.programs.geoImageTransform.activate();
            var sh = h.programs.geoImageTransform._program;
            var sha = sh.attributes,
                shu = sh.uniforms;

            gl.disable(gl.CULL_FACE);

            f.bindOutputTexture(this._materialTexture);
            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.bindBuffer(gl.ARRAY_BUFFER, creator._texCoordsBuffer);

            gl.vertexAttribPointer(sha.texCoords, 2, gl.UNSIGNED_SHORT, true, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._gridBuffer);
            gl.vertexAttribPointer(sha.corners, this._gridBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.uniform4fv(shu.extentParams, this._extentWgs84Params);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this._sourceTexture);
            gl.uniform1i(shu.sourceTexture, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, creator._indexBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP, creator._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
            f.deactivate();

            gl.enable(gl.CULL_FACE);

            this._ready = true;

            this._creationProceeding = false;
        }
    }

    /**
     * @module og/layer/GeoTexture2d
     */

    class GeoTexture2d extends BaseGeoImage {
        constructor(name, options) {
            super(name, options);

            this._sourceTexture = options.texture || null;

            if (options.texture) {
                this._sourceReady = true;
                this._sourceCreated = true;
            }

            this._frameWidth = options.frameWidth ? nextHighestPowerOfTwo(options.frameWidth) : 256;
            this._frameHeight = options.frameHeight ? nextHighestPowerOfTwo(options.frameHeight) : 256;

            this._animate = true;
        }

        get instanceName() {
            return "GeoTexture2d";
        }

        loadMaterial(material) {
            this._planet._geoImageCreator.add(this);
        }

        bindTexture(texture) {
            this._sourceReady = true;
            this._sourceCreated = true;
            this._sourceTexture = texture;
        }

        setSize(width, height) {
            this._frameWidth = width;
            this._frameHeight = height;
            this._frameCreated = false;
        }

        abortMaterialLoading(material) {
            this._creationProceeding = false;
            material.isLoading = false;
            material.isReady = false;
        }

        _renderingProjType1() {
            var p = this._planet,
                h = p.renderer.handler,
                gl = h.gl,
                creator = p._geoImageCreator;

            this._refreshFrame && this._createFrame();

            var f = creator._framebuffer;
            f.setSize(this._frameWidth, this._frameHeight);
            f.activate();

            h.programs.geoImageTransform.activate();
            var sh = h.programs.geoImageTransform._program;
            var sha = sh.attributes,
                shu = sh.uniforms;

            gl.disable(gl.CULL_FACE);

            f.bindOutputTexture(this._materialTexture);
            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.bindBuffer(gl.ARRAY_BUFFER, creator._texCoordsBuffer);
            
            gl.vertexAttribPointer(sha.texCoords, 2, gl.UNSIGNED_SHORT, true, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._gridBuffer);
            gl.vertexAttribPointer(sha.corners, this._gridBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.uniform4fv(shu.extentParams, this._extentMercParams);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this._sourceTexture);
            gl.uniform1i(shu.sourceTexture, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, creator._indexBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP, creator._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
            f.deactivate();

            gl.enable(gl.CULL_FACE);

            this._ready = true;

            this._creationProceeding = false;
        }

        _renderingProjType0() {
            var p = this._planet,
                h = p.renderer.handler,
                gl = h.gl,
                creator = p._geoImageCreator;

            var width = this._frameWidth,
                height = this._frameHeight;

            this._refreshFrame && this._createFrame();

            var f = creator._framebuffer;
            f.setSize(width, height);
            f.activate();

            h.programs.geoImageTransform.activate();
            var sh = h.programs.geoImageTransform._program;
            var sha = sh.attributes,
                shu = sh.uniforms;

            gl.disable(gl.CULL_FACE);

            f.bindOutputTexture(this._materialTexture);
            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.bindBuffer(gl.ARRAY_BUFFER, creator._texCoordsBuffer);

            gl.vertexAttribPointer(sha.texCoords, 2, gl.UNSIGNED_SHORT, true, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._gridBuffer);
            gl.vertexAttribPointer(sha.corners, this._gridBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.uniform4fv(shu.extentParams, this._extentWgs84Params);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this._sourceTexture);
            gl.uniform1i(shu.sourceTexture, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, creator._indexBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP, creator._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
            f.deactivate();

            gl.enable(gl.CULL_FACE);

            this._ready = true;

            this._creationProceeding = false;
        }
    }

    /**
     * @module og/layer/GeoVideo
     */

    /**
     * Used to load and display a video stream by specific corners coordinates on the globe, implements og.layer.BaseGeoImage interface.
     * @class
     * @extends {BaseGeoImage}
     */
    class GeoVideo extends BaseGeoImage {
        constructor(name, options) {
            super(name, options);

            /**
             * @protected
             * @const
             * @type {Boolean}
             */
            this._animate = true;

            /**
             * HTML5 video element object.
             * @private
             * @type {Object}
             */
            this._video = options.videoElement || null;

            /**
             * VIdeo source url path.
             * @private
             * @type {String}
             */
            this._src = options.src || null;
        }

        get instanceName() {
            return "GeoVideo";
        }

        /**
         * Sets video source url path.
         * @public
         * @param {String} srs - Video url path.
         */
        setSrc(src) {
            this._planet && this._planet._geoImageCreator.remove(this);
            this._src = src;
            this._sourceReady = false;
        }

        /**
         * Sets HTML5 video object.
         * @public
         * @param {Object} video - HTML5 video element object.
         */
        setVideoElement(video) {
            this._planet && this._planet._geoImageCreator.remove(this);
            this._video = video;
            this._src = video.src;
            this._sourceReady = false;
        }

        /**
         * Sets layer visibility.
         * @public
         * @param {boolean} visibility - Layer visibility.
         */
        setVisibility(visibility) {
            if (visibility != this._visibility) {
                super.setVisibility(visibility);

                // remove from creator
                if (visibility) {
                    this._sourceReady && this._planet._geoImageCreator.add(this);
                    this._video && this._video.play();
                } else {
                    this._sourceReady && this._planet._geoImageCreator.remove(this);
                    this._video && this._video.pause();
                }
            }
        }

        /**
         * Creates or refresh source video GL texture.
         * @virtual
         * @protected
         */
        _createSourceTexture() {
            if (!this._sourceCreated) {
                this._sourceTexture = this._planet.renderer.handler.createTexture_n(this._video);
                this._sourceCreated = true;
            } else {
                var gl = this._planet.renderer.handler.gl;
                gl.bindTexture(gl.TEXTURE_2D, this._sourceTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._video);
            }
        }

        /**
         * @private
         */
        _onCanPlay(video) {
            this._frameWidth = video.videoWidth;
            this._frameHeight = video.videoHeight;
            video.width = video.videoWidth;
            video.height = video.videoHeight;
            video.play();
            this._sourceReady = true;
            this._planet._geoImageCreator.add(this);
        }

        /**
         * @private
         */
        _onError(video) {
            var err = "unknown error";
            switch (video.error.code) {
                case 1:
                    err = "video loading aborted";
                    break;
                case 2:
                    err = "network loading error";
                    break;
                case 3:
                    err = "video decoding failed / corrupted data or unsupported codec";
                    break;
                case 4:
                    err = "video not supported";
                    break;
            }
            console.log("Error: " + err + " (errorcode=" + video.error.code + ")");
        }

        /**
         * Loads planet segment material. In this case - GeoImage source video.
         * @virtual
         * @public
         * @param {Material} material - GeoImage planet material.
         */
        loadMaterial(material) {
            material.isLoading = true;
            this._creationProceeding = true;
            if (!this._sourceReady && this._src) {
                if (this._video) {
                    if (this._video.readyState === this._video.HAVE_ENOUGH_DATA) {
                        this._onCanPlay(this._video);
                    } else if (this._video.src) {
                        let that = this;
                        this._video.addEventListener("canplay", function (e) {
                            that._onCanPlay(this);
                        });
                    }
                } else {
                    this._video = document.createElement("video");
                    let that = this;
                    this._video.addEventListener("canplay", function () {
                        that._onCanPlay(this);
                    });
                    this._video.addEventListener("error", function () {
                        that._onError(this);
                    });
                }
                this._video.autoplay = true;
                this._video.loop = true;
                this._video.src = this._src;
                this._video.muted = "muted";
                this._video.setAttribute("playsinline", "true");
                this._video.setAttribute("webkit-playsinline", "true");
            } else {
                this._planet._geoImageCreator.add(this);
            }
        }

        /**
         * @virtual
         * @param {Material} material - GeoImage material.
         */
        abortMaterialLoading(material) {
            this._video && (this._video.src = "");
            this._creationProceeding = false;
            material.isLoading = false;
            material.isReady = false;
        }

        _renderingProjType1() {
            var p = this._planet,
                h = p.renderer.handler,
                gl = h.gl,
                creator = p._geoImageCreator;

            this._refreshFrame && this._createFrame();

            if (this._sourceCreated) {
                gl.bindTexture(gl.TEXTURE_2D, this._sourceTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._video);
            } else {
                this._sourceTexture = this._planet.renderer.handler.createTexture_n(this._video);
                this._sourceCreated = true;
            }

            var f = creator._framebuffer;
            f.setSize(this._frameWidth, this._frameHeight);
            f.activate();

            h.programs.geoImageTransform.activate();
            var sh = h.programs.geoImageTransform._program;
            var sha = sh.attributes,
                shu = sh.uniforms;

            gl.disable(gl.CULL_FACE);

            f.bindOutputTexture(this._materialTexture);
            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.bindBuffer(gl.ARRAY_BUFFER, creator._texCoordsBuffer);

            gl.vertexAttribPointer(sha.texCoords, 2, gl.UNSIGNED_SHORT, true, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._gridBuffer);
            gl.vertexAttribPointer(sha.corners, this._gridBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.uniform4fv(shu.extentParams, this._extentMercParams);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this._sourceTexture);
            gl.uniform1i(shu.sourceTexture, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, creator._indexBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP, creator._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
            f.deactivate();

            gl.enable(gl.CULL_FACE);

            this._ready = true;

            this._creationProceeding = false;
        }

        _renderingProjType0() {
            var p = this._planet,
                h = p.renderer.handler,
                gl = h.gl,
                creator = p._geoImageCreator;

            this._refreshFrame && this._createFrame();
            if (!this._sourceCreated) {
                this._sourceTexture = this._planet.renderer.handler.createTexture_n(this._video);
                this._sourceCreated = true;
            } else {
                gl.bindTexture(gl.TEXTURE_2D, this._sourceTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._video);
            }

            var f = creator._framebuffer;
            f.setSize(this._frameWidth, this._frameHeight);
            f.activate();

            h.programs.geoImageTransform.activate();
            var sh = h.programs.geoImageTransform._program;
            var sha = sh.attributes,
                shu = sh.uniforms;

            gl.disable(gl.CULL_FACE);

            f.bindOutputTexture(this._materialTexture);
            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.bindBuffer(gl.ARRAY_BUFFER, creator._texCoordsBuffer);

            gl.vertexAttribPointer(sha.texCoords, 2, gl.UNSIGNED_SHORT, true, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._gridBuffer);
            gl.vertexAttribPointer(sha.corners, this._gridBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.uniform4fv(shu.extentParams, this._extentWgs84Params);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this._sourceTexture);
            gl.uniform1i(shu.sourceTexture, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, creator._indexBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP, creator._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
            f.deactivate();

            gl.enable(gl.CULL_FACE);

            this._ready = true;

            this._creationProceeding = false;
        }
    }

    // import { QueueArray } from '../QueueArray.js';

    const LOCK_UPDATE = -2;
    const LOCK_FREE = -1;

    class LabelWorker {
        constructor(numWorkers = 4) {
            this._id = 0;
            this._source = {};

            this._freeWorkerQueue = []; //new QueueArray(numWorkers);
            var labelProgramm = new Blob([_programm$2], { type: "application/javascript" });

            var that = this;

            for (let i = 0; i < numWorkers; i++) {
                var w = new Worker(URL.createObjectURL(labelProgramm));
                w.onmessage = function (e) {

                    let s = that._source[e.data.id];

                    if (s.label._lockId === LOCK_UPDATE) {
                        that.make(s.handler, s.label);
                    } else {
                        s.handler.workerCallback(e.data, s.label);
                    }

                    that._source[e.data.id] = null;
                    delete that._source[e.data.id];
                    that._freeWorkerQueue.unshift(this);

                    that.check();
                };

                this._freeWorkerQueue.push(w);
            }

            this._pendingQueue = []; //new QueueArray(512);
        }

        check() {
            if (this._pendingQueue.length) {
                var p = this._pendingQueue.pop();
                this.make(p.handler, p.label);
            }
        }

        make(handler, label) {

            if (handler._entityCollection) {
                let source = { handler: handler, label: label };

                if (this._freeWorkerQueue.length) {
                    var w = this._freeWorkerQueue.pop();

                    this._source[this._id] = source;

                    let labelData = new Float32Array([
                    /*0*/this._id++,
                    /*1*/handler._maxLetters,
                    /*2*/label.getVisibility() ? 1 : 0,
                    /*3, 4, 5*/label._positionHigh.x, label._positionHigh.y, label._positionHigh.z,
                    /*6, 7, 8*/label._positionLow.x, label._positionLow.y, label._positionLow.z,
                    /*9*/label._size,
                    /*10, 11, 12*/label._offset.x, label._offset.y, label._offset.z,
                    /*13, 14, 15, 16*/label._color.x, label._color.y, label._color.z, label._color.w,
                    /*17*/label._rotation,
                    /*18, 19, 20*/label._alignedAxis.x, label._alignedAxis.y, label._alignedAxis.z,
                    /*21*/label._fontIndex,
                    /*22*/label._outline,
                    /*23, 24, 25, 26*/label._outlineColor.x, label._outlineColor.y, label._outlineColor.z, label._outlineColor.w,
                    /*27, 28, 29*/label._entity._pickingColor.x, label._entity._pickingColor.y, label._entity._pickingColor.z
                    ]);

                    label._lockId = this._id;

                    w.postMessage({
                        labelData: labelData
                    }, [
                        labelData.buffer,
                    ]);
                } else {
                    this._pendingQueue.push(source);
                }
            }
        }
    }

    const _programm$2 = `'use strict';

    function concatTypedArrays(dest, index, source) {
        let len = source.length,
            offset = index * len;
        for(let i = 0; i < len; i++) {
            dest[offset + i] = source[i];
        }
    }

    self.onmessage = function (e) {
        var labelData = e.data.labelData,
            id = labelData[0],
            maxLetters = labelData[1],
            isVisible = labelData[2],
            /*3, 4, 5*/_positionHigh_x = labelData[3], _positionHigh_y = labelData[4], _positionHigh_z = labelData[5],
            /*6, 7, 8*/_positionLow_x = labelData[6], _positionLow_y = labelData[7], _positionLow_z = labelData[8],
            /*9*/_size = labelData[9],
            /*10, 11, 12*/_offset_x = labelData[10], _offset_y = labelData[11], _offset_z = labelData[12],
            /*13, 14, 15, 16*/_color_x = labelData[13], _color_y = labelData[14], _color_z = labelData[15], _color_w = labelData[16],
            /*17*/_rotation = labelData[17],
            /*18, 19, 20*/_alignedAxis_x = labelData[18], _alignedAxis_y = labelData[19], _alignedAxis_z = labelData[20],
            /*21*/_fontIndex = labelData[21],
            /*22*/_outline = labelData[22],
            /*23, 24, 25, 26*/_outlineColor_x = labelData[23], _outlineColor_y = labelData[24], _outlineColor_z = labelData[25], _outlineColor_w = labelData[26],
            /*27, 28, 29*/_pickingColor_x = labelData[27], _pickingColor_y = labelData[28], _pickingColor_z = labelData[29]
         

        let _vertexArr = new Float32Array(maxLetters * 12),
            _texCoordArr = new Float32Array(maxLetters * 24),
            _gliphParamArr = new Float32Array(maxLetters * 24),
            _positionHighArr = new Float32Array(maxLetters * 18),
            _positionLowArr = new Float32Array(maxLetters * 18),
            _sizeArr = new Float32Array(maxLetters * 6),
            _offsetArr = new Float32Array(maxLetters * 18),
            _rgbaArr = new Float32Array(maxLetters * 24),
            _rotationArr = new Float32Array(maxLetters * 6),
            _alignedAxisArr = new Float32Array(maxLetters * 18),
            _fontIndexArr = new Float32Array(maxLetters * 6),
            _outlineArr = new Float32Array(maxLetters * 6),
            _outlineColorArr = new Float32Array(maxLetters * 24),
            _pickingColorArr = new Float32Array(maxLetters * 18);
        
        for (var i = 0; i < maxLetters; i++) {
            if (isVisible !== 0) {
                concatTypedArrays(_vertexArr, i, [0, 0, 0, -1, 1, -1, 1, -1, 1, 0, 0, 0]);
            } else {
                concatTypedArrays(_vertexArr, i, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
            }

            concatTypedArrays(_texCoordArr, i, [0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0]);
            concatTypedArrays(_gliphParamArr, i, [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0]);

            var x = _positionHigh_x, y = _positionHigh_y, z = _positionHigh_z, w;
            concatTypedArrays(_positionHighArr, i, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);

            x = _positionLow_x; y = _positionLow_y; z = _positionLow_z;
            concatTypedArrays(_positionLowArr, i, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);

            x = _size;
            concatTypedArrays(_sizeArr, i, [x, x, x, x, x, x]);

            x = _offset_x; y = _offset_y; z = _offset_z;
            concatTypedArrays(_offsetArr, i, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);

            x = _color_x; y = _color_y; z = _color_z; w = _color_w;
            concatTypedArrays(_rgbaArr, i, [x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w]);

            x = _rotation;
            concatTypedArrays(_rotationArr, i, [x, x, x, x, x, x]);

            x = _alignedAxis_x; y = _alignedAxis_y; z = _alignedAxis_z;
            concatTypedArrays(_alignedAxisArr, i, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);

            x = _fontIndex;
            concatTypedArrays(_fontIndexArr, i, [x, x, x, x, x, x]);

            x = _outline;
            concatTypedArrays(_outlineArr, i, [x, x, x, x, x, x]);

            x = _outlineColor_x; y = _outlineColor_y; z = _outlineColor_z; w = _outlineColor_w;
            concatTypedArrays(_outlineColorArr, i, [x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w]);

            x = _pickingColor_x / 255; y = _pickingColor_y / 255; z = _pickingColor_z / 255;
            concatTypedArrays(_pickingColorArr, i, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);
        }

        self.postMessage({
                id: id,
                vertexArr: _vertexArr,
                texCoordArr: _texCoordArr,
                gliphParamArr: _gliphParamArr,
                positionHighArr: _positionHighArr,
                positionLowArr: _positionLowArr,
                sizeArr: _sizeArr,
                offsetArr: _offsetArr,
                rgbaArr: _rgbaArr,
                rotationArr: _rotationArr,
                alignedAxisArr: _alignedAxisArr,
                fontIndexArr: _fontIndexArr,
                outlineArr: _outlineArr,
                outlineColorArr: _outlineColorArr,
                pickingColorArr: _pickingColorArr
             }, [
                    _vertexArr.buffer,
                    _texCoordArr.buffer,
                    _gliphParamArr.buffer,
                    _positionHighArr.buffer,
                    _positionLowArr.buffer,
                    _sizeArr.buffer,
                    _offsetArr.buffer,
                    _rgbaArr.buffer,
                    _rotationArr.buffer,
                    _alignedAxisArr.buffer,
                    _fontIndexArr.buffer,
                    _outlineArr.buffer,
                    _outlineColorArr.buffer,
                    _pickingColorArr.buffer
            ]);
    }`;

    /**
     * @module og/entity/BaseBillboard
     */

    /**
     * Base prototype for billboard and label classes.
     * @class
     * @param {Object} [options] - Options:
     * @param {Vec3|Array.<number>} [options.position] - Billboard spatial position.
     * @param {number} [options.rotation] - Screen angle rotaion.
     * @param {Vec4|string|Array.<number>} [options.color] - Billboard color.
     * @param {Vec3|Array.<number>} [options.alignedAxis] - Billboard aligned vector.
     * @param {Vec3|Array.<number>} [options.offset] - Billboard center screen offset.
     * @param {boolean} [options.visibility] - Visibility.
     */
    class BaseBillboard {
        constructor(options) {
            options = options || {};

            /**
             * Object unic identifier.
             * @public
             * @readonly
             * @type {number}
             */
            this.id = BaseBillboard._staticCounter++;

            /**
             * Billboard center cartesian position.
             * @protected
             * @type {Vec3}
             */
            this._position = createVector3(options.position);

            this._positionHigh = new Vec3();

            this._positionLow = new Vec3();

            Vec3.doubleToTwoFloats(this._position, this._positionHigh, this._positionLow);

            /**
             * Screen space rotation angle.
             * @protected
             * @type {number}
             */
            this._rotation = options.rotation || 0;

            /**
             * RGBA color.
             * @protected
             * @type {Vec4}
             */
            this._color = createColorRGBA(options.color);

            /**
             * Cartesian aligned axis vector.
             * @protected
             * @type {Vec3}
             */
            this._alignedAxis = createVector3(options.alignedAxis);

            /**
             * Billboard center screen space offset. Where x,y - screen space offset and z - depth offset.
             * @protected
             * @type {math.Vecto3}
             */
            this._offset = createVector3(options.offset);

            /**
             * Billboard visibility.
             * @protected
             * @type {boolean}
             */
            this._visibility = options.visibility != undefined ? options.visibility : true;

            /**
             * Entity instance that holds this billboard.
             * @protected
             * @type {Entity}
             */
            this._entity = null;

            /**
             * Handler that stores and renders this billboard object.
             * @protected
             * @type {BillboardHandler}
             */
            this._handler = null;

            /**
             * Billboard handler array index.
             * @protected
             * @type {number}
             */
            this._handlerIndex = -1;

            /**
             * An indication that the object is ready to draw
             * @protected
             * @type {number}
             */
            this._isReady = false;

            this._lockId = LOCK_FREE;
        }

        static get _staticCounter() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set _staticCounter(n) {
            this._counter = n;
        }

        /**
         * Sets billboard position.
         * @public
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         * @param {number} z - Z coordinate.
         */
        setPosition(x, y, z) {
            this._position.x = x;
            this._position.y = y;
            this._position.z = z;
            Vec3.doubleToTwoFloats(this._position, this._positionHigh, this._positionLow);
            if (this._isReady && this._handler) {
                this._handler.setPositionArr(this._handlerIndex, this._positionHigh, this._positionLow);
            } else if (this._lockId !== LOCK_FREE) {
                this._lockId = LOCK_UPDATE;
            }
        }

        /**
         * Sets billboard position.
         * @public
         * @param {Vec3} position - Cartesian coordinates.
         */
        setPosition3v(position) {
            this._position.x = position.x;
            this._position.y = position.y;
            this._position.z = position.z;
            Vec3.doubleToTwoFloats(position, this._positionHigh, this._positionLow);
            if (this._isReady && this._handler) {
                this._handler.setPositionArr(this._handlerIndex, this._positionHigh, this._positionLow);
            } else if (this._lockId !== LOCK_FREE) {
                this._lockId = LOCK_UPDATE;
            }
        }

        /**
         * Returns billboard position.
         * @public
         * @returns {Vec3}
         */
        getPosition() {
            return this._position;
        }

        /**
         * Sets screen space offset.
         * @public
         * @param {number} x - X offset.
         * @param {number} y - Y offset.
         * @param {number} [z] - Z offset.
         */
        setOffset(x, y, z) {
            this._offset.x = x;
            this._offset.y = y;
            z != undefined && (this._offset.z = z);
            if (this._isReady && this._handler) {
                this._handler.setOffsetArr(this._handlerIndex, this._offset);
            } else if (this._lockId !== LOCK_FREE) {
                this._lockId = LOCK_UPDATE;
            }
        }

        /**
         * Sets screen space offset.
         * @public
         * @param {Vec2} offset - Offset size.
         */
        setOffset3v(offset) {
            this.setOffset(offset.x, offset.y, offset.z);
        }

        /**
         * Returns billboard screen space offset size.
         * @public
         * @returns {Vec3}
         */
        getOffset() {
            return this._offset;
        }

        /**
         * Sets billboard screen space rotation in radians.
         * @public
         * @param {number} rotation - Screen space rotation in radians.
         */
        setRotation(rotation) {
            if (rotation !== this._rotation) {
                this._rotation = rotation;
                if (this._isReady && this._handler) {
                    this._handler.setRotationArr(this._handlerIndex, rotation);
                } else if (this._lockId !== LOCK_FREE) {
                    this._lockId = LOCK_UPDATE;
                }
            }
        }

        /**
         * Gets screen space rotation.
         * @public
         * @returns {number}
         */
        getRotation() {
            return this._rotation;
        }

        /**
         * Sets billboard opacity.
         * @public
         * @param {number} a - Billboard opacity.
         */
        setOpacity(a) {
            if (a !== this._color.w) {
                a != undefined && (this._color.w = a);
                if (this._isReady && this._handler) {
                    this._handler.setRgbaArr(this._handlerIndex, this._color);
                } else if (this._lockId !== LOCK_FREE) {
                    this._lockId = LOCK_UPDATE;
                }
            }
        }

        /**
         * Sets RGBA color. Each channel from 0.0 to 1.0.
         * @public
         * @param {number} r - Red.
         * @param {number} g - Green.
         * @param {number} b - Blue.
         * @param {number} a - Alpha.
         */
        setColor(r, g, b, a) {
            if (a !== this._color.w || r !== this._color.x || g !== this._color.y || this._color.z !== b) {
                this._color.x = r;
                this._color.y = g;
                this._color.z = b;
                a != undefined && (this._color.w = a);
                if (this._isReady && this._handler) {
                    this._handler.setRgbaArr(this._handlerIndex, this._color);
                } else if (this._lockId !== LOCK_FREE) {
                    this._lockId = LOCK_UPDATE;
                }
            }
        }

        /**
         * Sets RGBA color. Each channel from 0.0 to 1.0.
         * @public
         * @param {Vec4} color - RGBA vector.
         */
        setColor4v(color) {
            this.setColor(color.x, color.y, color.z, color.w);
        }

        /**
         * Sets billboard color.
         * @public
         * @param {string} color - HTML style color.
         */
        setColorHTML(color) {
            this.setColor4v(htmlColorToRgba(color));
        }

        /**
         * Returns RGBA color.
         * @public
         * @returns {Vec4}
         */
        getColor() {
            return this._color;
        }

        /**
         * Sets billboard visibility.
         * @public
         * @param {boolean} visibility - Visibility flag.
         */
        setVisibility(visibility) {
            if (visibility !== this._visibility) {
                this._visibility = visibility;
                if (this._isReady && this._handler) {
                    this._handler.setVisibility(this._handlerIndex, visibility);
                } else if (this._lockId !== LOCK_FREE) {
                    this._lockId = LOCK_UPDATE;
                }
            }
        }

        /**
         * Returns billboard visibility.
         * @public
         * @returns {boolean}
         */
        getVisibility() {
            return this._visibility;
        }

        /**
         * Sets billboard cartesian aligned vector.
         * @public
         * @param {number} x - Aligned vector X coordinate.
         * @param {number} y - Aligned vector Y coordinate.
         * @param {number} z - Aligned vector Z coordinate.
         */
        setAlignedAxis(x, y, z) {
            this._alignedAxis.x = x;
            this._alignedAxis.y = y;
            this._alignedAxis.z = z;
            if (this._isReady && this._handler) {
                this._handler.setAlignedAxisArr(this._handlerIndex, this._alignedAxis);
            } else if (this._lockId !== LOCK_FREE) {
                this._lockId = LOCK_UPDATE;
            }
        }

        /**
         * Sets billboard aligned vector.
         * @public
         * @param {math.Vecto3} alignedAxis - Vector to align.
         */
        setAlignedAxis3v(alignedAxis) {
            this.setAlignedAxis(alignedAxis.x, alignedAxis.y, alignedAxis.z);
        }

        /**
         * Returns aligned vector.
         * @public
         * @returns {Vec3}
         */
        getAlignedAxis() {
            return this._alignedAxis;
        }

        /**
         * Removes billboard from hander.
         * @public
         */
        remove() {
            this._entity = null;
            this._handler && this._handler.remove(this);
        }

        /**
         * Sets billboard picking color.
         * @public
         * @param {Vec3} color - Picking color.
         */
        setPickingColor3v(color) {
            if (this._isReady && this._handler) {
                this._handler.setPickingColorArr(this._handlerIndex, color);
            } else if (this._lockId !== LOCK_FREE) {
                this._lockId = LOCK_UPDATE;
            }
        }
    }

    /**
     * @module og/entity/Billboard
     */

    /**
     * Represents basic quad billboard image.
     * @class
     * @extends {BaseBillboard}
     * @param {Object} [options] - Options:
     * @param {Vec3|Array.<number>} [options.position] - Billboard spatial position.
     * @param {number} [options.rotation] - Screen angle rotaion.
     * @param {Vec4|string|Array.<number>} [options.color] - Billboard color.
     * @param {Vec3|Array.<number>} [options.alignedAxis] - Billboard aligned vector.
     * @param {Vec3|Array.<number>} [options.offset] - Billboard center screen offset.
     * @param {boolean} [options.visibility] - Visibility.
     * @param {string} [options.src] - Billboard image url source.
     * @param {Image} [options.image] - Billboard image object.
     * @param {number} [options.width] - Screen width.
     * @param {number} [options.height] - Screen height.
     * @param {number} [options.scale] - Billboard scale.
     */
    class Billboard extends BaseBillboard {
        constructor(options) {
            super(options);

            options = options || {};

            /**
             * Image src.
             * @protected
             * @type {string}
             */
            this._src = options.src || null;

            /**
             * Image object.
             * @protected
             * @type {Object}
             */
            this._image = options.image || null;

            this._scale = 1.0;

            /**
             * Billboard screen width.
             * @protected
             * @type {number}
             */
            this._width = options.width || (options.size ? options.size[0] : 30);

            /**
             * Billboard screen height.
             * @protected
             * @type {number}
             */
            this._height = options.height || (options.size ? options.size[1] : 30);
        }

        /**
         * Sets billboard image url source.
         * @public
         * @param {string} src - Image url.
         */
        setSrc(src) {
            this._src = src;
            var bh = this._handler;
            if (bh && src) {
                var rn = bh._entityCollection.renderNode;
                if (rn) {
                    var ta = rn.renderer.billboardsTextureAtlas;
                    var that = this;
                    ta.loadImage(src, function (img) {
                        if (ta.get(img.__nodeIndex)) {
                            that._image = img;
                            bh.setTexCoordArr(
                                that._handlerIndex,
                                ta.get(that._image.__nodeIndex).texCoords
                            );
                        } else {
                            ta.addImage(img);
                            ta.createTexture();
                            that._image = img;
                            rn.updateBillboardsTexCoords();
                        }
                    });
                }
            }
        }

        /**
         * Sets image object.
         * @public
         * @param {Object} image - JavaScript image object.
         */
        setImage(image) {
            this.setSrc(image.src);
        }

        /**
         * Sets billboard screen size in pixels.
         * @public
         * @param {number} width - Billboard width.
         * @param {number} height - Billboard height.
         */
        setSize(width, height) {
            this._width = width;
            this._height = height;
            this._handler &&
                this._handler.setSizeArr(this._handlerIndex, width * this._scale, height * this._scale);
        }

        /**
         * Returns billboard screen size.
         * @public
         * @returns {Object}
         */
        getSize() {
            return {
                width: this._width,
                height: this._height
            };
        }

        /**
         * Sets billboard screen width.
         * @public
         * @param {number} width - Width.
         */
        setWidth(width) {
            this.setSize(width, this._height);
        }

        /**
         * Gets billboard screen width.
         * @public
         * @returns {number}
         */
        getWidth() {
            return this._width;
        }

        /**
         * Sets billboard screen heigh.
         * @public
         * @param {number} height - Height.
         */
        setHeight(height) {
            this.setSize(this._width, height);
        }

        /**
         * Gets billboard screen height.
         * @public
         * @returns {number}
         */
        getHeight() {
            return this._height;
        }
    }

    class Line3 {
        constructor(p0, p1) {
            this.p0 = p0 || new Vec3();
            this.p1 = p1 || new Vec3();
        }

        getMagnitude() {
            return this.p0.distance(this.p1);
        }

        getSphereIntersection(sphere) {
            var p0 = this.p0,
                p1 = this.p1;

            var cx = sphere.x,
                cy = sphere.y,
                cz = sphere.z;

            var px = p0.x,
                py = p0.y,
                pz = p0.z;

            var vx = p1.x - px,
                vy = p1.y - py,
                vz = p1.z - pz;

            var A = vx * vx + vy * vy + vz * vz,
                B = 2.0 * (px * vx + py * vy + pz * vz - vx * cx - vy * cy - vz * cz),
                C = px * px - 2 * px * cx + cx * cx + py * py - 2 * py * cy + cy * cy +
                    pz * pz - 2 * pz * cz + cz * cz - sphere.radius * sphere.radius;
            var D = B * B - 4 * A * C;

            if (D < 0) {
                return null;
            }

            var t1 = (-B - Math.Sqrt(D)) / (2.0 * A);

            var solution1 = new Vec3(
                p0.x * (1 - t1) + t1 * p1.x,
                p0.y * (1 - t1) + t1 * p1.y,
                p0.z * (1 - t1) + t1 * p1.z);

            if (D == 0) {
                return solution1;
            }

            var t2 = (-B + Math.Sqrt(D)) / (2.0 * A);
            var solution2 = new Vec3(
                p0.x * (1 - t2) + t2 * p1.x,
                p0.y * (1 - t2) + t2 * p1.y,
                p0.z * (1 - t2) + t2 * p1.z);

            // prefer a solution that's on the line segment itself
            if (Math.Abs(t1 - 0.5) < Math.abs(t2 - 0.5)) {
                return [solution1, solution2];
            }

            return [solution2, solution1];
        }

        intersects(line, res, res2) {

            let p13 = this.p0.sub(line.p0),
                p43 = line.p1.sub(line.p0);

            if (Math.abs(p43.x) < EPSILON10 && Math.abs(p43.y) < EPSILON10 && Math.abs(p43.z) < EPSILON10) {
                return false;
            }

            let p21 = this.p1.sub(this.p0);

            if (Math.abs(p21.x) < EPSILON10 && Math.abs(p21.y) < EPSILON10 && Math.abs(p21.z) < EPSILON10) {
                return false;
            }

            let d1343 = p13.x * p43.x + p13.y * p43.y + p13.z * p43.z,
                d4321 = p43.x * p21.x + p43.y * p21.y + p43.z * p21.z,
                d1321 = p13.x * p21.x + p13.y * p21.y + p13.z * p21.z,
                d4343 = p43.x * p43.x + p43.y * p43.y + p43.z * p43.z,
                d2121 = p21.x * p21.x + p21.y * p21.y + p21.z * p21.z;

            let denom = d2121 * d4343 - d4321 * d4321;

            if (Math.abs(denom) < EPSILON10) {
                return false;
            }

            let numer = d1343 * d4321 - d1321 * d4343;

            let mua = numer / denom;

            res.x = this.p0.x + mua * p21.x;
            res.y = this.p0.y + mua * p21.y;
            res.z = this.p0.z + mua * p21.z;

            if (res2) {

                let mub = (d1343 + d4321 * mua) / d4343;

                res2.x = line.p0.x + mub * p43.x;
                res2.y = line.p0.y + mub * p43.y;
                res2.z = line.p0.z + mub * p43.z;
            }

            return true;
        }

        getNearestDistancePoint(point, res) {

            let p0 = this.p0,
                p1 = this.p1;

            let mag = this.getMagnitude();

            let u =
                (
                    ((point.x - p0.x) * (p1.x - p0.x)) +
                    ((point.y - p0.y) * (p1.y - p0.y)) +
                    ((point.z - p0.z) * (p1.z - p0.z))
                ) /
                (mag * mag);

            res.x = p0.x + u * (p1.x - p0.x);
            res.y = p0.y + u * (p1.y - p0.y);
            res.z = p0.z + u * (p1.z - p0.z);

            if (u < 0.0 || u > 1.0) {
                return false;
            }

            return true;
        }

    }

    let _tempHigh$3 = new Vec3(),
        _tempLow$3 = new Vec3();

    /**
     * Strip object.
     * @class
     * @param {*} [options] - Strip options:
     * @param {boolean} [options.visibility] - Strip visibility.
     * @example <caption>Stripe example</caption>
     * new og.Entity({
     *     strip: {
     *         gridSize: 10,
     *         path: [
     *             [[],[]],
     *             [[],[]]
     *         ]
     *     }
     * });
     */
    class Strip {
        constructor(options) {
            options = options || {};

            /**
             * Object unic identifier.
             * @public
             * @readonly
             * @type {number}
             */
            this.id = Strip._staticCounter++;

            /**
             * Cloud visibility.
             * @public
             * @type {boolean}
             */
            this.visibility = options.visibility != undefined ? options.visibility : true;

            this.color = new Float32Array([1.0, 1.0, 1.0, 0.5]);

            if (options.color) {
                let color = createColorRGBA(options.color);
                this.setColor(color.x, color.y, color.z, color.w);
            }

            if (options.opacity) {
                this.setOpacity(options.opacity);
            }

            /**
             * Parent collection render node.
             * @private
             * @type {RenderNode}
             */
            this._renderNode = null;

            /**
             * Entity instance that holds this strip.
             * @private
             * @type {Entity}
             */
            this._entity = null;

            this._verticesHighBuffer = null;
            this._verticesLowBuffer = null;

            this._indexesBuffer = null;

            this._verticesHigh = [];
            this._verticesLow = [];

            this._indexes = [];

            this._path = [];

            this._pickingColor = new Float32Array(4);

            this._gridSize = 1;

            /**
             * Handler that stores and renders this object.
             * @private
             * @type {StripHandler}
             */
            this._handler = null;
            this._handlerIndex = -1;

            if (options.path) {
                this.setPath(options.path);
            }
        }

        static get _staticCounter() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set _staticCounter(n) {
            this._counter = n;
        }

        /**
         * Assign picking color.
         * @protected
         * @param {Vec3} color - Picking RGB color.
         */
        setPickingColor3v(color) {
            this._pickingColor[0] = color.x / 255.0;
            this._pickingColor[1] = color.y / 255.0;
            this._pickingColor[2] = color.z / 255.0;
            this._pickingColor[3] = 1.0;
        }

        /**
         * Clears object
         * @public
         */
        clear() {
            this._path.length = 0;
            this._path = [];

            this._verticesHigh.length = 0;
            this._verticesHigh = [];

            this._verticesLow.length = 0;
            this._verticesLow = [];

            this._indexes.length = 0;
            this._indexes = [];

            this._deleteBuffers();
        }

        setColor(r, g, b, a) {
            a = a || this.color[3];
            this.color[0] = r;
            this.color[1] = g;
            this.color[2] = b;
            this.color[3] = a;
        }

        /**
         * Set strip opacity.
         * @public
         * @param {number} opacity - opacity.
         */
        setOpacity(opacity) {
            this.color[3] = opacity || 0;
        }

        /**
         * Sets cloud visibility.
         * @public
         * @param {number} visibility - Visibility flag.
         */
        setVisibility(visibility) {
            this.visibility = visibility;
        }

        /**
         * @return {boolean} Strip visibily.
         */
        getVisibility() {
            return this.visibility;
        }

        /**
         * Assign rendering scene node.
         * @public
         * @param {RenderNode}  renderNode - Assigned render node.
         */
        setRenderNode(renderNode) {
            this._renderNode = renderNode;
            this._createBuffers();
        }

        /**
         * Removes from entity.
         * @public
         */
        remove() {
            this._entity = null;
            this._handler && this._handler.remove(this);
        }

        draw() {
            if (this.visibility && this._verticesHigh.length) {
                var r = this._renderNode.renderer;

                var gl = r.handler.gl;

                var sh = r.handler.programs.strip,
                    p = sh._program,
                    sha = p.attributes,
                    shu = p.uniforms;

                gl.disable(gl.CULL_FACE);
                gl.blendEquation(gl.FUNC_ADD);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                gl.enable(gl.BLEND);
                sh.activate();

                gl.uniformMatrix4fv(shu.viewMatrix, false, r.activeCamera.getViewMatrix());
                gl.uniformMatrix4fv(shu.projectionMatrix, false, r.activeCamera.getProjectionMatrix());

                gl.uniform3fv(shu.eyePositionHigh, r.activeCamera.eyeHigh);
                gl.uniform3fv(shu.eyePositionLow, r.activeCamera.eyeLow);

                gl.uniform4fv(shu.uColor, this.color);
                gl.uniform1f(shu.uOpacity, this._entity._entityCollection._fadingOpacity);
                gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesHighBuffer);
                gl.vertexAttribPointer(
                    sha.aVertexPositionHigh,
                    this._verticesHighBuffer.itemSize,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesLowBuffer);
                gl.vertexAttribPointer(
                    sha.aVertexPositionLow,
                    this._verticesLowBuffer.itemSize,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
                gl.drawElements(
                    r.handler.gl.TRIANGLE_STRIP,
                    this._indexBuffer.numItems,
                    gl.UNSIGNED_INT,
                    0
                );
                gl.enable(gl.CULL_FACE);
            }
        }

        drawPicking() {
            if (this.visibility && this._verticesHigh.length) {
                var r = this._renderNode.renderer;

                var gl = r.handler.gl;

                var sh = r.handler.programs.strip,
                    p = sh._program,
                    sha = p.attributes,
                    shu = p.uniforms;

                gl.disable(gl.CULL_FACE);
                gl.blendEquation(gl.FUNC_ADD);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                gl.enable(gl.BLEND);
                sh.activate();

                gl.uniformMatrix4fv(shu.viewMatrix, false, r.activeCamera.getViewMatrix());
                gl.uniformMatrix4fv(shu.projectionMatrix, false, r.activeCamera.getProjectionMatrix());

                gl.uniform3fv(shu.eyePositionHigh, r.activeCamera.eyeHigh);
                gl.uniform3fv(shu.eyePositionLow, r.activeCamera.eyeLow);
                gl.uniform1f(shu.uOpacity, this._entity._entityCollection._fadingOpacity != 0 ? 1 : 0);

                gl.uniform4fv(shu.uColor, this._pickingColor);
                gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesHighBuffer);
                gl.vertexAttribPointer(
                    sha.aVertexPositionHigh,
                    this._verticesHighBuffer.itemSize,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesLowBuffer);
                gl.vertexAttribPointer(
                    sha.aVertexPositionLow,
                    this._verticesLowBuffer.itemSize,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
                gl.drawElements(
                    r.handler.gl.TRIANGLE_STRIP,
                    this._indexBuffer.numItems,
                    gl.UNSIGNED_INT,
                    0
                );
                gl.enable(gl.CULL_FACE);
            }
        }

        /**
         * Delete buffers
         * @private
         */
        _deleteBuffers() {
            if (this._renderNode && this._renderNode.renderer) {
                var r = this._renderNode.renderer,
                    gl = r.handler.gl;

                gl.deleteBuffer(this._indexBuffer);
                gl.deleteBuffer(this._verticesHighBuffer);
                gl.deleteBuffer(this._verticesLowBuffer);
            }
            this._verticesHighBuffer = null;
            this._verticesLowBuffer = null;
            this._indexBuffer = null;
        }

        _createBuffers() {
            if (this._renderNode && this._renderNode.renderer) {
                var gl = this._renderNode.renderer.handler.gl;

                gl.deleteBuffer(this._indexBuffer);
                gl.deleteBuffer(this._verticesHighBuffer);
                gl.deleteBuffer(this._verticesLowBuffer);

                this._verticesHighBuffer = this._renderNode.renderer.handler.createArrayBuffer(
                    new Float32Array(this._verticesHigh),
                    3,
                    this._verticesHigh.length / 3
                );
                this._verticesLowBuffer = this._renderNode.renderer.handler.createArrayBuffer(
                    new Float32Array(this._verticesLow),
                    3,
                    this._verticesLow.length / 3
                );
                this._indexBuffer = this._renderNode.renderer.handler.createElementArrayBuffer(
                    new Uint32Array(this._indexes),
                    1,
                    this._indexes.length
                );
            }
        }

        addEdge3v(p2, p3) {
            let length = this._path.length;

            if (length === 0) {
                this._path.push([p2.clone(), p3.clone()]);
            } else {
                let p0 = this._path[length - 1][0],
                    p1 = this._path[length - 1][1];

                this._path.push([p2.clone(), p3.clone()]);

                let vHigh = this._verticesHigh,
                    vLow = this._verticesLow;

                let gs = this._gridSize,
                    gs1 = gs + 1;

                let p = new Vec3();

                let last = this._verticesHigh.length / 3,
                    ind = last;

                let d = Math.abs(p0.sub(p1).normal().dot(p2.sub(p0).normal()));

                for (let i = 0; i < gs1; i++) {
                    let di = i / gs;
                    let p02 = p0.lerp(p2, di),
                        p13 = p1.lerp(p3, di);

                    for (let j = 0; j < gs1; j++) {
                        let dj = j / gs;
                        let p01 = p0.lerp(p1, dj),
                            p23 = p2.lerp(p3, dj);

                        if (d !== 1.0) {
                            new Line3(p02, p13).intersects(new Line3(p01, p23), p);
                        } else {
                            p = p23;
                        }

                        ind = last + i * gs1 + j;

                        Vec3.doubleToTwoFloats(p, _tempHigh$3, _tempLow$3);

                        let ind3 = ind * 3;

                        vHigh[ind3] = _tempHigh$3.x;
                        vHigh[ind3 + 1] = _tempHigh$3.y;
                        vHigh[ind3 + 2] = _tempHigh$3.z;

                        vLow[ind3] = _tempLow$3.x;
                        vLow[ind3 + 1] = _tempLow$3.y;
                        vLow[ind3 + 2] = _tempLow$3.z;

                        if (i < gs) {
                            this._indexes.push(ind, ind + gs1);
                        }
                    }

                    if (i < gs) {
                        this._indexes.push(ind + gs1, ind + 1);
                    }
                }

                this._createBuffers();
            }
        }

        setEdge3v(p2, p3, index) {
            if (index === this._path.length) {
                this.addEdge3v(p2, p3);
                return;
            }
            if (this._path[index]) {
                this._path[index][0] = p2;
                this._path[index][1] = p3;

                if (this._path.length > 1) {
                    let gs = this._gridSize,
                        gs1 = gs + 1;

                    let vSize = gs1 * gs1;

                    let p = new Vec3();

                    let vHigh = this._verticesHigh,
                        vLow = this._verticesLow;

                    if (index === this._path.length - 1) {
                        let p0 = this._path[index - 1][0],
                            p1 = this._path[index - 1][1];

                        let prev = this._verticesHigh.length / 3 - vSize,
                            ind = prev;

                        let d = Math.abs(p0.sub(p1).normal().dot(p2.sub(p0).normal()));

                        for (let i = 0; i < gs1; i++) {
                            let di = i / gs;
                            let p02 = p0.lerp(p2, di),
                                p13 = p1.lerp(p3, di);

                            for (let j = 0; j < gs1; j++) {
                                let dj = j / gs;
                                let p01 = p0.lerp(p1, dj),
                                    p23 = p2.lerp(p3, dj);

                                if (d !== 1.0) {
                                    new Line3(p02, p13).intersects(new Line3(p01, p23), p);
                                } else {
                                    p = p23;
                                }

                                ind = prev + i * gs1 + j;

                                Vec3.doubleToTwoFloats(p, _tempHigh$3, _tempLow$3);

                                let ind3 = ind * 3;

                                vHigh[ind3] = _tempHigh$3.x;
                                vHigh[ind3 + 1] = _tempHigh$3.y;
                                vHigh[ind3 + 2] = _tempHigh$3.z;

                                vLow[ind3] = _tempLow$3.x;
                                vLow[ind3 + 1] = _tempLow$3.y;
                                vLow[ind3 + 2] = _tempLow$3.z;
                            }
                        }
                    } else if (index === 0) {
                        let ind = 0;

                        let p0 = p2,
                            p1 = p3;

                        p2 = this._path[1][0];
                        p3 = this._path[1][1];

                        for (let i = 0; i < gs1; i++) {
                            let di = i / gs;
                            let p02 = p0.lerp(p2, di),
                                p13 = p1.lerp(p3, di);

                            for (let j = 0; j < gs1; j++) {
                                let dj = j / gs;
                                let p01 = p0.lerp(p1, dj),
                                    p23 = p2.lerp(p3, dj);

                                new Line3(p02, p13).intersects(new Line3(p01, p23), p);

                                ind = i * gs1 + j;

                                Vec3.doubleToTwoFloats(p, _tempHigh$3, _tempLow$3);

                                let ind3 = ind * 3;

                                vHigh[ind3] = _tempHigh$3.x;
                                vHigh[ind3 + 1] = _tempHigh$3.y;
                                vHigh[ind3 + 2] = _tempHigh$3.z;

                                vLow[ind3] = _tempLow$3.x;
                                vLow[ind3 + 1] = _tempLow$3.y;
                                vLow[ind3 + 2] = _tempLow$3.z;
                            }
                        }
                    } else if (index > 0 && index < this._path.length) {
                        let p0 = this._path[index - 1][0],
                            p1 = this._path[index - 1][1];

                        let p4 = this._path[index + 1][0],
                            p5 = this._path[index + 1][1];

                        let next = index * vSize,
                            prev = (index - 1) * vSize,
                            ind = prev;

                        for (let i = 0; i < gs1; i++) {
                            let di = i / gs;
                            let p02 = p0.lerp(p2, di),
                                p35 = p3.lerp(p5, di),
                                p24 = p2.lerp(p4, di),
                                p13 = p1.lerp(p3, di);

                            for (let j = 0; j < gs1; j++) {
                                let dj = j / gs;
                                let p01 = p0.lerp(p1, dj),
                                    p23 = p2.lerp(p3, dj);

                                // prev
                                new Line3(p02, p13).intersects(new Line3(p01, p23), p);

                                let ij = i * gs1 + j;

                                ind = prev + ij;

                                Vec3.doubleToTwoFloats(p, _tempHigh$3, _tempLow$3);

                                let ind3 = ind * 3;

                                vHigh[ind3] = _tempHigh$3.x;
                                vHigh[ind3 + 1] = _tempHigh$3.y;
                                vHigh[ind3 + 2] = _tempHigh$3.z;

                                vLow[ind3] = _tempLow$3.x;
                                vLow[ind3 + 1] = _tempLow$3.y;
                                vLow[ind3 + 2] = _tempLow$3.z;

                                // next
                                let p45 = p4.lerp(p5, dj);

                                p23 = p2.lerp(p3, dj);

                                new Line3(p24, p35).intersects(new Line3(p23, p45), p);

                                ind = next + ij;

                                Vec3.doubleToTwoFloats(p, _tempHigh$3, _tempLow$3);

                                ind3 = ind * 3;

                                vHigh[ind3] = _tempHigh$3.x;
                                vHigh[ind3 + 1] = _tempHigh$3.y;
                                vHigh[ind3 + 2] = _tempHigh$3.z;

                                vLow[ind3] = _tempLow$3.x;
                                vLow[ind3 + 1] = _tempLow$3.y;
                                vLow[ind3 + 2] = _tempLow$3.z;
                            }
                        }
                    }

                    this._createBuffers();
                }
            } else {
                console.warn(`strip index ${index} is out of range`);
            }
        }

        removeEdge(index) {
            this._path.splice(index, 1);
            this.setPath([].concat(this._path));
        }

        setGridSize(gridSize) {
            this._gridSize = gridSize;
            this.setPath([].concat(this._path));
        }

        getPath() {
            return this._path;
        }

        setPath(path) {
            this._verticesHigh = [];
            this._verticesLow = [];
            this._indexes = [];
            this._path = [];

            for (let i = 0; i < path.length; i++) {
                let p0 = path[i][0],
                    p1 = path[i][1];

                if (p0 instanceof Array) {
                    p0 = new Vec3(p0[0], p0[1], p0[2]);
                }

                if (p1 instanceof Array) {
                    p1 = new Vec3(p1[0], p1[1], p1[2]);
                }

                this.addEdge3v(p0, p1);
            }
        }

        insertEdge3v(p0, p1, index) {
            if (index < this._path.length) {
                let p = [].concat(this._path);
                p.splice(index, 0, [p0, p1]);
                this.setPath(p);
            } else if (index === this._path.length) {
                this.addEdge3v(p0, p1);
            }
        }
    }

    /**
     * @module og/entity/Geometry
     */

    const GeometryType = {
        POINT: 1,
        LINESTRING: 2,
        POLYGON: 3,
        MULTIPOLYGON: 4,
        MULTILINESTRING: 5
    };

    class Geometry {
        constructor(options) {
            this._id = Geometry._staticCounter++;

            options = options || {};
            options.style = options.style || {};

            /**
             * Entity instance that holds this geometry.
             * @protected
             * @type {Entity}
             */
            this._entity = null;

            this._handler = null;
            this._handlerIndex = -1;

            // Polygon
            this._polyVerticesHighMerc = [];
            this._polyVerticesLowMerc = [];
            this._polyVerticesLength = -1;
            this._polyIndexesLength = -1;
            this._polyVerticesHandlerIndex = -1;
            this._polyIndexesHandlerIndex = -1;

            // Line(Linestring and polygon's stroke(s)
            this._lineVerticesHighMerc = [];
            this._lineVerticesLowMerc = [];
            this._lineVerticesLength = -1;
            this._lineOrdersLength = -1;
            this._lineIndexesLength = -1;
            this._lineColorsLength = -1;
            this._lineThicknessLength = -1;
            this._lineVerticesHandlerIndex = -1;
            this._lineOrdersHandlerIndex = -1;
            this._lineIndexesHandlerIndex = -1;
            this._lineThicknessHandlerIndex = -1;
            this._lineColorsHandlerIndex = -1;

            this._type = (options.type && Geometry.getType(options.type)) || GeometryType.POINT;
            this._coordinates = [];
            this._extent = Geometry.getExtent(
                {
                    type: options.type || "Point",
                    coordinates: options.coordinates || []
                },
                this._coordinates
            );

            this._style = options.style || {};
            this._style.fillColor = createColorRGBA(
                options.style.fillColor,
                new Vec4(0.19, 0.62, 0.85, 0.4)
            );
            this._style.lineColor = createColorRGBA(
                options.style.lineColor,
                new Vec4(0.19, 0.62, 0.85, 1)
            );
            this._style.strokeColor = createColorRGBA(
                options.style.strokeColor,
                new Vec4(1, 1, 1, 0.95)
            );
            this._style.lineWidth = options.style.lineWidth || 3;
            this._style.strokeWidth = options.style.strokeWidth || 0;

            this._visibility = options.visibility || true;

            // optimization flag for picking mask rendering pass
            this._pickingReady = false;
        }

        static get _staticCounter() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set _staticCounter(n) {
            this._counter = n;
        }

        static getType(typeStr) {
            return GeometryType[typeStr.toUpperCase()];
        }

        /**
         * Returns geometry feature extent.
         @static
         @param {Object} geometryObj - GeoJSON style geometry feature.
         @param {LonLat[]} outCoordinates - Geometry feature coordinates clone.
         @returns {Extent} -
         */
        static getExtent(geometryObj, outCoordinates) {
            var res = new Extent(new LonLat(180.0, 90.0), new LonLat(-180.0, -90.0));
            var t = Geometry.getType(geometryObj.type);

            if (t === GeometryType.POINT) {
                let lon = res.coordinates[0],
                    lat = res.coordinates[1];
                res.southWest.lon = lon;
                res.southWest.lat = lat;
                res.northEast.lon = lon;
                res.northEast.lat = lat;
                outCoordinates && (outCoordinates[0] = lon) && (outCoordinates[1] = lat);
            } else if (t === GeometryType.LINESTRING) {
                let c = geometryObj.coordinates;
                for (let i = 0; i < c.length; i++) {
                    let lon = c[i][0],
                        lat = c[i][1];
                    if (lon < res.southWest.lon) res.southWest.lon = lon;
                    if (lat < res.southWest.lat) res.southWest.lat = lat;
                    if (lon > res.northEast.lon) res.northEast.lon = lon;
                    if (lat > res.northEast.lat) res.northEast.lat = lat;
                    outCoordinates && (outCoordinates[i] = [lon, lat]);
                }
            } else if (t === GeometryType.POLYGON) {
                let c = geometryObj.coordinates;
                for (let i = 0; i < c.length; i++) {
                    let ci = c[i];
                    outCoordinates && (outCoordinates[i] = []);
                    for (let j = 0; j < ci.length; j++) {
                        let cij = ci[j];
                        let lon = cij[0],
                            lat = cij[1];
                        if (lon < res.southWest.lon) res.southWest.lon = lon;
                        if (lat < res.southWest.lat) res.southWest.lat = lat;
                        if (lon > res.northEast.lon) res.northEast.lon = lon;
                        if (lat > res.northEast.lat) res.northEast.lat = lat;
                        outCoordinates && (outCoordinates[i][j] = [lon, lat]);
                    }
                }
            } else if (t === GeometryType.MULTIPOLYGON) {
                let p = geometryObj.coordinates;
                for (let i = 0; i < p.length; i++) {
                    let pi = p[i];
                    outCoordinates && (outCoordinates[i] = []);
                    for (let j = 0; j < pi.length; j++) {
                        let pij = pi[j];
                        outCoordinates && (outCoordinates[i][j] = []);
                        for (let k = 0; k < pij.length; k++) {
                            let pijk = pij[k];
                            let lon = pijk[0],
                                lat = pijk[1];
                            if (lon < res.southWest.lon) res.southWest.lon = lon;
                            if (lat < res.southWest.lat) res.southWest.lat = lat;
                            if (lon > res.northEast.lon) res.northEast.lon = lon;
                            if (lat > res.northEast.lat) res.northEast.lat = lat;
                            outCoordinates && (outCoordinates[i][j][k] = [lon, lat]);
                        }
                    }
                }
            } else if (t === GeometryType.MULTILINESTRING) {
                let c = geometryObj.coordinates;
                for (let i = 0; i < c.length; i++) {
                    let ci = c[i];
                    outCoordinates && (outCoordinates[i] = []);
                    for (let j = 0; j < ci.length; j++) {
                        let cij = ci[j];
                        let lon = cij[0],
                            lat = cij[1];
                        if (lon < res.southWest.lon) res.southWest.lon = lon;
                        if (lat < res.southWest.lat) res.southWest.lat = lat;
                        if (lon > res.northEast.lon) res.northEast.lon = lon;
                        if (lat > res.northEast.lat) res.northEast.lat = lat;
                        outCoordinates && (outCoordinates[i][j] = [lon, lat]);
                    }
                }
            } else {
                res.southWest.lon = res.southWest.lat = res.northEast.lon = res.northEast.lat = 0.0;
                outCoordinates && (outCoordinates[0] = 0) && (outCoordinates[1] = 0);
            }
            return res;
        }

        setGeometry(geoJson) {
            var h = this._handler;
            this.remove();
            this._type = Geometry.getType(geoJson.type || "Point");
            this._extent = Geometry.getExtent(geoJson, this._coordinates);
            h.add(this);
            return this;
        }

        setFillColor(r, g, b, a) {
            var c = this._style.fillColor;
            if ((c.w === 0.0 && a !== 0.0) || (c.w !== 0.0 && a === 0.0)) {
                this._pickingReady = false;
            }
            c.x = r;
            c.y = g;
            c.z = b;
            c.w = a;
            this._handler && this._handler.setPolyColorArr(this, c);
            return this;
        }

        setFillColor4v(rgba) {
            return this.setFillColor(rgba.x, rgba.y, rgba.z, rgba.w);
        }

        setStrokeColor(r, g, b, a) {
            var c = this._style.strokeColor;
            if ((c.w === 0.0 && a !== 0.0) || (c.w !== 0.0 && a === 0.0)) {
                this._pickingReady = false;
            }
            c.x = r;
            c.y = g;
            c.z = b;
            c.w = a;
            this._handler && this._handler.setLineStrokeColorArr(this, c);
            return this;
        }

        setLineColor(r, g, b, a) {
            var c = this._style.lineColor;
            if ((c.w === 0.0 && a !== 0.0) || (c.w !== 0.0 && a === 0.0)) {
                this._pickingReady = false;
            }
            c.x = r;
            c.y = g;
            c.z = b;
            c.w = a;
            this._handler && this._handler.setLineColorArr(this, c);
            return this;
        }

        setStrokeColor4v(rgba) {
            return this.setStrokeColor(rgba.x, rgba.y, rgba.z, rgba.w);
        }

        setLineColor4v(rgba) {
            return this.setLineColor(rgba.x, rgba.y, rgba.z, rgba.w);
        }

        setStrokeOpacity(opacity) {
            var c = this._style.strokeColor;
            c.w = opacity;
            return this.setStrokeColor(c.x, c.y, c.z, opacity);
        }

        setLineOpacity(opacity) {
            var c = this._style.lineColor;
            c.w = opacity;
            return this.setLineColor(c.x, c.y, c.z, opacity);
        }

        setStrokeWidth(width) {
            this._style.strokeWidth = width;
            this._pickingReady = false;
            this._handler && this._handler.setLineStrokeArr(this, width);
            return this;
        }

        bringToFront() {
            this._handler && this._handler.bringToFront(this);
            return this;
        }

        setLineWidth(width) {
            this._style.lineWidth = width;
            this._pickingReady = false;
            this._handler && this._handler.setLineThicknessArr(this, width);
            return this;
        }

        setFillOpacity(opacity) {
            var c = this._style.fillColor;
            if ((c.w === 0.0 && opacity !== 0.0) || (c.w !== 0.0 && opacity === 0.0)) {
                this._pickingReady = false;
            }
            c.w = opacity;
            this._handler && this._handler.setPolyColorArr(this, c);
            return this;
        }

        setVisibility(visibility) {
            this._visibility = visibility;
            this._handler && this._handler.setGeometryVisibility(this);
            return this;
        }

        getVisibility() {
            return this._visibility;
        }

        remove() {
            this._handler && this._handler.remove(this);
        }

        getExtent() {
            return this._extent.clone();
        }

        getType() {
            return this._type;
        }
    }

    /**
     * @module og/entity/Label
     */

    const ALIGN = {
        RIGHT: 0,
        LEFT: 1,
        CENTER: 2
    };

    /**
     * Text align options.
     * @readonly
     * @enum {number}
     */
    const STR2ALIGN = {
        left: ALIGN.LEFT,
        right: ALIGN.RIGHT,
        center: ALIGN.CENTER
    };

    /**
     * Billboard text label.
     * @class
     * @extends {BaseBillboard}
     * @param {Object} [options] - Label options:
     * @param {Vec3|Array.<number>} [options.position] - Billboard spatial position.
     * @param {number} [options.rotation] - Screen angle rotaion.
     * @param {Vec4|string|Array.<number>} [options.color] - Billboard color.
     * @param {Vec3|Array.<number>} [options.alignedAxis] - Billboard aligned vector.
     * @param {Vec3|Array.<number>} [options.offset] - Billboard center screen offset.
     * @param {boolean} [options.visibility] - Visibility.
     * @param {string} [options.text] - Text string.
     * @param {string} [options.face] - HTML5 font face.
     * @param {number} [options.size] - Font size in pixels.
     * @param {string} [options.style] - HTML5 font style. Example 'normal', 'italic'.
     * @param {string} [options.weight] - HTML5 font weight. Example 'normal', 'bold'.
     * @param {number} [options.outline] - Text outline size. 0 - no outline, 1 - maximum outline. Default 0.58.
     * @param {Vec4|string|Array.<number>} [options.outlineColor] - Outline color.
     * @param {Label.ALIGN} [options.align] - Text horizontal align: "left", "right" and "center".
     */
    class Label extends BaseBillboard {
        constructor(options) {
            super(options);

            options = options || {};

            /**
             * Label text string.
             * @private
             * @type {string}
             */
            this._text = options.text;

            /**
             * HTML5 font face.
             * @private
             * @type {string}
             */
            this._face = defaultString(options.face, "arial");

            /**
             * Font size in pixels.
             * @private
             * @type {number}
             */
            this._size = options.size || 24;

            /**
             * Label outline.
             * @private
             * @type {number}
             */
            this._outline = options.outline != undefined ? options.outline : 0.0;

            /**
             * Label outline color.
             * @private
             * @type {Vec4}
             */
            this._outlineColor = createColorRGBA(
                options.outlineColor,
                new Vec4(0.0, 0.0, 0.0, 1.0)
            );

            /**
             * Text horizontal align: "left", "right" and "center".
             * @private
             * @type {Label.ALIGN}
             */
            this._align = options.align
                ? STR2ALIGN[options.align.trim().toLowerCase()] || ALIGN.RIGHT
                : ALIGN.RIGHT;

            /**
             * Label font atlas index.
             * @private
             * @type {number}
             */
            this._fontIndex = 0;

            /**
             * Font atlas pointer.
             * @private
             * @type {utils.FontAtlas}
             */
            this._fontAtlas = null;

            this._isRTL = options.isRTL || false;
        }

        /**
         * Sets lablel text.
         * @public
         * @param {string} text - Text string.
         * It can't be bigger than maximum labelHandler _maxLetters value.
         */
        setText(text) {
            this._text = text.toString();
            if (this._isReady && this._handler) {
                this._handler.setText(this._handlerIndex, text, this._fontIndex, this._align, this._isRTL);
            }
        }

        /**
         * Gets current text string.
         * @public
         * @returns {string}
         */
        getText() {
            return this._text;
        }

        /**
         * Sets label text align. Could be center, left or right. Left is default.
         * @public
         * @param {Label.ALIGN} align - Text align.
         */
        setAlign(align) {
            this._align = STR2ALIGN[align.trim().toLowerCase()];
            if (this._isReady && this._handler) {
                this._handler.setText(this._handlerIndex, this._text, this._fontIndex, this._align, this._isRTL);
            } else if (this._lockId !== LOCK_FREE) {
                this._lockId = LOCK_UPDATE;
            }
        }

        /**
         * Gets label text current alignment.
         * @public
         * @returns {Label.ALIGN}
         */
        getAlign() {
            return this._align;
        }

        /**
         * Sets font face family.
         * @public
         * @param {string} face - Font face family.
         */
        setFace(face) {
            this._face = face.trim().toLowerCase();
            this.update();
        }

        /**
         * Gets current font face.
         * @public
         * @returns {string}
         */
        getFace() {
            return this._face;
        }

        /**
         * Sets label font size in pixels.
         * @public
         * @param {number} size - Label size in pixels.
         */
        setSize(size) {
            if (size !== this._size) {
                this._size = size;
                if (this._isReady && this._handler) {
                    this._handler.setSizeArr(this._handlerIndex, size);
                } else if (this._lockId !== LOCK_FREE) {
                    this._lockId = LOCK_UPDATE;
                }
            }
        }

        /**
         * Gets label size in pixels.
         * @public
         * @returns {number}
         */
        getSize() {
            return this._size;
        }

        /**
         * Sets text outline border size. Where 0 - is no outline and 1 - is the maximum outline size.
         * @public
         * @param {number} outline - Text outline size.
         */
        setOutline(outline) {
            this._outline = outline;
            if (this._isReady && this._handler) {
                this._handler.setOutlineArr(this._handlerIndex, outline);
            } else if (this._lockId !== LOCK_FREE) {
                this._lockId = LOCK_UPDATE;
            }
        }

        /**
         * Gets text current outline size.
         * @public
         * @returns {number}
         */
        getOutline() {
            return this._outline;
        }

        /**
         * Sets label opacity.
         * @public
         * @param {number} a - Label opacity.
         */
        setOpacity(a) {
            super.setOpacity(a);
            this.setOutlineOpacity(a);
        }

        /**
         * Sets text outline color.
         * @public
         * @param {number} r - Red.
         * @param {number} g - Green.
         * @param {number} b - Blue.
         * @param {number} a - Alpha.
         */
        setOutlineColor(r, g, b, a) {
            if (a !== this._outlineColor.w || r !== this._outlineColor.x || g !== this._outlineColor.y || b !== this._outlineColor.z) {
                this._outlineColor.x = r;
                this._outlineColor.y = g;
                this._outlineColor.z = b;
                this._outlineColor.w = a;
                if (this._isReady && this._handler) {
                    this._handler.setOutlineColorArr(this._handlerIndex, this._outlineColor);
                } else if (this._lockId !== LOCK_FREE) {
                    this._lockId = LOCK_UPDATE;
                }
            }
        }

        /**
         * Sets text outline color.
         * @public
         * @param {Vec4} rgba - Color vector.
         */
        setOutlineColor4v(rgba) {
            this.setOutlineColor(rgba.x, rgba.y, rgba.z, rgba.w);
        }

        /**
         * Sets text outline color HTML string.
         * @public
         * @param {string} color - HTML string color.
         */
        setOutlineColorHTML(color) {
            this.setOutlineColor4v(htmlColorToRgba(color));
        }

        /**
         * Gets outline color vector.
         * @public
         * @returns {Vec4}
         */
        getOutlineColor() {
            return this._outlineColor;
        }

        /**
         * Sets outline opacity. Actually outline color alpha value.
         * @public
         * @param {number} opacity - Outline opacity.
         */
        setOutlineOpacity(opacity) {
            if (opacity !== this._outlineColor.w) {
                this._outlineColor.w = opacity;
                if (this._isReady && this._handler) {
                    this._handler.setOutlineColorArr(this._handlerIndex, this._outlineColor);
                } else if (this._lockId !== LOCK_FREE) {
                    this._lockId = LOCK_UPDATE;
                }
            }
        }

        /**
         * Gets outline opacity value.
         * @public
         * @returns {number}
         */
        getOutlineOpacity() {
            return this._outlineColor.w;
        }

        /**
         * Updates label parameters.
         * @public
         */
        async update() {
            if (this._fontAtlas) {
                const fontIndex = await this._fontAtlas.getFontIndex(this._face);
                this._applyFontIndex(fontIndex);
            }
        }

        _applyFontIndex(fontIndex) {
            this._fontIndex = fontIndex;
            if (this._isReady && this._handler) {
                this._handler.setFontIndexArr(this._handlerIndex, this._fontIndex);
                this._handler.setText(this._handlerIndex, this._text, this._fontIndex, this._align, this._isRTL);
            } else if (this._lockId !== LOCK_FREE) {
                this._lockId = LOCK_UPDATE;
            }
        }

        /**
         * Assigns font atlas and update.
         * @public
         * @param {utils.FontAtlas} fontAtlas - Font atlas.
         */
        assignFontAtlas(fontAtlas) {
            if (!this._fontAtlas) {
                this._fontAtlas = fontAtlas;
            }
            this.update();
        }
    }

    /**
     * @module og/entity/Polyline
     */

    window.POLYLINE_DEPTH_OFFSET = 0.0;

    const VERTICES_BUFFER = 0;
    const INDEX_BUFFER = 1;
    const COLORS_BUFFER = 2;

    const DEFAULT_COLOR = "#0000FF";

    const R = 0;
    const G = 1;
    const B = 2;
    const A = 3;

    /**
     * Polyline object.
     * @class
     * @param {Object} [options] - Polyline options:
     * @param {number} [options.thickness] - Thickness in screen pixels 1.5 is default.
     * @param {Number} [options.altitude] - Relative to ground layers altitude value.
     * @param {Vec4} [options.color] - RGBA color.
     * @param {Boolean} [options.opacity] - Line opacity.
     * @param {Boolean} [options.visibility] - Polyline visibility. True default.
     * @param {Boolean} [options.isClosed] - Closed geometry type identificator.
     * @param {Array.<Array.<number>>} [options.pathLonLat] - Polyline geodetic coordinates array. [[0,0,0], [1,1,1],...]
     * @param {Array.<Array.<number>>} [options.path3v] - LinesString cartesian coordinates array. [[0,0,0], [1,1,1],...]
     * @param {Array.<Array.<number>>} [options.pathColors] - Coordinates color. [[1,0,0,1], [0,1,0,1],...] for right and green colors.
     */
    class Polyline {
        constructor(options) {
            options = options || {};

            /**
             * Object unic identifier.
             * @public
             * @readonly
             * @type {number}
             */
            this.id = Polyline._staticCounter++;

            this.altitude = options.altitude || 0.0;

            /**
             * Polyline thickness in screen pixels.
             * @public
             * @type {number}
             */
            this.thickness = options.thickness || 1.5;

            /**
             * Polyline RGBA color.
             * @public
             * @type {Array<number>} - (exactly 4 entries)
             */
            this._defaultColor = htmlColorToFloat32Array(
                options.color || DEFAULT_COLOR,
                options.opacity
            ); // utils.createColorRGBA(options.color, new Vec4(1.0, 1.0, 1.0, 1.0));

            /**
             * Polyline visibility.
             * @public
             * @type {boolean}
             */
            this.visibility = options.visibility != undefined ? options.visibility : true;

            /**
             * Polyline geometry ring type identificator.
             * @protected
             * @type {Boolean}
             */
            this._closedLine = options.isClosed || false;

            /**
             * Polyline cartesian coordinates.
             * @private
             * @type {Array.<Vec3>}
             */
            this._path3v = [];

            this._pathLengths = [];

            /**
             * Polyline geodetic degrees coordiantes.
             * @private
             * @type {Array.<LonLat>}
             */
            this._pathLonLat = [];

            /**
             * Polyline geodetic mercator coordinates.
             * @private
             * @type {Array.<LonLat>}
             */
            this._pathLonLatMerc = [];

            this._pathColors = options.pathColors ? cloneArray(options.pathColors) : [];

            /**
             * Polyline geodetic extent.
             * @protected
             * @type {Extent}
             */
            this._extent = new Extent();

            this._verticesHigh = [];
            this._verticesLow = [];
            this._orders = [];
            this._indexes = [];
            this._colors = [];

            this._verticesHighBuffer = null;
            this._verticesLowBuffer = null;
            this._ordersBuffer = null;
            this._indexesBuffer = null;
            this._colorsBuffer = null;

            this._pickingColor = [0, 0, 0];

            this._renderNode = null;

            /**
             * Entity instance that holds this Polyline.
             * @private
             * @type {Entity}
             */
            this._entity = null;

            /**
             * Handler that stores and renders this Polyline object.
             * @private
             * @type {PolylineHandler}
             */
            this._handler = null;
            this._handlerIndex = -1;

            this._buffersUpdateCallbacks = [];
            this._buffersUpdateCallbacks[VERTICES_BUFFER] = this._createVerticesBuffer;
            this._buffersUpdateCallbacks[INDEX_BUFFER] = this._createIndexBuffer;
            this._buffersUpdateCallbacks[COLORS_BUFFER] = this._createColorsBuffer;

            this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);

            // create path
            if (options.pathLonLat) {
                this.setPathLonLat(options.pathLonLat);
            } else if (options.path3v) {
                this.setPath3v(options.path3v);
            }

            this._refresh();
        }

        static get _staticCounter() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set _staticCounter(n) {
            this._counter = n;
        }

        /**
         * Appends to the line array new cartesian coordinates line data.
         * @param {Array.<Array.<number>>} path3v - Line coordinates path array. [[0,0,0], [1,1,1],...]
         * @param {Boolean} isClosed - Identificator for the closed line data creation.
         * @param {Number[]} outVertices - Out vertices data array.
         * @param {Number[]} outOrders - Out vertices orders data array.
         * @param {Number[]} outIndexes - Out vertices indexes data array.
         * @param {Ellipsoid} [ellipsoid] - Ellipsoid to coordinates transformation.
         * @param {Array.<Array.<LonLat>>} [outTransformedPathLonLat] - Geodetic coordinates out array.
         * @param {Array.<Array.<LonLat>>} [outPath3v] - Cartesian coordinates out array.
         * @param {Array.<Array.<LonLat>>} [outTransformedPathMerc] - Mercator coordinates out array.
         * @param {Extent} [outExtent] - Geodetic line extent.
         * @param {Array} [outColors]
         * @static
         */
        static appendLineData3v(
            path3v,
            pathColors,
            defaultColor,
            isClosed,
            outVerticesHigh,
            outVerticesLow,
            outOrders,
            outIndexes,
            ellipsoid,
            outTransformedPathLonLat,
            outPath3v,
            outTransformedPathMerc,
            outExtent,
            outColors
        ) {
            var index = 0;

            var v_high = new Vec3(),
                v_low = new Vec3();

            if (outExtent) {
                outExtent.southWest.set(180.0, 90.0);
                outExtent.northEast.set(-180.0, -90.0);
            }

            if (outIndexes.length > 0) {
                index = outIndexes[outIndexes.length - 5] + 9;
                outIndexes.push(index, index);
            } else {
                outIndexes.push(0, 0);
            }

            for (var j = 0, len = path3v.length; j < len; j++) {
                var path = path3v[j],
                    pathColors_j = pathColors[j];

                outTransformedPathLonLat[j] = [];
                outTransformedPathMerc[j] = [];
                outPath3v[j] = [];

                if (path.length === 0) {
                    continue;
                }

                var startIndex = index;

                var last;

                if (isClosed) {
                    last = path[path.length - 1];
                    if (last instanceof Array) {
                        last = new Vec3(last[0], last[1], last[2]);
                    }
                } else {
                    var p0 = path[0],
                        p1 = path[1] || p0;
                    if (p0 instanceof Array) {
                        p0 = new Vec3(p0[0], p0[1], p0[2]);
                    }
                    if (p1 instanceof Array) {
                        p1 = new Vec3(p1[0], p1[1], p1[2]);
                    }
                    last = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
                }

                let color = defaultColor;

                if (pathColors_j && pathColors_j[0]) {
                    color = pathColors_j[0];
                }

                Vec3.doubleToTwoFloats(last, v_high, v_low);
                outVerticesHigh.push(
                    v_high.x,
                    v_high.y,
                    v_high.z,
                    v_high.x,
                    v_high.y,
                    v_high.z,
                    v_high.x,
                    v_high.y,
                    v_high.z,
                    v_high.x,
                    v_high.y,
                    v_high.z
                );
                outVerticesLow.push(
                    v_low.x,
                    v_low.y,
                    v_low.z,
                    v_low.x,
                    v_low.y,
                    v_low.z,
                    v_low.x,
                    v_low.y,
                    v_low.z,
                    v_low.x,
                    v_low.y,
                    v_low.z
                );

                let r = color[R],
                    g = color[G],
                    b = color[B],
                    a = color[A] != undefined ? color[A] : 1.0;

                if (j > 0) {
                    outColors.push(r, g, b, a, r, g, b, a, r, g, b, a, r, g, b, a);
                }

                outOrders.push(1, -1, 2, -2);

                for (let i = 0, len = path.length; i < len; i++) {
                    var cur = path[i];

                    if (cur instanceof Array) {
                        cur = new Vec3(cur[0], cur[1], cur[2]);
                    }

                    outPath3v[j].push(cur);

                    if (ellipsoid) {
                        var lonLat = ellipsoid.cartesianToLonLat(cur);
                        outTransformedPathLonLat[j].push(lonLat);
                        outTransformedPathMerc[j].push(lonLat.forwardMercator());

                        if (lonLat.lon < outExtent.southWest.lon) {
                            outExtent.southWest.lon = lonLat.lon;
                        }
                        if (lonLat.lat < outExtent.southWest.lat) {
                            outExtent.southWest.lat = lonLat.lat;
                        }
                        if (lonLat.lon > outExtent.northEast.lon) {
                            outExtent.northEast.lon = lonLat.lon;
                        }
                        if (lonLat.lat > outExtent.northEast.lat) {
                            outExtent.northEast.lat = lonLat.lat;
                        }
                    }

                    if (pathColors_j && pathColors_j[i]) {
                        color = pathColors_j[i];
                    }

                    r = color[R];
                    g = color[G];
                    b = color[B];
                    a = color[A] != undefined ? color[A] : 1.0;

                    Vec3.doubleToTwoFloats(cur, v_high, v_low);
                    outVerticesHigh.push(
                        v_high.x,
                        v_high.y,
                        v_high.z,
                        v_high.x,
                        v_high.y,
                        v_high.z,
                        v_high.x,
                        v_high.y,
                        v_high.z,
                        v_high.x,
                        v_high.y,
                        v_high.z
                    );
                    outVerticesLow.push(
                        v_low.x,
                        v_low.y,
                        v_low.z,
                        v_low.x,
                        v_low.y,
                        v_low.z,
                        v_low.x,
                        v_low.y,
                        v_low.z,
                        v_low.x,
                        v_low.y,
                        v_low.z
                    );

                    outColors.push(r, g, b, a, r, g, b, a, r, g, b, a, r, g, b, a);

                    outOrders.push(1, -1, 2, -2);
                    outIndexes.push(index++, index++, index++, index++);
                }

                var first;
                if (isClosed) {
                    first = path[0];
                    if (first instanceof Array) {
                        first = new Vec3(first[0], first[1], first[2]);
                    }
                    outIndexes.push(startIndex, startIndex + 1, startIndex + 1, startIndex + 1);
                } else {
                    let p0 = path[path.length - 1],
                        p1 = path[path.length - 2] || p0;
                    if (p0 instanceof Array) {
                        p0 = new Vec3(p0[0], p0[1], p0[2]);
                    }
                    if (p1 instanceof Array) {
                        p1 = new Vec3(p1[0], p1[1], p1[2]);
                    }
                    first = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
                    outIndexes.push(index - 1, index - 1, index - 1, index - 1);
                }

                if (pathColors_j && pathColors_j[path.length - 1]) {
                    color = pathColors_j[path.length - 1];
                }

                r = color[R];
                g = color[G];
                b = color[B];
                a = color[A] != undefined ? color[A] : 1.0;

                Vec3.doubleToTwoFloats(first, v_high, v_low);
                outVerticesHigh.push(
                    v_high.x,
                    v_high.y,
                    v_high.z,
                    v_high.x,
                    v_high.y,
                    v_high.z,
                    v_high.x,
                    v_high.y,
                    v_high.z,
                    v_high.x,
                    v_high.y,
                    v_high.z
                );
                outVerticesLow.push(
                    v_low.x,
                    v_low.y,
                    v_low.z,
                    v_low.x,
                    v_low.y,
                    v_low.z,
                    v_low.x,
                    v_low.y,
                    v_low.z,
                    v_low.x,
                    v_low.y,
                    v_low.z
                );

                outColors.push(r, g, b, a, r, g, b, a, r, g, b, a, r, g, b, a);

                outOrders.push(1, -1, 2, -2);

                if (j < path3v.length - 1 && path3v[j + 1].length !== 0) {
                    index += 8;
                    outIndexes.push(index, index);
                }
            }
        }

        /**
         * Appends to the line new cartesian coordinates point data.
         * @param {Array.<Array.<number>>} path3v - Line coordinates path array. [[0,0,0], [1,1,1],...]
         * @param {Boolean} isClosed - Identificator for the closed line data creation.
         * @param {Number[]} outVertices - Out vertices data array.
         * @param {Number[]} outOrders - Out vertices orders data array.
         * @param {Number[]} outIndexes - Out vertices indexes data array.
         * @param {Ellipsoid} [ellipsoid] - Ellipsoid to coordinates transformation.
         * @param {Array.<Array.<LonLat>>} [outTransformedPathLonLat] - Geodetic coordinates out array.
         * @param {Array.<Array.<LonLat>>} [outPath3v] - Cartesian coordinates out array.
         * @param {Array.<Array.<LonLat>>} [outTransformedPathMerc] - Mercator coordinates out array.
         * @param {Extent} [outExtent] - Geodetic line extent.
         * @static
         */
        static appendPoint3v(
            path3v,
            point3v,
            pathColors,
            color,
            isClosed,
            outVerticesHigh,
            outVerticesLow,
            outColors,
            outOrders,
            outIndexes,
            ellipsoid,
            outTransformedPathLonLat,
            outTransformedPathMerc,
            outExtent
        ) {
            var v_high = new Vec3(),
                v_low = new Vec3();

            var ii = outIndexes.length - 4,
                index = outIndexes[ii - 1] + 1;

            if (path3v.length === 0) {
                path3v.push([]);
                if (!pathColors[0]) {
                    pathColors[0] = [];
                }
            } else if (!pathColors[path3v.length - 1]) {
                pathColors[path3v.length - 1] = [];
            }

            var path = path3v[path3v.length - 1],
                len = path.length;

            path.push(point3v);

            let r = color[R],
                g = color[G],
                b = color[B],
                a = color[A] != undefined ? color[A] : 1.0,
                pathColors_last = pathColors[path3v.length - 1];

            if (pathColors_last[len]) {
                pathColors_last[len][R] = r;
                pathColors_last[len][G] = g;
                pathColors_last[len][B] = b;
                pathColors_last[len][A] = a;
            } else {
                pathColors_last.push(color);
            }

            if (len === 1) {
                var last;
                if (isClosed) {
                    last = path[len - 1];
                    if (last instanceof Array) {
                        last = new Vec3(last[0], last[1], last[2]);
                    }
                } else {
                    var p0 = path[0],
                        p1 = path[1] || p0;
                    if (p0 instanceof Array) {
                        p0 = new Vec3(p0[0], p0[1], p0[2]);
                    }
                    if (p1 instanceof Array) {
                        p1 = new Vec3(p1[0], p1[1], p1[2]);
                    }
                    last = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
                }

                Vec3.doubleToTwoFloats(last, v_high, v_low);

                let vi = outVerticesHigh.length - 3 * 12;

                outVerticesHigh[vi] = v_high.x;
                outVerticesHigh[vi + 1] = v_high.y;
                outVerticesHigh[vi + 2] = v_high.z;
                outVerticesHigh[vi + 3] = v_high.x;
                outVerticesHigh[vi + 4] = v_high.y;
                outVerticesHigh[vi + 5] = v_high.z;
                outVerticesHigh[vi + 6] = v_high.x;
                outVerticesHigh[vi + 7] = v_high.y;
                outVerticesHigh[vi + 8] = v_high.z;
                outVerticesHigh[vi + 9] = v_high.x;
                outVerticesHigh[vi + 10] = v_high.y;
                outVerticesHigh[vi + 11] = v_high.z;

                outVerticesLow[vi] = v_low.x;
                outVerticesLow[vi + 1] = v_low.y;
                outVerticesLow[vi + 2] = v_low.z;
                outVerticesLow[vi + 3] = v_low.x;
                outVerticesLow[vi + 4] = v_low.y;
                outVerticesLow[vi + 5] = v_low.z;
                outVerticesLow[vi + 6] = v_low.x;
                outVerticesLow[vi + 7] = v_low.y;
                outVerticesLow[vi + 8] = v_low.z;
                outVerticesLow[vi + 9] = v_low.x;
                outVerticesLow[vi + 10] = v_low.y;
                outVerticesLow[vi + 11] = v_low.z;
            }

            var startIndex = index;

            if (ellipsoid) {
                if (outTransformedPathLonLat.length === 0) {
                    outTransformedPathLonLat.push([]);
                }

                if (outTransformedPathMerc.length === 0) {
                    outTransformedPathMerc.push([]);
                }

                var transformedPathLonLat =
                        outTransformedPathLonLat[outTransformedPathLonLat.length - 1],
                    transformedPathMerc = outTransformedPathMerc[outTransformedPathMerc.length - 1];

                let lonLat = ellipsoid.cartesianToLonLat(point3v);
                transformedPathLonLat.push(lonLat);
                transformedPathMerc.push(lonLat.forwardMercator());

                if (lonLat.lon < outExtent.southWest.lon) {
                    outExtent.southWest.lon = lonLat.lon;
                }
                if (lonLat.lat < outExtent.southWest.lat) {
                    outExtent.southWest.lat = lonLat.lat;
                }
                if (lonLat.lon > outExtent.northEast.lon) {
                    outExtent.northEast.lon = lonLat.lon;
                }
                if (lonLat.lat > outExtent.northEast.lat) {
                    outExtent.northEast.lat = lonLat.lat;
                }
            }

            Vec3.doubleToTwoFloats(point3v, v_high, v_low);

            let vi = outVerticesHigh.length - 12;

            outVerticesHigh[vi] = v_high.x;
            outVerticesHigh[vi + 1] = v_high.y;
            outVerticesHigh[vi + 2] = v_high.z;
            outVerticesHigh[vi + 3] = v_high.x;
            outVerticesHigh[vi + 4] = v_high.y;
            outVerticesHigh[vi + 5] = v_high.z;
            outVerticesHigh[vi + 6] = v_high.x;
            outVerticesHigh[vi + 7] = v_high.y;
            outVerticesHigh[vi + 8] = v_high.z;
            outVerticesHigh[vi + 9] = v_high.x;
            outVerticesHigh[vi + 10] = v_high.y;
            outVerticesHigh[vi + 11] = v_high.z;

            outVerticesLow[vi] = v_low.x;
            outVerticesLow[vi + 1] = v_low.y;
            outVerticesLow[vi + 2] = v_low.z;
            outVerticesLow[vi + 3] = v_low.x;
            outVerticesLow[vi + 4] = v_low.y;
            outVerticesLow[vi + 5] = v_low.z;
            outVerticesLow[vi + 6] = v_low.x;
            outVerticesLow[vi + 7] = v_low.y;
            outVerticesLow[vi + 8] = v_low.z;
            outVerticesLow[vi + 9] = v_low.x;
            outVerticesLow[vi + 10] = v_low.y;
            outVerticesLow[vi + 11] = v_low.z;

            let ci = outColors.length - 16;

            outColors[ci] = r;
            outColors[ci + 1] = g;
            outColors[ci + 2] = b;
            outColors[ci + 3] = a;
            outColors[ci + 4] = r;
            outColors[ci + 5] = g;
            outColors[ci + 6] = b;
            outColors[ci + 7] = a;
            outColors[ci + 8] = r;
            outColors[ci + 9] = g;
            outColors[ci + 10] = b;
            outColors[ci + 11] = a;
            outColors[ci + 12] = r;
            outColors[ci + 13] = g;
            outColors[ci + 14] = b;
            outColors[ci + 15] = a;

            outIndexes[ii] = index++;
            outIndexes[ii + 1] = index++;
            outIndexes[ii + 2] = index++;
            outIndexes[ii + 3] = index++;

            //
            // Close path
            //
            var first;
            if (isClosed) {
                first = path[0];
                outIndexes.push(startIndex, startIndex + 1, startIndex + 1, startIndex + 1);
            } else {
                let p0 = path[path.length - 1],
                    p1 = path[path.length - 2] || p0;

                first = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
                outIndexes.push(index - 1, index - 1, index - 1, index - 1);
            }

            Vec3.doubleToTwoFloats(first, v_high, v_low);
            outVerticesHigh.push(
                v_high.x,
                v_high.y,
                v_high.z,
                v_high.x,
                v_high.y,
                v_high.z,
                v_high.x,
                v_high.y,
                v_high.z,
                v_high.x,
                v_high.y,
                v_high.z
            );
            outVerticesLow.push(
                v_low.x,
                v_low.y,
                v_low.z,
                v_low.x,
                v_low.y,
                v_low.z,
                v_low.x,
                v_low.y,
                v_low.z,
                v_low.x,
                v_low.y,
                v_low.z
            );

            outColors.push(r, g, b, a, r, g, b, a, r, g, b, a, r, g, b, a);

            outOrders.push(1, -1, 2, -2);
        }

        /**
         * Appends to the line array new geodetic coordinates line data.
         * @param {Array.<Array.<number>>} pathLonLat - Line geodetic coordinates path array. [[0,0,0], [1,1,1],...]
         * @param {Boolean} isClosed - Identificator for the closed line data creation.
         * @param {Number[]} outVertices - Out vertices data array.
         * @param {Number[]} outOrders - Out vertices orders data array.
         * @param {Number[]} outIndexes - Out indexes data array.
         * @param {Ellipsoid} ellipsoid - Ellipsoid to coordinates transformation.
         * @param {Array.<Array.<number>>} outTransformedPathCartesian - Cartesian coordinates out array. [[0,0,0], [1,1,1],...]
         * @param {Array.<Array.<LonLat>>} outPathLonLat - Geographic coordinates out array.
         * @param {Array.<Array.<LonLat>>} outTransformedPathMerc - Mercator coordinates out array.
         * @param {Extent} outExtent - Geodetic line extent.
         * @static
         */
        static appendLineDataLonLat(
            pathLonLat,
            pathColors,
            defaultColor,
            isClosed,
            outVerticesHigh,
            outVerticesLow,
            outOrders,
            outIndexes,
            ellipsoid,
            outTransformedPathCartesian,
            outPathLonLat,
            outTransformedPathMerc,
            outExtent,
            outColors
        ) {
            var index = 0;

            var v_high = new Vec3(),
                v_low = new Vec3();

            if (outExtent) {
                outExtent.southWest.set(180.0, 90.0);
                outExtent.northEast.set(-180.0, -90.0);
            }

            if (outIndexes.length > 0) {
                index = outIndexes[outIndexes.length - 5] + 9;
                outIndexes.push(index, index);
            } else {
                outIndexes.push(0, 0);
            }

            for (var j = 0, len = pathLonLat.length; j < len; j++) {
                var path = pathLonLat[j],
                    pathColors_j = pathColors[j];

                outTransformedPathCartesian[j] = [];
                outTransformedPathMerc[j] = [];
                outPathLonLat[j] = [];

                if (path.length === 0) {
                    continue;
                }

                var startIndex = index;

                var last;

                if (isClosed) {
                    let pp = path[path.length - 1];
                    if (pp instanceof Array) {
                        last = ellipsoid.lonLatToCartesian(new LonLat(pp[0], pp[1], pp[2]));
                    } else {
                        last = ellipsoid.lonLatToCartesian(pp);
                    }
                } else {
                    let p0, p1;
                    let pp = path[0];
                    if (pp instanceof Array) {
                        p0 = ellipsoid.lonLatToCartesian(new LonLat(pp[0], pp[1], pp[2]));
                    } else {
                        p0 = ellipsoid.lonLatToCartesian(pp);
                    }

                    pp = path[1];

                    if (!pp) {
                        pp = path[0];
                    }

                    if (pp instanceof Array) {
                        p1 = ellipsoid.lonLatToCartesian(new LonLat(pp[0], pp[1], pp[2]));
                    } else {
                        p1 = ellipsoid.lonLatToCartesian(pp);
                    }

                    last = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
                }

                let color = defaultColor;

                if (pathColors_j && pathColors_j[0]) {
                    color = pathColors_j[0];
                }

                Vec3.doubleToTwoFloats(last, v_high, v_low);
                outVerticesHigh.push(
                    v_high.x,
                    v_high.y,
                    v_high.z,
                    v_high.x,
                    v_high.y,
                    v_high.z,
                    v_high.x,
                    v_high.y,
                    v_high.z,
                    v_high.x,
                    v_high.y,
                    v_high.z
                );
                outVerticesLow.push(
                    v_low.x,
                    v_low.y,
                    v_low.z,
                    v_low.x,
                    v_low.y,
                    v_low.z,
                    v_low.x,
                    v_low.y,
                    v_low.z,
                    v_low.x,
                    v_low.y,
                    v_low.z
                );

                let r = color[R],
                    g = color[G],
                    b = color[B],
                    a = color[A] != undefined ? color[A] : 1.0;

                if (j > 0) {
                    outColors.push(r, g, b, a, r, g, b, a, r, g, b, a, r, g, b, a);
                }

                outOrders.push(1, -1, 2, -2);

                for (let i = 0, len = path.length; i < len; i++) {
                    var cur = path[i];

                    if (cur instanceof Array) {
                        cur = new LonLat(cur[0], cur[1], cur[2]);
                    }

                    if (pathColors_j && pathColors_j[i]) {
                        color = pathColors_j[i];
                    }

                    r = color[R];
                    g = color[G];
                    b = color[B];
                    a = color[A] != undefined ? color[A] : 1.0;

                    var cartesian = ellipsoid.lonLatToCartesian(cur);
                    outTransformedPathCartesian[j].push(cartesian);
                    outPathLonLat[j].push(cur);
                    outTransformedPathMerc[j].push(cur.forwardMercator());

                    Vec3.doubleToTwoFloats(cartesian, v_high, v_low);
                    outVerticesHigh.push(
                        v_high.x,
                        v_high.y,
                        v_high.z,
                        v_high.x,
                        v_high.y,
                        v_high.z,
                        v_high.x,
                        v_high.y,
                        v_high.z,
                        v_high.x,
                        v_high.y,
                        v_high.z
                    );
                    outVerticesLow.push(
                        v_low.x,
                        v_low.y,
                        v_low.z,
                        v_low.x,
                        v_low.y,
                        v_low.z,
                        v_low.x,
                        v_low.y,
                        v_low.z,
                        v_low.x,
                        v_low.y,
                        v_low.z
                    );

                    outColors.push(r, g, b, a, r, g, b, a, r, g, b, a, r, g, b, a);

                    outOrders.push(1, -1, 2, -2);
                    outIndexes.push(index++, index++, index++, index++);

                    if (cur.lon < outExtent.southWest.lon) {
                        outExtent.southWest.lon = cur.lon;
                    }
                    if (cur.lat < outExtent.southWest.lat) {
                        outExtent.southWest.lat = cur.lat;
                    }
                    if (cur.lon > outExtent.northEast.lon) {
                        outExtent.northEast.lon = cur.lon;
                    }
                    if (cur.lat > outExtent.northEast.lat) {
                        outExtent.northEast.lat = cur.lat;
                    }
                }

                var first;
                if (isClosed) {
                    let pp = path[0];
                    if (pp instanceof Array) {
                        first = ellipsoid.lonLatToCartesian(new LonLat(pp[0], pp[1], pp[2]));
                    } else {
                        first = ellipsoid.lonLatToCartesian(pp);
                    }
                    outIndexes.push(startIndex, startIndex + 1, startIndex + 1, startIndex + 1);
                } else {
                    let p0, p1;
                    let pp = path[path.length - 1];
                    if (pp instanceof Array) {
                        p0 = ellipsoid.lonLatToCartesian(new LonLat(pp[0], pp[1], pp[2]));
                    } else {
                        p0 = ellipsoid.lonLatToCartesian(pp);
                    }

                    pp = path[path.length - 2];

                    if (!pp) {
                        pp = path[0];
                    }

                    if (pp instanceof Array) {
                        p1 = ellipsoid.lonLatToCartesian(new LonLat(pp[0], pp[1], pp[2]));
                    } else {
                        p1 = ellipsoid.lonLatToCartesian(pp);
                    }
                    first = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
                    outIndexes.push(index - 1, index - 1, index - 1, index - 1);
                }

                if (pathColors_j && pathColors_j[path.length - 1]) {
                    color = pathColors_j[path.length - 1];
                }

                r = color[R];
                g = color[G];
                b = color[B];
                a = color[A] != undefined ? color[A] : 1.0;

                Vec3.doubleToTwoFloats(first, v_high, v_low);
                outVerticesHigh.push(
                    v_high.x,
                    v_high.y,
                    v_high.z,
                    v_high.x,
                    v_high.y,
                    v_high.z,
                    v_high.x,
                    v_high.y,
                    v_high.z,
                    v_high.x,
                    v_high.y,
                    v_high.z
                );
                outVerticesLow.push(
                    v_low.x,
                    v_low.y,
                    v_low.z,
                    v_low.x,
                    v_low.y,
                    v_low.z,
                    v_low.x,
                    v_low.y,
                    v_low.z,
                    v_low.x,
                    v_low.y,
                    v_low.z
                );

                outColors.push(r, g, b, a, r, g, b, a, r, g, b, a, r, g, b, a);

                outOrders.push(1, -1, 2, -2);

                if (j < pathLonLat.length - 1 && pathLonLat[j + 1].length !== 0) {
                    index += 8;
                    outIndexes.push(index, index);
                }
            }
        }

        /**
         * Sets polyline path with cartesian coordinates.
         * @protected
         * @param {pg.math.Vector3[]} path3v - Cartesian coordinates.
         */
        _setEqualPath3v(path3v) {
            var extent = this._extent;
            extent.southWest.set(180, 90);
            extent.northEast.set(-180, -90);

            var v_high = new Vec3(),
                v_low = new Vec3();

            var vh = this._verticesHigh,
                vl = this._verticesLow,
                l = this._pathLonLat,
                m = this._pathLonLatMerc,
                k = 0;

            var ellipsoid = this._renderNode.ellipsoid;

            for (var j = 0; j < path3v.length; j++) {
                var path = path3v[j];

                var last;
                if (this._closedLine) {
                    last = path[path.length - 1];
                } else {
                    last = new Vec3(
                        path[0].x + path[0].x - path[1].x,
                        path[0].y + path[0].y - path[1].y,
                        path[0].z + path[0].z - path[1].z
                    );
                }

                Vec3.doubleToTwoFloats(last, v_high, v_low);

                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;

                for (var i = 0; i < path.length; i++) {
                    var cur = path[i],
                        pji = this._path3v[j][i];

                    pji.x = cur.x;
                    pji.y = cur.y;
                    pji.z = cur.z;

                    if (ellipsoid) {
                        var lonLat = ellipsoid.cartesianToLonLat(cur);

                        this._pathLonLat[j][i] = lonLat;

                        l[j][i] = lonLat;
                        m[j][i] = lonLat.forwardMercator();

                        if (lonLat.lon < extent.southWest.lon) {
                            extent.southWest.lon = lonLat.lon;
                        }
                        if (lonLat.lat < extent.southWest.lat) {
                            extent.southWest.lat = lonLat.lat;
                        }
                        if (lonLat.lon > extent.northEast.lon) {
                            extent.northEast.lon = lonLat.lon;
                        }
                        if (lonLat.lat > extent.northEast.lat) {
                            extent.northEast.lat = lonLat.lat;
                        }
                    }

                    Vec3.doubleToTwoFloats(cur, v_high, v_low);

                    vh[k] = v_high.x;
                    vl[k++] = v_low.x;
                    vh[k] = v_high.y;
                    vl[k++] = v_low.y;
                    vh[k] = v_high.z;
                    vl[k++] = v_low.z;
                    vh[k] = v_high.x;
                    vl[k++] = v_low.x;
                    vh[k] = v_high.y;
                    vl[k++] = v_low.y;
                    vh[k] = v_high.z;
                    vl[k++] = v_low.z;
                    vh[k] = v_high.x;
                    vl[k++] = v_low.x;
                    vh[k] = v_high.y;
                    vl[k++] = v_low.y;
                    vh[k] = v_high.z;
                    vl[k++] = v_low.z;
                    vh[k] = v_high.x;
                    vl[k++] = v_low.x;
                    vh[k] = v_high.y;
                    vl[k++] = v_low.y;
                    vh[k] = v_high.z;
                    vl[k++] = v_low.z;
                }

                var first;
                if (this._closedLine) {
                    first = path[0];
                } else {
                    var l1 = path.length - 1;
                    first = new Vec3(
                        path[l1].x + path[l1].x - path[l1 - 1].x,
                        path[l1].y + path[l1].y - path[l1 - 1].y,
                        path[l1].z + path[l1].z - path[l1 - 1].z
                    );
                }

                Vec3.doubleToTwoFloats(first, v_high, v_low);

                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
            }
        }

        /**
         * Sets polyline with geodetic coordinates.
         * @protected
         * @param {LonLat[]} pathLonLat - Geodetic polyline path coordinates.
         */
        _setEqualPathLonLat(pathLonLat) {
            var extent = this._extent;
            extent.southWest.set(180.0, 90.0);
            extent.northEast.set(-180.0, -90.0);

            var v_high = new Vec3(),
                v_low = new Vec3();

            var vh = this._verticesHigh,
                vl = this._verticesLow,
                l = this._pathLonLat,
                m = this._pathLonLatMerc,
                c = this._path3v,
                k = 0;

            var ellipsoid = this._renderNode.ellipsoid;

            for (var j = 0; j < pathLonLat.length; j++) {
                var path = pathLonLat[j];

                var last;
                if (this._closedLine) {
                    last = ellipsoid.lonLatToCartesian(path[path.length - 1]);
                } else {
                    let p0 = ellipsoid.lonLatToCartesian(path[0]),
                        p1 = ellipsoid.lonLatToCartesian(path[1]);
                    last = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
                }

                Vec3.doubleToTwoFloats(last, v_high, v_low);

                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;

                for (var i = 0; i < path.length; i++) {
                    var cur = path[i];
                    var cartesian = ellipsoid.lonLatToCartesian(cur);
                    c[j][i] = cartesian;
                    m[j][i] = cur.forwardMercator();
                    l[j][i] = cur;

                    Vec3.doubleToTwoFloats(cartesian, v_high, v_low);

                    vh[k] = v_high.x;
                    vl[k++] = v_low.x;
                    vh[k] = v_high.y;
                    vl[k++] = v_low.y;
                    vh[k] = v_high.z;
                    vl[k++] = v_low.z;
                    vh[k] = v_high.x;
                    vl[k++] = v_low.x;
                    vh[k] = v_high.y;
                    vl[k++] = v_low.y;
                    vh[k] = v_high.z;
                    vl[k++] = v_low.z;
                    vh[k] = v_high.x;
                    vl[k++] = v_low.x;
                    vh[k] = v_high.y;
                    vl[k++] = v_low.y;
                    vh[k] = v_high.z;
                    vl[k++] = v_low.z;
                    vh[k] = v_high.x;
                    vl[k++] = v_low.x;
                    vh[k] = v_high.y;
                    vl[k++] = v_low.y;
                    vh[k] = v_high.z;
                    vl[k++] = v_low.z;

                    if (cur.lon < extent.southWest.lon) {
                        extent.southWest.lon = cur.lon;
                    }
                    if (cur.lat < extent.southWest.lat) {
                        extent.southWest.lat = cur.lat;
                    }
                    if (cur.lon > extent.northEast.lon) {
                        extent.northEast.lon = cur.lon;
                    }
                    if (cur.lat > extent.northEast.lat) {
                        extent.northEast.lat = cur.lat;
                    }
                }

                var first;
                if (this._closedLine) {
                    first = ellipsoid.lonLatToCartesian(path[0]);
                } else {
                    let p0 = ellipsoid.lonLatToCartesian(path[path.length - 1]),
                        p1 = ellipsoid.lonLatToCartesian(path[path.length - 2]);
                    first = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
                }

                Vec3.doubleToTwoFloats(first, v_high, v_low);

                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
            }
        }

        setPointLonLat(lonlat, index, segmentIndex) {
            if (this._renderNode && this._renderNode.ellipsoid) {
                let l = this._pathLonLat,
                    m = this._pathLonLatMerc;

                l[segmentIndex][index] = lonlat;
                m[segmentIndex][index] = lonlat.forwardMercator();

                //
                // Apply new extent(TODO: think about optimization)
                //
                var extent = this._extent;
                extent.southWest.set(180.0, 90.0);
                extent.northEast.set(-180.0, -90.0);
                for (var i = 0; i < l.length; i++) {
                    var pi = l[i];
                    for (var j = 0; j < pi.length; j++) {
                        var lon = pi[j].lon,
                            lat = pi[j].lat;
                        if (lon > extent.northEast.lon) {
                            extent.northEast.lon = lon;
                        }
                        if (lat > extent.northEast.lat) {
                            extent.northEast.lat = lat;
                        }
                        if (lon < extent.southWest.lon) {
                            extent.southWest.lon = lon;
                        }
                        if (lat < extent.southWest.lat) {
                            extent.southWest.lat = lat;
                        }
                    }
                }

                this.setPoint3v(
                    this._renderNode.ellipsoid.lonLatToCartesian(lonlat),
                    index,
                    segmentIndex,
                    true
                );
            } else {
                let path = this._pathLonLat[segmentIndex];
                path[index].lon = lonlat.lon;
                path[index].lat = lonlat.lat;
                path[index].height = lonlat.height;
            }
        }

        setPoint3v(coordinates, index = 0, segmentIndex = 0, skipLonLat = false) {

            if (this._renderNode) {
                var v_high = new Vec3(),
                    v_low = new Vec3();

                var vh = this._verticesHigh,
                    vl = this._verticesLow,
                    l = this._pathLonLat,
                    m = this._pathLonLatMerc,
                    k = 0,
                    kk = 0;

                //for (var i = 0; i < segmentIndex; i++) {
                //    kk += this._path3v[i].length * 12 + 24;
                //}
                kk = this._pathLengths[segmentIndex] * 12 + 24 * segmentIndex;

                let path = this._path3v[segmentIndex];

                path[index].x = coordinates.x;
                path[index].y = coordinates.y;
                path[index].z = coordinates.z;

                let _closedLine = this._closedLine || path.length === 1;

                if (index === 0 || index === 1) {
                    var last;
                    if (_closedLine) {
                        last = path[path.length - 1];
                    } else {
                        last = new Vec3(
                            path[0].x + path[0].x - path[1].x,
                            path[0].y + path[0].y - path[1].y,
                            path[0].z + path[0].z - path[1].z
                        );
                    }

                    k = kk;

                    Vec3.doubleToTwoFloats(last, v_high, v_low);

                    vh[k] = v_high.x;
                    vh[k + 1] = v_high.y;
                    vh[k + 2] = v_high.z;
                    vh[k + 3] = v_high.x;
                    vh[k + 4] = v_high.y;
                    vh[k + 5] = v_high.z;
                    vh[k + 6] = v_high.x;
                    vh[k + 7] = v_high.y;
                    vh[k + 8] = v_high.z;
                    vh[k + 9] = v_high.x;
                    vh[k + 10] = v_high.y;
                    vh[k + 11] = v_high.z;

                    vl[k] = v_low.x;
                    vl[k + 1] = v_low.y;
                    vl[k + 2] = v_low.z;
                    vl[k + 3] = v_low.x;
                    vl[k + 4] = v_low.y;
                    vl[k + 5] = v_low.z;
                    vl[k + 6] = v_low.x;
                    vl[k + 7] = v_low.y;
                    vl[k + 8] = v_low.z;
                    vl[k + 9] = v_low.x;
                    vl[k + 10] = v_low.y;
                    vl[k + 11] = v_low.z;
                }

                if (!skipLonLat && this._renderNode.ellipsoid) {
                    var lonLat = this._renderNode.ellipsoid.cartesianToLonLat(coordinates);
                    l[segmentIndex][index] = lonLat;
                    m[segmentIndex][index] = lonLat.forwardMercator();

                    //
                    // Apply new extent(TODO: think about optimization)
                    //
                    var extent = this._extent;
                    extent.southWest.set(180.0, 90.0);
                    extent.northEast.set(-180.0, -90.0);
                    for (let i = 0; i < l.length; i++) {
                        var pi = l[i];
                        for (var j = 0; j < pi.length; j++) {
                            var lon = pi[j].lon,
                                lat = pi[j].lat;
                            if (lon > extent.northEast.lon) {
                                extent.northEast.lon = lon;
                            }
                            if (lat > extent.northEast.lat) {
                                extent.northEast.lat = lat;
                            }
                            if (lon < extent.southWest.lon) {
                                extent.southWest.lon = lon;
                            }
                            if (lat < extent.southWest.lat) {
                                extent.southWest.lat = lat;
                            }
                        }
                    }
                }

                k = kk + index * 12 + 12;

                Vec3.doubleToTwoFloats(coordinates, v_high, v_low);

                vh[k] = v_high.x;
                vh[k + 1] = v_high.y;
                vh[k + 2] = v_high.z;
                vh[k + 3] = v_high.x;
                vh[k + 4] = v_high.y;
                vh[k + 5] = v_high.z;
                vh[k + 6] = v_high.x;
                vh[k + 7] = v_high.y;
                vh[k + 8] = v_high.z;
                vh[k + 9] = v_high.x;
                vh[k + 10] = v_high.y;
                vh[k + 11] = v_high.z;

                vl[k] = v_low.x;
                vl[k + 1] = v_low.y;
                vl[k + 2] = v_low.z;
                vl[k + 3] = v_low.x;
                vl[k + 4] = v_low.y;
                vl[k + 5] = v_low.z;
                vl[k + 6] = v_low.x;
                vl[k + 7] = v_low.y;
                vl[k + 8] = v_low.z;
                vl[k + 9] = v_low.x;
                vl[k + 10] = v_low.y;
                vl[k + 11] = v_low.z;

                if (index === path.length - 1 || index === path.length - 2) {
                    var first;
                    if (_closedLine) {
                        first = path[0];
                    } else {
                        var l1 = path.length - 1;
                        first = new Vec3(
                            path[l1].x + path[l1].x - path[l1 - 1].x,
                            path[l1].y + path[l1].y - path[l1 - 1].y,
                            path[l1].z + path[l1].z - path[l1 - 1].z
                        );
                    }

                    k = kk + path.length * 12 + 12;

                    Vec3.doubleToTwoFloats(first, v_high, v_low);

                    vh[k] = v_high.x;
                    vh[k + 1] = v_high.y;
                    vh[k + 2] = v_high.z;
                    vh[k + 3] = v_high.x;
                    vh[k + 4] = v_high.y;
                    vh[k + 5] = v_high.z;
                    vh[k + 6] = v_high.x;
                    vh[k + 7] = v_high.y;
                    vh[k + 8] = v_high.z;
                    vh[k + 9] = v_high.x;
                    vh[k + 10] = v_high.y;
                    vh[k + 11] = v_high.z;

                    vl[k] = v_low.x;
                    vl[k + 1] = v_low.y;
                    vl[k + 2] = v_low.z;
                    vl[k + 3] = v_low.x;
                    vl[k + 4] = v_low.y;
                    vl[k + 5] = v_low.z;
                    vl[k + 6] = v_low.x;
                    vl[k + 7] = v_low.y;
                    vl[k + 8] = v_low.z;
                    vl[k + 9] = v_low.x;
                    vl[k + 10] = v_low.y;
                    vl[k + 11] = v_low.z;
                }

                this._changedBuffers[VERTICES_BUFFER] = true;
            } else {
                let path = this._path3v[segmentIndex];
                path[index].x = coordinates.x;
                path[index].y = coordinates.y;
                path[index].z = coordinates.z;
            }
        }

        _resizePathLengths(index = 0) {
            this._pathLengths[0] = 0;
            for (let i = index + 1, len = this._path3v.length; i <= len; i++) {
                this._pathLengths[i] = this._pathLengths[i - 1] + this._path3v[i - 1].length;
            }
        }

        removeSegment(index) {
            this._path3v.splice(index, 1);
            this.setPath3v([].concat(this._path3v));
        }

        removePoint(index, multiLineIndex = 0) {
            this._path3v[multiLineIndex].splice(index, 1);
            if (this._path3v[multiLineIndex].length === 0) {
                this._path3v.splice(multiLineIndex, 1);
            }
            this.setPath3v([].concat(this._path3v));
        }

        insertPoint3v(point3v, index = 0, color, multilineIndex = 0) {
            let p = [].concat(this._path3v),
                pp = p[multilineIndex];
            if (pp) {
                let c = [].concat(this._pathColors);

                pp.splice(index, 0, point3v);

                if (color) {
                    let cc = c[multilineIndex];
                    if (!cc) {
                        cc = new Array(pp.length);
                    }
                    cc.splice(index, 0, color);
                }

                this.setPath3v(p, c);
            } else {
                this.addPoint3v(point3v, multilineIndex);
            }
        }

        /**
         * Adds a new cartesian point in the end of the path in a last line segment.
         * @public
         * @param {Vec3} point3v - New coordinate.
         */
        appendPoint3v(point3v, color, skipEllipsoid) {
            if (this._path3v.length === 0) {
                this._pathColors.push([color || this._defaultColor]);
                this.addPoint3v(point3v);
            } else {
                //
                // Making typedArrays suitable for appendPoint function
                //
                this._verticesHigh = makeArray(this._verticesHigh);
                this._verticesLow = makeArray(this._verticesLow);
                this._colors = makeArray(this._colors);
                this._orders = makeArray(this._orders);
                this._indexes = makeArray(this._indexes);

                Polyline.appendPoint3v(
                    this._path3v,
                    point3v,
                    this._pathColors,
                    color || this._defaultColor,
                    this._closedLine,
                    this._verticesHigh,
                    this._verticesLow,
                    this._colors,
                    this._orders,
                    this._indexes,
                    !skipEllipsoid && this._renderNode.ellipsoid,
                    this._pathLonLat,
                    this._pathLonLatMerc,
                    this._extent
                );

                this._pathLengths[this._path3v.length] += 1;

                this._changedBuffers[VERTICES_BUFFER] = true;
                this._changedBuffers[COLORS_BUFFER] = true;
                this._changedBuffers[INDEX_BUFFER] = true;
            }
        }

        /**
         * Adds a new cartesian point in the end of the path.
         * @public
         * @param {Vec3} point3v - New coordinate.
         * @param {number} [multiLineIndex=0] - Path part index, first by default.
         */
        addPoint3v(point3v, multiLineIndex = 0) {
            //
            // TODO: could be optimized
            //
            if (multiLineIndex >= this._path3v.length) {
                this._path3v.push([]);
            }
            this._path3v[multiLineIndex].push(point3v);
            this.setPath3v([].concat(this._path3v));
        }

        /**
         * Adds a new geodetic point in the end of the path.
         * @public
         * @param {LonLat} lonLat - New coordinate.
         * @param {number} [multiLineIndex=0] - Path part index, first by default.
         */
        addPointLonLat(lonLat, multiLineIndex = 0) {
            //
            // TODO: could be optimized
            //
            if (multiLineIndex >= this._pathLonLat.length) {
                this._pathLonLat.push([]);
            }
            this._pathLonLat[multiLineIndex].push(lonLat);
            this.setPathLonLat([].concat(this._pathLonLat));
        }

        /**
         * Clear Polyline object data.
         * @public
         */
        clear() {
            this._clearData();
        }

        setPointColor(color, index = 0, segmentIndex = 0) {
            if (this._renderNode && index < this._path3v[segmentIndex].length) {
                let colors = this._pathColors[segmentIndex];

                if (!colors) {
                    if (this._path3v[segmentIndex] && index < this._path3v[segmentIndex].length) {
                        this._pathColors[segmentIndex] = new Array(this._path3v[segmentIndex].length);
                    } else {
                        return;
                    }
                }

                if (!colors[index]) {
                    colors[index] = [color[R], color[G], color[B], color[A] || 1.0];
                } else {
                    colors[index][R] = color[R];
                    colors[index][G] = color[G];
                    colors[index][B] = color[B];
                    colors[index][A] = color[A] || 1.0;
                }

                let c = this._colors;

                //optimized with this._pathLengths
                //for (var i = 0; i < segmentIndex; i++) {
                //    kk += this._path3v[i].length * 16 + 32;
                //}

                let k = index * 16 + this._pathLengths[segmentIndex] * 16 + 32 * segmentIndex;

                c[k] = c[k + 4] = c[k + 8] = c[k + 12] = color[R];
                c[k + 1] = c[k + 5] = c[k + 9] = c[k + 13] = color[G];
                c[k + 2] = c[k + 6] = c[k + 10] = c[k + 14] = color[B];
                c[k + 3] = c[k + 7] = c[k + 11] = c[k + 15] = color[A] || 1.0;

                this._changedBuffers[COLORS_BUFFER] = true;
            } else {
                let pathColors = this._pathColors[segmentIndex];
                pathColors[index] = color;
            }
        }

        /**
         * Sets Polyline opacity.
         * @public
         * @param {number} opacity - Opacity.
         */
        setOpacity(opacity) {
            this.color.w = opacity;
        }

        /**
         * Sets Polyline thickness in screen pixels.
         * @public
         * @param {number} thickness - Thickness.
         */
        setThickness(thickness) {
            this.thickness = thickness;
        }

        /**
         * Returns thickness.
         * @public
         * @return {number} Thickness in screen pixels.
         */
        getThickness() {
            return this.thickness;
        }

        /**
         * Sets visibility.
         * @public
         * @param {boolean} visibility - Polyline visibility.
         */
        setVisibility(visibility) {
            this.visibility = visibility;
        }

        /**
         * Gets Polyline visibility.
         * @public
         * @return {boolean} Polyline visibility.
         */
        getVisibility() {
            return this.visibility;
        }

        /**
         * Assign with render node.
         * @public
         * @param {RenderNode} renderNode -
         */
        setRenderNode(renderNode) {
            if (renderNode) {
                this._renderNode = renderNode;
                if (this._pathLonLat.length) {
                    this._createDataLonLat([].concat(this._pathLonLat));
                } else {
                    this._createData3v([].concat(this._path3v));
                }
                this._refresh();
                this._update();
            }
        }

        /**
         * @protected
         */
        _clearData() {
            this._verticesHigh = null;
            this._verticesLow = null;
            this._orders = null;
            this._indexes = null;
            this._colors = null;

            this._verticesHigh = [];
            this._verticesLow = [];
            this._orders = [];
            this._indexes = [];
            this._colors = [];

            this._path3v.length = 0;
            this._pathLonLat.length = 0;
            this._pathLonLatMerc.length = 0;

            this._path3v = [];
            this._pathLonLat = [];
            this._pathLonLatMerc = [];
        }

        _createData3v(path3v) {
            this._clearData();
            Polyline.appendLineData3v(
                path3v,
                this._pathColors,
                this._defaultColor,
                this._closedLine,
                this._verticesHigh,
                this._verticesLow,
                this._orders,
                this._indexes,
                this._renderNode.ellipsoid,
                this._pathLonLat,
                this._path3v,
                this._pathLonLatMerc,
                this._extent,
                this._colors
            );
            this._resizePathLengths(0);
        }

        _createDataLonLat(pathLonlat) {
            this._clearData();
            Polyline.appendLineDataLonLat(
                pathLonlat,
                this._pathColors,
                this._defaultColor,
                this._closedLine,
                this._verticesHigh,
                this._verticesLow,
                this._orders,
                this._indexes,
                this._renderNode.ellipsoid,
                this._path3v,
                this._pathLonLat,
                this._pathLonLatMerc,
                this._extent,
                this._colors
            );
            this._resizePathLengths(0);
        }

        /**
         * Removes from an entity.
         * @public
         */
        remove() {
            this._entity = null;

            this._pathColors.length = 0;
            this._pathColors = [];

            this._verticesHigh = null;
            this._verticesLow = null;
            this._orders = null;
            this._indexes = null;
            this._colors = null;

            this._verticesHigh = [];
            this._verticesLow = [];
            this._orders = [];
            this._indexes = [];
            this._colors = [];

            this._deleteBuffers();

            this._handler && this._handler.remove(this);
        }

        setPickingColor3v(color) {
            this._pickingColor[0] = color.x / 255.0;
            this._pickingColor[1] = color.y / 255.0;
            this._pickingColor[2] = color.z / 255.0;
        }

        /**
         * Returns polyline geodetic extent.
         * @public
         * @returns {Extent} - Geodetic extent
         */
        getExtent() {
            return this._extent.clone();
        }

        /**
         * Returns path cartesian coordinates.
         * @return {Array.<Vec3>} Polyline path.
         */
        getPath3v() {
            return this._path3v;
        }

        /**
         * Returns geodetic path coordinates.
         * @return {Array.<LonLat>} Polyline path.
         */
        getPathLonLat() {
            return this._pathLonLat;
        }

        getPathColors() {
            return this._pathColors;
        }

        setPathColors(pathColors) {
            if (this._renderNode) ;
        }

        setColorHTML(htmlColor) {
            this._defaultColor = htmlColorToFloat32Array(htmlColor);

            let color = htmlColorToRgba(htmlColor),
                p = this._pathColors;

            for (let i = 0, len = p.length; i < len; i++) {
                let s = p[i];
                for (let j = 0, slen = s.length; j < slen; j++) {
                    s[j][0] = color.x;
                    s[j][1] = color.y;
                    s[j][2] = color.z;
                    s[j][3] = color.w;
                }
            }

            let c = this._colors;
            for (let i = 0, len = c.length; i < len; i += 4) {
                c[i] = color.x;
                c[i + 1] = color.y;
                c[i + 2] = color.z;
                c[i + 3] = color.w;
            }

            this._changedBuffers[COLORS_BUFFER] = true;
        }

        /**
         * Sets geodetic coordinates.
         * @public
         * @param {Array.<Array.<number>>} pathLonLat - Polyline path cartesian coordinates. (exactly 3 entries)
         * @param {Boolean} [forceEqual=false] - Makes assigning faster for size equal coordinates array.
         */
        setPathLonLat(pathLonLat, forceEqual) {
            if (this._renderNode && this._renderNode.ellipsoid) {
                if (forceEqual) {
                    this._setEqualPathLonLat(pathLonLat);
                    this._changedBuffers[VERTICES_BUFFER] = true;
                    this._changedBuffers[COLORS_BUFFER] = true;
                } else {
                    this._createDataLonLat(pathLonLat);
                    this._changedBuffers[VERTICES_BUFFER] = true;
                    this._changedBuffers[INDEX_BUFFER] = true;
                    this._changedBuffers[COLORS_BUFFER] = true;
                }
            } else {
                this._pathLonLat = [].concat(pathLonLat);
            }
        }

        /**
         * Sets Polyline cartesian coordinates.
         * @public
         * @param {Array.<Array.<number>>} path3v - Polyline path cartesian coordinates. (exactly 3 entries)
         * @param {Boolean} [forceEqual=false] - Makes assigning faster for size equal coordinates array.
         */
        setPath3v(path3v, pathColors, forceEqual) {
            if (pathColors) {
                this._pathColors = [].concat(pathColors);
            }

            if (this._renderNode) {
                if (forceEqual) {
                    this._setEqualPath3v(path3v);
                    this._changedBuffers[VERTICES_BUFFER] = true;
                    this._changedBuffers[COLORS_BUFFER] = true;
                } else {
                    this._createData3v(path3v);
                    this._changedBuffers[VERTICES_BUFFER] = true;
                    this._changedBuffers[INDEX_BUFFER] = true;
                    this._changedBuffers[COLORS_BUFFER] = true;
                }
            } else {
                this._path3v = [].concat(path3v);
            }
        }

        draw() {
            if (this.visibility && this._path3v.length) {
                this._update();

                var rn = this._renderNode;
                var r = rn.renderer;
                var sh = r.handler.programs.polyline_screen;
                var p = sh._program;
                var gl = r.handler.gl,
                    sha = p.attributes,
                    shu = p.uniforms,
                    ec = this._handler._entityCollection;

                sh.activate();

                gl.enable(gl.BLEND);
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(
                    gl.SRC_ALPHA,
                    gl.ONE_MINUS_SRC_ALPHA,
                    gl.ONE,
                    gl.ONE_MINUS_SRC_ALPHA
                );
                gl.disable(gl.CULL_FACE);

                gl.uniform1f(shu.depthOffset, ec.polygonOffsetUnits + window.POLYLINE_DEPTH_OFFSET);

                gl.uniformMatrix4fv(shu.proj, false, r.activeCamera.getProjectionMatrix());
                gl.uniformMatrix4fv(shu.view, false, r.activeCamera.getViewMatrix());

                // gl.uniform4fv(shu.color, [this.color.x, this.color.y, this.color.z, this.color.w * this._handler._entityCollection._fadingOpacity]);

                gl.uniform3fv(shu.eyePositionHigh, r.activeCamera.eyeHigh);
                gl.uniform3fv(shu.eyePositionLow, r.activeCamera.eyeLow);

                gl.uniform2fv(shu.uFloatParams, [
                    rn._planetRadius2 || 0.0,
                    r.activeCamera._tanViewAngle_hradOneByHeight
                ]);
                gl.uniform2fv(shu.viewport, [r.handler.canvas.width, r.handler.canvas.height]);
                gl.uniform1f(shu.thickness, this.thickness * 0.5);
                gl.uniform1f(shu.opacity, ec._fadingOpacity);

                gl.bindBuffer(gl.ARRAY_BUFFER, this._colorsBuffer);
                gl.vertexAttribPointer(sha.color, this._colorsBuffer.itemSize, gl.FLOAT, false, 0, 0);

                var v = this._verticesHighBuffer;
                gl.bindBuffer(gl.ARRAY_BUFFER, v);
                gl.vertexAttribPointer(sha.prevHigh, v.itemSize, gl.FLOAT, false, 12, 0);
                gl.vertexAttribPointer(sha.currentHigh, v.itemSize, gl.FLOAT, false, 12, 48);
                gl.vertexAttribPointer(sha.nextHigh, v.itemSize, gl.FLOAT, false, 12, 96);

                v = this._verticesLowBuffer;
                gl.bindBuffer(gl.ARRAY_BUFFER, v);
                gl.vertexAttribPointer(sha.prevLow, v.itemSize, gl.FLOAT, false, 12, 0);
                gl.vertexAttribPointer(sha.currentLow, v.itemSize, gl.FLOAT, false, 12, 48);
                gl.vertexAttribPointer(sha.nextLow, v.itemSize, gl.FLOAT, false, 12, 96);

                gl.bindBuffer(gl.ARRAY_BUFFER, this._ordersBuffer);
                gl.vertexAttribPointer(sha.order, this._ordersBuffer.itemSize, gl.FLOAT, false, 4, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexesBuffer);
                gl.drawElements(gl.TRIANGLE_STRIP, this._indexesBuffer.numItems, gl.UNSIGNED_INT, 0);
            }
        }

        drawPicking() {
            if (this.visibility && this._path3v.length) {
                var rn = this._renderNode;
                var r = rn.renderer;
                var sh = r.handler.programs.polyline_picking;
                var p = sh._program;
                var gl = r.handler.gl,
                    sha = p.attributes,
                    shu = p.uniforms;

                sh.activate();

                gl.enable(gl.BLEND);
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(
                    gl.SRC_ALPHA,
                    gl.ONE_MINUS_SRC_ALPHA,
                    gl.ONE,
                    gl.ONE_MINUS_SRC_ALPHA
                );
                gl.disable(gl.CULL_FACE);

                gl.uniform1f(shu.depthOffset, this._handler._entityCollection.polygonOffsetUnits + window.POLYLINE_DEPTH_OFFSET);

                gl.uniformMatrix4fv(shu.proj, false, r.activeCamera.getProjectionMatrix());
                gl.uniformMatrix4fv(shu.view, false, r.activeCamera.getViewMatrix());

                gl.uniform4fv(shu.color, [
                    this._pickingColor[0],
                    this._pickingColor[1],
                    this._pickingColor[2],
                    1.0
                ]);

                gl.uniform3fv(shu.eyePositionHigh, r.activeCamera.eyeHigh);
                gl.uniform3fv(shu.eyePositionLow, r.activeCamera.eyeLow);

                gl.uniform2fv(shu.uFloatParams, [
                    rn._planetRadius2 || 0.0,
                    r.activeCamera._tanViewAngle_hradOneByHeight
                ]);
                gl.uniform2fv(shu.viewport, [r.handler.canvas.width, r.handler.canvas.height]);
                gl.uniform1f(shu.thickness, this.thickness * 0.5);

                var v = this._verticesHighBuffer;
                gl.bindBuffer(gl.ARRAY_BUFFER, v);
                gl.vertexAttribPointer(sha.prevHigh, v.itemSize, gl.FLOAT, false, 12, 0);
                gl.vertexAttribPointer(sha.currentHigh, v.itemSize, gl.FLOAT, false, 12, 48);
                gl.vertexAttribPointer(sha.nextHigh, v.itemSize, gl.FLOAT, false, 12, 96);

                v = this._verticesLowBuffer;
                gl.bindBuffer(gl.ARRAY_BUFFER, v);
                gl.vertexAttribPointer(sha.prevLow, v.itemSize, gl.FLOAT, false, 12, 0);
                gl.vertexAttribPointer(sha.currentLow, v.itemSize, gl.FLOAT, false, 12, 48);
                gl.vertexAttribPointer(sha.nextLow, v.itemSize, gl.FLOAT, false, 12, 96);

                gl.bindBuffer(gl.ARRAY_BUFFER, this._ordersBuffer);
                gl.vertexAttribPointer(sha.order, this._ordersBuffer.itemSize, gl.FLOAT, false, 4, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexesBuffer);
                gl.drawElements(gl.TRIANGLE_STRIP, this._indexesBuffer.numItems, gl.UNSIGNED_INT, 0);
            }
        }

        /**
         * Refresh buffers.
         * @protected
         */
        _refresh() {
            var i = this._changedBuffers.length;
            while (i--) {
                this._changedBuffers[i] = true;
            }
        }

        /**
         * Updates render buffers.
         * @protected
         */
        _update() {
            if (this._renderNode) {
                var i = this._changedBuffers.length;
                while (i--) {
                    if (this._changedBuffers[i]) {
                        this._buffersUpdateCallbacks[i].call(this);
                        this._changedBuffers[i] = false;
                    }
                }
            }
        }

        /**
         * Clear GL buffers.
         * @protected
         */
        _deleteBuffers() {
            if (this._renderNode) {
                var r = this._renderNode.renderer,
                    gl = r.handler.gl;

                gl.deleteBuffer(this._verticesHighBuffer);
                gl.deleteBuffer(this._verticesLowBuffer);
                gl.deleteBuffer(this._ordersBuffer);
                gl.deleteBuffer(this._indexesBuffer);
                gl.deleteBuffer(this._colorsBuffer);

                this._verticesHighBuffer = null;
                this._verticesLowBuffer = null;
                this._ordersBuffer = null;
                this._indexesBuffer = null;
                this._colorsBuffer = null;
            }
        }

        /**
         * Creates gl main data buffer.
         * @protected
         */
        _createVerticesBuffer() {
            var h = this._renderNode.renderer.handler;

            let numItems = this._verticesHigh.length / 3;

            if (!this._verticesHighBuffer || this._verticesHighBuffer.numItems !== numItems) {
                h.gl.deleteBuffer(this._verticesHighBuffer);
                h.gl.deleteBuffer(this._verticesLowBuffer);
                this._verticesHighBuffer = h.createStreamArrayBuffer(3, numItems);
                this._verticesLowBuffer = h.createStreamArrayBuffer(3, numItems);
            }

            this._verticesHigh = makeArrayTyped(this._verticesHigh);
            this._verticesLow = makeArrayTyped(this._verticesLow);

            h.setStreamArrayBuffer(this._verticesHighBuffer, this._verticesHigh);
            h.setStreamArrayBuffer(this._verticesLowBuffer, this._verticesLow);
        }

        /**
         * Creates gl index and order buffer.
         * @protected
         */
        _createIndexBuffer() {
            var h = this._renderNode.renderer.handler;
            h.gl.deleteBuffer(this._ordersBuffer);
            h.gl.deleteBuffer(this._indexesBuffer);

            this._orders = makeArrayTyped(this._orders);

            this._ordersBuffer = h.createArrayBuffer(this._orders, 1, this._orders.length / 2);

            this._indexes = makeArrayTyped(this._indexes, Uint32Array);

            this._indexesBuffer = h.createElementArrayBuffer(this._indexes, 1, this._indexes.length);
        }

        _createColorsBuffer() {
            var h = this._renderNode.renderer.handler;
            h.gl.deleteBuffer(this._colorsBuffer);

            this._colors = makeArrayTyped(this._colors);

            this._colorsBuffer = h.createArrayBuffer(
                new Float32Array(this._colors),
                4,
                this._colors.length / 4
            );
        }
    }

    /**
     * @module og/math/coder
     */

    /**
     * Decode RGBA vector to 32 bit float value.
     * @function
     * @param {Vec4} rgba - RGBA encoded 32 bit float value.
     * @returns {number} - Float value.
     */
    function decodeFloatFromRGBAArr(arr, use32) {
        var s = 1.0 - step(128.0, arr[0]) * 2.0;
        var e = 2.0 * mod(arr[0], 128.0) + step(128.0, arr[1]) - 127.0;
        var m = mod(arr[1], 128.0) * 65536.0 + arr[2] * 256.0 + (use32 ? arr[3] : 0.0) + 8388608.0;
        return s * exp2(e) * (m * 1.1920928955078125e-7);
    }

    /**
     * Separate 64 bit value to two 32 bit float values.
     * @function
     * @param {number} value - Double type value.
     * @returns {Array.<number>} Encoded array. (exactly 2 entries)
     */
    function doubleToTwoFloats2(value, highLowArr) {
        if (value >= 0.0) {
            let doubleHigh = Math.floor(value / 65536.0) * 65536.0;
            highLowArr[0] = Math.fround(doubleHigh);
            highLowArr[1] = Math.fround(value - doubleHigh);
        } else {
            let doubleHigh = Math.floor(-value / 65536.0) * 65536.0;
            highLowArr[0] = Math.fround(-doubleHigh);
            highLowArr[1] = Math.fround(value + doubleHigh);
        }
        return highLowArr;
    }

    /**
     * Separate 64 bit value to two 32 bit float values.
     * @function
     * @param {number} value - Double type value.
     * @returns {Array.<number>} Encoded array. (exactly 2 entries)
     */
    function doubleToTwoFloatsV2(value, highLowVec) {
        if (value >= 0.0) {
            let doubleHigh = Math.floor(value / 65536.0) * 65536.0;
            highLowVec.x = Math.fround(doubleHigh);
            highLowVec.y = Math.fround(value - doubleHigh);
        } else {
            let doubleHigh = Math.floor(-value / 65536.0) * 65536.0;
            highLowVec.x = Math.fround(-doubleHigh);
            highLowVec.y = Math.fround(value + doubleHigh);
        }
        return highLowVec;
    }

    /**
     * @module og/entity/BaseBillboard
     */

    /**
     * Ray class.
     * @class
     * @param {Object} [options] - Options:
     * @param {Vec3|Array.<number>} [options.startPosition] - Ray start point position.
     * @param {Vec3|Array.<number>} [options.endPosition] - Ray end point position.
     * @param {Vec3|Array.<number>} [options.startColor] - Ray start point color.
     * @param {Vec3|Array.<number>} [options.endColor] - Ray end point color.
     * @param {boolean} [options.visibility] - Visibility.
     */
    class Ray {
        constructor(options) {
            options = options || {};

            /**
             * Object unic identifier.
             * @public
             * @readonly
             * @type {number}
             */
            this.id = Entity$1._staticCounter++;

            // Thickenss
            this._thickness = options.thickness || 2.0;

            // RTE length
            this._length = options.length || 0.0;
            this._lengthHighLow = new Float32Array(2);
            doubleToTwoFloats2(this._length, this._lengthHighLow);

            // RTE start position
            this._startPosition = createVector3(options.startPosition);
            this._startPositionHigh = new Vec3();
            this._startPositionLow = new Vec3();
            Vec3.doubleToTwoFloats(
                this._startPosition,
                this._startPositionHigh,
                this._startPositionLow
            );

            // RTE end position
            this._endPosition = createVector3(options.endPosition);
            this._endPositionHigh = new Vec3();
            this._endPositionLow = new Vec3();
            Vec3.doubleToTwoFloats(this._endPosition, this._endPositionHigh, this._endPositionLow);

            // start end point colors
            this._startColor = createColorRGBA(options.startColor);
            this._endColor = createColorRGBA(options.endColor);

            /**
             * Ray visibility.
             * @protected
             * @type {boolean}
             */
            this._visibility = options.visibility != undefined ? options.visibility : true;

            /**
             * Entity instance that holds this billboard.
             * @protected
             * @type {Entity}
             */
            this._entity = null;

            /**
             * Handler that stores and renders this billboard object.
             * @protected
             * @type {BillboardHandler}
             */
            this._handler = null;

            /**
             * Billboard handler array index.
             * @protected
             * @type {number}
             */
            this._handlerIndex = -1;
        }

        /**
         * Sets ray start position.
         * @public
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         * @param {number} z - Z coordinate.
         */
        setStartPosition(x, y, z) {
            this._startPosition.x = x;
            this._startPosition.y = y;
            this._startPosition.z = z;
            Vec3.doubleToTwoFloats(
                this._startPosition,
                this._startPositionHigh,
                this._startPositionLow
            );
            this._handler &&
                this._handler.setStartPositionArr(
                    this._handlerIndex,
                    this._startPositionHigh,
                    this._startPositionLow
                );
        }

        /**
         * Sets ray start position.
         * @public
         * @param {Vec3} position - Cartesian coordinates.
         */
        setStartPosition3v(position) {
            this._startPosition.x = position.x;
            this._startPosition.y = position.y;
            this._startPosition.z = position.z;
            Vec3.doubleToTwoFloats(
                this._startPosition,
                this._startPositionHigh,
                this._startPositionLow
            );
            this._handler &&
                this._handler.setStartPositionArr(
                    this._handlerIndex,
                    this._startPositionHigh,
                    this._startPositionLow
                );
        }

        /**
         * Sets ray end position.
         * @public
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         * @param {number} z - Z coordinate.
         */
        setEndPosition(x, y, z) {
            this._endPosition.x = x;
            this._endPosition.y = y;
            this._endPosition.z = z;
            Vec3.doubleToTwoFloats(this._endPosition, this._endPositionHigh, this._endPositionLow);
            this._handler &&
                this._handler.setEndPositionArr(
                    this._handlerIndex,
                    this._endPositionHigh,
                    this._endPositionLow
                );
        }

        /**
         * Sets ray end position.
         * @public
         * @param {Vec3} position - Cartesian coordinates.
         */
        setEndPosition3v(position) {
            this._endPosition.x = position.x;
            this._endPosition.y = position.y;
            this._endPosition.z = position.z;
            Vec3.doubleToTwoFloats(this._endPosition, this._endPositionHigh, this._endPositionLow);
            this._handler &&
                this._handler.setEndPositionArr(
                    this._handlerIndex,
                    this._endPositionHigh,
                    this._endPositionLow
                );
        }

        setLength(length) {
            this._length = length;
            this._handler && this._handler.setLengthArr(this._handlerIndex, length);
        }

        setThickness(thickness) {
            this._thickness = thickness;
            this._handler && this._handler.setThicknessArr(this._handlerIndex, thickness);
        }

        setColors4v(startColor, endColor) {
            if (startColor) {
                this._startColor.x = startColor.x;
                this._startColor.y = startColor.y;
                this._startColor.z = startColor.z;
                this._startColor.w = startColor.w;
            }

            if (this._endColor) {
                this._endColor.x = endColor.x;
                this._endColor.y = endColor.y;
                this._endColor.z = endColor.z;
                this._endColor.w = endColor.w;
            }

            this._handler &&
                this._handler.setRgbaArr(this._handlerIndex, this._startColor, this._endColor);
        }

        setColorsHTML(startColor, endColor) {
            if (startColor) {
                this._startColor = htmlColorToRgba(startColor);
            }

            if (endColor) {
                this._endColor = htmlColorToRgba(endColor);
            }

            this._handler &&
                this._handler.setRgbaArr(this._handlerIndex, this._startColor, this._endColor);
        }

        /**
         * Returns ray start position.
         * @public
         * @returns {Vec3}
         */
        getStartPosition() {
            return this._startPosition;
        }

        /**
         * Returns ray end position.
         * @public
         * @returns {Vec3}
         */
        getEndPosition() {
            return this._endPosition;
        }

        /**
         * Sets billboard visibility.
         * @public
         * @param {boolean} visibility - Visibility flag.
         */
        setVisibility(visibility) {
            this._visibility = visibility;
            this._handler && this._handler.setVisibility(this._handlerIndex, visibility);
        }

        /**
         * Returns billboard visibility.
         * @public
         * @returns {boolean}
         */
        getVisibility() {
            return this._visibility;
        }

        /**
         * Removes billboard from hander.
         * @public
         */
        remove() {
            this._entity = null;
            this._handler && this._handler.remove(this);
        }

        /**
         * Sets billboard picking color.
         * @public
         * @param {Vec3} color - Picking color.
         */
        setPickingColor3v(color) {
            this._handler && this._handler.setPickingColorArr(this._handlerIndex, color);
        }
    }

    /**
     * @module og/entity/PointCloud
     */

    const COORDINATES_BUFFER = 0;
    const COLOR_BUFFER = 1;
    const PICKING_COLOR_BUFFER = 2;

    /**
     * PointCloud object.
     * @class
     * @param {*} [options] - Point cloud options:
     * @param {Array.<Array.<number>>} [options.points] - Points cartesian coordinates array,
     * where first three is cartesian coordinates, next fourth is a RGBA color, and last is an point properties.
     * @param {number} [options.pointSize] - Point screen size in pixels.
     * @param {number} [options.pickingDistance] - Point border picking size in screen pixels.
     * @param {boolean} [options.visibility] - Point cloud visibility.
     * @example <caption>Creates point cloud with two ten pixel size points</caption>
     * new og.Entity({
     *     pointCloud: {
     *         pointSize: 10,
     *         points: [
     *             [0, 0, 0, 255, 255, 255, 255, { 'name': 'White point' }],
     *             [100, 100, 0, 255, 0, 0, 255, { 'name': 'Red point' }]
     *         ]
     *     }
     * });
     */
    class PointCloud {
        constructor(options) {
            options = options || {};

            /**
             * Object unic identifier.
             * @public
             * @readonly
             * @type {number}
             */
            this.id = PointCloud._staticCounter++;

            /**
             * Cloud visibility.
             * @public
             * @type {boolean}
             */
            this.visibility = options.visibility != undefined ? options.visibility : true;

            /**
             * Point screen size in pixels.
             * @public
             * @type {number}
             */
            this.pointSize = options.pointSize || 3;

            /**
             * Point picking border size in pixels.
             * @public
             * @type {number}
             */
            this.pickingDistance = options.pickingDistance || 0;

            /**
             * Parent collection render node.
             * @private
             * @type {RenderNode}
             */
            this._renderNode = null;

            /**
             * Entity instance that holds this point cloud.
             * @private
             * @type {Entity}
             */
            this._entity = null;

            /**
             * Points properties.
             * @private
             * @type {Array.<*>}
             */
            this._points = [];

            /**
             * Coordinates array.
             * @private
             * @type {Array.<number>}
             */
            this._coordinatesData = [];

            /**
             * Color array.
             * @private
             * @type {Array.<number>}
             */
            this._colorData = [];

            /**
             * Picking color array.
             * @private
             * @type {Array.<number>}
             */
            this._pickingColorData = [];

            this._coordinatesBuffer = null;
            this._colorBuffer = null;
            this._pickingColorBuffer = null;

            /**
             * Handler that stores and renders this object.
             * @private
             * @type {PointCloudHandler}
             */
            this._handler = null;
            this._handlerIndex = -1;

            this._buffersUpdateCallbacks = [];
            this._buffersUpdateCallbacks[COORDINATES_BUFFER] = this._createCoordinatesBuffer;
            this._buffersUpdateCallbacks[COLOR_BUFFER] = this._createColorBuffer;
            this._buffersUpdateCallbacks[PICKING_COLOR_BUFFER] = this._createPickingColorBuffer;

            this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);

            this.setPoints(options.points);
        }

        static get _staticCounter() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set _staticCounter(n) {
            this._counter = n;
        }

        /**
         * Clears point cloud data
         * @public
         */
        clear() {
            this._points.length = 0;
            this._points = [];

            this._coordinatesData.length = 0;
            this._coordinatesData = [];

            this._colorData.length = 0;
            this._colorData = [];

            this._pickingColorData.length = 0;
            this._pickingColorData = [];

            this._deleteBuffers();
        }

        /**
         * Set point cloud opacity.
         * @public
         * @param {number} opacity - Cloud opacity.
         */
        setOpacity(opacity) {
            this.opacity = opacity;
        }

        /**
         * Sets cloud visibility.
         * @public
         * @param {number} visibility - Visibility flag.
         */
        setVisibility(visibility) {
            this.visibility = visibility;
        }

        /**
         * @return {boolean} Point cloud visibily.
         */
        getVisibility() {
            return this.visibility;
        }

        /**
         * Assign rendering scene node.
         * @public
         * @param {RenderNode}  renderNode - Assigned render node.
         */
        setRenderNode(renderNode) {
            this._renderNode = renderNode;
            this._setPickingColors();
        }

        /**
         * Removes from entity.
         * @public
         */
        remove() {
            this._entity = null;
            this._handler && this._handler.remove(this);
        }

        /**
         * Adds points to render.
         * @public
         * @param {Array.<Array<number>>} points - Point cloud array.
         * @example
         * var points = [[0, 0, 0, 255, 255, 255, 255, { 'name': 'White point' }], [100, 100, 0, 255, 0, 0, 255, { 'name': 'Red point' }]];
         */
        setPoints(points) {
            this.clear();
            for (var i = 0; i < points.length; i++) {
                var pi = points[i];
                var pos = new Vec3(pi[0], pi[1], pi[2]),
                    col = new Vec4(pi[3], pi[4], pi[5], pi[6] == undefined ? 255.0 : pi[6]);
                this._coordinatesData.push(pos.x, pos.y, pos.z);
                this._colorData.push(col.x / 255.0, col.y / 255.0, col.z / 255.0, col.w / 255.0);
                var p = {
                    _pickingColor: new Vec3(),
                    _entityCollection: this._entity && this._entity._entityCollection,
                    index: i,
                    position: pos,
                    color: col,
                    pointCloud: this,
                    properties: pi[7] || {}
                };
                this._points.push(p);

                if (this._renderNode) {
                    this._renderNode.renderer.assignPickingColor(p);
                    this._pickingColorData.push(
                        p._pickingColor.x / 255.0,
                        p._pickingColor.y / 255.0,
                        p._pickingColor.z / 255.0,
                        1.0
                    );
                }
            }

            this._changedBuffers[COORDINATES_BUFFER] = true;
            this._changedBuffers[COLOR_BUFFER] = true;
            this._changedBuffers[PICKING_COLOR_BUFFER] = true;
        }

        setPointPosition(index, x, y, z) {
            // TODO: ...

            this._changedBuffers[COORDINATES_BUFFER] = true;
        }

        setPointColor(index, r, g, b, a) {
            // TODO: ...

            this._changedBuffers[COLOR_BUFFER] = true;
        }

        addPoints(points) {
            // TODO: ...

            this._changedBuffers[COORDINATES_BUFFER] = true;
            this._changedBuffers[COLOR_BUFFER] = true;
            this._changedBuffers[PICKING_COLOR_BUFFER] = true;
        }

        addPoint(index, point) {
            // TODO: ...

            this._changedBuffers[COORDINATES_BUFFER] = true;
            this._changedBuffers[COLOR_BUFFER] = true;
            this._changedBuffers[PICKING_COLOR_BUFFER] = true;
        }

        /**
         * Returns specific point by index.
         * @public
         * @param {number} index - Point index.
         * @return {*} Specific point
         */
        getPoint(index) {
            return this._points[index];
        }

        removePoint(index) {
            // TODO: ...

            this._changedBuffers[COORDINATES_BUFFER] = true;
            this._changedBuffers[COLOR_BUFFER] = true;
            this._changedBuffers[PICKING_COLOR_BUFFER] = true;
        }

        insertPoint(index, point) {
            // TODO: ...

            this._changedBuffers[COORDINATES_BUFFER] = true;
            this._changedBuffers[COLOR_BUFFER] = true;
            this._changedBuffers[PICKING_COLOR_BUFFER] = true;
        }

        /**
         * Each point iterator.
         * @public
         * @param {callback} callback -
         */
        each(callback) {
            var i = this._points.length;
            while (i--) {
                callback && callback(this._points[i]);
            }
        }

        draw() {
            if (this.visibility && this._coordinatesData.length) {
                this._update();

                var rn = this._renderNode;
                var r = rn.renderer;
                var sh = r.handler.programs.pointCloud;
                var p = sh._program;
                var gl = r.handler.gl,
                    sha = p.attributes,
                    shu = p.uniforms;

                // gl.polygonOffset(
                //     this._handler._entityCollection.polygonOffsetFactor,
                //     this._handler._entityCollection.polygonOffsetUnits
                // );

                sh.activate();

                gl.uniformMatrix4fv(
                    shu.projectionViewMatrix,
                    false,
                    r.activeCamera._projectionViewMatrix._m
                );

                gl.uniform1f(shu.opacity, this._handler._entityCollection._fadingOpacity);

                gl.uniform1f(shu.pointSize, this.pointSize);

                gl.bindBuffer(gl.ARRAY_BUFFER, this._coordinatesBuffer);
                gl.vertexAttribPointer(
                    sha.coordinates,
                    this._coordinatesBuffer.itemSize,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );

                gl.bindBuffer(gl.ARRAY_BUFFER, this._colorBuffer);
                gl.vertexAttribPointer(sha.colors, this._colorBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.drawArrays(gl.POINTS, 0, this._coordinatesBuffer.numItems);
            }
        }

        drawPicking() {
            if (this.visibility && this._coordinatesData.length) {
                var rn = this._renderNode;
                var r = rn.renderer;
                var sh = r.handler.programs.pointCloud;
                var p = sh._program;
                var gl = r.handler.gl,
                    sha = p.attributes,
                    shu = p.uniforms;

                sh.activate();

                // gl.polygonOffset(
                //     this._handler._entityCollection.polygonOffsetFactor,
                //     this._handler._entityCollection.polygonOffsetUnits
                // );

                gl.uniformMatrix4fv(
                    shu.projectionViewMatrix,
                    false,
                    r.activeCamera._projectionViewMatrix._m
                );

                gl.uniform1f(shu.opacity, this._handler._entityCollection._fadingOpacity);

                gl.uniform1f(shu.pointSize, this.pointSize + this.pickingDistance);

                gl.bindBuffer(gl.ARRAY_BUFFER, this._coordinatesBuffer);
                gl.vertexAttribPointer(
                    sha.coordinates,
                    this._coordinatesBuffer.itemSize,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );

                gl.bindBuffer(gl.ARRAY_BUFFER, this._pickingColorBuffer);
                gl.vertexAttribPointer(
                    sha.colors,
                    this._pickingColorBuffer.itemSize,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );

                gl.drawArrays(gl.POINTS, 0, this._coordinatesBuffer.numItems);
            }
        }

        /**
         * Update gl buffers.
         * @private
         */
        _update() {
            if (this._renderNode) {
                var i = this._changedBuffers.length;
                while (i--) {
                    if (this._changedBuffers[i]) {
                        this._buffersUpdateCallbacks[i].call(this);
                        this._changedBuffers[i] = false;
                    }
                }
            }
        }

        /**
         * Delete buffers
         * @private
         */
        _deleteBuffers() {
            if (this._renderNode) {
                var r = this._renderNode.renderer,
                    gl = r.handler.gl;

                gl.deleteBuffer(this._coordinatesBuffer);
                gl.deleteBuffer(this._colorBuffer);
                gl.deleteBuffer(this._pickingColorBuffer);
            }

            this._coordinatesBuffer = null;
            this._colorBuffer = null;
            this._pickingColorBuffer = null;
        }

        _createCoordinatesBuffer() {
            var h = this._renderNode.renderer.handler;
            h.gl.deleteBuffer(this._coordinatesBuffer);
            this._coordinatesBuffer = h.createArrayBuffer(
                new Float32Array(this._coordinatesData),
                3,
                this._coordinatesData.length / 3
            );
        }

        _createColorBuffer() {
            var h = this._renderNode.renderer.handler;
            h.gl.deleteBuffer(this._colorBuffer);
            this._colorBuffer = h.createArrayBuffer(
                new Float32Array(this._colorData),
                4,
                this._colorData.length / 4
            );
        }

        _createPickingColorBuffer() {
            var h = this._renderNode.renderer.handler;
            h.gl.deleteBuffer(this._pickingColorBuffer);
            this._pickingColorBuffer = h.createArrayBuffer(
                new Float32Array(this._pickingColorData),
                4,
                this._pickingColorData.length / 4
            );
        }

        _setPickingColors() {
            if (this._renderNode) {
                for (var i = 0; i < this._points.length; i++) {
                    var p = this._points[i];
                    p._entity = this._entity;
                    p._entityCollection = this._entity._entityCollection;
                    this._renderNode.renderer.assignPickingColor(p);
                    this._pickingColorData.push(
                        p._pickingColor.x / 255.0,
                        p._pickingColor.y / 255.0,
                        p._pickingColor.z / 255.0,
                        1.0
                    );
                }
                this._changedBuffers[PICKING_COLOR_BUFFER] = true;
            }
        }
    }

    /**
     * @module og/shape/BaseShape
     */

    /**
     * Base geometry shape class.
     * @class
     * @param {Object} options - Shape parameters:
     * @param {Vec3} [options.position] - Shape position.
     * @param {Quat} [options.orientation] - Shape orientation(rotation).
     * @param {Vec3} [options.scale] - Scale vector.
     * @param {Array.<number>} [options.color] - Shape RGBA color. (exactly 4 entries)
     * @param {string} [options.src] - Texture image url source.
     * @param {boolean} [options.visibility] - Shape visibility.
     */
    class BaseShape {
        constructor(options) {
            options = options || {};

            /**
             * Unic identifier.
             * @public
             * @readonly
             * @type {number}
             */
            this.id = BaseShape._staticCounter++;

            /**
             * Shape position.
             * @public
             * @type {Vec3}
             */
            this.position = options.position || new Vec3();

            /**
             * Shape orientation(rotation)
             * @public
             * @type {Quat}
             */
            this.orientation = options.orientation || new Quat(0.0, 0.0, 0.0, 1.0);

            /**
             * Scale.
             * @public
             * @type {Vec3}
             */
            this.scale = options.scale || new Vec3(1.0, 1.0, 1.0);

            /**
             * Shape RGBA color.
             * @public
             * @type {Array.<number>} - (exactly 4 entries)
             */
            this.color = options.color
                ? new Float32Array(options.color)
                : new Float32Array([1.0, 1.0, 1.0, 1.0]);

            /**
             * Shape visibility.
             * @public
             * @type {boolean}
             */
            this.visibility = options.visibility != undefined ? options.visibility : true;

            /**
             * Image url source.
             * @protected
             * @type {string}
             */
            this._src = options.src || null;

            /**
             * Vertices position gl buffer.
             * @protected
             */
            this._positionBuffer = null;

            /**
             * Vertices normal gl buffer.
             * @protected
             */
            this._normalBuffer = null;

            /**
             * Vertices indexes gl buffer.
             * @protected
             */
            this._indexBuffer = null;

            /**
             * Vertex texture coordinates gl buffer.
             * @protected
             */
            this._textureCoordBuffer = null;

            /**
             * Vertex positions.
             * @protected
             * @type {Array.<number>}
             */
            this._positionData = [];

            /**
             * Vertex normals.
             * @protected
             * @type {Array.<number>}
             */
            this._normalData = [];

            /**
             * Vertex indeces.
             * @protected
             * @type {Array.<number>}
             */
            this._indexData = [];

            /**
             * Vertex texture coordinates.
             * @protected
             * @type {Array.<number>}
             */
            this._textureCoordData = [];

            /**
             * Scale matrix.
             * @protected
             * @type {Mat4}
             */
            this._mxScale = new Mat4().setIdentity().scale(this.scale);

            /**
             * Translation matrix.
             * @protected
             * @type {Mat4}
             */
            this._mxTranslation = new Mat4().setIdentity();

            /**
             * Model matrix.
             * @protected
             * @type {Mat4}
             */
            this._mxModel = new Mat4().setIdentity();

            /**
             * Gl texture pointer.
             * @protected
             */
            this.texture = null;

            /**
             * Assigned render node.
             * @protected
             * @type {RenderNode}
             */
            this._renderNode = null;

            /**
             * Assigned picking color.
             * @protected
             * @type {Array.<number>} - (exactly 3 entries)
             */
            this._pickingColor = [0.0, 0.0, 0.0, 0.0];

            /**
             * Entity instance that holds this shape.
             * @protected
             * @type {Entity}
             */
            this._entity = null;

            /**
             * Handler that stores and renders this shape object.
             * @protected
             * @type {ShapeHandler}
             */
            this._handler = null;

            /**
             * Shape handler array index.
             * @protected
             * @type {number}
             */
            this._handlerIndex = -1;
        }

        static get _staticCounter() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set _staticCounter(n) {
            this._counter = n;
        }

        /**
         * Clear shape parameters.
         * @public
         */
        clear() {
            this.position.set(0.0, 0.0, 0.0);
            this.orientation.set(0.0, 0.0, 0.0, 1.0);
            this.scale.set(1.0, 1.0, 1.0);

            this._positionData.length = 0;
            this._normalData.length = 0;
            this._indexData.length = 0;

            this._mxScale.setIdentity();
            this._mxTranslation.setIdentity();
            this._mxModel.setIdentity();

            this._renderNode.handler.gl.deleteTexture(this.texture);
            this.texture = null;

            this._deleteBuffers();
        }

        /**
         * Sets shape color.
         * @public
         * @param {Array.<number>} color - RGBA color values array. (exactly 4 entries)
         */
        setColor(color) {
            this.color[0] = color[0];
            this.color[1] = color[1];
            this.color[2] = color[2];
            this.color[3] = color[3];
        }

        /**
         * Sets shape color.
         * @public
         * @param {Vec4} color - RGBA color vector.
         */
        setColor4v(color) {
            this.color[0] = color.x;
            this.color[1] = color.y;
            this.color[2] = color.z;
            this.color[3] = color.w;
        }

        /**
         * Sets shape opacity value.
         * @public
         * @param {number} opacity - Opacity value.
         */
        setOpacity(opacity) {
            this.color[3] = opacity;
        }

        /**
         * Delete gl buffers.
         * @protected
         */
        _deleteBuffers() {
            var r = this._renderNode.renderer,
                gl = r.handler.gl;

            gl.deleteBuffer(this._positionBuffer);
            gl.deleteBuffer(this._normalBuffer);
            gl.deleteBuffer(this._indexBuffer);

            this._positionBuffer = null;
            this._normalBuffer = null;
            this._indexBuffer = null;
        }

        /**
         * Sets shape visibility.
         * @public
         * @param {boolean} visibility - Visibility.
         */
        setVisibility(visibility) {
            this.visibility = visibility;
        }

        /**
         * Gets visibilty flag.
         * @public
         * @returns {boolean} -
         */
        getVisibility() {
            return this.visibility;
        }

        /**
         * Assign render node.
         * @public
         * @param {RenderNode} renderNode - Render node to assign.
         */
        setRenderNode(renderNode) {
            this._renderNode = renderNode;
            this._createBuffers();
            if (this._src) {
                var img = new Image();
                var that = this;
                img.onload = function () {
                    that.texture = renderNode.renderer.handler.createTextureDefault(this);
                };
                img.src = this._src;
            }
        }

        /**
         * Sets shape position.
         * @public
         * @param {Vec3} position - Shape position.
         */
        setPosition3v(position) {
            this.position.copy(position);
            this._mxTranslation.translateToPosition(position);
            this.refresh();
        }

        /**
         * Translate shape position to vector.
         * @public
         * @param {Vec3} vec - Translation vector.
         */
        translate3v(vec) {
            this.position.addA(vec);
            this._mxTranslation.translate(vec);
        }

        /**
         * Sets shape scale.
         * @param {Vec3} scale - Scale vector.
         */
        setScale3v(scale) {
            this.scale.copy(scale);
            this._mxScale.setIdentity().scale(scale);
        }

        setScale(scale) {
            this.scale.x = this.scale.y = this.scale.z = scale;
            this._mxScale.setIdentity().scale(this.scale);
        }

        /**
         * Removes shape from shape handler.
         * @public
         */
        remove() {
            this._entity = null;
            this._handler && this._handler.remove(this);
        }

        /**
         * Assign picking color.
         * @protected
         * @param {Vec3} color - Picking RGB color.
         */
        setPickingColor3v(color) {
            //...
            //TODO: check the renderer before
            //...
            this._pickingColor[0] = color.x / 255.0;
            this._pickingColor[1] = color.y / 255.0;
            this._pickingColor[2] = color.z / 255.0;
            this._pickingColor[3] = 1.0;
        }

        /**
         * Creates buffers.
         * @protected
         */
        _createBuffers() {
            this._deleteBuffers();
            var r = this._renderNode.renderer;
            this._positionBuffer = r.handler.createArrayBuffer(
                new Float32Array(this._positionData),
                3,
                this._positionData.length / 3
            );
            this._normalBuffer = r.handler.createArrayBuffer(
                new Float32Array(this._normalData),
                3,
                this._normalData.length / 3
            );
            this._indexBuffer = r.handler.createElementArrayBuffer(
                new Uint16Array(this._indexData),
                1,
                this._indexData.length
            );
            this._textureCoordBuffer = r.handler.createArrayBuffer(
                new Float32Array(this._textureCoordData),
                2,
                this._textureCoordData.length / 2
            );
        }

        /**
         * Update model matrix.
         * @public
         */
        refresh() {
            this._mxModel = this._mxTranslation.mul(this.orientation.getMat4().mul(this._mxScale));
        }

        /**
         * Shape rendering.
         * @public
         */
        draw() {
            if (this.visibility) {
                let rn = this._renderNode;
                let r = rn.renderer;

                let sh,
                    p,
                    gl = r.handler.gl,
                    sha,
                    shu;

                if (rn.lightEnabled) {
                    sh = r.handler.programs.shape_wl;
                    p = sh._program;
                    sha = p.attributes;
                    shu = p.uniforms;

                    sh.activate();

                    gl.uniform4fv(shu.lightsPositions, rn._lightsTransformedPositions);
                    gl.uniform3fv(shu.lightsParamsv, rn._lightsParamsv);
                    gl.uniform1fv(shu.lightsParamsf, rn._lightsParamsf);
                    gl.uniformMatrix4fv(
                        shu.projectionMatrix,
                        false,
                        r.activeCamera.getProjectionMatrix()
                    );
                    gl.uniformMatrix4fv(shu.viewMatrix, false, r.activeCamera.getViewMatrix());
                    gl.uniformMatrix3fv(shu.normalMatrix, false, r.activeCamera.getNormalMatrix());

                    gl.bindBuffer(gl.ARRAY_BUFFER, this._normalBuffer);
                    gl.vertexAttribPointer(
                        sha.aVertexNormal,
                        this._normalBuffer.itemSize,
                        gl.FLOAT,
                        false,
                        0,
                        0
                    );
                } else {
                    sh = r.handler.programs.shape_nl;
                    p = sh._program;
                    shu = p.uniforms;
                    sha = p.attributes;

                    sh.activate();

                    gl.uniformMatrix4fv(
                        shu.projectionViewMatrix,
                        false,
                        r.activeCamera.getProjectionViewMatrix()
                    );
                }

                gl.uniform4fv(shu.uColor, this.color);

                gl.bindBuffer(gl.ARRAY_BUFFER, this._positionBuffer);
                gl.vertexAttribPointer(
                    sha.aVertexPosition,
                    this._positionBuffer.itemSize,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.uniformMatrix4fv(shu.modelMatrix, false, this._mxModel._m);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.texture);
                gl.uniform1i(shu.uSampler, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, this._textureCoordBuffer);
                gl.vertexAttribPointer(
                    sha.aTextureCoord,
                    this._textureCoordBuffer.itemSize,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
                gl.drawElements(
                    r.handler.gl.TRIANGLES,
                    this._indexBuffer.numItems,
                    gl.UNSIGNED_SHORT,
                    0
                );
            }
        }

        drawPicking() {
            if (this.visibility) {
                let rn = this._renderNode;
                let r = rn.renderer;

                let sh,
                    p,
                    gl = r.handler.gl,
                    sha,
                    shu;

                sh = r.handler.programs.shape_picking;
                p = sh._program;
                shu = p.uniforms;
                sha = p.attributes;

                sh.activate();

                gl.uniformMatrix4fv(
                    shu.projectionViewMatrix,
                    false,
                    r.activeCamera.getProjectionViewMatrix()
                );

                gl.uniform4fv(shu.uColor, [
                    this._pickingColor[0],
                    this._pickingColor[1],
                    this._pickingColor[2],
                    1.0
                ]);

                gl.bindBuffer(gl.ARRAY_BUFFER, this._positionBuffer);
                gl.vertexAttribPointer(
                    sha.aVertexPosition,
                    this._positionBuffer.itemSize,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.uniformMatrix4fv(shu.modelMatrix, false, this._mxModel._m);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
                gl.drawElements(
                    r.handler.gl.TRIANGLES,
                    this._indexBuffer.numItems,
                    gl.UNSIGNED_SHORT,
                    0
                );
            }
        }
    }

    /**
     * @module og/shape/BaseShape
     */

    /**
     * @class
     * @extends {BaseShape}
     * @param {Object} options - Sphere parameters:
     * @param {Vec3} [options.position] - Sphere position.
     * @param {Quat} [options.orientation] - Sphere orientation(rotation).
     * @param {Vec3} [options.scale] - Scale vector.
     * @param {Array.<number>} [options.color] - Sphere RGBA color. (exactly 4 entries)
     * @param {string} [options.src] - Texture image url source.
     * @param {boolean} [options.visibility] - Sphere visibility.
     * @param {number} [options.radius=100] - Sphere radius.
     * @param {number} [options.latBands=16] - Number of latitude bands.
     * @param {number} [options.lonBands=16] - Number of longitude bands.
     */
    class Sphere extends BaseShape {
        constructor(options) {
            super(options);

            /**
             * Sphere radius.
             * @protected
             * @type {number}
             */
            this._radius = options.radius || 1;

            /**
             * Number of latitude bands.
             * @protected
             * @type {number}
             */
            this._latBands = options.latBands || 16;

            /**
             * Number of longitude bands.
             * @protected
             * @type {number}
             */
            this._lonBands = options.lonBands || 16;

            //BUG: virtual method in constructor
            this._createData();
        }

        /**
         * Create specific shape vertices data.
         * @protected
         * @virtual
         */
        _createData() {
            for (let latNumber = 0; latNumber <= this._latBands; latNumber++) {
                var theta = (latNumber * Math.PI) / this._latBands;
                var sinTheta = Math.sin(theta);
                var cosTheta = Math.cos(theta);

                for (let longNumber = 0; longNumber <= this._lonBands; longNumber++) {
                    var phi = (longNumber * 2 * Math.PI) / this._lonBands;
                    var sinPhi = Math.sin(phi);
                    var cosPhi = Math.cos(phi);
                    var x = cosPhi * sinTheta;
                    var y = cosTheta;
                    var z = sinPhi * sinTheta;
                    var u = 1 - longNumber / this._lonBands;
                    var v = latNumber / this._latBands;
                    this._normalData.push(x);
                    this._normalData.push(y);
                    this._normalData.push(z);
                    this._textureCoordData.push(u);
                    this._textureCoordData.push(v);
                    this._positionData.push(this._radius * x);
                    this._positionData.push(this._radius * y);
                    this._positionData.push(this._radius * z);
                }
            }

            for (let latNumber = 0; latNumber < this._latBands; latNumber++) {
                for (let longNumber = 0; longNumber < this._lonBands; longNumber++) {
                    var first = latNumber * (this._lonBands + 1) + longNumber;
                    var second = first + this._lonBands + 1;

                    this._indexData.push(first);
                    this._indexData.push(first + 1);
                    this._indexData.push(second);

                    this._indexData.push(second);
                    this._indexData.push(first + 1);
                    this._indexData.push(second + 1);
                }
            }
        }
    }

    /**
     * @module og/math/Line2
     */

    class Line2 {
        constructor(a = 0, b = 0, c = 0) {
            this.a = a;
            this.b = b;
            this.c = c;
        }

        static get(p0, p1) {
            return new Line2(p1.y - p0.y, p0.x - p1.x, p1.x * p0.y - p0.x * p1.y);
        }

        static getParallel(l, p) {
            return new Line2(l.a, l.b, -l.a * p.x - l.b * p.y);
        }

        static getIntersection(L0, L1) {
            var x = (L1.b * L0.c - L0.b * L1.c) / (L0.b * L1.a - L1.b * L0.a);
            return new Vec2(x, -(L0.c + L0.a * x) / L0.b);
        }

        intersects(l) {
            return Line2.getIntersection(this, l);
        }
    }

    /**
     * Plane class.
     * @constructor
     * @param {Vec3} [p] - Plane point.
     * @param {Vec3} [n] - Planet normal.
     */
    class Plane {
        constructor(p, n) {
            this.p = p ? p.clone() : new Vec3();
            this.n = n ? n.clone() : this.p.normal();
        }

        set(p, n) {
            this.p.copy(p);
            this.n.copy(n);
        }

        getNormal() {
            return this.n.clone();
        }

        distance(p) {
            let pp = this.getProjection(p);
            return p.distance(pp);
        }

        getProjection(v, def) {
            return Vec3.proj_b_to_plane(v, this.n, def);
        }

        getProjectionPoint(p, vh) {
            let v = p.sub(this.p),
                n = this.n,
                dist = v.dot(n);

            if (vh) {
                vh.copy(n.scale(dist));
            } else {
                vh = n.scale(dist);
            }
            return p.sub(vh);
        }

        getIntersection(Pn1, Pn2, L) {
            var u = Pn1.n.cross(Pn2.n);

            var ax = u.x >= 0 ? u.x : -u.x;
            var ay = u.y >= 0 ? u.y : -u.y;
            var az = u.z >= 0 ? u.z : -u.z;

            // test if the two planes are parallel
            if (ax + ay + az < EPSILON5) {
                // Pn1 and Pn2 are near parallel
                // test if disjoint or coincide
                var v = Pn2.p.sub(Pn1.p);
                if (Pn1.n.dot(v) == 0) {
                    // Pn2.V0 lies in Pn1
                    return 1; // Pn1 and Pn2 coincide
                } else {
                    return 0; // Pn1 and Pn2 are disjoint
                }
            }

            // Pn1 and Pn2 intersect in a line
            // first determine max abs coordinate of cross product
            var maxc; // max coordinate
            if (ax > ay) {
                if (ax > az) {
                    maxc = 1;
                } else {
                    maxc = 3;
                }
            } else {
                if (ay > az) {
                    maxc = 2;
                } else {
                    maxc = 3;
                }
            }

            // next, to get a point on the intersect line
            // zero the max coord, and solve for the other two
            var iP = new Vec3(); // intersect point

            var d1, d2; // the constants in the 2 plane equations
            d1 = -Pn1.n.dot(Pn1.p); // note: could be pre-stored  with plane
            d2 = -Pn2.n.dot(Pn2.p); // ditto

            // select max coordinate
            if (maxc === 1) {
                // intersect with x=0
                iP.x = 0;
                iP.y = (d2 * Pn1.n.z - d1 * Pn2.n.z) / u.x;
                iP.z = (d1 * Pn2.n.y - d2 * Pn1.n.y) / u.x;
            } else if (maxc === 2) {
                // intersect with y=0
                iP.x = (d1 * Pn2.n.z - d2 * Pn1.n.z) / u.y;
                iP.y = 0;
                iP.z = (d2 * Pn1.n.x - d1 * Pn2.n.x) / u.y;
            } else if (maxc === 3) {
                // intersect with z=0
                iP.x = (d2 * Pn1.n.y - d1 * Pn2.n.y) / u.z;
                iP.y = (d1 * Pn2.n.x - d2 * Pn1.n.x) / u.z;
                iP.z = 0;
            }
            L.p0.copy(iP);
            L.p1.copy(iP.add(u));
            return 2;
        }
    }

    /**
     * @module og/webgl/types
     */

    let _declarations = [
        "FLOAT", "DOUBLE", "BOOL", "INT", "UINT",
        "VEC2", "VEC3", "VEC4", "DVEC2",
        "DVEC3", "DVEC4",
        "BVEC2", "BVEC3", "BVEC4",
        "IVEC2", "IVEC3", "IVEC4",
        "UVEC2", "UVEC3", "UVEC4",
        "MAT2", "DMAT2", "MAT3", "DMAT3", "MAT4", "DMAT4",
        "MAT2X3", "MAT2X4", "MAT3X2", "MAT3X4", "MAT4X2",
        "MAT4X3", "DMAT2X3", "DMAT2X4", "DMAT3X2", "DMAT3X4",
        "DMAT4X2", "DMAT4X3",
        "SAMPLER1D", "SAMPLER2D", "SAMPLER3D", "SAMPLERCUBE", "SAMPLER2DSHADOW",
        "SAMPLER2DARRAY",
        "INTXX", "FLOATXX"];

    const types$1 = {};

    for (let i = 0; i < _declarations.length; i++) {
        types$1[_declarations[i]] = i;
    }

    const typeStr = {};
    for (let i = 0; i < _declarations.length; i++) {
        typeStr[_declarations[i].toLowerCase()] = types$1[_declarations[i]];
    }

    /**
     * @module og/webgl/callbacks
     */

    /*=========================
       Uniforms callbacks
     =========================*/
    const callbacks = {
        u: [],
        a: []
    };

    callbacks.u[types$1.MAT4] = function (program, variable) {
        program.gl.uniformMatrix4fv(variable._pName, false, variable.value);
    };

    callbacks.u[types$1.MAT3] = function (program, variable) {
        program.gl.uniformMatrix3fv(variable._pName, false, variable.value);
    };

    callbacks.u[types$1.FLOAT] = function (program, variable) {
        program.gl.uniform1f(variable._pName, variable.value);
    };

    callbacks.u[types$1.INT] = function (program, variable) {
        program.gl.uniform1i(variable._pName, variable.value);
    };

    callbacks.u[types$1.VEC2] = function (program, variable) {
        program.gl.uniform2fv(variable._pName, variable.value);
    };

    callbacks.u[types$1.VEC3] = function (program, variable) {
        program.gl.uniform3fv(variable._pName, variable.value);
    };

    callbacks.u[types$1.VEC4] = function (program, variable) {
        program.gl.uniform4fv(variable._pName, variable.value);
    };

    callbacks.u[types$1.SAMPLER2D] = function (program, variable) {
        let pgl = program.gl;
        pgl.activeTexture(pgl.TEXTURE0 + program._textureID);
        pgl.bindTexture(pgl.TEXTURE_2D, variable.value);
        pgl.uniform1i(variable._pName, program._textureID);
        program._textureID++;
    };

    callbacks.u[types$1.SAMPLERCUBE] = function (program, variable) {
        let pgl = program.gl;
        pgl.activeTexture(pgl.TEXTURE0 + program._textureID);
        pgl.bindTexture(pgl.TEXTURE_CUBE_MAP, variable.value);
        pgl.uniform1i(variable._pName, program._textureID);
        program._textureID++;
    };

    callbacks.u[types$1.SAMPLER2DARRAY] = function (program, variable) {
        let pgl = program.gl,
            size = variable.value.length;
        let samplerArr = new Int32Array(size);
        for (let i = 0; i < size; i++) {
            pgl.activeTexture(pgl.TEXTURE0 + program._textureID + i);
            pgl.bindTexture(pgl.TEXTURE_2D, variable.value[i]);
            samplerArr[i] = i;
        }
        pgl.uniform1iv(variable._pName, samplerArr);
    };

    callbacks.u[types$1.INTXX] = function (program, variable) {
        program.gl.uniform1iv(variable._pName, variable.value);
    };

    callbacks.u[types$1.FLOATXX] = function (program, variable) {
        program.gl.uniform1fv(variable._pName, variable.value);
    };

    /*========================
       Attributes callbacks
     ========================*/
    callbacks.a[types$1.FLOAT] = function (program, variable) {
        program.gl.vertexAttrib1f(variable._pName, variable.value);
    };

    callbacks.a[types$1.VEC2] = function (program, variable) {
        program.gl.vertexAttrib2fv(variable._pName, variable.value);
    };

    callbacks.a[types$1.VEC3] = function (program, variable) {
        program.gl.vertexAttrib3fv(variable._pName, variable.value);
    };

    //callbacks.a[types.VEC4] = function (program, variable) {
    //    program.gl.vertexAttrib4fv(variable._pName, variable.value);
    //};

    /**
     * Console logging singleton object.
     * @class
     */
    class Cons {
        constructor() {
            this._container = document.createElement("div");
            this._container.classList.add("ogConsole");
            this._container.style.display = "none";
            if (document.body) {
                document.body.appendChild(this._container);
            }

            this._visibility = false;
        }

        getVisibility() {
            return this._visibility;
        }

        setVisibility(visibility) {
            if (this._visibility != visibility) {
                this._visibility = visibility;
                if (this._visibility) {
                    this.show();
                } else {
                    this.hide();
                }
            }
        }

        /**
         * Show console panel.
         * @public
         */
        show() {
            if (!this._container.parentNode) {
                if (document.body) {
                    document.body.appendChild(this._container);
                }
            }
            this._container.style.display = "block";
            this._visibility = true;
        }

        /**
         * Hide console panel.
         * @public
         */
        hide() {
            this._container.style.display = "none";
            this._visibility = false;
        }

        /**
         * Adds error text in the console.
         * @public
         * @param {string} str - Error text.
         */
        logErr(str) {
            var d = document.createElement("div");
            d.classList.add("ogConsole-text");
            d.classList.add("ogConsole-error");
            d.innerHTML = "error: " + str;
            console.log(d.innerHTML);
            this._container.appendChild(d);
            this.show();
        }

        /**
         * Adds warning text in the console.
         * @public
         * @param {string} str - Warning text.
         */
        logWrn(str) {
            var d = document.createElement("div");
            d.classList.add("ogConsole-text");
            d.classList.add("ogConsole-warning");
            d.innerHTML = "warning: " + str;
            console.log(d.innerHTML);
            this._container.appendChild(d);
            this.show();
        }

        /**
         * Adds log text in the console.
         * @public
         * @param {string} str - Log text.
         * @param {Object} [style] - HTML style.
         */
        log(str, style) {
            var d = document.createElement("div");
            d.classList.add("ogConsole-text");
            if (style) {
                for (var s in style) {
                    d.style[s] = style[s];
                }
            }
            d.innerHTML = str;
            console.log(str);
            this._container.appendChild(d);
            this.show();
        }
    }

    const cons = new Cons();

    /**
     * @module og/webgl/Program
     */

    const itemTypes = ["BYTE", "SHORT", "UNSIGNED_BYTE", "UNSIGNED_SHORT", "FLOAT", "HALF_FLOAT"];

    /**
     * Represents more comfortable using WebGL shader program.
     * @class
     * @param {string} name - Shader program name identificator.
     * @param {object} material - Object stores uniforms, attributes and program codes:
     * @param {object} material.uniforms - Uniforms definition section.
     * @param {object} material.attributes - Attributes definition section.
     * @param {string} material.vertexShader - Vertex glsl code.
     * @param {string} material.fragmentShader - Fragment glsl code.
     */
    class Program {
        constructor(name, material) {
            /**
             * Shader progarm name.
             * @public
             * @type {string}
             */
            this.name = name;

            this.attributes = {};
            this.uniforms = {};

            /**
             * Attributes.
             * @public
             * @type {Object}
             */
            this._attributes = {};
            for (let t in material.attributes) {
                if (
                    typeof material.attributes[t] === "string" ||
                    typeof material.attributes[t] === "number"
                ) {
                    this._attributes[t] = { type: material.attributes[t] };
                } else {
                    this._attributes[t] = material.attributes[t];
                }
            }

            /**
             * Uniforms.
             * @public
             * @type {Object}
             */
            this._uniforms = {};
            for (let t in material.uniforms) {
                if (
                    typeof material.uniforms[t] === "string" ||
                    typeof material.uniforms[t] === "number"
                ) {
                    this._uniforms[t] = { type: material.uniforms[t] };
                } else {
                    this._uniforms[t] = material.uniforms[t];
                }
            }

            /**
             * Vertex shader.
             * @public
             * @type {string}
             */
            this.vertexShader = material.vertexShader;

            /**
             * Fragment shader.
             * @public
             * @type {string}
             */
            this.fragmentShader = material.fragmentShader;

            /**
             * Webgl context.
             * @public
             * @type {Object}
             */
            this.gl = null;

            /**
             * All program variables.
             * @private
             * @type {Object}
             */
            this._variables = {};

            /**
             * Program pointer.
             * @private
             * @type {Object}
             */
            this._p = null;

            /**
             * Texture counter.
             * @prvate
             * @type {number}
             */
            this._textureID = 0;

            /**
             * Program attributes array.
             * @private
             * @type {Array.<Object>}
             */
            this._attribArrays = [];

            /**
             * Program attributes divisor.
             * @private
             * @type {Array.<Object>}
             */
            this._attribDivisor = [];

        }

        /**
         * Bind program buffer.
         * @function
         * @param {Program} program - Used program.
         * @param {Object} variable - Variable represents buffer data.
         */
        static bindBuffer(program, variable) {
            var gl = program.gl;
            gl.bindBuffer(gl.ARRAY_BUFFER, variable.value);
            gl.vertexAttribPointer(
                variable._pName,
                variable.value.itemSize,
                variable.itemType,
                variable.normalized,
                0,
                0
            );
        }

        /**
         * Sets the current program frame.
         * @public
         */
        use() {
            this.gl.useProgram(this._p);
        }

        /**
         * Sets program variables.
         * @public
         * @param {Object} material - Variables and values object.
         */
        set(material) {
            this._textureID = 0;
            for (var i in material) {
                this._variables[i].value = material[i];
                this._variables[i]._callback(this, this._variables[i]);
            }
        }

        /**
         * Apply current variables.
         * @public
         */
        apply() {
            this._textureID = 0;
            var v = this._variables;
            for (var i in v) {
                v[i]._callback(this, v[i]);
            }
        }

        /**
         * Calls drawElements index buffer function.
         * @public
         * @param {number} mode - Draw mode(GL_TRIANGLES, GL_LINESTRING etc.).
         * @param {Object} buffer - Index buffer.
         */
        drawIndexBuffer(mode, buffer) {
            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, buffer);
            this.gl.drawElements(mode, buffer.numItems, this.gl.UNSIGNED_SHORT, 0);
        }

        /**
         * Calls drawArrays function.
         * @public
         * @param {number} mode - Draw mode(GL_TRIANGLES, GL_LINESTRING etc.).
         * @param {number} numItems - Curent binded buffer drawing items count.
         */
        drawArrays(mode, numItems) {
            this.gl.drawArrays(mode, 0, numItems);
        }

        /**
         * Check and log for an shader compile errors and warnings. Returns True - if no errors otherwise returns False.
         * @private
         * @param {Object} shader - WebGl shader program.
         * @param {string} src - Shader program source.
         * @returns {boolean} -
         */
        _getShaderCompileStatus(shader, src) {
            this.gl.shaderSource(shader, src);
            this.gl.compileShader(shader);
            if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                cons.logErr(
                    "og/Program/Program:" + this.name + " - " + this.gl.getShaderInfoLog(shader) + "."
                );
                return false;
            }
            return true;
        }

        /**
         * Returns compiled vertex shader program pointer.
         * @private
         * @param {string} src - Vertex shader source code.
         * @returns {Object} -
         */
        _createVertexShader(src) {
            var shader = this.gl.createShader(this.gl.VERTEX_SHADER);
            if (!this._getShaderCompileStatus(shader, src)) {
                return null;
            }
            return shader;
        }

        /**
         * Returns compiled fragment shader program pointer.
         * @private
         * @param {string} src - Vertex shader source code.
         * @returns {Object} -
         */
        _createFragmentShader(src) {
            var shader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
            if (!this._getShaderCompileStatus(shader, src)) {
                return null;
            }
            return shader;
        }

        /**
         * Disable current program vertexAttribArrays.
         * @public
         */
        disableAttribArrays() {
            var gl = this.gl;
            var a = this._attribArrays;
            for (let i = 0, len = a.length; i < len; i++) {
                gl.disableVertexAttribArray(a[i]);
                this.vertexAttribDivisor(a[i], 0);
            }
        }

        /**
         * Enable current program vertexAttribArrays.
         * @public
         */
        enableAttribArrays() {
            var gl = this.gl;
            var a = this._attribArrays;
            var d = this._attribDivisor;
            for (let i = 0, len = a.length; i < len; i++) {
                gl.enableVertexAttribArray(a[i]);
                this.vertexAttribDivisor(a[i], d[i]);
            }
        }

        vertexAttribDivisor(index, divisor) {
            const gl = this.gl;
            gl.vertexAttribDivisor ? gl.vertexAttribDivisor(index, divisor) : gl.getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(index, divisor);
        }

        /**
         * Delete program.
         * @public
         */
        delete() {
            this.gl.deleteProgram(this._p);
        }

        /**
         * Creates program.
         * @public
         * @param {Object} gl - WebGl context.
         */
        createProgram(gl) {
            this.gl = gl;
            this._p = this.gl.createProgram();

            var fs = this._createFragmentShader(this.fragmentShader);
            var vs = this._createVertexShader(this.vertexShader);
            gl.attachShader(this._p, fs);
            gl.attachShader(this._p, vs);
            gl.linkProgram(this._p);

            if (!this.drawElementsInstanced) {
                this.drawElementsInstanced = gl.drawElementsInstanced ? gl.drawElementsInstanced.bind(gl) : gl.getExtension('ANGLE_instanced_arrays').drawElementsInstancedANGLE.bind(gl.getExtension('ANGLE_instanced_arrays'));
            }

            if (!this.vertexAttribDivisor) {
                this.vertexAttribDivisor = gl.vertexAttribDivisor ? gl.vertexAttribDivisor.bind(gl) : gl.getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE.bind(gl.getExtension('ANGLE_instanced_arrays'));
            }


            if (!gl.getProgramParameter(this._p, gl.LINK_STATUS)) {
                cons.logErr(
                    "og/Program/Program:" +
                    this.name +
                    " - couldn't initialise shaders. " +
                    gl.getProgramInfoLog(this._p) +
                    "."
                );
                gl.deleteProgram(this._p);
                return;
            }

            this.use();

            for (var a in this._attributes) {
                //this.attributes[a]._name = a;
                this._variables[a] = this._attributes[a];

                this._attributes[a]._callback = Program.bindBuffer;

                let itemTypeStr = this._attributes[a].itemType
                    ? this._attributes[a].itemType.trim().toUpperCase()
                    : "FLOAT";

                if (itemTypes.indexOf(itemTypeStr) == -1) {
                    cons.logErr(
                        `og/Program/Program: ${this.name}- attribute '${a}', item type ${this._attributes[a].itemType} not exists.`
                    );
                    this._attributes[a].itemType = gl.FLOAT;
                } else {
                    this._attributes[a].itemType = gl[itemTypeStr];
                }

                this._attributes[a].normalized = this._attributes[a].normalized || false;
                this._attributes[a].divisor = this._attributes[a].divisor || 0;

                this._p[a] = gl.getAttribLocation(this._p, a);

                if (this._p[a] == undefined) {
                    cons.logErr(
                        "og/Program/Program:" + this.name + " - attribute '" + a + "' is not exists."
                    );
                    gl.deleteProgram(this._p);
                    return;
                }

                let type = this._attributes[a].type;
                if (typeof type === "string") {
                    type = typeStr[type.trim().toLowerCase()];
                }

                let d = this._attributes[a].divisor;
                if (type === types$1.MAT4) {
                    let loc = this._p[a];
                    this._attribArrays.push(loc, loc + 1, loc + 2, loc + 3);
                    this._attribDivisor.push(d, d, d, d);
                } else {
                    this._attribArrays.push(this._p[a]);
                    this._attribDivisor.push(d);
                }

                gl.enableVertexAttribArray(this._p[a]);

                this._attributes[a]._pName = this._p[a];
                this.attributes[a] = this._p[a];
            }

            for (var u in this._uniforms) {
                //this.uniforms[u]._name = u;

                if (typeof this._uniforms[u].type === "string") {
                    this._uniforms[u]._callback =
                        callbacks.u[typeStr[this._uniforms[u].type.trim().toLowerCase()]];
                } else {
                    this._uniforms[u]._callback = callbacks.u[this._uniforms[u].type];
                }

                this._variables[u] = this._uniforms[u];
                this._p[u] = gl.getUniformLocation(this._p, u);

                if (this._p[u] == undefined) {
                    cons.logErr(
                        "og/Program/Program:" + this.name + " - uniform '" + u + "' is not exists."
                    );
                    gl.deleteProgram(this._p);
                    return;
                }

                this._uniforms[u]._pName = this._p[u];
                this.uniforms[u] = this._p[u];
            }

            gl.detachShader(this._p, fs);
            gl.detachShader(this._p, vs);

            gl.deleteShader(fs);
            gl.deleteShader(vs);
        }
    }

    /**
     * @module og/shaders/drawnode
     */

    // REMEMBER!
    // src*(1)+dest*(1-src.alpha)
    // glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
    // src*(src.alpha)+dest*(1-src.alpha)
    // glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);


    const NIGHT$1 = `const vec3 nightStep = 10.0 * vec3(0.58, 0.48, 0.25);`;

    const DEF_BLEND = `#define blend(DEST, SAMPLER, OFFSET, OPACITY) \
                    src = texture( SAMPLER, OFFSET.xy + vTextureCoord.xy * OFFSET.zw ); \
                    DEST = DEST * (1.0 - src.a * OPACITY) + src * OPACITY;`;

    const DEF_BLEND_WEBGL1 = `#define blend(DEST, SAMPLER, OFFSET, OPACITY) \
                            src = texture2D( SAMPLER, OFFSET.xy + vTextureCoord.xy * OFFSET.zw ); \
                            DEST = DEST * (1.0 - src.a * OPACITY) + src * OPACITY;`;

    const DEF_BLEND_PICKING = `#define blendPicking(DEST, OFFSET, SAMPLER, MASK, COLOR, OPACITY) \
    tc = OFFSET.xy + vTextureCoord.xy * OFFSET.zw; \
    t = texture2D(SAMPLER, tc); \
    p = texture2D(MASK, tc); \
    DEST = mix(DEST, vec4(max(COLOR.rgb, p.rgb), OPACITY), (t.a == 0.0 ? 0.0 : 1.0) * COLOR.a);`;


    const SLICE_SIZE = 4;

    function drawnode_screen_nl() {
        return new Program("drawnode_screen_nl", {
            uniforms: {
                projectionMatrix: "mat4",
                viewMatrix: "mat4",
                eyePositionHigh: "vec3",
                eyePositionLow: "vec3",
                samplerCount: "int",
                tileOffsetArr: "vec4",
                layerOpacityArr: "float",
                samplerArr: "sampler2darray",
                defaultTexture: "sampler2d",
                height: "float"
            },
            attributes: {
                aVertexPositionHigh: "vec3",
                aVertexPositionLow: "vec3",
                aTextureCoord: "vec2"
            },

            vertexShader: `attribute vec3 aVertexPositionHigh;
            attribute vec3 aVertexPositionLow;
            attribute vec2 aTextureCoord;

            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float height;

            varying vec2 vTextureCoord;

            void main(void) {
                vTextureCoord = aTextureCoord;

                vec3 aVertexPosition = aVertexPositionHigh + aVertexPositionLow;
                vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                vec3 lowDiff = aVertexPositionLow + normalize(aVertexPosition) * height - eyePositionLow;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
            }`,

            fragmentShader: `precision highp float;
            #define SLICE_SIZE ${SLICE_SIZE + 1}
            uniform vec4 tileOffsetArr[SLICE_SIZE];
            uniform float layerOpacityArr[SLICE_SIZE];
            uniform sampler2D defaultTexture;
            uniform sampler2D samplerArr[SLICE_SIZE];
            uniform int samplerCount;
            varying vec2 vTextureCoord;

            ${DEF_BLEND_WEBGL1}

            void main(void) {
                gl_FragColor = texture2D( defaultTexture, vTextureCoord );
                if( samplerCount == 0 ) return;

                vec4 src;

                blend(gl_FragColor, samplerArr[0], tileOffsetArr[0], layerOpacityArr[0]);
                if( samplerCount == 1 ) return;

                blend(gl_FragColor, samplerArr[1], tileOffsetArr[1], layerOpacityArr[1]);
                if( samplerCount == 2 ) return;

                blend(gl_FragColor, samplerArr[2], tileOffsetArr[2], layerOpacityArr[2]);
                if( samplerCount == 3 ) return;

                blend(gl_FragColor, samplerArr[3], tileOffsetArr[3], layerOpacityArr[3]);
                if( samplerCount == 4 ) return;

                blend(gl_FragColor, samplerArr[4], tileOffsetArr[4], layerOpacityArr[4]);
            }`
        });
    }

    function drawnode_screen_wl() {
        return new Program("drawnode_screen_wl", {
            uniforms: {
                projectionMatrix: "mat4",
                viewMatrix: "mat4",
                eyePositionHigh: "vec3",
                eyePositionLow: "vec3",
                height: "float",

                uGlobalTextureCoord: "vec4",
                uNormalMapBias: "vec3",

                samplerCount: "int",
                tileOffsetArr: "vec4",
                layerOpacityArr: "float",
                samplerArr: "sampler2darray",
                defaultTexture: "sampler2d",
                normalMatrix: "mat3",
                uNormalMap: "sampler2d",
                nightTexture: "sampler2d",
                specularTexture: "sampler2d",
                lightsPositions: "vec4",
                diffuse: "vec3",
                ambient: "vec3",
                specular: "vec4"
            },
            attributes: {
                aVertexPositionHigh: "vec3",
                aVertexPositionLow: "vec3",
                aTextureCoord: "vec2"
            },

            vertexShader: `attribute vec3 aVertexPositionHigh;
            attribute vec3 aVertexPositionLow;
            attribute vec2 aTextureCoord;

            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform float height;
            uniform vec4 uGlobalTextureCoord;
            uniform vec3 uNormalMapBias;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;

            varying vec4 vTextureCoord;
            varying vec2 vGlobalTextureCoord;
            varying vec4 v_vertex;
            varying float v_height;           

            void main(void) {

                vec3 aVertexPosition = aVertexPositionHigh + aVertexPositionLow;
                vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                vec3 lowDiff = aVertexPositionLow + normalize(aVertexPosition) * height - eyePositionLow;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                v_height = height;
                vec3 heightVertex = aVertexPosition + normalize(aVertexPosition) * height;
                v_vertex = viewMatrix * vec4(heightVertex, 1.0);
                vTextureCoord.xy = aTextureCoord;
                vGlobalTextureCoord = uGlobalTextureCoord.xy + (uGlobalTextureCoord.zw - uGlobalTextureCoord.xy) * aTextureCoord;
                vTextureCoord.zw = uNormalMapBias.z * ( aTextureCoord + uNormalMapBias.xy );
                gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
            }`,

            fragmentShader: `precision highp float;

            #define MAX_POINT_LIGHTS 1
            #define SLICE_SIZE ${SLICE_SIZE + 1}

            uniform vec3 diffuse;
            uniform vec3 ambient;
            uniform vec4 specular;

            uniform sampler2D uNormalMap;
            uniform vec4 lightsPositions[MAX_POINT_LIGHTS];
            uniform mat3 normalMatrix;
            uniform sampler2D nightTexture;
            uniform sampler2D specularTexture;

            uniform vec4 tileOffsetArr[SLICE_SIZE];
            uniform float layerOpacityArr[SLICE_SIZE];

            uniform sampler2D defaultTexture;
            uniform sampler2D samplerArr[SLICE_SIZE];
            uniform int samplerCount;

            varying vec4 vTextureCoord;
            varying vec2 vGlobalTextureCoord;
            varying vec4 v_vertex;
            varying float v_height;

            ${NIGHT$1}

            ${DEF_BLEND_WEBGL1}

            float shininess;
            float reflection;
            float diffuseLightWeighting;
            vec3 night;

            void main(void) {
            
                float overGround = 1.0 - step(0.1, v_height);
                vec3 normal = normalize(normalMatrix * ((texture2D(uNormalMap, vTextureCoord.zw).rgb - 0.5) * 2.0));
                vec3 lightDirection = normalize(lightsPositions[0].xyz - v_vertex.xyz * lightsPositions[0].w);
                vec3 eyeDirection = normalize(-v_vertex.xyz);
                vec3 reflectionDirection = reflect(-lightDirection, normal);
                vec4 nightImageColor = texture2D( nightTexture, vGlobalTextureCoord.st );
                shininess = texture2D( specularTexture, vGlobalTextureCoord.st ).r * 255.0 * overGround;
                reflection = max( dot(reflectionDirection, eyeDirection), 0.0);
                diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);
                night = nightStep * (.18 - diffuseLightWeighting * 3.0) * nightImageColor.rgb;
                night *= overGround * step(0.0, night);

                vec3 spec = specular.rgb * pow( reflection, specular.w) * shininess;
                vec4 lightWeighting = vec4(ambient + diffuse * diffuseLightWeighting + spec + night, 1.0);

                gl_FragColor = texture2D( defaultTexture, vTextureCoord.xy );
                if( samplerCount == 0 ) {
                    gl_FragColor *= lightWeighting;
                    return;
                }
    
                vec4 src;

                blend(gl_FragColor, samplerArr[0], tileOffsetArr[0], layerOpacityArr[0]);
                if( samplerCount == 1 ) {
                    gl_FragColor *= lightWeighting;
                    return;
                }

                blend(gl_FragColor, samplerArr[1], tileOffsetArr[1], layerOpacityArr[1]);
                if( samplerCount == 2 ) {
                    gl_FragColor *= lightWeighting;
                    return;
                }

                blend(gl_FragColor, samplerArr[2], tileOffsetArr[2], layerOpacityArr[2]);
                if( samplerCount == 3 ) {
                    gl_FragColor *= lightWeighting;
                    return;
                }

                blend(gl_FragColor, samplerArr[3], tileOffsetArr[3], layerOpacityArr[3]);
                if( samplerCount == 4 ) {
                    gl_FragColor *= lightWeighting;
                    return;
                }

                blend(gl_FragColor, samplerArr[4], tileOffsetArr[4], layerOpacityArr[4]);
                gl_FragColor *= lightWeighting;
            }`
        });
    }

    function drawnode_screen_wl_webgl2() {
        return new Program("drawnode_screen_wl", {
            uniforms: {
                projectionMatrix: "mat4",
                viewMatrix: "mat4",
                eyePositionHigh: "vec3",
                eyePositionLow: "vec3",
                height: "float",

                uGlobalTextureCoord: "vec4",
                uNormalMapBias: "vec3",

                samplerCount: "int",
                tileOffsetArr: "vec4",
                layerOpacityArr: "float",
                samplerArr: "sampler2darray",
                defaultTexture: "sampler2d",
                normalMatrix: "mat3",
                uNormalMap: "sampler2d",
                nightTexture: "sampler2d",
                specularTexture: "sampler2d",
                lightsPositions: "vec4",
                diffuse: "vec3",
                ambient: "vec3",
                specular: "vec4"
            },
            attributes: {
                aVertexPositionHigh: "vec3",
                aVertexPositionLow: "vec3",
                aTextureCoord: "vec2"
            },

            vertexShader: `#version 300 es

            in vec3 aVertexPositionHigh;
            in vec3 aVertexPositionLow;
            in vec2 aTextureCoord;

            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform float height;
            uniform vec4 uGlobalTextureCoord;
            uniform vec3 uNormalMapBias;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;

            out vec4 vTextureCoord;
            out vec2 vGlobalTextureCoord;
            out vec4 v_vertex;
            out float v_height;

            void main(void) {

                vec3 aVertexPosition = aVertexPositionHigh + aVertexPositionLow;
                vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                vec3 lowDiff = aVertexPositionLow + normalize(aVertexPosition) * height - eyePositionLow;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                v_height = height;
                vec3 heightVertex = aVertexPosition + normalize(aVertexPosition) * height;
                v_vertex = viewMatrix * vec4(heightVertex, 1.0);
                vTextureCoord.xy = aTextureCoord;
                vGlobalTextureCoord = uGlobalTextureCoord.xy + (uGlobalTextureCoord.zw - uGlobalTextureCoord.xy) * aTextureCoord;
                vTextureCoord.zw = uNormalMapBias.z * ( aTextureCoord + uNormalMapBias.xy );
                gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
            }`,

            fragmentShader: `#version 300 es

            precision highp float;

            #define MAX_POINT_LIGHTS 1
            #define SLICE_SIZE ${SLICE_SIZE + 1}

            uniform vec3 diffuse;
            uniform vec3 ambient;
            uniform vec4 specular;

            uniform sampler2D uNormalMap;
            uniform vec4 lightsPositions[MAX_POINT_LIGHTS];
            uniform mat3 normalMatrix;
            uniform sampler2D nightTexture;
            uniform sampler2D specularTexture;

            uniform vec4 tileOffsetArr[SLICE_SIZE];
            uniform float layerOpacityArr[SLICE_SIZE];

            uniform sampler2D defaultTexture;
            uniform sampler2D samplerArr[SLICE_SIZE];
            uniform int samplerCount;

            in vec4 vTextureCoord;
            in vec2 vGlobalTextureCoord;
            in vec4 v_vertex;
            in float v_height;

            float shininess;
            float reflection;
            float diffuseLightWeighting;
            vec3 night;

            layout(location = 0) out vec4 fragColor;

            ${NIGHT$1}

            ${DEF_BLEND}

            void main(void) {

                float overGround = 1.0 - step(0.1, v_height);
                vec3 normal = normalize(normalMatrix * ((texture(uNormalMap, vTextureCoord.zw).rgb - 0.5) * 2.0));
                vec3 lightDirection = normalize(lightsPositions[0].xyz - v_vertex.xyz * lightsPositions[0].w);
                vec3 eyeDirection = normalize(-v_vertex.xyz);
                vec3 reflectionDirection = reflect(-lightDirection, normal);
                vec4 nightImageColor = texture( nightTexture, vGlobalTextureCoord.st );

                shininess = texture( specularTexture, vGlobalTextureCoord.st ).r * 255.0 * overGround;
                reflection = max( dot(reflectionDirection, eyeDirection), 0.0);
                diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);
                night = nightStep * (.18 - diffuseLightWeighting * 3.0) * nightImageColor.rgb;
                night *= overGround * step(0.0, night);

                vec3 spec = specular.rgb * pow( reflection, specular.w) * shininess;
                vec4 lightWeighting = vec4(ambient + diffuse * diffuseLightWeighting + spec + night, 1.0);

                fragColor = texture( defaultTexture, vTextureCoord.xy );
                if( samplerCount == 0 ) {
                    fragColor *= lightWeighting;
                    return;
                }

                vec4 src;

                blend(fragColor, samplerArr[0], tileOffsetArr[0], layerOpacityArr[0]);
                if( samplerCount == 1 ) {
                    fragColor *= lightWeighting;
                    return;
                }

                blend(fragColor, samplerArr[1], tileOffsetArr[1], layerOpacityArr[1]);
                if( samplerCount == 2 ) {
                    fragColor *= lightWeighting;
                    return;
                }

                blend(fragColor, samplerArr[2], tileOffsetArr[2], layerOpacityArr[2]);
                if( samplerCount == 3 ) {
                    fragColor *= lightWeighting;
                    return;
                }

                blend(fragColor, samplerArr[3], tileOffsetArr[3], layerOpacityArr[3]);
                if( samplerCount == 4 ) {
                    fragColor *= lightWeighting;
                    return;
                }

                blend(fragColor, samplerArr[4], tileOffsetArr[4], layerOpacityArr[4]);
                fragColor *= lightWeighting;
            }`
        });
    }

    function drawnode_colorPicking() {
        return new Program("drawnode_colorPicking", {
            uniforms: {
                projectionMatrix: "mat4",
                viewMatrix: "mat4",
                eyePositionHigh: "vec3",
                eyePositionLow: "vec3",
                samplerCount: "int",
                tileOffsetArr: "vec4",
                samplerArr: "sampler2darray",
                pickingMaskArr: "sampler2darray",
                pickingColorArr: "vec4",
                height: "float"
            },
            attributes: {
                aVertexPositionHigh: "vec3",
                aVertexPositionLow: "vec3",
                aTextureCoord: "vec2"
            },

            vertexShader: `attribute vec3 aVertexPositionHigh;
            attribute vec3 aVertexPositionLow;
            attribute vec2 aTextureCoord;

            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float height;

            varying vec2 vTextureCoord;

            void main(void) {

                vec3 aVertexPosition = aVertexPositionHigh + aVertexPositionLow;
                vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                vec3 lowDiff = aVertexPositionLow + normalize(aVertexPosition) * height - eyePositionLow;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                vTextureCoord = aTextureCoord;
                gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
            }`,

            fragmentShader: `precision highp float;
            #define SLICE_SIZE ${SLICE_SIZE + 1}
            uniform vec4 tileOffsetArr[SLICE_SIZE];
            uniform vec4 pickingColorArr[SLICE_SIZE];
            uniform sampler2D samplerArr[SLICE_SIZE];
            uniform sampler2D pickingMaskArr[SLICE_SIZE];
            uniform int samplerCount;
            varying vec2 vTextureCoord;

            ${DEF_BLEND_PICKING}

            void main(void) {
                gl_FragColor = vec4(0.0);
                if( samplerCount == 0 ) return;

                vec2 tc;
                vec4 t;
                vec4 p;

                blendPicking(gl_FragColor, tileOffsetArr[0], samplerArr[0], pickingMaskArr[0], pickingColorArr[0], 1.0);
                if( samplerCount == 1 ) return;

                blendPicking(gl_FragColor, tileOffsetArr[1], samplerArr[1], pickingMaskArr[1], pickingColorArr[1], 1.0);
                if( samplerCount == 2 ) return;

                blendPicking(gl_FragColor, tileOffsetArr[2], samplerArr[2], pickingMaskArr[2], pickingColorArr[2], 1.0);
                if( samplerCount == 3 ) return;

                blendPicking(gl_FragColor, tileOffsetArr[3], samplerArr[3], pickingMaskArr[3], pickingColorArr[3], 1.0);
                if( samplerCount == 4 ) return;

                blendPicking(gl_FragColor, tileOffsetArr[4], samplerArr[4], pickingMaskArr[4], pickingColorArr[4], 1.0);
            }`
        });
    }

    function drawnode_heightPicking() {
        return new Program("drawnode_heightPicking", {
            uniforms: {
                projectionMatrix: "mat4",
                viewMatrix: "mat4",
                height: "float",
                eyePositionHigh: "vec3",
                eyePositionLow: "vec3"
            },
            attributes: {
                aVertexPositionHigh: "vec3",
                aVertexPositionLow: "vec3"
            },

            vertexShader: `attribute vec3 aVertexPositionHigh;
            attribute vec3 aVertexPositionLow;

            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform float height;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;

            varying float range;

            void main(void) {

                vec3 cameraPosition = eyePositionHigh + eyePositionLow;
                vec3 aVertexPosition = aVertexPositionHigh + aVertexPositionLow;

                vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                vec3 lowDiff = aVertexPositionLow + normalize(aVertexPosition) * height - eyePositionLow;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                range = distance(cameraPosition, aVertexPosition + normalize(aVertexPosition) * height);
                gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
            }`,

            fragmentShader: `precision highp float;

            varying float range;

            vec3 encode24(highp float f) {
                float F = abs(f);
                float s = step( 0.0, -f );
                float e = floor( log2(F) );
                float m = exp2(- e) * F;
                e = floor( log2(F) + 127.0 ) + floor( log2(m) );
                return vec3(
                    ( 128.0 * s + floor( e * exp2(-1.0) ) ) / 255.0,
                    ( 128.0 * mod( e, 2.0 ) + mod( floor( m * 128.0 ), 128.0 ) ) / 255.0,
                    floor( mod( floor( m * exp2( 23.0 - 8.0) ), exp2(8.0) ) ) / 255.0);
            }

            void main(void) {
                gl_FragColor = vec4(encode24(range), 1.0);
            }`
        });
    }

    function drawnode_depth() {
        return new Program("drawnode_depth", {
            uniforms: {
                projectionMatrix: "mat4",
                viewMatrix: "mat4",
                height: "float",
                eyePositionHigh: "vec3",
                eyePositionLow: "vec3",
                frustumPickingColor: "vec3"
            },
            attributes: {
                aVertexPositionHigh: "vec3",
                aVertexPositionLow: "vec3"
            },

            vertexShader: `attribute vec3 aVertexPositionHigh;
            attribute vec3 aVertexPositionLow;

            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform float height;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;

            void main(void) {

                vec3 cameraPosition = eyePositionHigh + eyePositionLow;
                vec3 aVertexPosition = aVertexPositionHigh + aVertexPositionLow;

                vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                vec3 lowDiff = aVertexPositionLow + normalize(aVertexPosition) * height - eyePositionLow;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
            }`,

            fragmentShader: `precision highp float;
            uniform vec3 frustumPickingColor;

            void main(void) {
                gl_FragColor = vec4(frustumPickingColor, 1.0);
            } `
        });
    }

    function NewIndexesTypedArray(arr) {
        return new Uint32Array(arr);
    }

    function createCenterBodyIndexes(size) {

        let indexes = [];

        var i0 = 1,
            j0 = 1;

        var i1 = 1,
            j1 = 1;

        var ind1, ind2, nr;
        for (var i = i0; i < size - 1 - i1; i++) {
            for (var j = j0; j < size - j1; j++) {
                ind1 = i * size + j;
                nr = (i + 1) * size;
                ind2 = nr + j;
                indexes.push(ind1, ind2);
            }
            indexes.push(ind2, nr + j0);
        }
        indexes.push(indexes[indexes.length - 1], size * size - size);

        return NewIndexesTypedArray(indexes);
    }

    function createWestNeighborSkirt(size, deltaGr) {
        let indexes = [];
        var grCount = (size - 1) / deltaGr;
        var b = size * size - size;
        var k = 0;
        for (var i = 0; i < size - 2; i++) {
            if (i % grCount === 0) {
                k = i;
            }
            var rind = b - size * i - size + 1,
                lind = b - size * k;
            indexes.push(lind, rind);
        }

        if (deltaGr === (size - 1)) {
            indexes.push(size);
            indexes.push(0);
        }

        return NewIndexesTypedArray(indexes);
    }

    function createNorthNeighborSkirt(size, deltaGr) {
        let indexes = [];
        var grCount = (size - 1) / deltaGr;
        var k = 0;
        for (var i = 0; i < size - 2; i++) {
            if (i % grCount === 0) {
                k = i;
            }
            var rind = size + i + 1,
                lind = k;
            indexes.push(lind, rind);
        }

        if (deltaGr === (size - 1)) {
            indexes.push(size - 2);
            indexes.push(size - 1);
        }

        return NewIndexesTypedArray(indexes);
    }

    function createEastNeighborSkirt(size, deltaGr) {
        let indexes = [];
        var grCount = (size - 1) / deltaGr;
        var k = 0;
        for (var i = 0; i < size - 2; i++) {
            if (i % grCount === 0) {
                k = i;
            }
            var rind = size * (i + 1) + size - 2,
                lind = size + size * k - 1;
            indexes.push(lind, rind);
        }

        if (deltaGr === (size - 1)) {
            indexes.push(size * (size - 1) - 1);
            indexes.push(size * size - 1);
        }

        return NewIndexesTypedArray(indexes);
    }

    function createSouthNeighborSkirt(size, deltaGr) {
        let indexes = [];
        var grCount = (size - 1) / deltaGr;
        var k = 0;
        var rb = size * (size - 1) - 2;
        var lb = size * size - 1;
        for (var i = 0; i < size - 2; i++) {
            if (i % grCount === 0) {
                k = i;
            }
            var rind = rb - i,
                lind = lb - k;
            indexes.push(lind, rind);
        }

        if (deltaGr === (size - 1)) {
            indexes.push(size * size - size + 1);
        }
        indexes.push(size * size - size);

        return NewIndexesTypedArray(indexes);
    }

    function initIndexesBodySkirts(pow) {
        var table = [];

        table[N] = [];
        table[W] = [];
        table[S] = [];
        table[E] = [];

        for (var i = 0; i <= pow; i++) {
            var d = Math.pow(2, i),
                d1 = d + 1;

            table[N][i] = [];
            table[W][i] = [];
            table[S][i] = [];
            table[E][i] = [];

            for (var j = 0; j <= pow; j++) {
                var dd = Math.pow(2, j);
                table[W][i][j] = createWestNeighborSkirt(d1, dd);
                table[N][i][j] = createNorthNeighborSkirt(d1, dd);
                table[E][i][j] = createEastNeighborSkirt(d1, dd);
                table[S][i][j] = createSouthNeighborSkirt(d1, dd);

            }
        }
        return table;
    }

    function initIndexBodiesTable(pow) {
        var table = [];
        for (var i = 0; i <= pow; i++) {
            var d = Math.pow(2, i);
            table[i] = createCenterBodyIndexes(d + 1);
        }
        return table;
    }

    function createTextureCoords(size) {
        var texCoords = new Uint16Array((size + 1) * (size + 1) * 2);
        let k = 0;
        for (var i = 0; i <= size; i++) {
            for (var j = 0; j <= size; j++) {
                texCoords[k++] = j / size * 0xFFFF;
                texCoords[k++] = i / size * 0xFFFF;
            }
        }
        return texCoords;
    }

    class SegmentHelper {
        constructor(maxGridSize = 0) {
            this._maxGridSize = maxGridSize;
        }

        get maxGridSize() {
            return this._maxGridSize;
        }

        init() {
            this.centerIndexesTable = initIndexBodiesTable(this._maxGridSize);
            this.skirtsIndexesTable = initIndexesBodySkirts(this._maxGridSize);
        }

        setMaxGridSize(gridSize) {
            this._maxGridSize = gridSize;
            this.init();
        }

        createSegmentIndexes(size, sidesSizes) {
            if (size) {
                let c = this.centerIndexesTable[size],
                    w = this.skirtsIndexesTable[W][size][sidesSizes[W]],
                    n = this.skirtsIndexesTable[N][size][sidesSizes[N]],
                    e = this.skirtsIndexesTable[E][size][sidesSizes[E]],
                    s = this.skirtsIndexesTable[S][size][sidesSizes[S]];

                let indexes = NewIndexesTypedArray(c.length + w.length + n.length + e.length + s.length);

                indexes.set(c, 0);
                indexes.set(w, c.length);
                indexes.set(n, c.length + w.length);
                indexes.set(e, c.length + w.length + n.length);
                indexes.set(s, c.length + w.length + n.length + e.length);

                return indexes;
            } else {
                return NewIndexesTypedArray([0, 2, 1, 3]);
            }
        }

        initTextureCoordsTable(pow) {
            var table = [];
            for (var i = 0; i <= pow; i++) {
                var d = Math.pow(2, i);
                table[i] = createTextureCoords(d);
            }
            return table;
        }
    }

    let instance = new SegmentHelper();

    function getInstance() {
        return instance;
    }

    /**
     * @module og/ImageCanvas
     */

    /**
     * Usefull class for working with JS canvas object.
     * @class
     */
    class ImageCanvas {
        /**
         * @param {number} [width] - Canvas width. Default 256.
         * @param {number} [height] - Canvas height. Default 256.
         */
        constructor(width = 256, height = 256) {
            /**
             * Canvas object.
             * @protected
             * @type {Object}
             */
            this._canvas = document.createElement("canvas");
            this._canvas.width = width;
            this._canvas.height = height;

            /**
             * Canvas context.
             * @protected
             * @type {Object}
             */
            this._context = this._canvas.getContext("2d");
        }

        /**
         * Returns canvas object.
         * @public
         * @returns {Object}
         */
        getCanvas() {
            return this._canvas;
        }

        /**
         * Returns canvas context pointer.
         * @public
         * @returns {Object}
         */
        getContext() {
            return this._context;
        }

        /**
         * Fills canvas RGBA with zeroes.
         * @public
         */
        fillEmpty() {
            var imgd = this._context.getImageData(0, 0, this._canvas.width, this._canvas.height);
            var pixels = imgd.data;
            for (var i = 0, n = pixels.length; i < n; i += 4) {
                pixels[i] = pixels[i + 1] = pixels[i + 2] = pixels[i + 3] = 0;
            }
            this._context.putImageData(imgd, 0, 0);
        }

        /**
         * Gets canvas pixels RGBA data.
         * @public
         * @returns {Array.<number>}
         */
        getData() {
            var imgd = this._context.getImageData(0, 0, this._canvas.width, this._canvas.height);
            return imgd.data;
        }

        /**
         * Fill the canvas by color.
         * @public
         * @param {string} color - CSS string color.
         */
        fillColor(color) {
            this._context.fillStyle = color;
            this._context.fillRect(0, 0, this._canvas.width, this._canvas.height);
        }

        /**
         * Sets RGBA pixel data.
         * @public
         * @param {Array.<number>} data - Array RGBA data.
         */
        setData(data) {
            var imageData = this._context.createImageData(this._canvas.width, this._canvas.height);
            imageData.data.set(data);
            this._context.putImageData(imageData, 0, 0);
        }

        /**
         * Resize canvas.
         * @public
         * @param {number} width - Width.
         * @param {number} height - Height.
         */
        resize(width, height) {
            this._canvas.width = width;
            this._canvas.height = height;
            this._context = this._canvas.getContext("2d");
        }

        /**
         * Draw an image on the canvas.
         * @public
         * @param {Image} img - Draw image.
         * @param {number} [x] - Left top image corner X coordinate on the canvas.
         * @param {number} [y] - Left top image corner Y coordinate on the canvas.
         * @param {number} [width] - Image width slice. Image width is default.
         * @param {number} [height] - Image height slice. Image height is default.
         */
        drawImage(img, x, y, width, height) {
            this._context = this._canvas.getContext("2d");
            this._context.drawImage(img, x || 0, y || 0, width || img.width, height || img.height);
        }

        /**
         * Converts canvas to JS image object.
         * @public
         * @returns {Image}
         */
        getImage() {
            var img = new Image();
            img.width = this.getWidth();
            img.height = this.getHeight();
            img.src = this._canvas.toDataURL("image/png");
            return img;
        }

        /**
         * Get measured text width.
         * @public
         * @param {string} text - Measured text.
         * @returns {number}
         */
        getTextWidth(text) {
            var metrics = this._context.measureText(text);
            return Math.round(metrics.width);
        }

        /**
         * Draw a text on the canvas.
         * @public
         * @param {string} text - Text.
         * @param {number} [x] - Canvas X - coordinate. 0 - default.
         * @param {number} [y] - Canvas Y - coordinate. 0 - default.
         * @param {string} [font] - Font style. 'normal 14px Verdana' - is default.
         * @param {string} [color] - Css font color.
         */
        drawText(text, x, y, font, color) {
            this._context.fillStyle = color || "black";
            this._context.font = font || "normal 14px Verdana";
            this._context.fillText(text, x || 0, y || 14);
        }

        /**
         * Gets canvas width.
         * @public
         * @returns {number}
         */
        getWidth() {
            return this._canvas.width;
        }

        /**
         * Gets canvas height.
         * @public
         * @returns {number}
         */
        getHeight() {
            return this._canvas.height;
        }

        /**
         * Load image to canvas.
         * @public
         * @param {string} url - Image url.
         * @pararm {imageCallback} [callback] - Image onload callback.
         */
        load(url, callback) {
            var img = new Image();
            var that = this;
            img.onload = function () {
                that.resize(img.width, img.height);
                that._context.drawImage(img, 0, 0, img.width, img.height);
                callback && callback(img);
            };
            img.src = url;
        }

        /**
         * Open canvas image in the new window.
         * @public
         */
        openImage() {
            var img = this.getImage();
            var dataUrl = img.src;
            var windowContent = "<!DOCTYPE html>";
            windowContent += "<html>";
            windowContent += "<head><title>Print</title></head>";
            windowContent += "<body>";
            windowContent += '<img src="' + dataUrl + '">';
            windowContent += "</body>";
            windowContent += "</html>";
            var printWin = window.open(
                "",
                "",
                "width=" + img.width + "px ,height=" + img.height + "px"
            );
            printWin.document.open();
            printWin.document.write(windowContent);
            printWin.document.close();
            printWin.focus();
        }

        destroy() {
            this._canvas.width = 1;
            this._canvas.height = 1;
            this._canvas = null;
            this._context = null;
        }
    }

    /**
     * @module og/webgl/Framebuffer
     */

    /**
     * Class represents framebuffer.
     * @class
     * @param {Handler} handler - WebGL handler.
     * @param {Object} [options] - Framebuffer options:
     * @param {number} [options.width] - Framebuffer width. Default is handler canvas width.
     * @param {number} [options.height] - Framebuffer height. Default is handler canvas height.
     * @param {number} [options.size] - Color attachment size.
     * @param {String} [options.internalFormat="RGBA"] - Specifies the color components in the texture.
     * @param {String} [options.format="RGBA"] - Specifies the format of the texel data.
     * @param {String} [options.type="UNSIGNED_BYTE"] - Specifies the data type of the texel data.
     * @param {String} [options.depthComponent="DEPTH_COMPONENT16"] - Specifies depth buffer size.
     * @param {Boolean} [options.useDepth] - Using depth buffer during the rendering.
     */
    class Framebuffer {
        constructor(handler, options = {}) {
            /**
             * WebGL handler.
             * @public
             * @type {Handler}
             */
            this.handler = handler;

            /**
             * Framebuffer object.
             * @private
             * @type {Object}
             */
            this._fbo = null;

            this._isBare = options.isBare || false;

            /**
             * Renderbuffer object.
             * @private
             * @type {Object}
             */
            this._depthRenderbuffer = null;

            this._filter = options.filter || "NEAREST";

            this._internalFormatArr =
                options.internalFormat instanceof Array
                    ? options.internalFormat
                    : [options.internalFormat || "RGBA"];

            this._formatArr =
                options.format instanceof Array ? options.format : [options.format || "RGBA"];

            this._typeArr =
                options.type instanceof Array ? options.type : [options.type || "UNSIGNED_BYTE"];

            this._attachmentArr =
                options.attachment instanceof Array
                    ? options.attachment.map((a, i) => {
                          let res = a.toUpperCase();
                          if (res === "COLOR_ATTACHMENT") {
                              return `${res}${i.toString()}`;
                          }
                          return res;
                      })
                    : [options.attachment || "COLOR_ATTACHMENT0"];

            /**
             * Framebuffer width.
             * @private
             * @type {number}
             */
            this._width = options.width || handler.canvas.width;

            /**
             * Framebuffer width.
             * @private
             * @type {number}
             */
            this._height = options.height || handler.canvas.height;

            this._depthComponent =
                options.depthComponent != undefined ? options.depthComponent : "DEPTH_COMPONENT16";

            this._useDepth = options.useDepth != undefined ? options.useDepth : true;

            /**
             * Framebuffer activity.
             * @private
             * @type {boolean}
             */
            this._active = false;

            this._size = options.size || 1;

            /**
             * Framebuffer texture.
             * @public
             * @type {number}
             */
            this.textures = options.textures || new Array(this._size);
        }

        static blit(sourceFramebuffer, destFramebuffer, glAttachment, glMask, glFilter) {
            let gl = sourceFramebuffer.handler.gl;

            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, sourceFramebuffer._fbo);
            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, destFramebuffer._fbo);
            gl.readBuffer(glAttachment);

            gl.clearBufferfv(gl.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);

            gl.blitFramebuffer(
                0,
                0,
                sourceFramebuffer._width,
                sourceFramebuffer._height,
                0,
                0,
                destFramebuffer._width,
                destFramebuffer._height,
                glMask,
                glFilter
            );

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
        }

        destroy() {
            var gl = this.handler.gl;

            for (var i = 0; i < this.textures.length; i++) {
                gl.deleteTexture(this.textures[i]);
            }
            this.textures = new Array(this._size);

            gl.deleteFramebuffer(this._fbo);
            gl.deleteRenderbuffer(this._depthRenderbuffer);

            this._depthRenderbuffer = null;
            this._fbo = null;

            this._active = false;
        }

        /**
         * Framebuffer initialization.
         * @private
         */
        init() {
            var gl = this.handler.gl;

            this._fbo = gl.createFramebuffer();

            gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);

            if (!this._isBare) {
                let attachmentArr = [];
                for (var i = 0; i < this.textures.length; i++) {
                    let ti =
                        this.textures[i] ||
                        this.handler.createEmptyTexture2DExt(
                            this._width,
                            this._height,
                            this._filter,
                            this._internalFormatArr[i],
                            this._formatArr[i],
                            this._typeArr[i]
                        );

                    let att_i = gl[this._attachmentArr[i]];

                    this.bindOutputTexture(ti, att_i);

                    this.textures[i] = ti;

                    if (this._attachmentArr[i] != "DEPTH_ATTACHMENT") {
                        attachmentArr.push(att_i);
                    }
                }
                gl.drawBuffers && gl.drawBuffers(attachmentArr);
            }

            if (this._useDepth) {
                this._depthRenderbuffer = gl.createRenderbuffer();
                gl.bindRenderbuffer(gl.RENDERBUFFER, this._depthRenderbuffer);
                gl.renderbufferStorage(
                    gl.RENDERBUFFER,
                    gl[this._depthComponent],
                    this._width,
                    this._height
                );
                gl.framebufferRenderbuffer(
                    gl.FRAMEBUFFER,
                    gl.DEPTH_ATTACHMENT,
                    gl.RENDERBUFFER,
                    this._depthRenderbuffer
                );
                gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            }

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            return this;
        }

        /**
         * Bind buffer texture.
         * @public
         * @param{Object} texture - Output texture.
         * @param {Number} [attachmentIndex=0] - color attachment index.
         */
        bindOutputTexture(texture, glAttachment) {
            var gl = this.handler.gl;
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.framebufferTexture2D(
                gl.FRAMEBUFFER,
                glAttachment || gl.COLOR_ATTACHMENT0,
                gl.TEXTURE_2D,
                texture,
                0
            );
            gl.bindTexture(gl.TEXTURE_2D, null);
        }

        /**
         * Sets framebuffer viewport size.
         * @public
         * @param {number} width - Framebuffer width.
         * @param {number} height - Framebuffer height.
         */
        setSize(width, height, forceDestroy) {
            this._width = width;
            this._height = height;

            if (this._active) {
                this.handler.gl.viewport(0, 0, this._width, this._height);
            }

            if (this._useDepth || forceDestroy) {
                this.destroy();
                this.init();
            }
        }

        /**
         * Returns framebuffer completed.
         * @public
         * @returns {boolean} -
         */
        isComplete() {
            var gl = this.handler.gl;
            if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
                return true;
            }
            return false;
        }

        /**
         * Gets pixel RBGA color from framebuffer by coordinates.
         * @public
         * @param {Uint8Array} res - Normalized x - coordinate.
         * @param {number} nx - Normalized x - coordinate.
         * @param {number} ny - Normalized y - coordinate.
         * @param {number} [w=1] - Normalized width.
         * @param {number} [h=1] - Normalized height.
         * @param {Number} [attachmentIndex=0] - color attachment index.
         */
        readPixels(res, nx, ny, index = 0, w = 1, h = 1) {
            var gl = this.handler.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
            gl.readBuffer && gl.readBuffer(gl.COLOR_ATTACHMENT0 + index || 0);
            gl.readPixels(
                nx * this._width,
                ny * this._height,
                w,
                h,
                gl.RGBA,
                gl[this._typeArr[index]],
                res
            );
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }

        /**
         * Reads all pixels(RGBA colors) from framebuffer.
         * @public
         * @param {Uint8Array} res - Result array.
         * @param {Number} [attachmentIndex=0] - color attachment index.
         */
        readAllPixels(res, attachmentIndex = 0) {
            var gl = this.handler.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
            gl.readBuffer && gl.readBuffer(gl.COLOR_ATTACHMENT0 + attachmentIndex);
            gl.readPixels(
                0,
                0,
                this._width,
                this._height,
                gl.RGBA,
                gl[this._typeArr[attachmentIndex]],
                res
            );
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }

        /**
         * Activate framebuffer frame to draw.
         * @public
         * @returns {Framebuffer} Returns Current framebuffer.
         */
        activate() {
            var gl = this.handler.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
            gl.viewport(0, 0, this._width, this._height);
            this._active = true;
            var c = this.handler.framebufferStack.current().data;
            c && (c._active = false);
            this.handler.framebufferStack.push(this);
            return this;
        }

        /**
         * Deactivate framebuffer frame.
         * @public
         */
        deactivate() {
            var h = this.handler,
                gl = h.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            this._active = false;

            var f = this.handler.framebufferStack.popPrev();

            if (f) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, f._fbo);
                gl.viewport(0, 0, f._width, f._height);
            } else {
                gl.viewport(0, 0, h.canvas.width, h.canvas.height);
            }
        }

        /**
         * Gets JavaScript image object that framebuffer has drawn.
         * @public
         * @returns {Object} -
         */
        getImage() {
            var data = new Uint8Array(4 * this._width * this._height);
            this.readAllPixels(data);
            var imageCanvas = new ImageCanvas(this._width, this._height);
            imageCanvas.setData(data);
            return imageCanvas.getImage();
        }

        /**
         * Open dialog window with framebuffer image.
         * @public
         */
        openImage() {
            var img = this.getImage();
            var dataUrl = img.src;
            var windowContent = "<!DOCTYPE html>";
            windowContent += "<html>";
            windowContent += "<head><title>Print</title></head>";
            windowContent += "<body>";
            windowContent += '<img src="' + dataUrl + '">';
            windowContent += "</body>";
            windowContent += "</html>";
            var printWin = window.open(
                "",
                "",
                "width=" + img.width + "px ,height=" + img.height + "px"
            );
            printWin.document.open();
            printWin.document.write(windowContent);
            printWin.document.close();
            printWin.focus();
        }
    }

    class GeoImageCreator {

        constructor(planet, maxFrames) {
            this._gridSize = 64;
            this._planet = planet;
            this._framebuffer = null;
            this._texCoordsBuffer = null;
            this._indexBuffer = null;
            this.MAX_FRAMES = maxFrames || 5;
            this._currentFrame = 0;
            this._queue = [];
            this._animate = [];
            this._initialize();
        }

        _initialize() {
            this._initShaders();
            this._initBuffers();
        }

        /**
         * Creates geoImage corners coordinates grid buffer.
         * @public
         * @param{Array.<LonLat>} c - GeoImage corners coordinates.
         * @return{WebGLBuffer} Grid coordinates buffer.
         */
        createGridBuffer(c, toMerc) {
            var gs = this._gridSize;

            var v03 = new LonLat((c[3].lon - c[0].lon) / gs, (c[3].lat - c[0].lat) / gs),
                v12 = new LonLat((c[2].lon - c[1].lon) / gs, (c[2].lat - c[1].lat) / gs),
                v01 = new LonLat((c[1].lon - c[0].lon) / gs, (c[1].lat - c[0].lat) / gs),
                v32 = new LonLat((c[2].lon - c[3].lon) / gs, (c[2].lat - c[3].lat) / gs);

            var grid = new Float32Array((gs + 1) * (gs + 1) * 2);
            var k = 0;
            for (let i = 0; i <= gs; i++) {
                var P03i = new LonLat(c[0].lon + i * v03.lon, c[0].lat + i * v03.lat),
                    P12i = new LonLat(c[1].lon + i * v12.lon, c[1].lat + i * v12.lat);
                for (let j = 0; j <= gs; j++) {
                    var P01j = new LonLat(c[0].lon + j * v01.lon, c[0].lat + j * v01.lat),
                        P32j = new LonLat(c[3].lon + j * v32.lon, c[3].lat + j * v32.lat);
                    var xx = getLinesIntersectionLonLat(P03i, P12i, P01j, P32j);
                    grid[k++] = xx.lon;
                    grid[k++] = xx.lat;
                }
            }

            if (toMerc) {
                for (let i = 0; i < grid.length; i += 2) {
                    let c = new LonLat(grid[i], grid[i + 1]).forwardMercator();
                    grid[i] = c.lon;
                    grid[i + 1] = c.lat;
                }
            }
            return this._planet.renderer.handler.createArrayBuffer(grid, 2, grid.length / 2);
        }

        frame() {
            var i = this.MAX_FRAMES;
            while (i-- && this._queue.length) {
                var q = this._queue.shift();
                q._isRendering = false;
                q.rendering();
            }

            i = this._animate.length;
            while (i--) {
                this._animate[i].rendering();
            }
        }

        add(geoImage) {
            if (!geoImage._isRendering) {
                geoImage._isRendering = true;
                if (geoImage._animate) {
                    this._animate.push(geoImage);
                } else {
                    this._queue.push(geoImage);
                }
            }
        }

        remove(geoImage) {
            if (geoImage._isRendering) {
                geoImage._creationProceeding = false;
                geoImage._isRendering = false;
                var arr;
                if (geoImage._animate) {
                    arr = this._animate;
                } else {
                    arr = this._queue;
                }
                for (var i = 0; i < arr.length; i++) {
                    if (arr[i].isEqual(geoImage)) {
                        arr.splice(i, 1);
                        return;
                    }
                }
            }
        }

        _initBuffers() {

            let h = this._planet.renderer.handler;

            this._framebuffer = new Framebuffer(h, { width: 2, height: 2, useDepth: false });
            this._framebuffer.init();

            this._framebufferMercProj = new Framebuffer(h, { width: 2, height: 2, useDepth: false });
            this._framebufferMercProj.init();

            let gs = Math.log2(this._gridSize);

            this._texCoordsBuffer = this._planet._textureCoordsBufferCache[gs];

            this._indexBuffer = this._planet._indexesCache[gs][gs][gs][gs][gs].buffer;

            this._quadTexCoordsBuffer = h.createArrayBuffer(new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]), 2, 4);
            this._quadVertexBuffer = h.createArrayBuffer(new Float32Array([-1, 1, 1, 1, -1, -1, 1, -1]), 2, 4);
        }

        _initShaders() {

            this._planet.renderer.handler.addProgram(new Program("geoImageTransform", {
                uniforms: {
                    sourceTexture: { type: types$1.SAMPLER2D },
                    extentParams: { type: types$1.VEC4 }
                },
                attributes: {
                    corners: "vec2",
                    texCoords: "vec2"
                },
                vertexShader: `attribute vec2 corners; 
                      attribute vec2 texCoords; 
                      varying vec2 v_texCoords; 
                      uniform vec4 extentParams; 
                      void main() { 
                          v_texCoords = texCoords; 
                          gl_Position = vec4((-1.0 + (corners - extentParams.xy) * extentParams.zw) * vec2(1.0, -1.0), 0.0, 1.0); 
                      }`,
                fragmentShader:
                    `precision highp float;
                        uniform sampler2D sourceTexture;
                        varying vec2 v_texCoords;
                        void main () {
                            if(v_texCoords.x <= 0.001 || v_texCoords.x >= 0.999 ||
                                v_texCoords.y <= 0.001 || v_texCoords.y >= 0.999) {
                                discard;
                            }
                            gl_FragColor = texture2D(sourceTexture, v_texCoords);
                        }`
            }));
        }
    }

    /**
     * @module og/shaders/billboard
     */

    const PROJECT$1 = `vec2 project(vec4 p) {
                    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;
                }`;

    const ROTATE2D$1 =
        `mat2 rotate2d(float angle) {
        return mat2(cos(angle), -sin(angle),
           sin(angle), cos(angle));
     }`;

    function billboardPicking() {
        return new Program("billboardPicking", {
            uniforms: {
                viewport: "vec2",
                projectionMatrix: "mat4",
                viewMatrix: "mat4",
                eyePositionHigh: "vec3",
                eyePositionLow: "vec3",
                planetRadius: "float",
                uScaleByDistance: "vec3",
                opacity: "float",
                depthOffset: "float"
            },
            attributes: {
                a_vertices: "vec2",
                a_positionsHigh: "vec3",
                a_positionsLow: "vec3",
                a_offset: "vec3",
                a_size: "vec2",
                a_rotation: "float",
                a_rgba: "vec4"
            },
            vertexShader:
                `precision highp float;
            attribute vec2 a_vertices;
            attribute vec3 a_positionsHigh;
            attribute vec3 a_positionsLow;
            attribute vec3 a_offset;
            attribute vec2 a_size;
            attribute float a_rotation;
            attribute vec4 a_rgba;

            varying vec3 v_rgb;

            uniform mat4 viewMatrix;
            uniform mat4 projectionMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform vec3 uScaleByDistance;
            uniform float opacity;
            uniform float planetRadius;
            uniform vec2 viewport;
            uniform float depthOffset;

            const vec3 ZERO3 = vec3(0.0);

            ${PROJECT$1}

            ${ROTATE2D$1}

            void main() {

                vec3 a_positions = a_positionsHigh + a_positionsLow;
                vec3 cameraPos = eyePositionHigh + eyePositionLow;

                vec3 look = a_positions - cameraPos;
                float lookDist = length(look);
                v_rgb = a_rgba.rgb;

                if(opacity * step(lookDist, sqrt(dot(cameraPos,cameraPos) - planetRadius) + sqrt(dot(a_positions,a_positions) - planetRadius)) == 0.0){
                    return;
                }

                vec3 up = vec3( viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1] );
                vec3 right = vec3( viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0] );

                float scd = (1.0 - smoothstep(uScaleByDistance[0], uScaleByDistance[1], lookDist)) * (1.0 - step(uScaleByDistance[2], lookDist));

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                vec3 highDiff = a_positionsHigh - eyePositionHigh;
                vec3 lowDiff = a_positionsLow - eyePositionLow;
                vec4 posRTE = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
                vec4 projPos = projectionMatrix * posRTE;
                                
                float camSlope = dot(vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]), normalize(cameraPos));                
                if(camSlope > 0.5) {
                    float dist = dot(look, normalize(cameraPos));
                    projPos.z += dist * 0.02;
                }else{
                    projPos.z += -(abs(projPos.z)) * 0.002;                 
                }
                
                projPos.z += depthOffset + a_offset.z;
                                
                vec2 screenPos = project(projPos);

                vec2 v =  screenPos + rotate2d(a_rotation) * (a_vertices * a_size * scd + a_offset.xy);

                gl_Position = vec4((2.0 * v / viewport - 1.0) * projPos.w, projPos.z, projPos.w);
            }`,
            fragmentShader:
                `precision highp float;
            varying vec3 v_rgb;
            void main () {
                gl_FragColor = vec4(v_rgb, 1.0);
            }`
        });
    }

    function billboard_screen() {
        return new Program("billboard", {
            uniforms: {
                viewport: "vec2",
                u_texture: "sampler2d",
                projectionMatrix: "mat4",
                viewMatrix: "mat4",
                eyePositionHigh: "vec3",
                eyePositionLow: "vec3",
                planetRadius: "float",
                uScaleByDistance: "vec3",
                opacity: "float",
                depthOffset: "float"
            },
            attributes: {
                a_vertices: "vec2",
                a_texCoord: "vec2",
                a_positionsHigh: "vec3",
                a_positionsLow: "vec3",
                a_offset: "vec3",
                a_size: "vec2",
                a_rotation: "float",
                a_rgba: "vec4",
            },
            vertexShader:
                `precision highp float;
            attribute vec2 a_vertices;
            attribute vec2 a_texCoord;
            attribute vec3 a_positionsHigh;
            attribute vec3 a_positionsLow;
            attribute vec3 a_offset;
            attribute vec2 a_size;
            attribute float a_rotation;
            attribute vec4 a_rgba;

            varying vec2 v_texCoords;
            varying vec4 v_rgba;

            uniform mat4 viewMatrix;
            uniform mat4 projectionMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform vec3 uScaleByDistance;
            uniform float opacity;
            uniform float planetRadius;
            uniform vec2 viewport;
            uniform float depthOffset;

            const vec3 ZERO3 = vec3(0.0);

            ${PROJECT$1}

            ${ROTATE2D$1}

            void main() {
                
                vec3 a_positions = a_positionsHigh + a_positionsLow;
                vec3 cameraPos = eyePositionHigh + eyePositionLow;

                v_texCoords = a_texCoord;
                vec3 look = a_positions - cameraPos;
                float lookDist = length(look);
                v_rgba = a_rgba;

                if(opacity * step(lookDist, sqrt(dot(cameraPos,cameraPos) - planetRadius) + sqrt(dot(a_positions,a_positions) - planetRadius)) == 0.0){
                    return;
                }

                vec3 up = vec3( viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1] );
                vec3 right = vec3( viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0] );

                float scd = (1.0 - smoothstep(uScaleByDistance[0], uScaleByDistance[1], lookDist)) * (1.0 - step(uScaleByDistance[2], lookDist));

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                vec3 highDiff = a_positionsHigh - eyePositionHigh;
                vec3 lowDiff = a_positionsLow - eyePositionLow;
                vec4 posRTE = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
                vec4 projPos = projectionMatrix * posRTE;
                                                
                float camSlope = dot(vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]), normalize(cameraPos));                
                if(camSlope > 0.5) {
                    float dist = dot(look, normalize(cameraPos));
                    projPos.z += dist * 0.02;
                }else{
                    projPos.z += -(abs(projPos.z)) * 0.002;                 
                }
                
                projPos.z += depthOffset + a_offset.z;
                
                vec2 screenPos = project(projPos);

                vec2 v = screenPos + rotate2d(a_rotation) * (a_vertices * a_size * scd + a_offset.xy);

                gl_Position = vec4((2.0 * v / viewport - 1.0) * projPos.w, projPos.z, projPos.w);
            }`,
            fragmentShader:
                `precision highp float;
            uniform sampler2D u_texture;
            varying vec2 v_texCoords;
            varying vec4 v_rgba;
            void main () {
                vec4 color = texture2D(u_texture, v_texCoords);
                if(color.a < 0.1)
                    discard;
                gl_FragColor = color * v_rgba;
            }`
        });
    }

    /**
     * @module og/entity/BillboardHandler
     */

    const PICKINGCOLOR_BUFFER$3 = 0;
    const POSITION_BUFFER$2 = 1;
    const SIZE_BUFFER$2 = 2;
    const OFFSET_BUFFER$1 = 3;
    const RGBA_BUFFER$3 = 4;
    const ROTATION_BUFFER$1 = 5;
    const TEXCOORD_BUFFER$1 = 6;
    const VERTEX_BUFFER$3 = 7;

    window.BILLBOARD_DEPTH_OFFSET = 0.0;

    /*
     * og.BillboardHandler
     *
     *
     */
    class BillboardHandler {
        /**
         *
         * @param {*} entityCollection
         */
        constructor(entityCollection) {
            /**
             * Picking rendering option.
             * @public
             * @type {boolean}
             */
            this.pickingEnabled = true;

            this._entityCollection = entityCollection;

            this._renderer = null;

            this._billboards = [];

            this._positionHighBuffer = null;
            this._positionLowBuffer = null;
            this._sizeBuffer = null;
            this._offsetBuffer = null;
            this._rgbaBuffer = null;
            this._rotationBuffer = null;
            this._texCoordBuffer = null;
            this._vertexBuffer = null;

            this._texCoordArr = new Float32Array();
            this._vertexArr = new Float32Array();
            this._positionHighArr = new Float32Array();
            this._positionLowArr = new Float32Array();
            this._sizeArr = new Float32Array();
            this._offsetArr = new Float32Array();
            this._rgbaArr = new Float32Array();
            this._rotationArr = new Float32Array();

            this._pickingColorBuffer = null;
            this._pickingColorArr = new Float32Array();

            this._buffersUpdateCallbacks = [];
            this._buffersUpdateCallbacks[PICKINGCOLOR_BUFFER$3] = this.createPickingColorBuffer;
            this._buffersUpdateCallbacks[POSITION_BUFFER$2] = this.createPositionBuffer;
            this._buffersUpdateCallbacks[SIZE_BUFFER$2] = this.createSizeBuffer;
            this._buffersUpdateCallbacks[OFFSET_BUFFER$1] = this.createOffsetBuffer;
            this._buffersUpdateCallbacks[RGBA_BUFFER$3] = this.createRgbaBuffer;
            this._buffersUpdateCallbacks[ROTATION_BUFFER$1] = this.createRotationBuffer;
            this._buffersUpdateCallbacks[TEXCOORD_BUFFER$1] = this.createTexCoordBuffer;
            this._buffersUpdateCallbacks[VERTEX_BUFFER$3] = this.createVertexBuffer;

            this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);

            this.__staticId = BillboardHandler._staticCounter++;
        }

        isEqual(handler) {
            return handler && (handler.__staticId === this.__staticId);
        }

        static get _staticCounter() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set _staticCounter(n) {
            this._counter = n;
        }

        static concArr(dest, curr) {
            for (var i = 0; i < curr.length; i++) {
                dest.push(curr[i]);
            }
        }

        initProgram() {
            if (this._renderer.handler) {
                if (!this._renderer.handler.programs.billboard) {
                    this._renderer.handler.addProgram(billboard_screen());
                }

                if (!this._renderer.handler.programs.billboardPicking) {
                    this._renderer.handler.addProgram(billboardPicking());
                }
            }
        }

        setRenderer(renderer) {
            this._renderer = renderer;
            this.initProgram();
        }

        refresh() {
            var i = this._changedBuffers.length;
            while (i--) {
                this._changedBuffers[i] = true;
            }
        }

        _removeBillboards() {
            var i = this._billboards.length;
            while (i--) {
                var bi = this._billboards[i];
                bi._handlerIndex = -1;
                bi._handler = null;
                bi._isReady = false;
                bi._lockId = LOCK_FREE;
            }
            this._billboards.length = 0;
            this._billboards = [];
        }

        clear() {
            this._texCoordArr = null;
            this._vertexArr = null;
            this._positionHighArr = null;
            this._positionLowArr = null;
            this._sizeArr = null;
            this._offsetArr = null;
            this._rgbaArr = null;
            this._rotationArr = null;
            this._pickingColorArr = null;

            this._texCoordArr = new Float32Array();
            this._vertexArr = new Float32Array();
            this._positionHighArr = new Float32Array();
            this._positionLowArr = new Float32Array();
            this._sizeArr = new Float32Array();
            this._offsetArr = new Float32Array();
            this._rgbaArr = new Float32Array();
            this._rotationArr = new Float32Array();
            this._pickingColorArr = new Float32Array();

            this._removeBillboards();
            this._deleteBuffers();
            this.refresh();
        }

        _deleteBuffers() {
            if (this._renderer) {
                var gl = this._renderer.handler.gl;
                gl.deleteBuffer(this._positionHighBuffer);
                gl.deleteBuffer(this._positionLowBuffer);
                gl.deleteBuffer(this._sizeBuffer);
                gl.deleteBuffer(this._offsetBuffer);
                gl.deleteBuffer(this._rgbaBuffer);
                gl.deleteBuffer(this._rotationBuffer);
                gl.deleteBuffer(this._vertexBuffer);
                gl.deleteBuffer(this._texCoordBuffer);
                gl.deleteBuffer(this._pickingColorBuffer);
            }

            this._positionHighBuffer = null;
            this._positionLowBuffer = null;
            this._sizeBuffer = null;
            this._offsetBuffer = null;
            this._rgbaBuffer = null;
            this._rotationBuffer = null;
            this._vertexBuffer = null;
            this._texCoordBuffer = null;
            this._pickingColorBuffer = null;
        }

        update() {
            if (this._renderer) {
                var i = this._changedBuffers.length;
                while (i--) {
                    if (this._changedBuffers[i]) {
                        this._buffersUpdateCallbacks[i].call(this);
                        this._changedBuffers[i] = false;
                    }
                }
            }
        }

        add(billboard) {
            if (billboard._handlerIndex == -1) {
                billboard._isReady = true;
                billboard._handler = this;
                billboard._handlerIndex = this._billboards.length;
                this._billboards.push(billboard);
                this._addBillboardToArrays(billboard);
                this.refresh();
                billboard.setSrc(billboard._src || (billboard._image && billboard._image.src));
            }
        }

        _addBillboardToArrays(billboard) {
            if (billboard._visibility) {
                this._vertexArr = concatTypedArrays(
                    this._vertexArr,
                    [-0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5]
                );
            } else {
                this._vertexArr = concatTypedArrays(
                    this._vertexArr,
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
                );
            }

            this._texCoordArr = concatTypedArrays(
                this._texCoordArr,
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            );

            var x = billboard._positionHigh.x,
                y = billboard._positionHigh.y,
                z = billboard._positionHigh.z,
                w;
            this._positionHighArr = concatTypedArrays(this._positionHighArr, [x, y, z, x, y, z, x, y, z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z
            ]);

            x = billboard._positionLow.x;
            y = billboard._positionLow.y;
            z = billboard._positionLow.z;
            this._positionLowArr = concatTypedArrays(this._positionLowArr, [
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z
            ]);

            x = billboard._width;
            y = billboard._height;
            this._sizeArr = concatTypedArrays(this._sizeArr, [x, y, x, y, x, y, x, y, x, y, x, y]);

            x = billboard._offset.x;
            y = billboard._offset.y;
            z = billboard._offset.z;
            this._offsetArr = concatTypedArrays(this._offsetArr, [
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z
            ]);

            x = billboard._color.x;
            y = billboard._color.y;
            z = billboard._color.z;
            w = billboard._color.w;
            this._rgbaArr = concatTypedArrays(this._rgbaArr, [
                x,
                y,
                z,
                w,
                x,
                y,
                z,
                w,
                x,
                y,
                z,
                w,
                x,
                y,
                z,
                w,
                x,
                y,
                z,
                w,
                x,
                y,
                z,
                w
            ]);

            x = billboard._rotation;
            this._rotationArr = concatTypedArrays(this._rotationArr, [x, x, x, x, x, x]);

            x = billboard._entity._pickingColor.x / 255;
            y = billboard._entity._pickingColor.y / 255;
            z = billboard._entity._pickingColor.z / 255;
            this._pickingColorArr = concatTypedArrays(this._pickingColorArr, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);
        }

        _displayPASS() {
            var r = this._renderer;
            var h = r.handler;
            h.programs.billboard.activate();
            var sh = h.programs.billboard._program;
            var sha = sh.attributes,
                shu = sh.uniforms;

            var gl = h.gl,
                ec = this._entityCollection;
            
            gl.uniform1f(shu.depthOffset, ec.polygonOffsetUnits + window.BILLBOARD_DEPTH_OFFSET);

            gl.uniform1i(shu.u_texture, 0);

            gl.uniformMatrix4fv(shu.viewMatrix, false, r.activeCamera._viewMatrix._m);
            gl.uniformMatrix4fv(shu.projectionMatrix, false, r.activeCamera.getProjectionMatrix());

            gl.uniform3fv(shu.eyePositionHigh, r.activeCamera.eyeHigh);
            gl.uniform3fv(shu.eyePositionLow, r.activeCamera.eyeLow);

            gl.uniform3fv(shu.uScaleByDistance, ec.scaleByDistance);

            gl.uniform1f(shu.opacity, ec._fadingOpacity);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordBuffer);
            gl.vertexAttribPointer(sha.a_texCoord, this._texCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
            gl.vertexAttribPointer(sha.a_vertices, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._positionHighBuffer);
            gl.vertexAttribPointer(sha.a_positionsHigh, this._positionHighBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._positionLowBuffer);
            gl.vertexAttribPointer(sha.a_positionsLow, this._positionLowBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._rgbaBuffer);
            gl.vertexAttribPointer(sha.a_rgba, this._rgbaBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._sizeBuffer);
            gl.vertexAttribPointer(sha.a_size, this._sizeBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._offsetBuffer);
            gl.vertexAttribPointer(sha.a_offset, this._offsetBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.uniform1f(shu.planetRadius, ec.renderNode._planetRadius2 || 0);

            gl.uniform2fv(shu.viewport, [h.canvas.clientWidth, h.canvas.clientHeight]);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._rotationBuffer);
            gl.vertexAttribPointer(sha.a_rotation, this._rotationBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
        }

        _pickingPASS() {
            var r = this._renderer;
            var h = r.handler;
            h.programs.billboardPicking.activate();
            var sh = h.programs.billboardPicking._program;
            var sha = sh.attributes,
                shu = sh.uniforms;

            var gl = h.gl,
                ec = this._entityCollection;

            gl.uniform1f(shu.depthOffset, ec.polygonOffsetUnits + window.BILLBOARD_DEPTH_OFFSET);

            gl.uniformMatrix4fv(shu.viewMatrix, false, r.activeCamera._viewMatrix._m);
            gl.uniformMatrix4fv(shu.projectionMatrix, false, r.activeCamera.getProjectionMatrix());

            gl.uniform3fv(shu.eyePositionHigh, r.activeCamera.eyeHigh);
            gl.uniform3fv(shu.eyePositionLow, r.activeCamera.eyeLow);

            gl.uniform3fv(shu.uScaleByDistance, ec.scaleByDistance);

            gl.uniform1f(shu.opacity, ec._fadingOpacity);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
            gl.vertexAttribPointer(sha.a_vertices, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._positionHighBuffer);
            gl.vertexAttribPointer(sha.a_positionsHigh, this._positionHighBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._positionLowBuffer);
            gl.vertexAttribPointer(sha.a_positionsLow, this._positionLowBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._pickingColorBuffer);
            gl.vertexAttribPointer(sha.a_rgba, this._pickingColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._sizeBuffer);
            gl.vertexAttribPointer(sha.a_size, this._sizeBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._offsetBuffer);
            gl.vertexAttribPointer(sha.a_offset, this._offsetBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.uniform1f(shu.planetRadius, ec.renderNode._planetRadius2 || 0);

            gl.uniform2fv(shu.viewport, [h.canvas.clientWidth, h.canvas.clientHeight]);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._rotationBuffer);
            gl.vertexAttribPointer(sha.a_rotation, this._rotationBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
        }

        draw() {
            if (this._billboards.length) {
                this.update();
                this._displayPASS();
            }
        }

        drawPicking() {
            if (this._billboards.length && this.pickingEnabled) {
                this._pickingPASS();
            }
        }

        reindexBillbordsArray(startIndex) {
            var b = this._billboards;
            for (var i = startIndex; i < b.length; i++) {
                b[i]._handlerIndex = i;
            }
        }

        _removeBillboard(billboard) {
            var bi = billboard._handlerIndex;

            this._billboards.splice(bi, 1);

            var i = bi * 24;
            this._rgbaArr = spliceTypedArray(this._rgbaArr, i, 24);

            i = bi * 18;
            this._positionHighArr = spliceTypedArray(this._positionHighArr, i, 18);
            this._positionLowArr = spliceTypedArray(this._positionLowArr, i, 18);
            this._offsetArr = spliceTypedArray(this._offsetArr, i, 18);
            //this._alignedAxisArr = spliceTypedArray(this._alignedAxisArr, i, 18);
            this._pickingColorArr = spliceTypedArray(this._pickingColorArr, i, 18);

            i = bi * 12;
            this._vertexArr = spliceTypedArray(this._vertexArr, i, 12);
            this._sizeArr = spliceTypedArray(this._sizeArr, i, 12);
            this._texCoordArr = spliceTypedArray(this._texCoordArr, i, 12);

            i = bi * 6;
            this._rotationArr = spliceTypedArray(this._rotationArr, i, 6);

            this.reindexBillbordsArray(bi);
            this.refresh();

            billboard._handlerIndex = -1;
            billboard._handler = null;
            billboard._isReady = false;
            billboard._lockId = LOCK_FREE;
        }

        remove(billboard) {
            if (billboard._isReady && this.__staticId == billboard._handler.__staticId) {
                this._removeBillboard(billboard);
            } else {
                billboard._handler = null;
            }
        }

        setPositionArr(index, positionHigh, positionLow) {
            var i = index * 18;

            // High
            var a = this._positionHighArr,
                x = positionHigh.x,
                y = positionHigh.y,
                z = positionHigh.z;

            a[i] = x;
            a[i + 1] = y;
            a[i + 2] = z;

            a[i + 3] = x;
            a[i + 4] = y;
            a[i + 5] = z;

            a[i + 6] = x;
            a[i + 7] = y;
            a[i + 8] = z;

            a[i + 9] = x;
            a[i + 10] = y;
            a[i + 11] = z;

            a[i + 12] = x;
            a[i + 13] = y;
            a[i + 14] = z;

            a[i + 15] = x;
            a[i + 16] = y;
            a[i + 17] = z;

            // Low
            a = this._positionLowArr;
            x = positionLow.x;
            y = positionLow.y;
            z = positionLow.z;

            a[i] = x;
            a[i + 1] = y;
            a[i + 2] = z;

            a[i + 3] = x;
            a[i + 4] = y;
            a[i + 5] = z;

            a[i + 6] = x;
            a[i + 7] = y;
            a[i + 8] = z;

            a[i + 9] = x;
            a[i + 10] = y;
            a[i + 11] = z;

            a[i + 12] = x;
            a[i + 13] = y;
            a[i + 14] = z;

            a[i + 15] = x;
            a[i + 16] = y;
            a[i + 17] = z;

            this._changedBuffers[POSITION_BUFFER$2] = true;
        }

        setPickingColorArr(index, color) {
            var i = index * 18;
            var a = this._pickingColorArr,
                x = color.x / 255,
                y = color.y / 255,
                z = color.z / 255;

            a[i] = x;
            a[i + 1] = y;
            a[i + 2] = z;

            a[i + 3] = x;
            a[i + 4] = y;
            a[i + 5] = z;

            a[i + 6] = x;
            a[i + 7] = y;
            a[i + 8] = z;

            a[i + 9] = x;
            a[i + 10] = y;
            a[i + 11] = z;

            a[i + 12] = x;
            a[i + 13] = y;
            a[i + 14] = z;

            a[i + 15] = x;
            a[i + 16] = y;
            a[i + 17] = z;

            this._changedBuffers[PICKINGCOLOR_BUFFER$3] = true;
        }

        setSizeArr(index, width, height) {
            var i = index * 12;
            var a = this._sizeArr,
                x = width,
                y = height;

            a[i] = x;
            a[i + 1] = y;

            a[i + 2] = x;
            a[i + 3] = y;

            a[i + 4] = x;
            a[i + 5] = y;

            a[i + 6] = x;
            a[i + 7] = y;

            a[i + 8] = x;
            a[i + 9] = y;

            a[i + 10] = x;
            a[i + 11] = y;

            this._changedBuffers[SIZE_BUFFER$2] = true;
        }

        setOffsetArr(index, offset) {
            var i = index * 18;
            var a = this._offsetArr,
                x = offset.x,
                y = offset.y,
                z = offset.z;

            a[i] = x;
            a[i + 1] = y;
            a[i + 2] = z;

            a[i + 3] = x;
            a[i + 4] = y;
            a[i + 5] = z;

            a[i + 6] = x;
            a[i + 7] = y;
            a[i + 8] = z;

            a[i + 9] = x;
            a[i + 10] = y;
            a[i + 11] = z;

            a[i + 12] = x;
            a[i + 13] = y;
            a[i + 14] = z;

            a[i + 15] = x;
            a[i + 16] = y;
            a[i + 17] = z;

            this._changedBuffers[OFFSET_BUFFER$1] = true;
        }

        setRgbaArr(index, rgba) {
            var i = index * 24;
            var a = this._rgbaArr,
                x = rgba.x,
                y = rgba.y,
                z = rgba.z,
                w = rgba.w;

            a[i] = x;
            a[i + 1] = y;
            a[i + 2] = z;
            a[i + 3] = w;

            a[i + 4] = x;
            a[i + 5] = y;
            a[i + 6] = z;
            a[i + 7] = w;

            a[i + 8] = x;
            a[i + 9] = y;
            a[i + 10] = z;
            a[i + 11] = w;

            a[i + 12] = x;
            a[i + 13] = y;
            a[i + 14] = z;
            a[i + 15] = w;

            a[i + 16] = x;
            a[i + 17] = y;
            a[i + 18] = z;
            a[i + 19] = w;

            a[i + 20] = x;
            a[i + 21] = y;
            a[i + 22] = z;
            a[i + 23] = w;

            this._changedBuffers[RGBA_BUFFER$3] = true;
        }

        setRotationArr(index, rotation) {
            var i = index * 6;
            var a = this._rotationArr;

            a[i] = rotation;
            a[i + 1] = rotation;
            a[i + 2] = rotation;
            a[i + 3] = rotation;
            a[i + 4] = rotation;
            a[i + 5] = rotation;

            this._changedBuffers[ROTATION_BUFFER$1] = true;
        }

        setTexCoordArr(index, tcoordArr) {
            var i = index * 12;
            var a = this._texCoordArr;

            a[i] = tcoordArr[0];
            a[i + 1] = tcoordArr[1];

            a[i + 2] = tcoordArr[2];
            a[i + 3] = tcoordArr[3];

            a[i + 4] = tcoordArr[4];
            a[i + 5] = tcoordArr[5];

            a[i + 6] = tcoordArr[6];
            a[i + 7] = tcoordArr[7];

            a[i + 8] = tcoordArr[8];
            a[i + 9] = tcoordArr[9];

            a[i + 10] = tcoordArr[10];
            a[i + 11] = tcoordArr[11];

            this._changedBuffers[TEXCOORD_BUFFER$1] = true;
        }

        setVisibility(index, visibility) {
            var vArr;
            if (visibility) {
                vArr = [-0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5];
            } else {
                vArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            }
            this.setVertexArr(index, vArr);
        }

        setVertexArr(index, vertexArr) {
            var i = index * 12;
            var a = this._vertexArr;

            a[i] = vertexArr[0];
            a[i + 1] = vertexArr[1];
            a[i + 2] = vertexArr[2];

            a[i + 3] = vertexArr[3];
            a[i + 4] = vertexArr[4];
            a[i + 5] = vertexArr[5];

            a[i + 6] = vertexArr[6];
            a[i + 7] = vertexArr[7];
            a[i + 8] = vertexArr[8];

            a[i + 9] = vertexArr[9];
            a[i + 10] = vertexArr[10];
            a[i + 11] = vertexArr[11];

            this._changedBuffers[VERTEX_BUFFER$3] = true;
        }

        createPositionBuffer() {
            let h = this._renderer.handler,
                numItems = this._positionHighArr.length / 3;

            if (!this._positionHighBuffer || this._positionHighBuffer.numItems !== numItems) {
                h.gl.deleteBuffer(this._positionHighBuffer);
                h.gl.deleteBuffer(this._positionLowBuffer);
                this._positionHighBuffer = h.createStreamArrayBuffer(3, numItems);
                this._positionLowBuffer = h.createStreamArrayBuffer(3, numItems);
            }

            h.setStreamArrayBuffer(this._positionHighBuffer, this._positionHighArr);
            h.setStreamArrayBuffer(this._positionLowBuffer, this._positionLowArr);
        }

        createSizeBuffer() {
            var h = this._renderer.handler;
            h.gl.deleteBuffer(this._sizeBuffer);
            this._sizeBuffer = h.createArrayBuffer(this._sizeArr, 2, this._sizeArr.length / 2);
        }

        createOffsetBuffer() {
            var h = this._renderer.handler;
            h.gl.deleteBuffer(this._offsetBuffer);
            this._offsetBuffer = h.createArrayBuffer(this._offsetArr, 3, this._offsetArr.length / 3);
        }

        createRgbaBuffer() {
            var h = this._renderer.handler;
            h.gl.deleteBuffer(this._rgbaBuffer);
            this._rgbaBuffer = h.createArrayBuffer(this._rgbaArr, 4, this._rgbaArr.length / 4);
        }

        createRotationBuffer() {
            let h = this._renderer.handler;

            if (!this._rotationBuffer || this._rotationBuffer.numItems !== this._rotationArr.length) {
                h.gl.deleteBuffer(this._rotationBuffer);
                this._rotationBuffer = h.createStreamArrayBuffer(1, this._rotationArr.length);
            }

            h.setStreamArrayBuffer(this._rotationBuffer, this._rotationArr);
        }

        createVertexBuffer() {
            var h = this._renderer.handler;
            h.gl.deleteBuffer(this._vertexBuffer);
            this._vertexBuffer = h.createArrayBuffer(this._vertexArr, 2, this._vertexArr.length / 2);
        }

        createTexCoordBuffer() {
            var h = this._renderer.handler;
            h.gl.deleteBuffer(this._texCoordBuffer);
            this._texCoordBuffer = h.createArrayBuffer(
                this._texCoordArr,
                2,
                this._texCoordArr.length / 2
            );
        }

        //createAlignedAxisBuffer() {
        //    var h = this._renderer.handler;
        //    h.gl.deleteBuffer(this._alignedAxisBuffer);
        //    this._alignedAxisBuffer = h.createArrayBuffer(
        //        this._alignedAxisArr,
        //        3,
        //        this._alignedAxisArr.length / 3
        //    );
        //}

        createPickingColorBuffer() {
            var h = this._renderer.handler;
            h.gl.deleteBuffer(this._pickingColorBuffer);
            this._pickingColorBuffer = h.createArrayBuffer(
                this._pickingColorArr,
                3,
                this._pickingColorArr.length / 3
            );
        }

        refreshTexCoordsArr() {
            var bc = this._entityCollection;
            if (bc && this._renderer) {
                var ta = this._renderer.billboardsTextureAtlas;
                for (var i = 0; i < this._billboards.length; i++) {
                    var bi = this._billboards[i];
                    var img = bi._image;
                    if (img) {
                        var imageNode = ta.get(bi._image.__nodeIndex);
                        if (imageNode) {
                            this.setTexCoordArr(bi._handlerIndex, imageNode.texCoords);
                        }
                    }
                }
            }
        }
    }

    /**
     * @module og/shaders/label
     */

    const DEFINE = `
#define EMPTY -1.0
#define RTL 1.0`;

    const PROJECT = `vec2 project(vec4 p) {
                    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;
                }`;

    const ROTATE2D =
        `mat2 rotate2d(float angle) {
        return mat2(cos(angle), -sin(angle),
           sin(angle), cos(angle));
     }`;

    function label_webgl2() {
        return new Program("label", {
            uniforms: {
                viewport: "vec2",
                fontTextureArr: "sampler2darray",
                sdfParamsArr: "vec4",
                projectionMatrix: "mat4",
                viewMatrix: "mat4",
                eyePositionHigh: "vec3",
                eyePositionLow: "vec3",
                planetRadius: "float",
                scaleByDistance: "vec3",
                opacity: "float",
                isOutlinePass: "int",
                depthOffset: "float"
            },
            attributes: {
                a_outline: "float",
                a_gliphParam: "vec4",
                a_vertices: "vec2",
                a_texCoord: "vec4",
                a_positionsHigh: "vec3",
                a_positionsLow: "vec3",
                a_size: "float",
                a_rotation: "float",
                a_rgba: "vec4",
                a_offset: "vec3",
                a_fontIndex: "float"
            },
            vertexShader:
                `#version 300 es
            
            ${DEFINE}
            
            in float a_outline;
            in vec4 a_gliphParam;
            in vec2 a_vertices;
            in vec4 a_texCoord;
            in vec3 a_positionsHigh;
            in vec3 a_positionsLow;
            in vec3 a_offset;
            in float a_size;
            in float a_rotation;
            in vec4 a_rgba;
            in float a_fontIndex;

            out vec2 v_uv;
            out vec4 v_rgba;
            flat out int v_fontIndex;            
            out vec4 v_outlineColor;
            flat out float v_outline;

            uniform vec2 viewport;
            uniform mat4 viewMatrix;
            uniform mat4 projectionMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float planetRadius;
            uniform vec3 scaleByDistance;
            uniform float opacity;
            uniform float depthOffset;

            const vec3 ZERO3 = vec3(0.0);
           
            ${PROJECT}

            ${ROTATE2D}

            void main() {

                if(a_texCoord.w == EMPTY) {
                    gl_Position = vec4(0.0);
                    v_fontIndex = -1;
                    return;
                }
               
                vec3 a_positions = a_positionsHigh + a_positionsLow;
                vec3 cameraPos = eyePositionHigh + eyePositionLow;

                v_outline = a_outline;

                v_fontIndex = int(a_fontIndex);
                v_uv = a_texCoord.xy;
                vec3 look = a_positions - cameraPos;
                float lookDist = length(look);
                v_rgba = a_rgba;
                
                if(opacity * step(lookDist, sqrt(dot(cameraPos,cameraPos) - planetRadius) + sqrt(dot(a_positions,a_positions) - planetRadius)) == 0.0){
                    return;
                }

                float scd = (1.0 - smoothstep(scaleByDistance[0], scaleByDistance[1], lookDist)) * (1.0 - step(scaleByDistance[2], lookDist));

                v_rgba.a *= opacity;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                vec3 highDiff = a_positionsHigh - eyePositionHigh;
                vec3 lowDiff = a_positionsLow - eyePositionLow;
                vec4 posRTE = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
                vec4 projPos = projectionMatrix * posRTE;
                                
                float camSlope = dot(vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]), normalize(cameraPos));                
                if(camSlope > 0.5) {
                    float dist = dot(look, normalize(cameraPos));
                    projPos.z += dist * 0.02;                  
                }else{
                    projPos.z += -(abs(projPos.z)) * 0.002;                 
                }
                        
                projPos.z += depthOffset + a_offset.z;
                               
                vec2 screenPos = project(projPos);
                
                vec2 vert = a_vertices;                
                vec4 gp = a_gliphParam;                                
                if(a_texCoord.w == RTL){
                    vert.x = step(vert.x * 0.5 + 1.0, 1.0);
                    gp.x = -a_gliphParam.x;
                    gp.z = -(a_gliphParam.z + a_texCoord.z);
                }else{
                    gp.z = a_gliphParam.z + a_texCoord.z;
                }
                                
                vec2 v = screenPos + rotate2d(a_rotation) * ((vert * gp.xy + gp.zw) * a_size * scd + a_offset.xy);

                gl_Position = vec4((2.0 * v / viewport - 1.0) * projPos.w, projPos.z, projPos.w);
            }`,
            fragmentShader:
                `#version 300 es

            uniform int isOutlinePass;
            
            precision highp float;

            const int MAX_SIZE = 11;

            // x - ATLAS_WIDTH = 512.0;
            // y - ATLAS_HEIGHT = 512.0;
            // z - ATLAS_GLYPH_SIZE = 32.0;
            // w - ATLAS_FIELD_RANGE = 8.0;

            uniform sampler2D fontTextureArr[MAX_SIZE];
            uniform vec4 sdfParamsArr[MAX_SIZE];

            flat in int v_fontIndex;
            in vec2 v_uv;
            in vec4 v_rgba;           

            flat in float v_outline;

            in vec3 v_pickingColor;

            layout(location = 0) out vec4 outScreen;

            float median(float r, float g, float b) {
                return max(min(r, g), min(max(r, g), b));
            }

            float getDistance() {
                vec3 msdf;
                if(v_fontIndex == 0) {
                    msdf = texture(fontTextureArr[0], v_uv).rgb;
                } else if(v_fontIndex == 1){
                    msdf = texture(fontTextureArr[1], v_uv).rgb;
                } else if(v_fontIndex == 2){
                    msdf = texture(fontTextureArr[2], v_uv).rgb;
                } else if(v_fontIndex == 3){
                    msdf = texture(fontTextureArr[3], v_uv).rgb;
                } else if(v_fontIndex == 4){
                    msdf = texture(fontTextureArr[4], v_uv).rgb;
                } else if(v_fontIndex == 5){
                    msdf = texture(fontTextureArr[5], v_uv).rgb;
                } else if(v_fontIndex == 6){
                    msdf = texture(fontTextureArr[6], v_uv).rgb;
                } else if(v_fontIndex == 7){
                    msdf = texture(fontTextureArr[7], v_uv).rgb;
                } else if(v_fontIndex == 8){
                    msdf = texture(fontTextureArr[8], v_uv).rgb;
                } else if(v_fontIndex == 9){
                    msdf = texture(fontTextureArr[9], v_uv).rgb;
                } else if(v_fontIndex == 10){
                    msdf = texture(fontTextureArr[10], v_uv).rgb;
                }
                return median(msdf.r, msdf.g, msdf.b);
            }
                        
            void main () {
            
                if(v_fontIndex == -1) {
                    return;
                }
                
                vec4 sdfParams = sdfParamsArr[v_fontIndex];
                float sd = getDistance();             
                vec2 dxdy = fwidth(v_uv) * sdfParams.xy;
                float dist = sd + min(0.001, 0.5 - 1.0 / sdfParams.w) - 0.5;
                float opacity = clamp(dist * sdfParams.w / length(dxdy) + 0.5, 0.0, 1.0);

                if(isOutlinePass == 0){                             
                    outScreen = vec4(v_rgba.rgb, opacity * v_rgba.a);
                } else {                
                    float strokeDist = sd + min(v_outline, 0.5 - 1.0 / sdfParams.w) - 0.5;
                    float strokeAlpha = v_rgba.a * clamp(strokeDist * sdfParams.w / length(dxdy) + 0.5, 0.0, 1.0);                    
                    if(strokeAlpha < 0.1){
                        discard;
                    }
                    outScreen = v_rgba * strokeAlpha * (0.5 - opacity) * 2.0;
                }         
            }`
        });
    }

    function label_screen() {
        return new Program("label", {
            uniforms: {
                viewport: "vec2",
                fontTextureArr: "sampler2darray",
                sdfParamsArr: "vec4",
                projectionMatrix: "mat4",
                viewMatrix: "mat4",
                eyePositionHigh: "vec3",
                eyePositionLow: "vec3",
                planetRadius: "float",
                scaleByDistance: "vec3",
                opacity: "float",
                isOutlinePass: "int",
                depthOffset: "float"
            },
            attributes: {
                a_outline: "float",
                a_gliphParam: "vec4",
                a_vertices: "vec2",
                a_texCoord: "vec4",
                a_positionsHigh: "vec3",
                a_positionsLow: "vec3",
                a_size: "float",
                a_rotation: "float",
                a_rgba: "vec4",
                a_offset: "vec3",
                a_fontIndex: "float"
            },
            vertexShader:
                `            
            ${DEFINE}
                        
            attribute float a_outline;
            attribute vec4 a_gliphParam;
            attribute vec2 a_vertices;
            attribute vec4 a_texCoord;
            attribute vec3 a_positionsHigh;
            attribute vec3 a_positionsLow;
            attribute vec3 a_offset;
            attribute float a_size;
            attribute float a_rotation;
            attribute vec4 a_rgba;
            attribute float a_fontIndex;

            varying float v_outline;
            varying vec2 v_uv;
            varying vec4 v_rgba;
            varying float v_fontIndex;            

            uniform vec2 viewport;
            uniform mat4 viewMatrix;
            uniform mat4 projectionMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float planetRadius;
            uniform vec3 scaleByDistance;
            uniform float opacity;
            uniform float depthOffset;

            const vec3 ZERO3 = vec3(0.0);

            ${PROJECT}

            ${ROTATE2D}

            void main() {

                if(a_texCoord.w == EMPTY) {
                    gl_Position = vec4(0.0);
                    v_fontIndex = -1.0;
                    return;
                }
               
                vec3 a_positions = a_positionsHigh + a_positionsLow;
                vec3 cameraPos = eyePositionHigh + eyePositionLow;

                v_outline = a_outline;
                v_uv = vec2(a_texCoord.xy);
                v_rgba = a_rgba;
                v_fontIndex = a_fontIndex;
                
                vec3 look = a_positions - cameraPos;
                float lookDist = length(look);
                
                if(opacity * step(lookDist, sqrt(dot(cameraPos,cameraPos) - planetRadius) + sqrt(dot(a_positions,a_positions) - planetRadius)) == 0.0){
                    return;
                }

                float scd = (1.0 - smoothstep(scaleByDistance[0], scaleByDistance[1], lookDist)) * (1.0 - step(scaleByDistance[2], lookDist));

                v_rgba.a *= opacity;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                vec3 highDiff = a_positionsHigh - eyePositionHigh;
                vec3 lowDiff = a_positionsLow - eyePositionLow;
                vec4 posRTE = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
                vec4 projPos = projectionMatrix * posRTE;
                                
                float camSlope = dot(vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]), normalize(cameraPos));                
                if(camSlope > 0.5) {
                    float dist = dot(look, normalize(cameraPos));
                    projPos.z += dist * 0.02;                  
                }else{
                    projPos.z += -(abs(projPos.z)) * 0.002;                 
                }
                        
                projPos.z += depthOffset + a_offset.z;
                               
                vec2 screenPos = project(projPos);
                
                vec2 vert = a_vertices;                
                vec4 gp = a_gliphParam;                                
                if(a_texCoord.w == RTL){
                    vert.x = step(vert.x * 0.5 + 1.0, 1.0);
                    gp.x = -a_gliphParam.x;
                    gp.z = -(a_gliphParam.z + a_texCoord.z);
                }else{
                    gp.z = a_gliphParam.z + a_texCoord.z;
                }
                                
                vec2 v = screenPos + rotate2d(a_rotation) * ((vert * gp.xy + gp.zw) * a_size * scd + a_offset.xy);
                
                gl_Position = vec4((2.0 * v / viewport - 1.0) * projPos.w, projPos.z, projPos.w);
            }`,
            fragmentShader:
                `#extension GL_OES_standard_derivatives : enable

            precision highp float;
            precision highp int;

            const int MAX_SIZE = 11;

            // x - ATLAS_WIDTH = 512.0;
            // y - ATLAS_HEIGHT = 512.0;
            // z - ATLAS_GLYPH_SIZE = 32.0;
            // w - ATLAS_FIELD_RANGE = 8.0;

            uniform sampler2D fontTextureArr[MAX_SIZE];
            uniform vec4 sdfParamsArr[MAX_SIZE];
            uniform int isOutlinePass;
            
            varying float v_outline;
            varying vec2 v_uv;
            varying vec4 v_rgba;           
            varying float v_fontIndex;
            
            float fontIndex;

            float median(float r, float g, float b) {
                return max(min(r, g), min(max(r, g), b));
            }

            float getDistance() {
                vec3 msdf;
                if(fontIndex >= 0.0 && fontIndex < 1.0) {
                    msdf = texture2D(fontTextureArr[0], v_uv).rgb;
                } else if(fontIndex >= 1.0 && fontIndex < 2.0){
                    msdf = texture2D(fontTextureArr[1], v_uv).rgb;
                } else if(fontIndex >= 2.0 && fontIndex < 3.0){
                    msdf = texture2D(fontTextureArr[2], v_uv).rgb;
                } else if(fontIndex >= 3.0 && fontIndex < 4.0){
                    msdf = texture2D(fontTextureArr[3], v_uv).rgb;
                } else if(fontIndex >= 4.0 && fontIndex < 5.0){
                    msdf = texture2D(fontTextureArr[4], v_uv).rgb;
                } else if(fontIndex >= 5.0 && fontIndex < 6.0){
                    msdf = texture2D(fontTextureArr[5], v_uv).rgb;
                } else if(fontIndex >= 6.0 && fontIndex < 7.0){
                    msdf = texture2D(fontTextureArr[6], v_uv).rgb;
                } else if(fontIndex >= 7.0 && fontIndex < 8.0){
                    msdf = texture2D(fontTextureArr[7], v_uv).rgb;
                } else if(fontIndex >= 8.0 && fontIndex < 9.0){
                    msdf = texture2D(fontTextureArr[8], v_uv).rgb;
                } else if(fontIndex >= 9.0 && fontIndex < 10.0){
                    msdf = texture2D(fontTextureArr[9], v_uv).rgb;
                } else if(fontIndex >= 10.0 && fontIndex < 11.0){
                    msdf = texture2D(fontTextureArr[10], v_uv).rgb;
                }
                return median(msdf.r, msdf.g, msdf.b);
            }


            vec4 getSDFParams() {
                if(fontIndex >= 0.0 && fontIndex < 1.0) {
                    return sdfParamsArr[0];
                } else if(fontIndex >= 1.0 && fontIndex < 2.0){
                    return sdfParamsArr[1];
                } else if(fontIndex >= 2.0 && fontIndex < 3.0){
                    return sdfParamsArr[2];
                } else if(fontIndex >= 3.0 && fontIndex < 4.0){
                    return sdfParamsArr[3];
                } else if(fontIndex >= 4.0 && fontIndex < 5.0){
                    return sdfParamsArr[4];
                } else if(fontIndex >= 5.0 && fontIndex < 6.0){
                    return sdfParamsArr[5];
                } else if(fontIndex >= 6.0 && fontIndex < 7.0){
                    return sdfParamsArr[6];
                } else if(fontIndex >= 7.0 && fontIndex < 8.0){
                    return sdfParamsArr[7];
                } else if(fontIndex >= 8.0 && fontIndex < 9.0){
                    return sdfParamsArr[8];
                } else if(fontIndex >= 9.0 && fontIndex < 10.0){
                    return sdfParamsArr[9];
                } else if(fontIndex >= 10.0 && fontIndex < 11.0){
                    return sdfParamsArr[10];
                }
            }
                    
            void main () {

                fontIndex = v_fontIndex + 0.1;
                
                if(v_fontIndex < 0.0){
                    return;
                }
                
                vec4 sdfParams = getSDFParams();
                float sd = getDistance();             
                vec2 dxdy = fwidth(v_uv) * sdfParams.xy;
                float dist = sd + min(0.001, 0.5 - 1.0 / sdfParams.w) - 0.5;
                float opacity = clamp(dist * sdfParams.w / length(dxdy) + 0.5, 0.0, 1.0);

                if(isOutlinePass == 0){                             
                    gl_FragColor = vec4(v_rgba.rgb, opacity * v_rgba.a);
                } else {                
                    float strokeDist = sd + min(v_outline, 0.5 - 1.0 / sdfParams.w) - 0.5;
                    float strokeAlpha = v_rgba.a * clamp(strokeDist * sdfParams.w / length(dxdy) + 0.5, 0.0, 1.0);                    
                    if(strokeAlpha < 0.1){
                        discard;
                    }
                    gl_FragColor = v_rgba * strokeAlpha * (0.5 - opacity) * 2.0;
                }
            }`
        });
    }

    function labelPicking() {
        return new Program("labelPicking", {
            uniforms: {
                viewport: "vec2",
                projectionMatrix: "mat4",
                viewMatrix: "mat4",
                eyePositionHigh: "vec3",
                eyePositionLow: "vec3",
                planetRadius: "float",
                scaleByDistance: "vec3",
                opacity: "float",
                depthOffset: "float"
            },
            attributes: {
                a_gliphParam: "vec4",
                a_vertices: "vec2",
                a_texCoord: "vec4",
                a_positionsHigh: "vec3",
                a_positionsLow: "vec3",
                a_offset: "vec3",
                a_size: "float",
                a_rotation: "float",
                a_rgba: "vec4"
            },
            vertexShader:
                `
            
            ${DEFINE}
            
            attribute vec4 a_gliphParam;
            attribute vec2 a_vertices;
            attribute vec4 a_texCoord;
            attribute vec3 a_positionsHigh;
            attribute vec3 a_positionsLow;
            attribute vec3 a_offset;
            attribute float a_size;
            attribute float a_rotation;
            attribute vec4 a_rgba;

            varying vec4 v_rgba;

            uniform vec2 viewport;
            uniform mat4 viewMatrix;
            uniform mat4 projectionMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float planetRadius;
            uniform vec3 scaleByDistance;
            uniform float opacity;
            uniform float depthOffset;

            const vec3 ZERO3 = vec3(0.0);

            ${PROJECT}

            ${ROTATE2D}

            void main() {
                vec3 a_positions = a_positionsHigh + a_positionsLow;
                vec3 cameraPos = eyePositionHigh + eyePositionLow;
                v_rgba = a_rgba;
                
                if(a_texCoord.w == EMPTY) {
                    v_rgba.a = 0.0;
                    gl_Position = vec4(0.0);
                    return;
                }

                vec3 look = a_positions - cameraPos;
                float lookDist = length(look);
                if(opacity * step(lookDist, sqrt(dot(cameraPos,cameraPos) - planetRadius) + sqrt(dot(a_positions,a_positions) - planetRadius)) == 0.0){
                    return;
                }

                float scd = (1.0 - smoothstep(scaleByDistance[0], scaleByDistance[1], lookDist)) * (1.0 - step(scaleByDistance[2], lookDist));

                v_rgba.a *= opacity;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                vec3 highDiff = a_positionsHigh - eyePositionHigh;
                vec3 lowDiff = a_positionsLow - eyePositionLow;
                vec4 posRTE = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
                vec4 projPos = projectionMatrix * posRTE;
                
                float camSlope = dot(vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]), normalize(cameraPos));                
                if(camSlope > 0.5) {
                    float dist = dot(look, normalize(cameraPos));
                    projPos.z += dist * 0.02;                  
                }else{
                    projPos.z += -(abs(projPos.z)) * 0.002;                 
                }
                        
                projPos.z += depthOffset + a_offset.z;
                
                vec2 screenPos = project(projPos);
                
                vec2 vert = a_vertices;                
                vec4 gp = a_gliphParam;                                
                if(a_texCoord.w == RTL){
                    vert.x = step(vert.x * 0.5 + 1.0, 1.0);
                    gp.x = -a_gliphParam.x;
                    gp.z = -(a_gliphParam.z + a_texCoord.z);
                }else{
                    gp.z = a_gliphParam.z + a_texCoord.z;
                }
                                
                vec2 v = screenPos + rotate2d(a_rotation) * ((vert * gp.xy + gp.zw) * a_size * scd + a_offset.xy);
                                
                gl_Position = vec4((2.0 * v / viewport - 1.0) * projPos.w, projPos.z, projPos.w);
            }`,
            fragmentShader:
                `precision highp float;

            varying vec4 v_rgba;

            varying vec3 v_pickingColor;

            void main () {

                vec4 color = v_rgba;
                if (color.a < 0.05) {
                    return;
                }

                gl_FragColor = vec4(v_rgba.rgb, v_rgba.a);
            }`
        });
    }

    /**
     * @module og/entity/LabelHandler
     */

    const PICKINGCOLOR_BUFFER$2 = 0;
    const POSITION_BUFFER$1 = 1;
    const SIZE_BUFFER$1 = 2;
    const OFFSET_BUFFER = 3;
    const RGBA_BUFFER$2 = 4;
    const ROTATION_BUFFER = 5;
    const TEXCOORD_BUFFER = 6;
    const VERTEX_BUFFER$2 = 7;
    const FONTINDEX_BUFFER = 8;
    const OUTLINE_BUFFER = 9;
    const OUTLINECOLOR_BUFFER = 10;

    window.LABEL_DEPTH_OFFSET = -0;

    const EMPTY = -1.0;
    const RTL = 1.0;

    /*
     * og.LabelHandler
     *
     *
     */
    class LabelHandler extends BillboardHandler {
        /**
         *
         * @param {*} entityCollection
         * @param {*} maxLetters
         */
        constructor(entityCollection, maxLetters = 21) {
            super(entityCollection);

            this._gliphParamBuffer = null;
            this._fontIndexBuffer = null;
            this._outlineBuffer = null;
            this._outlineColorBuffer = null;

            this._gliphParamArr = new Float32Array();
            this._fontIndexArr = new Float32Array();
            this._outlineArr = new Float32Array();
            this._outlineColorArr = new Float32Array();

            this._buffersUpdateCallbacks[FONTINDEX_BUFFER] = this.createFontIndexBuffer;
            this._buffersUpdateCallbacks[OUTLINE_BUFFER] = this.createOutlineBuffer;
            this._buffersUpdateCallbacks[OUTLINECOLOR_BUFFER] = this.createOutlineColorBuffer;

            this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);

            this._maxLetters = maxLetters;
        }

        initProgram() {
            if (this._renderer.handler) {
                if (!this._renderer.handler.programs.label) {
                    if (this._renderer.handler.gl.type === "webgl2") {
                        this._renderer.handler.addProgram(label_webgl2());
                    } else {
                        this._renderer.handler.addProgram(label_screen());
                    }
                }

                if (!this._renderer.handler.programs.labelPicking) {
                    this._renderer.handler.addProgram(labelPicking());
                }
            }
        }

        add(label) {
            if (!label._handler) {
                label._handler = this;
                this.assignFontAtlas(label);
                this.refresh();
            }
        }

        _addLabelToArrays(label) {
            this._renderer.labelWorker.make(this, label);
        }

        assignFontAtlas(label) {
            if (this._entityCollection && this._renderer) {
                label.assignFontAtlas(this._renderer.fontAtlas);
                this._addLabelToArrays(label);
            } else {
                this._billboards.push(label);
            }
        }

        workerCallback(data, label) {
            if (label._lockId !== LOCK_FREE && this.isEqual(label._handler)) {
                label._isReady = true;
                label._lockId = LOCK_FREE;
                label._handlerIndex = this._billboards.length;
                this._billboards.push(label);

                this._vertexArr = concatTypedArrays(this._vertexArr, data.vertexArr);
                this._texCoordArr = concatTypedArrays(this._texCoordArr, data.texCoordArr);
                this._gliphParamArr = concatTypedArrays(this._gliphParamArr, data.gliphParamArr);
                this._positionHighArr = concatTypedArrays(this._positionHighArr, data.positionHighArr);
                this._positionLowArr = concatTypedArrays(this._positionLowArr, data.positionLowArr);
                this._sizeArr = concatTypedArrays(this._sizeArr, data.sizeArr);
                this._offsetArr = concatTypedArrays(this._offsetArr, data.offsetArr);
                this._rgbaArr = concatTypedArrays(this._rgbaArr, data.rgbaArr);
                this._rotationArr = concatTypedArrays(this._rotationArr, data.rotationArr);
                this._fontIndexArr = concatTypedArrays(this._fontIndexArr, data.fontIndexArr);
                this._outlineArr = concatTypedArrays(this._outlineArr, data.outlineArr);
                this._outlineColorArr = concatTypedArrays(this._outlineColorArr, data.outlineColorArr);
                this._pickingColorArr = concatTypedArrays(this._pickingColorArr, data.pickingColorArr);

                label.update();

                this.refresh();
            }
        }

        clear() {
            this._texCoordArr = null;
            this._gliphParamArr = null;
            this._vertexArr = null;
            this._positionHighArr = null;
            this._positionLowArr = null;
            this._sizeArr = null;
            this._offsetArr = null;
            this._rgbaArr = null;
            this._rotationArr = null;
            this._fontIndexArr = null;
            this._outlineArr = null;
            this._outlineColorArr = null;

            this._texCoordArr = new Float32Array();
            this._gliphParamArr = new Float32Array();
            this._vertexArr = new Float32Array();
            this._positionHighArr = new Float32Array();
            this._positionLowArr = new Float32Array();
            this._sizeArr = new Float32Array();
            this._offsetArr = new Float32Array();
            this._rgbaArr = new Float32Array();
            this._rotationArr = new Float32Array();
            this._fontIndexArr = new Float32Array();
            this._outlineArr = new Float32Array();
            this._outlineColorArr = new Float32Array();

            this._removeBillboards();
            this._deleteBuffers();
            this.refresh();
        }

        _deleteBuffers() {
            if (this._renderer) {
                var gl = this._renderer.handler.gl;
                gl.deleteBuffer(this._gliphParamBuffer);
                gl.deleteBuffer(this._sizeBuffer);
                gl.deleteBuffer(this._fontIndexBuffer);
                gl.deleteBuffer(this._texCoordBuffer);
                gl.deleteBuffer(this._outlineBuffer);
                gl.deleteBuffer(this._outlineColorBuffer);
                gl.deleteBuffer(this._positionHighBuffer);
                gl.deleteBuffer(this._positionLowBuffer);
                gl.deleteBuffer(this._sizeBuffer);
                gl.deleteBuffer(this._offsetBuffer);
                gl.deleteBuffer(this._rgbaBuffer);
                gl.deleteBuffer(this._rotationBuffer);
                gl.deleteBuffer(this._vertexBuffer);
                gl.deleteBuffer(this._texCoordBuffer);
                gl.deleteBuffer(this._pickingColorBuffer);

                this._gliphParamBuffer = null;
                this._sizeBuffer = null;
                this._fontIndexBuffer = null;
                this._texCoordBuffer = null;
                this._outlineBuffer = null;
                this._outlineColorBuffer = null;
                this._positionHighBuffer = null;
                this._positionLowBuffer = null;
                this._sizeBuffer = null;
                this._offsetBuffer = null;
                this._rgbaBuffer = null;
                this._rotationBuffer = null;
                this._vertexBuffer = null;
                this._texCoordBuffer = null;
                this._pickingColorBuffer = null;
            }
        }

        _displayPASS() {
            var r = this._renderer;
            var h = r.handler;
            h.programs.label.activate();
            var sh = h.programs.label._program;
            var sha = sh.attributes,
                shu = sh.uniforms;

            var gl = h.gl,
                ec = this._entityCollection;

            gl.disable(gl.CULL_FACE);

            gl.uniform1iv(shu.fontTextureArr, r.fontAtlas.samplerArr);
            gl.uniform4fv(shu.sdfParamsArr, r.fontAtlas.sdfParamsArr);
            gl.uniformMatrix4fv(shu.viewMatrix, false, r.activeCamera._viewMatrix._m);
            gl.uniformMatrix4fv(shu.projectionMatrix, false, r.activeCamera.getProjectionMatrix());
            gl.uniform3fv(shu.eyePositionHigh, r.activeCamera.eyeHigh);
            gl.uniform3fv(shu.eyePositionLow, r.activeCamera.eyeLow);
            gl.uniform3fv(shu.scaleByDistance, ec.scaleByDistance);
            gl.uniform1f(shu.opacity, ec._fadingOpacity);
            gl.uniform1f(shu.planetRadius, ec.renderNode._planetRadius2 || 0);
            gl.uniform2fv(shu.viewport, [h.canvas.clientWidth, h.canvas.clientHeight]);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordBuffer);
            gl.vertexAttribPointer(sha.a_texCoord, this._texCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._gliphParamBuffer);
            gl.vertexAttribPointer(sha.a_gliphParam, this._gliphParamBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
            gl.vertexAttribPointer(sha.a_vertices, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._positionHighBuffer);
            gl.vertexAttribPointer(sha.a_positionsHigh, this._positionHighBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._positionLowBuffer);
            gl.vertexAttribPointer(sha.a_positionsLow, this._positionLowBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._sizeBuffer);
            gl.vertexAttribPointer(sha.a_size, this._sizeBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._rotationBuffer);
            gl.vertexAttribPointer(sha.a_rotation, this._rotationBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._offsetBuffer);
            gl.vertexAttribPointer(sha.a_offset, this._offsetBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._fontIndexBuffer);
            gl.vertexAttribPointer(sha.a_fontIndex, this._fontIndexBuffer.itemSize, gl.FLOAT, false, 0, 0);

            //
            // outline PASS
            gl.uniform1i(shu.isOutlinePass, 1);
            gl.uniform1f(shu.depthOffset, ec.polygonOffsetUnits + window.LABEL_DEPTH_OFFSET);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._outlineColorBuffer);
            gl.vertexAttribPointer(sha.a_rgba, this._outlineColorBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._outlineBuffer);
            gl.vertexAttribPointer(sha.a_outline, this._outlineBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);

            //
            // no outline PASS
            gl.depthFunc(gl.EQUAL);
            gl.uniform1i(shu.isOutlinePass, 0);
            gl.uniform1f(shu.depthOffset, ec.polygonOffsetUnits + window.LABEL_DEPTH_OFFSET);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._rgbaBuffer);
            gl.vertexAttribPointer(sha.a_rgba, this._rgbaBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);

            gl.depthFunc(gl.LESS);

            gl.enable(gl.CULL_FACE);
        }

        _pickingPASS() {
            var r = this._renderer;
            var h = r.handler;
            h.programs.labelPicking.activate();
            var sh = h.programs.labelPicking._program;
            var sha = sh.attributes,
                shu = sh.uniforms;

            var gl = h.gl,
                ec = this._entityCollection;

            var rn = ec.renderNode;

            gl.uniformMatrix4fv(shu.viewMatrix, false, r.activeCamera._viewMatrix._m);
            gl.uniformMatrix4fv(shu.projectionMatrix, false, r.activeCamera.getProjectionMatrix());
            gl.uniform3fv(shu.eyePositionHigh, r.activeCamera.eyeHigh);
            gl.uniform3fv(shu.eyePositionLow, r.activeCamera.eyeLow);
            gl.uniform3fv(shu.scaleByDistance, ec.scaleByDistance);
            gl.uniform1f(shu.opacity, ec._fadingOpacity);
            gl.uniform1f(shu.planetRadius, rn._planetRadius2 || 0);
            gl.uniform2fv(shu.viewport, [h.canvas.clientWidth, h.canvas.clientHeight]);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordBuffer);
            gl.vertexAttribPointer(sha.a_texCoord, this._texCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._gliphParamBuffer);
            gl.vertexAttribPointer(sha.a_gliphParam, this._gliphParamBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
            gl.vertexAttribPointer(sha.a_vertices, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._positionHighBuffer);
            gl.vertexAttribPointer(sha.a_positionsHigh, this._positionHighBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._positionLowBuffer);
            gl.vertexAttribPointer(sha.a_positionsLow, this._positionLowBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._sizeBuffer);
            gl.vertexAttribPointer(sha.a_size, this._sizeBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._rotationBuffer);
            gl.vertexAttribPointer(sha.a_rotation, this._rotationBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._offsetBuffer);
            gl.vertexAttribPointer(sha.a_offset, this._offsetBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._pickingColorBuffer);
            gl.vertexAttribPointer(sha.a_rgba, this._pickingColorBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.uniform1f(shu.depthOffset, ec.polygonOffsetUnits + window.LABEL_DEPTH_OFFSET);


            gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
        }

        _removeBillboard(label) {
            var li = label._handlerIndex;

            this._billboards.splice(li, 1);

            var ml = 24 * this._maxLetters;
            var i = li * ml;
            this._rgbaArr = spliceTypedArray(this._rgbaArr, i, ml);
            this._outlineColorArr = spliceTypedArray(this._outlineColorArr, i, ml);
            this._texCoordArr = spliceTypedArray(this._texCoordArr, i, ml);
            this._gliphParamArr = spliceTypedArray(this._gliphParamArr, i, ml);

            ml = 18 * this._maxLetters;
            i = li * ml;
            this._positionHighArr = spliceTypedArray(this._positionHighArr, i, ml);
            this._positionLowArr = spliceTypedArray(this._positionLowArr, i, ml);
            this._offsetArr = spliceTypedArray(this._offsetArr, i, ml);
            this._pickingColorArr = spliceTypedArray(this._pickingColorArr, i, ml);

            ml = 12 * this._maxLetters;
            i = li * ml;
            this._vertexArr = spliceTypedArray(this._vertexArr, i, ml);

            ml = 6 * this._maxLetters;
            i = li * ml;
            this._sizeArr = spliceTypedArray(this._sizeArr, i, ml);
            this._rotationArr = spliceTypedArray(this._rotationArr, i, ml);
            this._fontIndexArr = spliceTypedArray(this._fontIndexArr, i, ml);
            this._outlineArr = spliceTypedArray(this._outlineArr, i, ml);

            this.reindexBillbordsArray(li);
            this.refresh();

            label._handlerIndex = -1;
            label._handler = null;
            label._isReady = false;
        }

        setText(index, text, fontIndex, align, isRTL = false) {

            text = text.normalize('NFKC');

            var fa = this._renderer.fontAtlas.atlasesArr[fontIndex];

            if (!fa) return;

            let i = index * 24 * this._maxLetters;
            let a = this._texCoordArr,
                g = this._gliphParamArr;

            let c = 0;

            let len = Math.min(this._maxLetters, text.length);
            let _rtl_ = 0.0;
            if (isRTL) {
                _rtl_ = RTL;
            }
            
            let offset = 0.0;
            let kern = fa.kernings;

            for (c = 0; c < len; c++) {
                let j = i + c * 24;
                let char = text[c];
                let n = fa.get(char.charCodeAt()) || fa.get(" ".charCodeAt());
                let tc = n.texCoords;

                let m = n.metrics;

                a[j] = tc[0];
                a[j + 1] = tc[1];
                a[j + 2] = offset;
                a[j + 3] = _rtl_;

                a[j + 4] = tc[2];
                a[j + 5] = tc[3];
                a[j + 6] = offset;
                a[j + 7] = _rtl_;

                a[j + 8] = tc[4];
                a[j + 9] = tc[5];
                a[j + 10] = offset;
                a[j + 11] = _rtl_;

                a[j + 12] = tc[6];
                a[j + 13] = tc[7];
                a[j + 14] = offset;
                a[j + 15] = _rtl_;

                a[j + 16] = tc[8];
                a[j + 17] = tc[9];
                a[j + 18] = offset;
                a[j + 19] = _rtl_;

                a[j + 20] = tc[10];
                a[j + 21] = tc[11];
                a[j + 22] = offset;
                a[j + 23] = _rtl_;

                //
                // Gliph
                //
                g[j] = m.nWidth;
                g[j + 1] = m.nHeight;
                g[j + 2] = m.nXOffset;
                g[j + 3] = m.nYOffset;

                g[j + 4] = m.nWidth;
                g[j + 5] = m.nHeight;
                g[j + 6] = m.nXOffset;
                g[j + 7] = m.nYOffset;

                g[j + 8] = m.nWidth;
                g[j + 9] = m.nHeight;
                g[j + 10] = m.nXOffset;
                g[j + 11] = m.nYOffset;

                g[j + 12] = m.nWidth;
                g[j + 13] = m.nHeight;
                g[j + 14] = m.nXOffset;
                g[j + 15] = m.nYOffset;

                g[j + 16] = m.nWidth;
                g[j + 17] = m.nHeight;
                g[j + 18] = m.nXOffset;
                g[j + 19] = m.nYOffset;

                g[j + 20] = m.nWidth;
                g[j + 21] = m.nHeight;
                g[j + 22] = m.nXOffset;
                g[j + 23] = m.nYOffset;

                let k = kern[char.charCodeAt()];
                if (k && text[c + 1]) {
                    k = k[text[c + 1].charCodeAt()];
                    if (k) {
                        offset += m.nAdvance + k;
                    } else {
                        offset += m.nAdvance;
                    }
                } else {
                    offset += m.nAdvance;
                }
            }

            // 49/512 - font atlas left border letter offset
            if (align === ALIGN.CENTER) {
                offset *= -0.5;
                for (c = 0; c < len; c++) {
                    let j = i + c * 24;
                    a[j + 2] += offset;
                    a[j + 6] += offset;
                    a[j + 10] += offset;
                    a[j + 14] += offset;
                    a[j + 18] += offset;
                    a[j + 22] += offset;
                }
            }

            for (; c < this._maxLetters; c++) {
                let j = i + c * 24;
                a[j + 3] = EMPTY;
                a[j + 7] = EMPTY;
                a[j + 11] = EMPTY;
                a[j + 15] = EMPTY;
                a[j + 19] = EMPTY;
                a[j + 23] = EMPTY;
            }

            this._changedBuffers[TEXCOORD_BUFFER] = true;
        }

        setPositionArr(index, positionHigh, positionLow) {
            var i = index * 18 * this._maxLetters;
            var a = this._positionHighArr,
                x = positionHigh.x,
                y = positionHigh.y,
                z = positionHigh.z,
                b = this._positionLowArr,
                xl = positionLow.x,
                yl = positionLow.y,
                zl = positionLow.z;

            for (var q = 0; q < this._maxLetters; q++) {
                var j = i + q * 18;
                a[j] = x;
                a[j + 1] = y;
                a[j + 2] = z;

                a[j + 3] = x;
                a[j + 4] = y;
                a[j + 5] = z;

                a[j + 6] = x;
                a[j + 7] = y;
                a[j + 8] = z;

                a[j + 9] = x;
                a[j + 10] = y;
                a[j + 11] = z;

                a[j + 12] = x;
                a[j + 13] = y;
                a[j + 14] = z;

                a[j + 15] = x;
                a[j + 16] = y;
                a[j + 17] = z;

                // low
                b[j] = xl;
                b[j + 1] = yl;
                b[j + 2] = zl;

                b[j + 3] = xl;
                b[j + 4] = yl;
                b[j + 5] = zl;

                b[j + 6] = xl;
                b[j + 7] = yl;
                b[j + 8] = zl;

                b[j + 9] = xl;
                b[j + 10] = yl;
                b[j + 11] = zl;

                b[j + 12] = xl;
                b[j + 13] = yl;
                b[j + 14] = zl;

                b[j + 15] = xl;
                b[j + 16] = yl;
                b[j + 17] = zl;
            }

            this._changedBuffers[POSITION_BUFFER$1] = true;
        }

        setPickingColorArr(index, color) {
            var i = index * 18 * this._maxLetters;
            var a = this._pickingColorArr,
                x = color.x / 255,
                y = color.y / 255,
                z = color.z / 255;

            for (var q = 0; q < this._maxLetters; q++) {
                var j = i + q * 18;
                a[j] = x;
                a[j + 1] = y;
                a[j + 2] = z;

                a[j + 3] = x;
                a[j + 4] = y;
                a[j + 5] = z;

                a[j + 6] = x;
                a[j + 7] = y;
                a[j + 8] = z;

                a[j + 9] = x;
                a[j + 10] = y;
                a[j + 11] = z;

                a[j + 12] = x;
                a[j + 13] = y;
                a[j + 14] = z;

                a[j + 15] = x;
                a[j + 16] = y;
                a[j + 17] = z;
            }

            this._changedBuffers[PICKINGCOLOR_BUFFER$2] = true;
        }

        setSizeArr(index, size) {
            var i = index * 6 * this._maxLetters;
            var a = this._sizeArr;

            for (var q = 0; q < this._maxLetters; q++) {
                var j = i + q * 6;
                a[j] = size;
                a[j + 1] = size;
                a[j + 2] = size;
                a[j + 3] = size;
                a[j + 4] = size;
                a[j + 5] = size;
            }

            this._changedBuffers[SIZE_BUFFER$1] = true;
        }

        setOffsetArr(index, offset) {
            var i = index * 18 * this._maxLetters;
            var a = this._offsetArr,
                x = offset.x,
                y = offset.y,
                z = offset.z;

            for (var q = 0; q < this._maxLetters; q++) {
                var j = i + q * 18;
                a[j] = x;
                a[j + 1] = y;
                a[j + 2] = z;

                a[j + 3] = x;
                a[j + 4] = y;
                a[j + 5] = z;

                a[j + 6] = x;
                a[j + 7] = y;
                a[j + 8] = z;

                a[j + 9] = x;
                a[j + 10] = y;
                a[j + 11] = z;

                a[j + 12] = x;
                a[j + 13] = y;
                a[j + 14] = z;

                a[j + 15] = x;
                a[j + 16] = y;
                a[j + 17] = z;
            }

            this._changedBuffers[OFFSET_BUFFER] = true;
        }

        setRgbaArr(index, rgba) {
            var i = index * 24 * this._maxLetters;
            var a = this._rgbaArr,
                x = rgba.x,
                y = rgba.y,
                z = rgba.z,
                w = rgba.w;

            for (var q = 0; q < this._maxLetters; q++) {
                var j = i + q * 24;

                a[j] = x;
                a[j + 1] = y;
                a[j + 2] = z;
                a[j + 3] = w;

                a[j + 4] = x;
                a[j + 5] = y;
                a[j + 6] = z;
                a[j + 7] = w;

                a[j + 8] = x;
                a[j + 9] = y;
                a[j + 10] = z;
                a[j + 11] = w;

                a[j + 12] = x;
                a[j + 13] = y;
                a[j + 14] = z;
                a[j + 15] = w;

                a[j + 16] = x;
                a[j + 17] = y;
                a[j + 18] = z;
                a[j + 19] = w;

                a[j + 20] = x;
                a[j + 21] = y;
                a[j + 22] = z;
                a[j + 23] = w;
            }

            this._changedBuffers[RGBA_BUFFER$2] = true;
        }

        setOutlineColorArr(index, rgba) {
            var i = index * 24 * this._maxLetters;
            var a = this._outlineColorArr,
                x = rgba.x,
                y = rgba.y,
                z = rgba.z,
                w = rgba.w;

            for (var q = 0; q < this._maxLetters; q++) {
                var j = i + q * 24;

                a[j] = x;
                a[j + 1] = y;
                a[j + 2] = z;
                a[j + 3] = w;

                a[j + 4] = x;
                a[j + 5] = y;
                a[j + 6] = z;
                a[j + 7] = w;

                a[j + 8] = x;
                a[j + 9] = y;
                a[j + 10] = z;
                a[j + 11] = w;

                a[j + 12] = x;
                a[j + 13] = y;
                a[j + 14] = z;
                a[j + 15] = w;

                a[j + 16] = x;
                a[j + 17] = y;
                a[j + 18] = z;
                a[j + 19] = w;

                a[j + 20] = x;
                a[j + 21] = y;
                a[j + 22] = z;
                a[j + 23] = w;
            }

            this._changedBuffers[OUTLINECOLOR_BUFFER] = true;
        }

        setOutlineArr(index, outline) {
            var i = index * 6 * this._maxLetters;
            var a = this._outlineArr;

            for (var q = 0; q < this._maxLetters; q++) {
                var j = i + q * 6;
                a[j] = outline;
                a[j + 1] = outline;
                a[j + 2] = outline;
                a[j + 3] = outline;
                a[j + 4] = outline;
                a[j + 5] = outline;
            }

            this._changedBuffers[OUTLINE_BUFFER] = true;
        }

        setRotationArr(index, rotation) {
            var i = index * 6 * this._maxLetters;
            var a = this._rotationArr;

            for (var q = 0; q < this._maxLetters; q++) {
                var j = i + q * 6;
                a[j] = rotation;
                a[j + 1] = rotation;
                a[j + 2] = rotation;
                a[j + 3] = rotation;
                a[j + 4] = rotation;
                a[j + 5] = rotation;
            }

            this._changedBuffers[ROTATION_BUFFER] = true;
        }

        setVisibility(index, visibility) {
            var vArr;
            if (visibility) {
                vArr = [0, 0, 0, -1, 1, -1, 1, -1, 1, 0, 0, 0];
            } else {
                vArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            }
            this.setVertexArr(index, vArr);
        }

        setVertexArr(index, vertexArr) {
            var i = index * 12 * this._maxLetters;
            var a = this._vertexArr;

            for (var q = 0; q < this._maxLetters; q++) {
                var j = i + q * 12;

                a[j] = vertexArr[0];
                a[j + 1] = vertexArr[1];

                a[j + 2] = vertexArr[2];
                a[j + 3] = vertexArr[3];

                a[j + 4] = vertexArr[4];
                a[j + 5] = vertexArr[5];

                a[j + 6] = vertexArr[6];
                a[j + 7] = vertexArr[7];

                a[j + 8] = vertexArr[8];
                a[j + 9] = vertexArr[9];

                a[j + 10] = vertexArr[10];
                a[j + 11] = vertexArr[11];
            }

            this._changedBuffers[VERTEX_BUFFER$2] = true;
        }

        setFontIndexArr(index, fontIndex) {
            var i = index * 6 * this._maxLetters;
            var a = this._fontIndexArr;

            for (var q = 0; q < this._maxLetters; q++) {
                var j = i + q * 6;
                a[j] = fontIndex;
                a[j + 1] = fontIndex;
                a[j + 2] = fontIndex;
                a[j + 3] = fontIndex;
                a[j + 4] = fontIndex;
                a[j + 5] = fontIndex;
            }

            this._changedBuffers[FONTINDEX_BUFFER] = true;
        }

        createSizeBuffer() {
            var h = this._renderer.handler;
            h.gl.deleteBuffer(this._sizeBuffer);
            this._sizeBuffer = h.createArrayBuffer(this._sizeArr, 1, this._sizeArr.length);
        }

        createFontIndexBuffer() {
            var h = this._renderer.handler;
            h.gl.deleteBuffer(this._fontIndexBuffer);
            this._fontIndexBuffer = h.createArrayBuffer(
                this._fontIndexArr,
                1,
                this._fontIndexArr.length
            );
        }

        createTexCoordBuffer() {
            var h = this._renderer.handler;
            h.gl.deleteBuffer(this._texCoordBuffer);
            this._texCoordBuffer = h.createArrayBuffer(
                this._texCoordArr,
                4,
                this._texCoordArr.length / 4
            );

            h.gl.deleteBuffer(this._gliphParamBuffer);
            this._gliphParamBuffer = h.createArrayBuffer(
                this._gliphParamArr,
                4,
                this._gliphParamArr.length / 4
            );
        }

        createOutlineBuffer() {
            var h = this._renderer.handler;
            h.gl.deleteBuffer(this._outlineBuffer);
            this._outlineBuffer = h.createArrayBuffer(this._outlineArr, 1, this._outlineArr.length);
        }

        createOutlineColorBuffer() {
            var h = this._renderer.handler;
            h.gl.deleteBuffer(this._outlineColorBuffer);
            this._outlineColorBuffer = h.createArrayBuffer(this._outlineColorArr, 4, this._outlineColorArr.length / 4);
        }

        setMaxLetters(c) {
            this._maxLetters = c;
            // TODO: ...
        }

        refreshTexCoordsArr() {
            // it is empty
            return null;
        }
    }

    /**
     * @module og/shaders/polyline
     */

    function polyline_screen() {
        return new Program("polyline_screen", {
            uniforms: {
                viewport: "vec2",
                proj: "mat4",
                view: "mat4",
                eyePositionHigh: "vec3",
                eyePositionLow: "vec3",
                uFloatParams: "vec2",
                thickness: "float",
                opacity: "float",
                depthOffset: "float"
            },
            attributes: {
                prevHigh: "vec3",
                currentHigh: "vec3",
                nextHigh: "vec3",

                prevLow: "vec3",
                currentLow: "vec3",
                nextLow: "vec3",

                order: "float",

                color: "vec4"
            },

            vertexShader:
                `precision highp float;
                
                attribute vec3 prevHigh;
                attribute vec3 currentHigh;
                attribute vec3 nextHigh;
                
                attribute vec3 prevLow;
                attribute vec3 currentLow;
                attribute vec3 nextLow;

                attribute float order;

                attribute vec4 color;

                uniform float thickness;
                uniform mat4 proj;
                uniform mat4 view;
                uniform vec2 viewport;
                uniform vec3 eyePositionHigh;
                uniform vec3 eyePositionLow;
                uniform float opacity;
                uniform float depthOffset;

                varying vec4 vColor;
                varying vec3 vPos;
                varying vec3 uCamPos;
                
                const float NEAR = -1.0;
                
                vec2 getIntersection(vec2 start1, vec2 end1, vec2 start2, vec2 end2){
                    vec2 dir = end2 - start2;
                    vec2 perp = vec2(-dir.y, dir.x);
                    float d2 = dot(perp, start2);
                    float seg = dot(perp, start1) - d2;
                    float prl = seg - dot(perp, end1) + d2;
                    if(prl > -1.0 && prl < 1.0){
                        return start1;
                    }
                    float u = seg / prl;
                    return start1 + u * (end1 - start1);
                }
                
                vec2 project(vec4 p){
                    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;
                }
                
                void main(){

                    uCamPos = eyePositionHigh + eyePositionLow;

                    vColor = vec4(color.rgb, color.a * opacity);

                    vec3 current = currentHigh + currentLow;

                    vPos = current;                    

                    mat4 viewMatrixRTE = view;
                    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                    vec3 highDiff, lowDiff;

                    highDiff = currentHigh - eyePositionHigh;
                    lowDiff = currentLow - eyePositionLow;
                    vec4 vCurrent = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);

                    highDiff = prevHigh - eyePositionHigh;
                    lowDiff = prevLow - eyePositionLow;    
                    vec4 vPrev = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);

                    highDiff = nextHigh - eyePositionHigh;
                    lowDiff = nextLow - eyePositionLow;    
                    vec4 vNext = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);

                    /*Clip near plane, the point behind view plane*/
                    if(vCurrent.z > NEAR) {
                        if(vPrev.z < NEAR && abs(order) == 1.0){
                            vCurrent = vPrev + (vCurrent - vPrev) * (NEAR - vPrev.z) / (vCurrent.z - vPrev.z);
                        } else if(vNext.z < NEAR && abs(order) == 2.0){
                            vCurrent = vNext + (vCurrent - vNext) * (NEAR - vNext.z) / (vCurrent.z - vNext.z);
                        }
                    }
                    
                    vec4 dCurrent = proj * vCurrent;
                    vec2 _next = project(proj * vNext);
                    vec2 _prev = project(proj * vPrev);
                    vec2 _current = project(dCurrent);

                    if(_prev == _current){
                        if(_next == _current){
                            _next = _current + vec2(1.0, 0.0);
                            _prev = _current - _next;
                        }else{
                            _prev = _current + normalize(_current - _next);
                        }
                    }

                    if(_next == _current){
                        _next = _current + normalize(_current - _prev);
                    }
                    
                    vec2 sNext = _next,
                         sCurrent = _current,
                         sPrev = _prev;

                    vec2 dirNext = normalize(sNext - sCurrent);
                    vec2 dirPrev = normalize(sPrev - sCurrent);
                    float dotNP = dot(dirNext, dirPrev);
                    
                    vec2 normalNext = normalize(vec2(-dirNext.y, dirNext.x));
                    vec2 normalPrev = normalize(vec2(dirPrev.y, -dirPrev.x));
                    
                    float d = thickness * sign(order);
                    
                    vec2 m;
                    if(dotNP >= 0.99991){
                        m = sCurrent - normalPrev * d;
                    }else{
                        m = getIntersection( sCurrent + normalPrev * d, sPrev + normalPrev * d,
                                sCurrent + normalNext * d, sNext + normalNext * d );
                        
                        if( dotNP > 0.5 && dot(dirNext + dirPrev, m - sCurrent) < 0.0 ){
                            float occw = order * sign(dirNext.x * dirPrev.y - dirNext.y * dirPrev.x);
                            if(occw == -1.0){
                                m = sCurrent + normalPrev * d;
                            }else if(occw == 1.0){
                                m = sCurrent + normalNext * d;
                            }else if(occw == -2.0){
                                m = sCurrent + normalNext * d;
                            }else if(occw == 2.0){
                                m = sCurrent + normalPrev * d;
                            }
                        }else if(distance(sCurrent, m) > min(distance(sCurrent, sNext), distance(sCurrent, sPrev))){
                            m = sCurrent + normalNext * d;
                        }
                    }
                                            
                    gl_Position = vec4((2.0 * m / viewport - 1.0) * dCurrent.w, dCurrent.z + depthOffset, dCurrent.w);
                }`,

            fragmentShader:
                `precision highp float;
                uniform vec2 uFloatParams;
                varying vec3 uCamPos;
                varying vec4 vColor;
                varying vec3 vPos;
                void main() {
                    vec3 look = vPos - uCamPos;
                    float lookLength = length(look);
                    float a = vColor.a * step(lookLength, sqrt(dot(uCamPos,uCamPos) - uFloatParams[0]) + sqrt(dot(vPos,vPos) - uFloatParams[0]));                    
                    gl_FragColor = vec4(vColor.rgb, a);
                }`
        });
    }

    function polyline_picking() {
        return new Program("polyline_picking", {
            uniforms: {
                viewport: "vec2",
                proj: "mat4",
                view: "mat4",
                eyePositionHigh: "vec3",
                eyePositionLow: "vec3",
                uFloatParams: "vec2",
                color: "vec4",
                thickness: "float",
                depthOffset: "float"
            },
            attributes: {
                prevHigh: "vec3",
                currentHigh: "vec3",
                nextHigh: "vec3",

                prevLow: "vec3",
                currentLow: "vec3",
                nextLow: "vec3",

                order: "float"
            },

            vertexShader:
                `precision highp float;
                
                attribute vec3 prevHigh;
                attribute vec3 currentHigh;
                attribute vec3 nextHigh;
                
                attribute vec3 prevLow;
                attribute vec3 currentLow;
                attribute vec3 nextLow;

                attribute float order;

                uniform float thickness;
                uniform vec4 color;
                uniform mat4 proj;
                uniform mat4 view;
                uniform vec2 viewport;
                uniform vec3 eyePositionHigh;
                uniform vec3 eyePositionLow;
                uniform float depthOffset;

                varying vec4 vColor;
                varying vec3 vPos;
                varying vec3 uCamPos;
               
                
                const float NEAR = -1.0;
                
                vec2 getIntersection(vec2 start1, vec2 end1, vec2 start2, vec2 end2){
                    vec2 dir = end2 - start2;
                    vec2 perp = vec2(-dir.y, dir.x);
                    float d2 = dot(perp, start2);
                    float seg = dot(perp, start1) - d2;
                    float prl = seg - dot(perp, end1) + d2;
                    if(prl > -1.0 && prl < 1.0){
                        return start1;
                    }
                    float u = seg / prl;
                    return start1 + u * (end1 - start1);
                }
                
                vec2 project(vec4 p){
                    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;
                }
                
                void main(){

                    uCamPos = eyePositionHigh + eyePositionLow;

                    vColor = color;

                    vec3 current = currentHigh + currentLow;

                    vPos = current;                    

                    vec3 highDiff, lowDiff;

                    mat4 viewMatrixRTE = view;
                    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                    highDiff = currentHigh - eyePositionHigh;
                    lowDiff = currentLow - eyePositionLow;
                    vec4 vCurrent = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);

                    highDiff = prevHigh - eyePositionHigh;
                    lowDiff = prevLow - eyePositionLow;    
                    vec4 vPrev = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);

                    highDiff = nextHigh - eyePositionHigh;
                    lowDiff = nextLow - eyePositionLow;    
                    vec4 vNext = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);

                    /*Clip near plane*/
                    if(vCurrent.z > NEAR) {
                        if(vPrev.z < NEAR && abs(order) == 1.0){
                            vCurrent = vPrev + (vCurrent - vPrev) * (NEAR - vPrev.z) / (vCurrent.z - vPrev.z);
                        } else if(vNext.z < NEAR && abs(order) == 2.0){
                            vCurrent = vNext + (vCurrent - vNext) * (NEAR - vNext.z) / (vCurrent.z - vNext.z);
                        }
                    }
                    
                    vec4 dCurrent = proj * vCurrent;
                    vec2 _next = project(proj * vNext);
                    vec2 _prev = project(proj * vPrev);
                    vec2 _current = project(dCurrent);
                    if(_prev == _current){
                        if(_next == _current){
                            _next = _current + vec2(1.0, 0.0);
                            _prev = _current - _next;
                        }else{
                            _prev = _current + normalize(_current - _next);
                        }
                    }
                    if(_next == _current){
                        _next = _current + normalize(_current - _prev);
                    }
                    
                    vec2 sNext = _next,
                         sCurrent = _current,
                         sPrev = _prev;

                    vec2 dirNext = normalize(sNext - sCurrent);
                    vec2 dirPrev = normalize(sPrev - sCurrent);
                    float dotNP = dot(dirNext, dirPrev);
                    
                    vec2 normalNext = normalize(vec2(-dirNext.y, dirNext.x));
                    vec2 normalPrev = normalize(vec2(dirPrev.y, -dirPrev.x));
                    
                    float d = thickness * sign(order);
                    
                    vec2 m;
                    if(dotNP >= 0.99991){
                        m = sCurrent - normalPrev * d;
                    }else{
                        m = getIntersection( sCurrent + normalPrev * d, sPrev + normalPrev * d,
                                sCurrent + normalNext * d, sNext + normalNext * d );
                        
                        if( dotNP > 0.5 && dot(dirNext + dirPrev, m - sCurrent) < 0.0 ){
                            float occw = order * sign(dirNext.x * dirPrev.y - dirNext.y * dirPrev.x);
                            if(occw == -1.0){
                                m = sCurrent + normalPrev * d;
                            }else if(occw == 1.0){
                                m = sCurrent + normalNext * d;
                            }else if(occw == -2.0){
                                m = sCurrent + normalNext * d;
                            }else if(occw == 2.0){
                                m = sCurrent + normalPrev * d;
                            }
                        }
                        else if(distance(sCurrent, m) > min(distance(sCurrent, sNext), distance(sCurrent, sPrev))){
                            m = sCurrent + normalNext * d;
                        }
                    }
                    gl_Position = vec4((2.0 * m / viewport - 1.0) * dCurrent.w, dCurrent.z + depthOffset, dCurrent.w);
                }`,

            fragmentShader:
                `precision highp float;
                uniform vec2 uFloatParams;
                varying vec3 uCamPos;
                varying vec4 vColor;
                varying vec3 vPos;
                void main() {
                    vec3 look = vPos - uCamPos;
                    float lookLength = length(look);
                    float a = vColor.a * step(lookLength, sqrt(dot(uCamPos,uCamPos) - uFloatParams[0]) + sqrt(dot(vPos,vPos) - uFloatParams[0]));                    
                    gl_FragColor = vec4(vColor.rgb, a);
                }`
        });
    }

    /**
     * @module og/entity/PolylineHandler
     */

    class PolylineHandler {
        constructor(entityCollection) {

            this._entityCollection = entityCollection;

            this._renderer = null;

            this._polylines = [];

            this.__staticId = PolylineHandler._staticCounter++;

            this.pickingEnabled = true;
        }

        static get _staticCounter() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set _staticCounter(n) {
            this._counter = n;
        }

        _initProgram() {
            if (this._renderer.handler) {
                if (!this._renderer.handler.programs.polyline_screen) {
                    this._renderer.handler.addProgram(polyline_screen());
                }
                if (!this._renderer.handler.programs.polyline_picking) {
                    this._renderer.handler.addProgram(polyline_picking());
                }
            }
        }

        setRenderNode(renderNode) {
            this._renderer = renderNode.renderer;
            this._initProgram();
            for (var i = 0; i < this._polylines.length; i++) {
                this._polylines[i].setRenderNode(renderNode);
            }
        }

        add(polyline) {
            if (polyline._handlerIndex === -1) {
                polyline._handler = this;
                polyline._handlerIndex = this._polylines.length;
                this._polylines.push(polyline);
                this._entityCollection && this._entityCollection.renderNode &&
                    polyline.setRenderNode(this._entityCollection.renderNode);
            }
        }

        remove(polyline) {
            var index = polyline._handlerIndex;
            if (index !== -1) {
                polyline._deleteBuffers();
                polyline._handlerIndex = -1;
                polyline._handler = null;
                this._polylines.splice(index, 1);
                this.reindexPolylineArray(index);
            }
        }

        reindexPolylineArray(startIndex) {
            var ls = this._polylines;
            for (var i = startIndex; i < ls.length; i++) {
                ls[i]._handlerIndex = i;
            }
        }

        draw() {
            let i = this._polylines.length;
            while (i--) {
                this._polylines[i].draw();
            }
        }

        drawPicking() {
            if (this.pickingEnabled) {
                let i = this._polylines.length;
                while (i--) {
                    this._polylines[i].drawPicking();
                }
            }
        }

        clear() {
            var i = this._polylines.length;
            while (i--) {
                this._polylines[i]._deleteBuffers();
                this._polylines[i]._handler = null;
                this._polylines[i]._handlerIndex = -1;
            }
            this._polylines.length = 0;
            this._polylines = [];
        }
    }

    /**
     * @module og/shaders/ray
     */

    function rayScreen() {
        return new Program("rayScreen", {
            uniforms: {
                projectionMatrix: "mat4",
                viewMatrix: "mat4",
                eyePositionHigh: "vec3",
                eyePositionLow: "vec3",
                resolution: "float",
                uOpacity: "float"
            },
            attributes: {
                a_vertices: "vec2",
                a_startPosHigh: "vec3",
                a_startPosLow: "vec3",
                a_endPosHigh: "vec3",
                a_endPosLow: "vec3",
                a_length: "float",
                a_thickness: "float",
                a_rgba: "vec4"
            },
            vertexShader:
                `precision highp float;
            attribute vec2 a_vertices;
            attribute vec3 a_startPosHigh;
            attribute vec3 a_startPosLow;
            attribute vec3 a_endPosHigh;
            attribute vec3 a_endPosLow;
            attribute float a_thickness;
            attribute float a_length;
            attribute vec4 a_rgba;

            varying vec4 v_rgba;

            uniform mat4 viewMatrix;
            uniform mat4 projectionMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float resolution;
            uniform float uOpacity;

            void main() {

                v_rgba = vec4(a_rgba.rgb, a_rgba.a * uOpacity);

                vec3 camPos = eyePositionHigh + eyePositionLow;

                vec3 startPos = a_startPosHigh + a_startPosLow;
                vec3 direction = normalize((a_endPosHigh + a_endPosLow) - startPos);
                vec3 vertPos = startPos + a_vertices.y * direction * a_length;

                vec3 look = vertPos - camPos;
                vec3 up = normalize(direction);
                vec3 right = normalize(cross(look,up));
 
                float dist = dot(camPos - vertPos, vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]));
                float focalSize = 2.0 * dist * resolution;
                vec3 rr = right * a_thickness * focalSize * a_vertices.x + up * a_length * a_vertices.y;

                vec3 highDiff = a_startPosHigh - eyePositionHigh;
                vec3 lowDiff = a_startPosLow + rr - eyePositionLow;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                vec4 pos = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
                
                gl_Position = projectionMatrix * pos;
            }`,
            fragmentShader:
                `precision highp float;
            varying vec4 v_rgba;
            void main () {
                gl_FragColor = v_rgba;
            }`
        });
    }

    const PICKINGCOLOR_BUFFER$1 = 0;
    const START_POSITION_BUFFER = 1;
    const END_POSITION_BUFFER = 2;
    const LENGTH_BUFFER = 3;
    const RGBA_BUFFER$1 = 4;
    const THICKNESS_BUFFER = 5;
    const VERTEX_BUFFER$1 = 6;

    /*
     * og.RayHandler
     *
     *
     */
    class RayHandler {
        constructor(entityCollection) {
            /**
             * Picking rendering option.
             * @public
             * @type {boolean}
             */
            this.pickingEnabled = true;

            this._entityCollection = entityCollection;

            this._renderer = null;

            this._rays = [];

            this._vertexBuffer = null;
            this._startPositionHighBuffer = null;
            this._startPositionLowBuffer = null;
            this._endPositionHighBuffer = null;
            this._endPositionLowBuffer = null;
            this._lengthBuffer = null;
            this._thicknessBuffer = null;
            this._rgbaBuffer = null;

            this._vertexArr = [];
            this._startPositionHighArr = [];
            this._startPositionLowArr = [];
            this._endPositionHighArr = [];
            this._endPositionLowArr = [];
            this._lengthArr = [];
            this._thicknessArr = [];
            this._rgbaArr = [];

            this._pickingColorBuffer = null;
            this._pickingColorArr = [];

            this._buffersUpdateCallbacks = [];
            this._buffersUpdateCallbacks[VERTEX_BUFFER$1] = this.createVertexBuffer;
            this._buffersUpdateCallbacks[START_POSITION_BUFFER] = this.createStartPositionBuffer;
            this._buffersUpdateCallbacks[END_POSITION_BUFFER] = this.createEndPositionBuffer;
            this._buffersUpdateCallbacks[LENGTH_BUFFER] = this.createLengthBuffer;
            this._buffersUpdateCallbacks[THICKNESS_BUFFER] = this.createThicknessBuffer;
            this._buffersUpdateCallbacks[RGBA_BUFFER$1] = this.createRgbaBuffer;
            this._buffersUpdateCallbacks[PICKINGCOLOR_BUFFER$1] = this.createPickingColorBuffer;

            this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);

            this.__staticId = RayHandler._staticCounter++;
        }

        static get _staticCounter() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set _staticCounter(n) {
            this._counter = n;
        }

        static concArr(dest, curr) {
            for (var i = 0; i < curr.length; i++) {
                dest.push(curr[i]);
            }
        }

        initProgram() {
            if (this._renderer.handler) {
                if (!this._renderer.handler.programs.rayScreen) {
                    this._renderer.handler.addProgram(rayScreen());
                }

                // if (!this._renderer.handler.programs.billboardPicking) {
                //     this._renderer.handler.addProgram(shaders.billboardPicking());
                // }
            }
        }

        setRenderer(renderer) {
            this._renderer = renderer;
            this.initProgram();
        }

        refresh() {
            var i = this._changedBuffers.length;
            while (i--) {
                this._changedBuffers[i] = true;
            }
        }

        _removeRays() {
            var i = this._rays.length;
            while (i--) {
                var ri = this._rays[i];
                ri._handlerIndex = -1;
                ri._handler = null;
            }
            this._rays.length = 0;
            this._rays = [];
        }

        clear() {
            this._vertexArr = null;
            this._startPositionHighArr = null;
            this._startPositionLowArr = null;
            this._endPositionHighArr = null;
            this._endPositionLowArr = null;
            this._lengthArr = null;
            this._thicknessArr = null;
            this._rgbaArr = null;

            this._vertexArr = new Float32Array();
            this._startPositionHighArr = new Float32Array();
            this._startPositionLowArr = new Float32Array();
            this._endPositionHighArr = new Float32Array();
            this._endPositionLowArr = new Float32Array();
            this._lengthArr = new Float32Array();
            this._thicknessArr = new Float32Array();
            this._rgbaArr = new Float32Array();

            this._removeRays();
            this._deleteBuffers();
            this.refresh();
        }

        _deleteBuffers() {
            if (this._renderer) {
                var gl = this._renderer.handler.gl;

                gl.deleteBuffer(this._startPositionHighBuffer);
                gl.deleteBuffer(this._startPositionLowBuffer);
                gl.deleteBuffer(this._endPositionHighBuffer);
                gl.deleteBuffer(this._endPositionLowBuffer);
                gl.deleteBuffer(this._lengthBuffer);
                gl.deleteBuffer(this._thicknessBuffer);
                gl.deleteBuffer(this._rgbaBuffer);
                gl.deleteBuffer(this._vertexBuffer);

                this._startPositionHighBuffer = null;
                this._startPositionLowBuffer = null;
                this._endPositionHighBuffer = null;
                this._endPositionLowBuffer = null;
                this._lengthBuffer = null;
                this._thicknessBuffer = null;
                this._rgbaBuffer = null;
                this._vertexBuffer = null;
            }
        }

        update() {
            if (this._renderer) {
                var i = this._changedBuffers.length;
                while (i--) {
                    if (this._changedBuffers[i]) {
                        this._buffersUpdateCallbacks[i].call(this);
                        this._changedBuffers[i] = false;
                    }
                }
            }
        }

        add(ray) {
            if (ray._handlerIndex == -1) {
                ray._handler = this;
                ray._handlerIndex = this._rays.length;
                this._rays.push(ray);
                this._addRayToArrays(ray);
                this.refresh();
            }
        }

        _addRayToArrays(ray) {
            if (ray._visibility) {
                this._vertexArr = concatArrays(
                    this._vertexArr,
                    [-0.5, 1.0, -0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 1.0, -0.5, 1.0]
                );
            } else {
                this._vertexArr = concatArrays(
                    this._vertexArr,
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
                );
            }

            let x = ray._startPositionHigh.x,
                y = ray._startPositionHigh.y,
                z = ray._startPositionHigh.z;
            this._startPositionHighArr = concatArrays(this._startPositionHighArr, [
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z
            ]);

            x = ray._startPositionLow.x;
            y = ray._startPositionLow.y;
            z = ray._startPositionLow.z;
            this._startPositionLowArr = concatArrays(this._startPositionLowArr, [
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z
            ]);

            x = ray._endPositionHigh.x;
            y = ray._endPositionHigh.y;
            z = ray._endPositionHigh.z;
            this._endPositionHighArr = concatArrays(this._endPositionHighArr, [
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z
            ]);

            x = ray._endPositionLow.x;
            y = ray._endPositionLow.y;
            z = ray._endPositionLow.z;
            this._endPositionLowArr = concatArrays(this._endPositionLowArr, [
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z
            ]);

            x = ray._thickness;
            this._thicknessArr = concatArrays(this._thicknessArr, [x, x, x, x, x, x]);

            x = ray._length;
            this._lengthArr = concatArrays(this._lengthArr, [x, x, x, x, x, x]);

            let r0 = ray._startColor.x,
                g0 = ray._startColor.y,
                b0 = ray._startColor.z,
                a0 = ray._startColor.w,
                r1 = ray._endColor.x,
                g1 = ray._endColor.y,
                b1 = ray._endColor.z,
                a1 = ray._endColor.w;
            this._rgbaArr = concatArrays(this._rgbaArr, [
                r1,
                g1,
                b1,
                a1,
                r0,
                g0,
                b0,
                a0,
                r0,
                g0,
                b0,
                a0,
                r0,
                g0,
                b0,
                a0,
                r1,
                g1,
                b1,
                a1,
                r1,
                g1,
                b1,
                a1
            ]);

            x = ray._entity._pickingColor.x / 255;
            y = ray._entity._pickingColor.y / 255;
            z = ray._entity._pickingColor.z / 255;
            this._pickingColorArr = concatArrays(this._pickingColorArr, [
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z,
                x,
                y,
                z
            ]);
        }

        _displayPASS() {
            var r = this._renderer;
            var h = r.handler;
            h.programs.rayScreen.activate();
            var sh = h.programs.rayScreen._program;
            var sha = sh.attributes,
                shu = sh.uniforms;

            var gl = h.gl,
                ec = this._entityCollection;

            //gl.polygonOffset(ec.polygonOffsetFactor, ec.polygonOffsetUnits);

            gl.uniform1f(shu.uOpacity, ec._fadingOpacity);

            gl.uniformMatrix4fv(shu.viewMatrix, false, r.activeCamera.getViewMatrix());
            gl.uniformMatrix4fv(shu.projectionMatrix, false, r.activeCamera.getProjectionMatrix());

            gl.uniform3fv(shu.eyePositionHigh, r.activeCamera.eyeHigh);
            gl.uniform3fv(shu.eyePositionLow, r.activeCamera.eyeLow);

            gl.uniform1f(shu.resolution, r.activeCamera._tanViewAngle_hradOneByHeight);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._startPositionHighBuffer);
            gl.vertexAttribPointer(
                sha.a_startPosHigh,
                this._startPositionHighBuffer.itemSize,
                gl.FLOAT,
                false,
                0,
                0
            );

            gl.bindBuffer(gl.ARRAY_BUFFER, this._startPositionLowBuffer);
            gl.vertexAttribPointer(
                sha.a_startPosLow,
                this._startPositionLowBuffer.itemSize,
                gl.FLOAT,
                false,
                0,
                0
            );

            gl.bindBuffer(gl.ARRAY_BUFFER, this._endPositionHighBuffer);
            gl.vertexAttribPointer(
                sha.a_endPosHigh,
                this._endPositionHighBuffer.itemSize,
                gl.FLOAT,
                false,
                0,
                0
            );

            gl.bindBuffer(gl.ARRAY_BUFFER, this._endPositionLowBuffer);
            gl.vertexAttribPointer(
                sha.a_endPosLow,
                this._endPositionLowBuffer.itemSize,
                gl.FLOAT,
                false,
                0,
                0
            );

            gl.bindBuffer(gl.ARRAY_BUFFER, this._rgbaBuffer);
            gl.vertexAttribPointer(sha.a_rgba, this._rgbaBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._thicknessBuffer);
            gl.vertexAttribPointer(
                sha.a_thickness,
                this._thicknessBuffer.itemSize,
                gl.FLOAT,
                false,
                0,
                0
            );

            gl.bindBuffer(gl.ARRAY_BUFFER, this._lengthBuffer);
            gl.vertexAttribPointer(sha.a_length, this._lengthBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
            gl.vertexAttribPointer(sha.a_vertices, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
        }

        _pickingPASS() {
            // ...
        }

        draw() {
            if (this._rays.length) {
                this.update();
                this._displayPASS();
            }
        }

        drawPicking() {
            if (this._rays.length && this.pickingEnabled) {
                this._pickingPASS();
            }
        }

        reindexRaysArray(startIndex) {
            var r = this._rays;
            for (var i = startIndex; i < r.length; i++) {
                r[i]._handlerIndex = i;
            }
        }

        _removeRay(ray) {
            var ri = ray._handlerIndex;

            this._rays.splice(ri, 1);

            var i = ri * 24;
            this._rgbaArr = spliceArray(this._rgbaArr, i, 24);

            i = ri * 18;
            this._startPositionHighArr = spliceArray(this._startPositionHighArr, i, 18);
            this._startPositionLowArr = spliceArray(this._startPositionLowArr, i, 18);
            this._endPositionHighArr = spliceArray(this._endPositionHighArr, i, 18);
            this._endPositionLowArr = spliceArray(this._endPositionLowArr, i, 18);
            this._pickingColorArr = spliceArray(this._pickingColorArr, i, 18);

            i = ri * 12;
            this._vertexArr = spliceArray(this._vertexArr, i, 12);

            i = ri * 6;
            this._thicknessArr = spliceArray(this._thicknessArr, i, 6);
            this._lengthArr = spliceArray(this._lengthArr, i, 6);

            this.reindexRaysArray(ri);
            this.refresh();

            ray._handlerIndex = -1;
            ray._handler = null;
        }

        remove(ray) {
            if (ray._handler && this.__staticId == ray._handler.__staticId) {
                this._removeRay(ray);
            }
        }

        setStartPositionArr(index, positionHigh, positionLow) {
            var i = index * 18;

            // High
            var a = this._startPositionHighArr,
                x = positionHigh.x,
                y = positionHigh.y,
                z = positionHigh.z;

            a[i] = x;
            a[i + 1] = y;
            a[i + 2] = z;

            a[i + 3] = x;
            a[i + 4] = y;
            a[i + 5] = z;

            a[i + 6] = x;
            a[i + 7] = y;
            a[i + 8] = z;

            a[i + 9] = x;
            a[i + 10] = y;
            a[i + 11] = z;

            a[i + 12] = x;
            a[i + 13] = y;
            a[i + 14] = z;

            a[i + 15] = x;
            a[i + 16] = y;
            a[i + 17] = z;

            // Low
            a = this._startPositionLowArr;
            x = positionLow.x;
            y = positionLow.y;
            z = positionLow.z;

            a[i] = x;
            a[i + 1] = y;
            a[i + 2] = z;

            a[i + 3] = x;
            a[i + 4] = y;
            a[i + 5] = z;

            a[i + 6] = x;
            a[i + 7] = y;
            a[i + 8] = z;

            a[i + 9] = x;
            a[i + 10] = y;
            a[i + 11] = z;

            a[i + 12] = x;
            a[i + 13] = y;
            a[i + 14] = z;

            a[i + 15] = x;
            a[i + 16] = y;
            a[i + 17] = z;

            this._changedBuffers[START_POSITION_BUFFER] = true;
        }

        setEndPositionArr(index, positionHigh, positionLow) {
            var i = index * 18;

            // High
            var a = this._endPositionHighArr,
                x = positionHigh.x,
                y = positionHigh.y,
                z = positionHigh.z;

            a[i] = x;
            a[i + 1] = y;
            a[i + 2] = z;

            a[i + 3] = x;
            a[i + 4] = y;
            a[i + 5] = z;

            a[i + 6] = x;
            a[i + 7] = y;
            a[i + 8] = z;

            a[i + 9] = x;
            a[i + 10] = y;
            a[i + 11] = z;

            a[i + 12] = x;
            a[i + 13] = y;
            a[i + 14] = z;

            a[i + 15] = x;
            a[i + 16] = y;
            a[i + 17] = z;

            // Low
            a = this._endPositionLowArr;
            x = positionLow.x;
            y = positionLow.y;
            z = positionLow.z;

            a[i] = x;
            a[i + 1] = y;
            a[i + 2] = z;

            a[i + 3] = x;
            a[i + 4] = y;
            a[i + 5] = z;

            a[i + 6] = x;
            a[i + 7] = y;
            a[i + 8] = z;

            a[i + 9] = x;
            a[i + 10] = y;
            a[i + 11] = z;

            a[i + 12] = x;
            a[i + 13] = y;
            a[i + 14] = z;

            a[i + 15] = x;
            a[i + 16] = y;
            a[i + 17] = z;

            this._changedBuffers[END_POSITION_BUFFER] = true;
        }

        setPickingColorArr(index, color) {
            var i = index * 18;
            var a = this._pickingColorArr,
                x = color.x / 255,
                y = color.y / 255,
                z = color.z / 255;

            a[i] = x;
            a[i + 1] = y;
            a[i + 2] = z;

            a[i + 3] = x;
            a[i + 4] = y;
            a[i + 5] = z;

            a[i + 6] = x;
            a[i + 7] = y;
            a[i + 8] = z;

            a[i + 9] = x;
            a[i + 10] = y;
            a[i + 11] = z;

            a[i + 12] = x;
            a[i + 13] = y;
            a[i + 14] = z;

            a[i + 15] = x;
            a[i + 16] = y;
            a[i + 17] = z;

            this._changedBuffers[PICKINGCOLOR_BUFFER$1] = true;
        }

        setRgbaArr(index, startColor, endColor) {
            var i = index * 24;
            var a = this._rgbaArr,
                r0 = startColor.x,
                g0 = startColor.y,
                b0 = startColor.z,
                a0 = startColor.w,
                r1 = endColor.x,
                g1 = endColor.y,
                b1 = endColor.z,
                a1 = endColor.w;

            a[i] = r1;
            a[i + 1] = g1;
            a[i + 2] = b1;
            a[i + 3] = a1;

            a[i + 4] = r0;
            a[i + 5] = g0;
            a[i + 6] = b0;
            a[i + 7] = a0;

            a[i + 8] = r0;
            a[i + 9] = g0;
            a[i + 10] = b0;
            a[i + 11] = a0;

            a[i + 12] = r0;
            a[i + 13] = g0;
            a[i + 14] = b0;
            a[i + 15] = a0;

            a[i + 16] = r1;
            a[i + 17] = g1;
            a[i + 18] = b1;
            a[i + 19] = a1;

            a[i + 20] = r1;
            a[i + 21] = g1;
            a[i + 22] = b1;
            a[i + 23] = a1;

            this._changedBuffers[RGBA_BUFFER$1] = true;
        }

        setThicknessArr(index, thickness) {
            var i = index * 6;
            var a = this._thicknessArr;

            a[i] = thickness;
            a[i + 1] = thickness;
            a[i + 2] = thickness;
            a[i + 3] = thickness;
            a[i + 4] = thickness;
            a[i + 5] = thickness;

            this._changedBuffers[THICKNESS_BUFFER] = true;
        }

        setLengthArr(index, length) {
            var i = index * 6;
            var a = this._lengthArr;

            a[i] = length;
            a[i + 1] = length;
            a[i + 2] = length;
            a[i + 3] = length;
            a[i + 4] = length;
            a[i + 5] = length;

            this._changedBuffers[LENGTH_BUFFER] = true;
        }

        setVisibility(index, visibility) {
            var vArr;
            if (visibility) {
                vArr = [-0.5, 1.0, -0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 1.0, -0.5, 1.0];
            } else {
                vArr = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
            }
            this.setVertexArr(index, vArr);
        }

        setVertexArr(index, vertexArr) {
            var i = index * 12;
            var a = this._vertexArr;

            a[i] = vertexArr[0];
            a[i + 1] = vertexArr[1];
            a[i + 2] = vertexArr[2];

            a[i + 3] = vertexArr[3];
            a[i + 4] = vertexArr[4];
            a[i + 5] = vertexArr[5];

            a[i + 6] = vertexArr[6];
            a[i + 7] = vertexArr[7];
            a[i + 8] = vertexArr[8];

            a[i + 9] = vertexArr[9];
            a[i + 10] = vertexArr[10];
            a[i + 11] = vertexArr[11];

            this._changedBuffers[VERTEX_BUFFER$1] = true;
        }

        createStartPositionBuffer() {
            var h = this._renderer.handler;
            h.gl.deleteBuffer(this._startPositionHighBuffer);
            this._startPositionHighArr = makeArrayTyped(this._startPositionHighArr);
            this._startPositionHighBuffer = h.createArrayBuffer(
                this._startPositionHighArr,
                3,
                this._startPositionHighArr.length / 3,
                h.gl.DYNAMIC_DRAW
            );
            h.gl.deleteBuffer(this._startPositionLowBuffer);
            this._startPositionLowArr = makeArrayTyped(this._startPositionLowArr);

            this._startPositionLowBuffer = h.createArrayBuffer(
                this._startPositionLowArr,
                3,
                this._startPositionLowArr.length / 3,
                h.gl.DYNAMIC_DRAW
            );
        }

        createEndPositionBuffer() {
            var h = this._renderer.handler;
            h.gl.deleteBuffer(this._endPositionHighBuffer);
            this._endPositionHighArr = makeArrayTyped(this._endPositionHighArr);
            this._endPositionHighBuffer = h.createArrayBuffer(
                this._endPositionHighArr,
                3,
                this._endPositionHighArr.length / 3,
                h.gl.DYNAMIC_DRAW
            );
            h.gl.deleteBuffer(this._endPositionLowBuffer);
            this._endPositionLowArr = makeArrayTyped(this._endPositionLowArr);
            this._endPositionLowBuffer = h.createArrayBuffer(
                this._endPositionLowArr,
                3,
                this._endPositionLowArr.length / 3,
                h.gl.DYNAMIC_DRAW
            );
        }

        createRgbaBuffer() {
            var h = this._renderer.handler;
            h.gl.deleteBuffer(this._rgbaBuffer);
            this._rgbaArr = makeArrayTyped(this._rgbaArr);
            this._rgbaBuffer = h.createArrayBuffer(this._rgbaArr, 4, this._rgbaArr.length / 4);
        }

        createThicknessBuffer() {
            var h = this._renderer.handler;
            h.gl.deleteBuffer(this._thicknessBuffer);
            this._thicknessArr = makeArrayTyped(this._thicknessArr);
            this._thicknessBuffer = h.createArrayBuffer(
                this._thicknessArr,
                1,
                this._thicknessArr.length,
                h.gl.DYNAMIC_DRAW
            );
        }

        createLengthBuffer() {
            var h = this._renderer.handler;
            h.gl.deleteBuffer(this._lengthBuffer);
            this._lengthArr = makeArrayTyped(this._lengthArr);
            this._lengthBuffer = h.createArrayBuffer(
                this._lengthArr,
                1,
                this._lengthArr.length,
                h.gl.DYNAMIC_DRAW
            );
        }

        createVertexBuffer() {
            var h = this._renderer.handler;
            h.gl.deleteBuffer(this._vertexBuffer);
            this._vertexArr = makeArrayTyped(this._vertexArr);
            this._vertexBuffer = h.createArrayBuffer(
                this._vertexArr,
                2,
                this._vertexArr.length / 2,
                h.gl.DYNAMIC_DRAW
            );
        }

        createPickingColorBuffer() {
            var h = this._renderer.handler;
            h.gl.deleteBuffer(this._pickingColorBuffer);
            this._pickingColorArr = makeArrayTyped(this._pickingColorArr);
            this._pickingColorBuffer = h.createArrayBuffer(
                this._pickingColorArr,
                3,
                this._pickingColorArr.length / 3
            );
        }
    }

    /**
     * @module og/shaders/pointCloud
     */

    //Picking is the same
    function pointCloud() {
        return new Program("pointCloud", {
            uniforms: {
                projectionViewMatrix: { type: types$1.MAT4 },
                opacity: { type: types$1.FLOAT },
                pointSize: { type: types$1.FLOAT }
            },
            attributes: {
                coordinates: { type: types$1.VEC3, enableArray: true },
                colors: { type: types$1.VEC3, enableArray: true }
            },
            vertexShader:
                `attribute vec3 coordinates;
            attribute vec4 colors;
            uniform mat4 projectionViewMatrix;
            uniform float opacity;
            uniform float pointSize;
            varying vec4 color;
            void main() {
                color = colors;
                color.a *= opacity;
                gl_Position = projectionViewMatrix * vec4(coordinates, 1.0);
                gl_PointSize = pointSize;
            }`,
            fragmentShader:
                `precision highp float;
            varying vec4 color;
            void main(void) {
                gl_FragColor = color;
            }`
        });
    }

    /**
     * @module og/entity/PointCloudHandler
     */

    class PointCloudHandler {
        constructor(entityCollection) {
            /**
             * Picking rendering option.
             * @public
             * @type {boolean}
             */
            this.pickingEnabled = true;

            /**
             * Parent collection
             * @private
             * @type {EntityCollection}
             */
            this._entityCollection = entityCollection;

            /**
             * Renderer
             * @private
             * @type {Renderer}
             */
            this._renderer = null;

            /**
             * Point cloud array
             * @private
             * @type {Array.<PointCloud>}
             */
            this._pointClouds = [];

            this.__staticId = PointCloudHandler._staticCounter++;
        }

        static get _staticCounter() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set _staticCounter(n) {
            this._counter = n;
        }

        _initProgram() {
            if (this._renderer.handler) {
                if (!this._renderer.handler.programs.pointCloud) {
                    this._renderer.handler.addProgram(pointCloud());
                }
            }
        }

        setRenderNode(renderNode) {
            this._renderer = renderNode.renderer;
            this._initProgram();
            for (var i = 0; i < this._pointClouds.length; i++) {
                this._pointClouds[i].setRenderNode(renderNode);
            }
        }

        add(pointCloud) {
            if (pointCloud._handlerIndex === -1) {
                pointCloud._handler = this;
                pointCloud._handlerIndex = this._pointClouds.length;
                this._pointClouds.push(pointCloud);
                this._entityCollection &&
                    this._entityCollection.renderNode &&
                    pointCloud.setRenderNode(this._entityCollection.renderNode);
            }
        }

        remove(pointCloud) {
            var index = pointCloud._handlerIndex;
            if (index !== -1) {
                pointCloud._deleteBuffers();
                pointCloud._handlerIndex = -1;
                pointCloud._handler = null;
                this._pointClouds.splice(index, 1);
                this.reindexPointCloudArray(index);
            }
        }

        reindexPointCloudArray(startIndex) {
            var pc = this._pointClouds;
            for (var i = startIndex; i < pc.length; i++) {
                pc[i]._handlerIndex = i;
            }
        }

        draw() {
            var i = this._pointClouds.length;
            while (i--) {
                this._pointClouds[i].draw();
            }
        }

        drawPicking() {
            if (this.pickingEnabled) {
                var i = this._pointClouds.length;
                while (i--) {
                    this._pointClouds[i].drawPicking();
                }
            }
        }

        clear() {
            var i = this._pointClouds.length;
            while (i--) {
                this._pointClouds[i]._deleteBuffers();
                this._pointClouds[i]._handler = null;
                this._pointClouds[i]._handlerIndex = -1;
            }
            this._pointClouds.length = 0;
            this._pointClouds = [];
        }
    }

    class StripHandler {
        constructor(entityCollection) {
            /**
             * Picking rendering option.
             * @public
             * @type {boolean}
             */
            this.pickingEnabled = true;

            /**
             * Parent collection
             * @private
             * @type {EntityCollection}
             */
            this._entityCollection = entityCollection;

            /**
             * Renderer
             * @private
             * @type {Renderer}
             */
            this._renderer = null;

            /**
             * Point cloud array
             * @private
             * @type {Array.<Strip>}
             */
            this._strips = [];

            this.__staticId = StripHandler._staticCounter++;
        }

        static get _staticCounter() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set _staticCounter(n) {
            this._counter = n;
        }

        _initProgram() {
            if (this._renderer.handler) {
                !this._renderer.handler.programs.strip &&
                    this._renderer.handler.addProgram(
                        new Program("strip", {
                            uniforms: {
                                projectionMatrix: { type: "mat4" },
                                viewMatrix: { type: "mat4" },
                                eyePositionHigh: "vec3",
                                eyePositionLow: "vec3",
                                uColor: { type: "vec4" },
                                uOpacity: { type: "float" }
                            },
                            attributes: {
                                aVertexPositionHigh: { type: "vec3" },
                                aVertexPositionLow: { type: "vec3" }
                            },
                            vertexShader: `attribute vec3 aVertexPositionHigh;
                        attribute vec3 aVertexPositionLow;
                        uniform mat4 projectionMatrix;
                        uniform mat4 viewMatrix;
                        uniform vec3 eyePositionHigh;
                        uniform vec3 eyePositionLow;
                        void main(void) {

                            vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                            vec3 lowDiff = aVertexPositionLow - eyePositionLow;

                            mat4 viewMatrixRTE = viewMatrix;
                            viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                            gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
                        }`,
                            fragmentShader: `precision highp float;
                        uniform vec4 uColor;
                        uniform float uOpacity;
                        void main(void) {
                            gl_FragColor = vec4(uColor.rgb, uColor.a * uOpacity);
                        }`
                        })
                    );
            }
        }

        setRenderNode(renderNode) {
            this._renderer = renderNode.renderer;
            this._initProgram();
            for (var i = 0; i < this._strips.length; i++) {
                this._strips[i].setRenderNode(renderNode);
            }
        }

        add(strip) {
            if (strip._handlerIndex === -1) {
                strip._handler = this;
                strip._handlerIndex = this._strips.length;
                this._strips.push(strip);
                this._entityCollection &&
                    this._entityCollection.renderNode &&
                    strip.setRenderNode(this._entityCollection.renderNode);
            }
        }

        remove(strip) {
            var index = strip._handlerIndex;
            if (index !== -1) {
                strip._deleteBuffers();
                strip._handlerIndex = -1;
                strip._handler = null;
                this._strips.splice(index, 1);
                this.reindexStripArray(index);
            }
        }

        reindexStripArray(startIndex) {
            var pc = this._strips;
            for (var i = startIndex; i < pc.length; i++) {
                pc[i]._handlerIndex = i;
            }
        }

        draw() {
            var i = this._strips.length;
            while (i--) {
                this._strips[i].draw();
            }
        }

        drawPicking() {
            if (this.pickingEnabled) {
                var i = this._strips.length;
                while (i--) {
                    this._strips[i].drawPicking();
                }
            }
        }

        clear() {
            var i = this._strips.length;
            while (i--) {
                this._strips[i]._deleteBuffers();
                this._strips[i]._handler = null;
                this._strips[i]._handlerIndex = -1;
            }
            this._strips.length = 0;
            this._strips = [];
        }
    }

    /**
     * @module og/shaders/shape
     */

    function shape_wl() {
        return new Program("shape_wl", {
            uniforms: {
                viewMatrix: { type: types$1.MAT4 },
                projectionMatrix: { type: types$1.MAT4 },
                modelMatrix: { type: types$1.MAT4 },
                normalMatrix: { type: types$1.MAT4 },

                lightsPositions: { type: types$1.VEC4 },
                lightsParamsv: { type: types$1.VEC3 },
                lightsParamsf: { type: types$1.FLOAT },

                uColor: { type: types$1.VEC4 },
                uSampler: { type: types$1.SAMPLER2D }
            },
            attributes: {
                aVertexNormal: { type: types$1.VEC3 },
                aVertexPosition: { type: types$1.VEC3 },
                aTextureCoord: { type: types$1.VEC2 }
            },
            vertexShader: `attribute vec3 aVertexNormal;
            attribute vec3 aVertexPosition;
            attribute vec2 aTextureCoord;
            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform mat4 modelMatrix;
            uniform mat3 normalMatrix;
            varying vec2 vTextureCoord;
            varying vec3 vNormal;
            varying vec4 vPosition;

            void main(void) {
                vTextureCoord = aTextureCoord;
                vNormal = normalMatrix * aVertexNormal;
                vPosition = viewMatrix * modelMatrix * vec4(aVertexPosition, 1.0);
                gl_Position = projectionMatrix * vPosition;
            }`,
            fragmentShader: `precision highp float;
            varying vec2 vTextureCoord;
            varying vec3 vNormal;
            varying vec4 vPosition;
            uniform vec4 uColor;
            uniform sampler2D uSampler;
            #define MAX_POINT_LIGHTS 1
            uniform int lightsQuantity;
            uniform vec4 lightsPositions[MAX_POINT_LIGHTS];
            uniform vec3 lightsParamsv[MAX_POINT_LIGHTS * 3];
            uniform float lightsParamsf[MAX_POINT_LIGHTS];
            void main(void) {
                vec3 lightWeighting;
                vec3 lightDirection;
                vec3 normal;
                vec3 eyeDirection;
                vec3 reflectionDirection;
                float specularLightWeighting;
                float diffuseLightWeighting;
                lightDirection = normalize(lightsPositions[0].xyz - vPosition.xyz * lightsPositions[0].w);
                normal = normalize(vNormal);
                eyeDirection = normalize(-vPosition.xyz);
                reflectionDirection = reflect(-lightDirection, normal);
                specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), lightsParamsf[0]);
                diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);
                lightWeighting = lightsParamsv[0] + lightsParamsv[1] * diffuseLightWeighting + lightsParamsv[2] * specularLightWeighting;
                vec4 cc = texture2D( uSampler, vTextureCoord.st );
                gl_FragColor = vec4(lightWeighting, uColor.a) * cc * uColor;
            }`
        });
    }

    function shape_nl() {
        return new Program("shape_nl", {
            uniforms: {
                projectionViewMatrix: { type: types$1.MAT4 },
                modelMatrix: { type: types$1.MAT4 },
                uColor: { type: types$1.VEC4 },
                uSampler: { type: types$1.SAMPLER2D }
            },
            attributes: {
                aVertexPosition: { type: types$1.VEC3, enableArray: true },
                aTextureCoord: { type: types$1.VEC2, enableArray: true }
            },
            vertexShader: `attribute vec3 aVertexPosition;
            attribute vec2 aTextureCoord;
            uniform mat4 projectionViewMatrix;
            uniform mat4 modelMatrix;
            varying vec2 vTextureCoord;

            void main(void) {
                gl_Position = projectionViewMatrix * (modelMatrix * vec4(aVertexPosition, 1.0));
                vTextureCoord = aTextureCoord;
            }`,
            fragmentShader: `precision highp float;
            uniform vec4 uColor;
            uniform sampler2D uSampler;
            varying vec2 vTextureCoord;
            void main(void) {
                gl_FragColor = uColor*texture2D( uSampler, vTextureCoord.st );
            }`
        });
    }

    function shape_picking() {
        return new Program("shape_picking", {
            uniforms: {
                projectionViewMatrix: { type: types$1.MAT4 },
                modelMatrix: { type: types$1.MAT4 },
                uColor: { type: types$1.VEC4 }
            },
            attributes: {
                aVertexPosition: { type: types$1.VEC3, enableArray: true }
            },
            vertexShader: `attribute vec3 aVertexPosition;
            uniform mat4 projectionViewMatrix;
            uniform mat4 modelMatrix;

            void main(void) {
                gl_Position = projectionViewMatrix * (modelMatrix * vec4(aVertexPosition, 1.0));
            }`,
            fragmentShader: `precision highp float;
            uniform vec4 uColor;
            uniform sampler2D uSampler;
            void main(void) {
                gl_FragColor = uColor;
            }`
        });
    }

    /**
     * @module og/entity/ShapeHandler
     */

    class ShapeHandler {
        constructor(entityCollection) {

            /**
             * Picking rendering option.
             * @public
             * @type {boolean}
             */
            this.pickingEnabled = true;

            this._entityCollection = entityCollection;

            this._renderer = null;

            this._shapes = [];

            this.__staticId = ShapeHandler._staticCounter++;
        }

        static get _staticCounter() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set _staticCounter(n) {
            this._counter = n;
        }

        _initProgram() {
            if (this._renderer.handler) {
                if (!this._renderer.handler.programs.shape_nl) {
                    this._renderer.handler.addProgram(shape_nl());
                }
                if (!this._renderer.handler.programs.shape_wl) {
                    this._renderer.handler.addProgram(shape_wl());
                }
                if (!this._renderer.handler.programs.shape_picking) {
                    this._renderer.handler.addProgram(shape_picking());
                }
            }
        }

        setRenderNode(renderNode) {
            this._renderer = renderNode.renderer;
            this._initProgram();
            for (var i = 0; i < this._shapes.length; i++) {
                this._shapes[i].setRenderNode(renderNode);
            }
        }

        add(shape) {
            if (shape._handlerIndex == -1) {
                shape._handler = this;
                shape._handlerIndex = this._shapes.length;
                this._shapes.push(shape);
                this._entityCollection && this._entityCollection.renderNode && shape.setRenderNode(this._entityCollection.renderNode);
            }
        }

        remove(shape) {
            // TODO
        }

        draw() {
            var i = this._shapes.length;
            while (i--) {
                this._shapes[i].draw();
            }
        }

        drawPicking() {
            var i = this._shapes.length;
            while (i--) {
                this._shapes[i].drawPicking();
            }
        }

        clear() {
            for (let i = 0, len = this._shapes.length; i < len; i++) {
                var ri = this._shapes[i];
                ri._handlerIndex = -1;
                ri._handler = null;
            }
            this._shapes.length = 0;
            this._shapes = [];
        }
    }

    /**
     * @module og/shaders/drawnode
     */

    const geo_object = () =>
        new Program("geo_object", {
            uniforms: {
                viewMatrix: "mat4",
                projectionMatrix: "mat4",
                normalMatrix: "mat3",

                uScaleByDistance: "vec3",

                eyePositionHigh: "vec3",
                eyePositionLow: "vec3",

                lightsPositions: "vec4",
                lightsParamsv: "vec3",
                lightsParamsf: "float"
            },
            attributes: {
                aVertexPosition: "vec3",
                aVertexNormal: "vec3",
                aPositionHigh: { type: "vec3", divisor: 1 },
                aPositionLow: { type: "vec3", divisor: 1 },
                aDirection: { type: "vec3", divisor: 1 },
                aPitchRoll: { type: "vec2", divisor: 1 },
                aColor: { type: "vec4", divisor: 1 },
                aScale: { type: "float", divisor: 1 },
                aDispose: { type: "float", divisor: 1 }
            },
            vertexShader: `precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal; 
            attribute vec3 aPositionHigh;
            attribute vec3 aPositionLow;    
            attribute vec3 aDirection;
            attribute vec2 aPitchRoll;
            attribute vec4 aColor;
            attribute float aScale;
            attribute float aDispose;
            
            uniform vec3 uScaleByDistance;
            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform mat3 normalMatrix;
            
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;

            varying vec3 vNormal;
            varying vec4 vPosition;           
            varying vec4 vColor;
            varying float vDispose;
            
            const float RADIANS = 3.141592653589793 / 180.0;

            void main(void) {
            
                vDispose = aDispose;
                vColor = aColor;
                float roll = aPitchRoll.y * RADIANS;
                mat3 rotZ = mat3(
                     vec3(cos(roll), sin(roll), 0.0),
                     vec3(-sin(roll), cos(roll), 0.0), 
                     vec3(0.0, 0.0, 1.0) 
                );

                float pitch = aPitchRoll.x * RADIANS;
                mat3 rotX = mat3(
                    vec3(1.0, 0.0, 0.0),
                    vec3(0.0, cos(pitch), sin(pitch)), 
                    vec3(0.0, -sin(pitch), cos(pitch)) 
               );

                vec3 position = aPositionHigh + aPositionLow;
                vec3 r = cross(normalize(-position), aDirection);
                mat3 modelMatrix = mat3(r, normalize(position), -aDirection) * rotX * rotZ; /*up=-cross(aDirection, r)*/

                vec3 look = position - (eyePositionHigh + eyePositionLow);
                float lookLength = length(look);
                float scd = aScale * (1.0 - smoothstep(uScaleByDistance[0], uScaleByDistance[1], lookLength)) * (1.0 - step(uScaleByDistance[2], lookLength));
                vNormal = normalMatrix * modelMatrix * aVertexNormal;

                vec3 highDiff = aPositionHigh - eyePositionHigh;
                vec3 lowDiff = aPositionLow + modelMatrix * (aVertexPosition * scd) - eyePositionLow;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                vPosition = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);

                gl_Position = mix(vec4(0.0, 0.0, 0.0, 0.0), projectionMatrix * vPosition, aDispose);
            }`,
            fragmentShader: `precision highp float;

                varying vec4 vColor;
                #define MAX_POINT_LIGHTS 1
                
                uniform vec4 lightsPositions[MAX_POINT_LIGHTS];
                uniform vec3 lightsParamsv[MAX_POINT_LIGHTS * 3];
                uniform float lightsParamsf[MAX_POINT_LIGHTS];
                
                varying vec3 vNormal;
                varying vec4 vPosition;
                
                void main(void) {
                    vec3 lightWeighting;
                    vec3 lightDirection;
                    vec3 normal;
                    vec3 eyeDirection;
                    vec3 reflectionDirection;
                    float specularLightWeighting;
                    float diffuseLightWeighting;
                
                    lightDirection = normalize(lightsPositions[0].xyz - vPosition.xyz * lightsPositions[0].w);
                    normal = normalize(vNormal);
                    eyeDirection = normalize(-vPosition.xyz);
                    reflectionDirection = reflect(-lightDirection, normal);
                    specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), lightsParamsf[0]);
                    diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);
                    lightWeighting = lightsParamsv[0] + lightsParamsv[1] * diffuseLightWeighting + lightsParamsv[2] * specularLightWeighting;
                    gl_FragColor = vec4(lightWeighting, 1.0) * vColor;
                }`
        });

    const geo_object_picking = () =>
        new Program("geo_object_picking", {
            uniforms: {
                viewMatrix: "mat4",
                projectionMatrix: "mat4",

                uScaleByDistance: "vec3",

                eyePositionHigh: "vec3",
                eyePositionLow: "vec3",
                pickingScale: "float"

            },
            attributes: {
                aVertexPosition: "vec3",
                aPositionHigh: { type: "vec3", divisor: 1 },
                aPositionLow: { type: "vec3", divisor: 1 },
                aDirection: { type: "vec3", divisor: 1 },
                aPitchRoll: { type: "vec2", divisor: 1 },
                aPickingColor: { type: "vec3", divisor: 1 },
                aScale: { type: "float", divisor: 1 },
                aDispose: { type: "float", divisor: 1 }
            },
            vertexShader: `precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aPositionHigh;
            attribute vec3 aPositionLow;    
            attribute vec3 aDirection;
            attribute vec2 aPitchRoll;
            attribute vec3 aPickingColor;
            attribute float aScale;
            attribute float aDispose;
            
            uniform vec3 uScaleByDistance;
            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform float pickingScale;
            
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;

            varying float vDispose;
            varying vec3 vColor;
            
            const float RADIANS = 3.141592653589793 / 180.0;

            void main(void) {
            
                vDispose = aDispose;
                vColor = aPickingColor;
                float roll = aPitchRoll.y * RADIANS;
                mat3 rotZ = mat3(
                     vec3(cos(roll), sin(roll), 0.0),
                     vec3(-sin(roll), cos(roll), 0.0), 
                     vec3(0.0, 0.0, 1.0) 
                );

                float pitch = aPitchRoll.x * RADIANS;
                mat3 rotX = mat3(
                    vec3(1.0, 0.0, 0.0),
                    vec3(0.0, cos(pitch), sin(pitch)), 
                    vec3(0.0, -sin(pitch), cos(pitch)) 
               );

                vec3 position = aPositionHigh + aPositionLow;
                vec3 r = cross(normalize(-position), aDirection);
                mat3 modelMatrix = mat3(r, normalize(position), -aDirection) * rotX * rotZ; /*up=-cross(aDirection, r)*/

                vec3 look = position - (eyePositionHigh + eyePositionLow);
                float lookLength = length(look);
                float scd = aScale * pickingScale * (1.0 - smoothstep(uScaleByDistance[0], uScaleByDistance[1], lookLength)) * (1.0 - step(uScaleByDistance[2], lookLength));

                vec3 highDiff = aPositionHigh - eyePositionHigh;
                vec3 lowDiff = aPositionLow + modelMatrix * (aVertexPosition * scd) - eyePositionLow;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                gl_Position = mix(vec4(0.0, 0.0, 0.0, 0.0),  projectionMatrix *viewMatrixRTE * vec4(highDiff + lowDiff, 1.0), aDispose);
            }`,
            fragmentShader:
                `precision highp float;
            varying vec3 vColor;
            varying float vDispose;
            void main () {
                gl_FragColor = vec4(vColor, vDispose);
            }`
        });

    const VERTEX_BUFFER = 0,
        POSITION_BUFFER = 1,
        RGBA_BUFFER = 2,
        NORMALS_BUFFER = 3,
        INDECIES_BUFFER = 4,
        DIRECTION_BUFFER = 5,
        PITCH_ROLL_BUFFER = 6,
        SIZE_BUFFER = 7,
        PICKINGCOLOR_BUFFER = 8,
        VISIBLE_BUFFER = 9;

    const setParametersToArray = (arr = [], index = 0, length, itemSize, ...params) => {
        const currIndex = index * length;
        for (let i = currIndex, len = currIndex + length; i < len; i++) {
            arr[i] = params[i % itemSize];
        }
        return arr;
    };

    class GeoObjectHandler {
        constructor(entityCollection) {
            /**
             * Picking rendering option.
             * @public
             * @type {boolean}
             */
            this.pickingEnabled = true;

            this._entityCollection = entityCollection;
            this._renderer = null;
            this._planet = null;

            this._geoObjects = [];
            this._pitchRollArr = [[]];
            this._sizeArr = [[]];
            this._vertexArr = [[]];
            this._positionHighArr = [[]];
            this._positionLowArr = [[]];
            this._directionArr = [[]];
            this._rgbaArr = [[]];
            this._normalsArr = [[]];
            this._indicesArr = [[]];
            this._pickingColorArr = [[]];
            this._vehicleVisibleArr = [[]];

            this._pitchRollBuffer = [];
            this._sizeBuffer = [];
            this._vertexBuffer = [];
            this._positionHighBuffer = [];
            this._positionLowBuffer = [];
            this._directionBuffer = [];
            this._rgbaBuffer = [];
            this._normalsBuffer = [];
            this._indicesBuffer = [];
            this._pickingColorBuffer = [];
            this._vehicleVisibleBuffer = [];

            this.__staticId = GeoObjectHandler._staticCounter++;
            this._buffersUpdateCallbacks = [];
            this._buffersUpdateCallbacks[PICKINGCOLOR_BUFFER] = this.createPickingColorBuffer;
            this._buffersUpdateCallbacks[POSITION_BUFFER] = this.createPositionBuffer;
            this._buffersUpdateCallbacks[DIRECTION_BUFFER] = this.createDirectionBuffer;
            this._buffersUpdateCallbacks[NORMALS_BUFFER] = this.createNormalsBuffer;
            this._buffersUpdateCallbacks[RGBA_BUFFER] = this.createRgbaBuffer;
            this._buffersUpdateCallbacks[INDECIES_BUFFER] = this.createIndicesBuffer;
            this._buffersUpdateCallbacks[VERTEX_BUFFER] = this.createVertexBuffer;
            this._buffersUpdateCallbacks[SIZE_BUFFER] = this.createSizeBuffer;
            this._buffersUpdateCallbacks[PITCH_ROLL_BUFFER] = this.createPitchRollBuffer;
            this._buffersUpdateCallbacks[VISIBLE_BUFFER] = this.createVisibleBuffer;

            this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);

            this._instancedTags = new Map();
        }

        getObjectByIndex(index) {
            return this._geoObjects[index];
        }

        //Create buffers
        createVertexBuffer() {
            const h = this._renderer.handler;
            for (let i = 0, len = this._vertexArr.length; i < len; i++) {
                this._vertexBuffer && h.gl.deleteBuffer(this._vertexBuffer[i]);
                this._vertexBuffer[i] = h.createArrayBuffer(new Float32Array(this._vertexArr[i]), 3, this._vertexArr[i].length / 3);
            }
        }

        createPitchRollBuffer() {
            const h = this._renderer.handler;
            for (let i = 0, len = this._pitchRollArr.length; i < len; i++) {
                this._pitchRollBuffer && h.gl.deleteBuffer(this._pitchRollBuffer[i]);
                this._pitchRollBuffer[i] = h.createArrayBuffer(new Float32Array(this._pitchRollArr[i]), 2, this._pitchRollArr[i].length / 2);
            }
        }

        createVisibleBuffer() {
            const h = this._renderer.handler;
            for (let i = 0, len = this._vehicleVisibleArr.length; i < len; i++) {
                this._vehicleVisibleBuffer && h.gl.deleteBuffer(this._vehicleVisibleBuffer[i]);
                this._vehicleVisibleBuffer[i] = h.createArrayBuffer(new Float32Array(this._vehicleVisibleArr[i]), 1, this._vehicleVisibleArr[i].length);
            }
        }

        createSizeBuffer() {
            const h = this._renderer.handler;
            for (let i = 0, len = this._sizeArr.length; i < len; i++) {
                this._sizeBuffer && h.gl.deleteBuffer(this._sizeBuffer[i]);
                this._sizeBuffer[i] = h.createArrayBuffer(new Float32Array(this._sizeArr[i]), 1, this._sizeArr[i].length);
            }
        }

        createPositionBuffer() {
            let h = this._renderer.handler;
            for (let i = 0, len = this._positionHighArr.length; i < len; i++) {
                this._positionHighBuffer && h.gl.deleteBuffer(this._positionHighBuffer[i]);
                this._positionHighBuffer[i] = h.createArrayBuffer(new Float32Array(this._positionHighArr[i]), 3, this._positionHighArr[i].length / 3);
                this._positionLowBuffer && h.gl.deleteBuffer(this._positionLowBuffer[i]);
                this._positionLowBuffer[i] = h.createArrayBuffer(new Float32Array(this._positionLowArr[i]), 3, this._positionLowArr[i].length / 3);
            }
        }

        createRgbaBuffer() {
            const h = this._renderer.handler;
            for (let i = 0, len = this._rgbaArr.length; i < len; i++) {
                this._rgbaBuffer && h.gl.deleteBuffer(this._rgbaBuffer[i]);
                this._rgbaBuffer[i] = h.createArrayBuffer(new Float32Array(this._rgbaArr[i]), 4, this._rgbaArr[i].length / 4);
            }
        }

        createDirectionBuffer() {
            const h = this._renderer.handler;
            for (let i = 0, len = this._directionArr.length; i < len; i++) {
                this._directionBuffer && h.gl.deleteBuffer(this._directionBuffer[i]);
                this._directionBuffer[i] = h.createArrayBuffer(new Float32Array(this._directionArr[i]), 3, this._directionArr[i].length / 3);
            }
        }

        createNormalsBuffer() {
            const h = this._renderer.handler;
            for (let i = 0, len = this._normalsArr.length; i < len; i++) {
                this._normalsBuffer && h.gl.deleteBuffer(this._normalsBuffer[i]);
                this._normalsBuffer[i] = h.createArrayBuffer(new Float32Array(this._normalsArr[i]), 3, this._normalsArr[i].length / 3);
            }
        }

        createIndicesBuffer() {
            const h = this._renderer.handler;
            for (let i = 0, len = this._indicesArr.length; i < len; i++) {
                this._indicesBuffer && h.gl.deleteBuffer(this._indicesBuffer[i]);
                this._indicesBuffer[i] = h.createElementArrayBuffer(new Uint16Array(this._indicesArr[i]), 1, this._indicesArr[i].length);
            }
        }

        createPickingColorBuffer() {
            const h = this._renderer.handler;
            for (let i = 0, len = this._pickingColorArr.length; i < len; i++) {
                this._pickingColorBuffer && h.gl.deleteBuffer(this._pickingColorBuffer[i]);
                this._pickingColorBuffer[i] = h.createArrayBuffer(new Float32Array(this._pickingColorArr[i]), 3, this._pickingColorArr[i].length / 3);
            }
        }

        static get _staticCounter() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set _staticCounter(n) {
            this._counter = n;
        }

        initProgram() {
            if (this._renderer.handler) {
                if (!this._renderer.handler.programs.geo_object) {
                    this._renderer.handler.addProgram(geo_object());
                }
                if (!this._renderer.handler.programs.geo_object_picking) {
                    this._renderer.handler.addProgram(geo_object_picking());
                }
            }
        }

        setRenderNode(renderNode) {
            this._renderer = renderNode.renderer;
            this._planet = renderNode;
            this.initProgram();
        }

        setRenderer(planet) {
            super.setRenderer(planet);
        }

        _addGeoObjectToArray(geoObject) {
            let itemSize = 3;

            const tag = geoObject.tag,
                alreadyAdded = this._instancedTags.has(tag);

            if (!alreadyAdded) {
                this._instancedTags.set(tag, {
                    iCounts: 1,
                    maxIndex: Math.max(...geoObject._indices),
                    index: this._instancedTags.size
                });
            } else {
                const prevState = this._instancedTags.get(tag),
                    nextCount = prevState.iCounts + 1;
                this._instancedTags.set(tag, {
                    ...prevState,
                    iCounts: nextCount
                });
            }
            const tagData = this._instancedTags.get(tag),
                ti = tagData.index;

            /**
             * mark object by index for recalc indices array
             */
            geoObject._tagIndex = tagData.iCounts - 1;

                if (!this._vertexArr[ti] || this._vertexArr[ti].length !== geoObject._vertices.length) {

                    this._vertexArr[ti] = concatArrays(
                        this._vertexArr[ti],
                        setParametersToArray(
                            [],
                            0,
                            geoObject._verticesCount * itemSize,
                            geoObject._verticesCount * itemSize,
                            ...geoObject._vertices
                        )
                    );
                    this._normalsArr[ti] = concatArrays(
                        this._normalsArr[ti],
                        setParametersToArray(
                            [],
                            0,
                            geoObject._verticesCount * itemSize,
                            geoObject._verticesCount * itemSize,
                            ...geoObject._normals
                            // ...getTriangleNormals(geoObject._vertices, geoObject._indices)
                        )
                    );
                }
            this._vehicleVisibleArr[ti] = concatArrays(
                this._vehicleVisibleArr[ti],
                setParametersToArray([], 0, 1, 1, geoObject._visibility ? 1 : 0)
            );

            let x = geoObject._positionHigh.x,
                y = geoObject._positionHigh.y,
                z = geoObject._positionHigh.z,
                w;

            this._positionHighArr[ti] = concatArrays(
                this._positionHighArr[ti],
                setParametersToArray([], 0, itemSize, itemSize, x, y, z)
            );
            x = geoObject._positionLow.x;
            y = geoObject._positionLow.y;
            z = geoObject._positionLow.z;
            this._positionLowArr[ti] = concatArrays(
                this._positionLowArr[ti],
                setParametersToArray([], 0, itemSize, itemSize, x, y, z)
            );

            x = geoObject._entity._pickingColor.x / 255;
            y = geoObject._entity._pickingColor.y / 255;
            z = geoObject._entity._pickingColor.z / 255;
            this._pickingColorArr[ti] = concatArrays(
                this._pickingColorArr[ti],
                setParametersToArray([], 0, itemSize, itemSize, x, y, z)
            );

            x = geoObject._direction.x;
            y = geoObject._direction.y;
            z = geoObject._direction.z;
            this._directionArr[ti] = concatArrays(
                this._directionArr[ti],
                setParametersToArray([], 0, itemSize, itemSize, x, y, z)
            );

            itemSize = 4;

            x = geoObject._color.x;
            y = geoObject._color.y;
            z = geoObject._color.z;
            w = geoObject._color.w;
            this._rgbaArr[ti] = concatArrays(
                this._rgbaArr[ti],
                setParametersToArray([], 0, itemSize, itemSize, x, y, z, w)
            );

            x = geoObject._pitch;
            y = geoObject._roll;

            itemSize = 2;

            this._pitchRollArr[ti] = concatArrays(
                this._pitchRollArr[ti],
                setParametersToArray([], 0, itemSize, itemSize, x, y)
            );

            itemSize = 1;

            this._sizeArr[ti] = concatArrays(
                this._sizeArr[ti],
                setParametersToArray([], 0, itemSize, itemSize, geoObject.scale)
            );
            this._addIndices(geoObject);
        }

        _displayPASS() {
            const r = this._renderer,
                sh = r.handler.programs.geo_object,
                p = sh._program,
                u = p.uniforms,
                a = p.attributes,
                gl = r.handler.gl,
                ec = this._entityCollection;

            sh.activate();

            gl.enable(gl.CULL_FACE);
            gl.uniform3fv(u.uScaleByDistance, ec.scaleByDistance);

            gl.uniform3fv(u.eyePositionHigh, r.activeCamera.eyeHigh);
            gl.uniform3fv(u.eyePositionLow, r.activeCamera.eyeLow);

            gl.uniformMatrix4fv(u.projectionMatrix, false, r.activeCamera.getProjectionMatrix());
            gl.uniformMatrix4fv(u.viewMatrix, false, r.activeCamera.getViewMatrix());
            gl.uniformMatrix3fv(u.normalMatrix, false, r.activeCamera._normalMatrix._m);

            gl.uniform4fv(u.lightsPositions, this._planet._lightsTransformedPositions);
            gl.uniform3fv(u.lightsParamsv, this._planet._lightsParamsv);
            gl.uniform1fv(u.lightsParamsf, this._planet._lightsParamsf);

            for (const tag of this._instancedTags) {
                const tagData = tag[1],
                    ti = tagData.index;

                gl.bindBuffer(gl.ARRAY_BUFFER, this._normalsBuffer[ti]);
                gl.vertexAttribPointer(a.aVertexNormal, this._normalsBuffer[ti].itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer[ti]);
                gl.vertexAttribPointer(a.aVertexPosition, this._vertexBuffer[ti].itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, this._directionBuffer[ti]);
                gl.vertexAttribPointer(a.aDirection, this._directionBuffer[ti].itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, this._sizeBuffer[ti]);
                gl.vertexAttribPointer(a.aScale, this._sizeBuffer[ti].itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, this._pitchRollBuffer[ti]);
                gl.vertexAttribPointer(a.aPitchRoll, this._pitchRollBuffer[ti].itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, this._rgbaBuffer[ti]);
                gl.vertexAttribPointer(a.aColor, this._rgbaBuffer[ti].itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, this._vehicleVisibleBuffer[ti]);
                gl.vertexAttribPointer(a.aDispose, this._vehicleVisibleBuffer[ti].itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, this._positionHighBuffer[ti]);
                gl.vertexAttribPointer(
                    a.aPositionHigh,
                    this._positionHighBuffer[ti].itemSize,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );

                gl.bindBuffer(gl.ARRAY_BUFFER, this._positionLowBuffer[ti]);
                gl.vertexAttribPointer(
                    a.aPositionLow,
                    this._positionLowBuffer[ti].itemSize,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indicesBuffer[ti]);

                if (tagData.iCounts) {
                    p.drawElementsInstanced(
                        gl.TRIANGLES,
                        this._indicesBuffer[ti].numItems / tagData.iCounts,
                        gl.UNSIGNED_SHORT,
                        0,
                        tagData.iCounts
                    );
                } else {
                    gl.drawElements(
                        gl.TRIANGLES,
                        this._indicesBuffer[ti].numItems,
                        gl.UNSIGNED_SHORT,
                        0
                    );
                }
            }
            gl.disable(gl.CULL_FACE);
        }

        drawPicking() {
            if (this._geoObjects.length && this.pickingEnabled) {
                this._pickingPASS();
            }
        }

        _pickingPASS() {
            const r = this._renderer,
                sh = r.handler.programs.geo_object_picking,
                p = sh._program,
                u = p.uniforms,
                a = p.attributes,
                gl = r.handler.gl,
                ec = this._entityCollection;

            sh.activate();

            gl.enable(gl.CULL_FACE);
            gl.uniform3fv(u.uScaleByDistance, ec.scaleByDistance);

            gl.uniform1f(u.pickingScale, ec.pickingScale);

            gl.uniform3fv(u.eyePositionHigh, r.activeCamera.eyeHigh);
            gl.uniform3fv(u.eyePositionLow, r.activeCamera.eyeLow);

            gl.uniformMatrix4fv(u.projectionMatrix, false, r.activeCamera.getProjectionMatrix());
            gl.uniformMatrix4fv(u.viewMatrix, false, r.activeCamera.getViewMatrix());

            for (const tag of this._instancedTags) {
                const tagData = tag[1],
                    ti = tagData.index;

                gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer[ti]);
                gl.vertexAttribPointer(
                    a.aVertexPosition,
                    this._vertexBuffer[ti].itemSize,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );

                gl.bindBuffer(gl.ARRAY_BUFFER, this._directionBuffer[ti]);
                gl.vertexAttribPointer(
                    a.aDirection,
                    this._directionBuffer[ti].itemSize,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );

                gl.bindBuffer(gl.ARRAY_BUFFER, this._sizeBuffer[ti]);
                gl.vertexAttribPointer(a.aScale, this._sizeBuffer[ti].itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, this._pitchRollBuffer[ti]);
                gl.vertexAttribPointer(
                    a.aPitchRoll,
                    this._pitchRollBuffer[ti].itemSize,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );

                gl.bindBuffer(gl.ARRAY_BUFFER, this._pickingColorBuffer[ti]);
                gl.vertexAttribPointer(
                    a.aPickingColor,
                    this._pickingColorBuffer[ti].itemSize,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );

                gl.bindBuffer(gl.ARRAY_BUFFER, this._positionHighBuffer[ti]);
                gl.vertexAttribPointer(
                    a.aPositionHigh,
                    this._positionHighBuffer[ti].itemSize,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );

                gl.bindBuffer(gl.ARRAY_BUFFER, this._positionLowBuffer[ti]);
                gl.vertexAttribPointer(
                    a.aPositionLow,
                    this._positionLowBuffer[ti].itemSize,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );

                gl.bindBuffer(gl.ARRAY_BUFFER, this._vehicleVisibleBuffer[ti]);
                gl.vertexAttribPointer(a.aDispose, this._vehicleVisibleBuffer[ti].itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indicesBuffer[ti]);

                if (tagData.iCounts) {
                    p.drawElementsInstanced(
                        gl.TRIANGLES,
                        this._indicesBuffer[ti].numItems / tagData.iCounts,
                        gl.UNSIGNED_SHORT,
                        0,
                        tagData.iCounts
                    );
                } else {
                    gl.drawElements(
                        gl.TRIANGLES,
                        this._indicesBuffer[ti].numItems,
                        gl.UNSIGNED_SHORT,
                        0
                    );
                }
            }
            gl.disable(gl.CULL_FACE);
        }

        _recalculateIndices(startIndex) {
            const allIndices = this._indicesArr,
                goArr = this._geoObjects,
                maxIndicesByTags = new Array(this._instancedTags.size).fill(0);

            for (let gi = 0; gi < goArr.length; gi++) {
                const go = goArr[gi],
                    ti = this.getTagIndexByObjectIndex(go._handlerIndex),
                    gIndices = go._indices;

                for (let ii = 0; ii < gIndices.length; ii++) {
                    const gIndex = gIndices[ii];

                    const i = go._indicesCount * go._tagIndex + ii;
                    if (go._tagIndex > 0) {
                        allIndices[ti][i] = gIndex + maxIndicesByTags[ti];
                        if (allIndices[ti][i] > maxIndicesByTags[ti]) {
                            maxIndicesByTags[ti] = allIndices[ti][i] + 1;
                        }
                    } else {
                        allIndices[ti][i] = gIndex;
                        if (gIndex > maxIndicesByTags[ti]) {
                            maxIndicesByTags[ti] = gIndex + 1;
                        }
                    }
                }
            }
        }

        _addIndices(g) {
            let i = g._handlerIndex;
            const allIndices = this._indicesArr,
                gArr = this._geoObjects,
                iLen = g._indices.length,
                tagData = this._instancedTags.get(g.tag),
                maxIndex = tagData.maxIndex,
                ti = tagData.index;

            allIndices[ti] = concatArrays(allIndices[ti], g._indices);

            while (gArr[i]) {
                const g = gArr[i];

                if (g._tagIndex > 0) {
                    setParametersToArray(allIndices[ti], g._tagIndex, iLen, iLen, ...g._indices.reduce((acc, cur) => {
                        acc.push(cur + ((maxIndex + 1) * g._tagIndex));
                        return acc;
                    }, []));
                }
                i++;

            }

        }

        _removeIndices(geoObject) {
            const allIndices = this._indicesArr,
                gArr = this._geoObjects,
                iLen = geoObject._indices.length,
                tagData = this._instancedTags.get(geoObject.tag),
                maxIndex = tagData.maxIndex,
                ti = tagData.index,
                count = tagData.iCounts;

            let i = geoObject._handlerIndex;

            this._indicesArr[ti] = spliceArray(this._indicesArr[ti], geoObject._tagIndex * geoObject._indicesCount, geoObject._indicesCount);

            while (gArr[i]) {
                if (geoObject.tag === gArr[i].tag) {
                    if (count !== 0) {
                        const startI = (gArr[i]._tagIndex - 1) * iLen;
                        let stopI = startI + geoObject._indicesCount;
                        while (stopI > startI) {
                            this._indicesArr[ti][stopI - 1] = allIndices[ti][stopI - 1] - maxIndex - 1;
                            stopI--;
                        }
                    } else {
                        allIndices[ti] = geoObject._indices;
                    }
                }
                i++;

            }

        }

        setDirectionArr(index, direction) {
            const itemSize = 3,
                ob = this.getObjectByIndex(index),
                ti = this.getTagIndexByObjectIndex(index);
            let length = ob._verticesCount * itemSize;

            if (ob.instanced) {
                length = itemSize;
            }

            setParametersToArray(this._directionArr[ti], ob._tagIndex, length, itemSize, direction.x, direction.y, direction.z);
            this._changedBuffers[DIRECTION_BUFFER] = true;
        }

        setVisibility(index, visibility) {
            const ob = this.getObjectByIndex(index),
                ti = this.getTagIndexByObjectIndex(index);

            setParametersToArray(this._vehicleVisibleArr[ti], ob._tagIndex, 1, 1, visibility ? 1 : 0);

            this._changedBuffers[VISIBLE_BUFFER] = true;
        }

        setPositionArr(index, positionHigh, positionLow) {
            const itemSize = 3,
                ob = this.getObjectByIndex(index),
                ti = this.getTagIndexByObjectIndex(index);
            let length = ob._verticesCount * itemSize;

            if (ob.instanced) {
                length = itemSize;
            }

            setParametersToArray(this._positionHighArr[ti], ob._tagIndex, length, itemSize, positionHigh.x, positionHigh.y, positionHigh.z);

            // Low
            setParametersToArray(this._positionLowArr[ti], ob._tagIndex, length, itemSize, positionLow.x, positionLow.y, positionLow.z);

            this._changedBuffers[POSITION_BUFFER] = true;
        }

        setRgbaArr(index, rgba) {
            const itemSize = 4,
                ob = this.getObjectByIndex(index),
                ti = this.getTagIndexByObjectIndex(index);
            let length = ob._verticesCount * itemSize;

            if (ob.instanced) {
                length = itemSize;
            }

            setParametersToArray(this._rgbaArr[ti], ob._tagIndex, length, itemSize, rgba.x, rgba.y, rgba.z, rgba.w);

            this._changedBuffers[RGBA_BUFFER] = true;
        }

        getTagIndexByObjectIndex(index) {
            return this._instancedTags.get(this.getObjectByIndex(index).tag).index;
        }

        getTagDataByObjectIndex(index) {
            return this._instancedTags.get(this.getObjectByIndex(index).tag);
        }

        setPickingColorArr(index, color) {
            const itemSize = 3,
                ti = this.getTagIndexByObjectIndex(index),
                ob = this.getObjectByIndex(index),
                x = color.x / 255,
                y = color.y / 255,
                z = color.z / 255;

            let length = ob._verticesCount * itemSize;

            if (ob.instanced) {
                length = itemSize;
            }

            setParametersToArray(this._pickingColorArr[ti], ob._tagIndex, length, itemSize, x, y, z);
            this._changedBuffers[PICKINGCOLOR_BUFFER] = true;
        }

        setPitchRollArr(index, pitch, roll) {
            const itemSize = 2,
                ti = this.getTagIndexByObjectIndex(index),
                ob = this.getObjectByIndex(index);
            let length = ob._verticesCount * itemSize;

            if (ob.instanced) {
                length = itemSize;
            }

            setParametersToArray(this._pitchRollArr[ti], ob._tagIndex, length, itemSize, pitch, roll);
            this._changedBuffers[PITCH_ROLL_BUFFER] = true;
        }

        setScaleArr(index, scale) {
            const itemSize = 1,
                ti = this.getTagIndexByObjectIndex(index),
                ob = this.getObjectByIndex(index);
            let length = ob._verticesCount * itemSize;

            if (ob.instanced) {
                length = itemSize;
            }

            setParametersToArray(this._sizeArr[ti], ob._tagIndex, length, itemSize, scale);
            this._changedBuffers[SIZE_BUFFER] = true;
        }

        refresh() {
            let i = this._changedBuffers.length;
            while (i--) {
                this._changedBuffers[i] = true;
            }
        }

        _removeGeoObjects() {
            let i = this._geoObjects.length;
            while (i--) {
                const bi = this._geoObjects[i];
                bi._handlerIndex = -1;
                bi._handler = null;
            }
            this._geoObjects.length = 0;
            this._geoObjects = [];
        }

        clear() {
            this._sizeArr = null;
            this._pitchRollArr = null;
            this._vertexArr = null;
            this._positionHighArr = null;
            this._positionLowArr = null;
            this._directionArr = null;
            this._rgbaArr = null;
            this._normalsArr = null;
            this._indicesArr = null;
            this._pickingColorArr = null;
            this._vehicleVisibleArr = null;

            this._pitchRollArr = [];
            this._sizeArr = [];
            this._vertexArr = [];
            this._positionHighArr = [];
            this._positionLowArr = [];
            this._rgbaArr = [];
            this._directionArr = [];
            this._normalsArr = [];
            this._indicesArr = [];
            this._pickingColorArr = [];
            this._vehicleVisibleArr = [];

            this._removeGeoObjects();
            this._deleteBuffers();
            this.refresh();
        }

        _deleteBuffers() {
            if (this._renderer) {
                const gl = this._renderer.handler.gl;
                gl.deleteBuffer(this._sizeBuffer);
                gl.deleteBuffer(this._pitchRollBuffer);
                gl.deleteBuffer(this._vertexBuffer);
                gl.deleteBuffer(this._positionHighBuffer);
                gl.deleteBuffer(this._positionLowBuffer);
                gl.deleteBuffer(this._rgbaBuffer);
                gl.deleteBuffer(this._indicesBuffer);
                gl.deleteBuffer(this._normalsBuffer);
                gl.deleteBuffer(this._directionBuffer);
                gl.deleteBuffer(this._pickingColorBuffer);
            }

            this._pitchRollBuffer = null;
            this._sizeBuffer = null;
            this._vertexBuffer = null;
            this._positionHighBuffer = null;
            this._positionLowBuffer = null;
            this._rgbaBuffer = null;
            this._indicesBuffer = null;
            this._normalsBuffer = null;
            this._directionBuffer = null;
            this._pickingColorBuffer = null;
        }

        update() {
            if (this._renderer) {
                let i = this._changedBuffers.length;
                while (i--) {
                    if (this._changedBuffers[i]) {
                        this._buffersUpdateCallbacks[i].call(this);
                        this._changedBuffers[i] = false;
                    }
                }
            }
        }

        draw() {
            if (this._geoObjects.length) {
                this.update();
                this._displayPASS();
            }
        }

        _reindexGeoObjects(startIndex, tag) {
            const b = this._geoObjects;

            for (let i = startIndex; i < b.length; i++) {
                const go = b[i];

                b[i]._handlerIndex = i;
                if (tag === go.tag) {
                    --b[i]._tagIndex;
                }
            }
        }

        add(geoObject) {
            if (geoObject._handlerIndex === -1) {
                geoObject._handler = this;
                geoObject._handlerIndex = this._geoObjects.length;
                this._geoObjects.push(geoObject);
                this._addGeoObjectToArray(geoObject);
                this.refresh();
            }
        }

        remove(geoObject) {
            if (geoObject._handler && this.__staticId == geoObject._handler.__staticId) {
                this._removeGeoObject(geoObject);
            }
        }

        _removeGeoObject(geoObject) {
            const gi = geoObject._handlerIndex,
                tag = geoObject.tag,
                ti = this.getTagIndexByObjectIndex(gi),
                prevState = this._instancedTags.get(tag),
                iCount = prevState.iCounts - 1;

            this._instancedTags.set(tag, {
                ...prevState,
                iCounts: iCount
            });

            this._geoObjects.splice(gi, 1);

            let i = geoObject._tagIndex * 4;
            this._rgbaArr[ti] = spliceArray(this._rgbaArr[ti], i, 4);

            i = geoObject._tagIndex * 3;
            if (prevState.iCounts <= 1) {
                this._vertexArr[ti] = spliceArray(this._vertexArr[ti], 0, geoObject._verticesCount * 3);
                this._normalsArr[ti] = spliceArray(
                    this._normalsArr[ti],
                    0,
                    geoObject._verticesCount * 3
                );
            }
            this._positionHighArr[ti] = spliceArray(this._positionHighArr[ti], i, 3);
            this._positionLowArr[ti] = spliceArray(this._positionLowArr[ti], i, 3);
            this._directionArr[ti] = spliceArray(this._directionArr[ti], i, 3);
            this._pickingColorArr[ti] = spliceArray(this._pickingColorArr[ti], i, 3);

            i = geoObject._tagIndex * 2;
            this._pitchRollArr[ti] = spliceArray(this._pitchRollArr[ti], i, 2);
            i = geoObject._tagIndex;
            this._sizeArr[ti] = spliceArray(this._sizeArr[ti], i, 1);
            this._vehicleVisibleArr[ti] = spliceArray(this._vehicleVisibleArr[ti], i, 1);

            this._removeIndices(geoObject);

            this._reindexGeoObjects(gi, tag);

            this.refresh();

            geoObject._handlerIndex = -1;
            geoObject._handler = null;
        }
    }

    /**
     * @module og/entity/EntityCollection
     */

    /**
     * An observable collection of og.Entity instances where each entity has a unique id.
     * Entity collection provide handlers for an each type of entity like billboard, label or 3ds object.
     * @constructor
     * @param {Object} [options] - Entity options:
     * @param {Array.<Entity>} [options.entities] - Entities array.
     * @param {boolean} [options.visibility=true] - Entity visibility.
     * @param {Array.<number>} [options.scaleByDistance] - Entity scale by distance parameters. (exactly 3 entries)
     * First index - near distance to the entity, after entity becomes full scale.
     * Second index - far distance to the entity, when entity becomes zero scale.
     * Third index - far distance to the entity, when entity becomes invisible.
     * @param {number} [options.opacity] - Entity global opacity.
     * @param {boolean} [options.pickingEnabled=true] - Entity picking enable.
     * @param {Number} [options.polygonOffsetUnits=0.0] - The multiplier by which an implementation-specific value is multiplied with to create a constant depth offset. The default value is 0.
     * @fires og.EntityCollection#entitymove
     * @fires og.EntityCollection#draw
     * @fires og.EntityCollection#drawend
     * @fires og.EntityCollection#add
     * @fires og.EntityCollection#remove
     * @fires og.EntityCollection#entityadd
     * @fires og.EntityCollection#entityremove
     * @fires og.EntityCollection#visibilitychange
     * @fires og.EntityCollection#mousemove
     * @fires og.EntityCollection#mouseenter
     * @fires og.EntityCollection#mouseleave
     * @fires og.EntityCollection#lclick
     * @fires og.EntityCollection#rclick
     * @fires og.EntityCollection#mclick
     * @fires og.EntityCollection#ldblclick
     * @fires og.EntityCollection#rdblclick
     * @fires og.EntityCollection#mdblclick
     * @fires og.EntityCollection#lup
     * @fires og.EntityCollection#rup
     * @fires og.EntityCollection#mup
     * @fires og.EntityCollection#ldown
     * @fires og.EntityCollection#rdown
     * @fires og.EntityCollection#mdown
     * @fires og.EntityCollection#lhold
     * @fires og.EntityCollection#rhold
     * @fires og.EntityCollection#mhold
     * @fires og.EntityCollection#mousewheel
     * @fires og.EntityCollection#touchmove
     * @fires og.EntityCollection#touchstart
     * @fires og.EntityCollection#touchend
     * @fires og.EntityCollection#doubletouch
     * @fires og.EntityCollection#touchleave
     * @fires og.EntityCollection#touchenter
     */
    class EntityCollection$1 {
        constructor(options) {
            options = options || {};

            /**
             * Unic identifier.
             * @public
             * @readonly
             */
            this.id = EntityCollection$1._staticCounter++;

            /**
             * Render node collections array index.
             * @protected
             * @type {number}
             */
            this._renderNodeIndex = -1;

            /**
             * Render node context.
             * @public
             * @type {RenderNode}
             */
            this.renderNode = null;

            /**
             * Visibility option.
             * @protected
             * @type {boolean}
             */
            this._visibility = options.visibility == undefined ? true : options.visibility;

            /**
             * Specifies the scale Units for gl.polygonOffset function to calculate depth values, 0.0 is default.
             * @public
             * @type {Number}
             */
            this.polygonOffsetUnits =
                options.polygonOffsetUnits != undefined ? options.polygonOffsetUnits : 0.0;

            /**
             * Billboards handler
             * @public
             * @type {BillboardHandler}
             */
            this.billboardHandler = new BillboardHandler(this);

            /**
             * Labels handler
             * @public
             * @type {LabelHandler}
             */
            this.labelHandler = new LabelHandler(this, options.labelMaxLetters);

            /**
             * Shape handler
             * @public
             * @type {ShapeHandler}
             */
            this.shapeHandler = new ShapeHandler(this);

            /**
             * Polyline handler
             * @public
             * @type {PolylineHandler}
             */
            this.polylineHandler = new PolylineHandler(this);

            /**
             * Ray handler
             * @public
             * @type {RayHandler}
             */
            this.rayHandler = new RayHandler(this);

            /**
             * PointCloud handler
             * @public
             * @type {PointCloudHandler}
             */
            this.pointCloudHandler = new PointCloudHandler(this);

            /**
             * Strip handler
             * @public
             * @type {StripHandler}
             */
            this.stripHandler = new StripHandler(this);

            /**
             * Geo object handler
             * @public
             * @type {og.GeoObjectHandler}
             */
            this.geoObjectHandler = new GeoObjectHandler(this);

            if (options.pickingEnabled != undefined) {
                this.setPickingEnabled(options.pickingEnabled);
            }

            /**
             * Entities array.
             * @protected
             * @type {Array.<Entity>}
             */
            this._entities = [];

            /**
             * First index - near distance to the entity, after entity becomes full scale.
             * Second index - far distance to the entity, when entity becomes zero scale.
             * Third index - far distance to the entity, when entity becomes invisible.
             * @public
             * @type {Array.<number>} - (exactly 3 entries)
             */
            this.scaleByDistance = options.scaleByDistance || [MAX32, MAX32, MAX32];

            this.pickingScale = options.pickingScale || 1.0;

            /**
             * Global opacity.
             * @protected
             * @type {number}
             */
            this._opacity = options.opacity == undefined ? 1.0 : options.opacity;

            /**
             * Opacity state during the animated opacity.
             * @protected
             * @type {number}
             */
            this._fadingOpacity = this._opacity;

            /**
             * Entity collection events handler.
             * @public
             * @type {Events}
             */
            this.events = new Events(EVENT_NAMES$6, this);

            this.rendererEvents = this.events;

            // initialize current entities
            if (options.entities) {
                this.addEntities(options.entities);
            }
        }

        static get _staticCounter() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set _staticCounter(n) {
            this._counter = n;
        }

        // setPolygonOffset(factor, units) {
        //     this.polygonOffsetUnits = units;
        // }

        /**
         * Sets collection visibility.
         * @public
         * @param {boolean} visibility - Visibility flag.
         */
        setVisibility(visibility) {
            this._visibility = visibility;
            this._fadingOpacity = this._opacity * (visibility ? 1 : 0);
            this.events.dispatch(this.events.visibilitychange, this);
        }

        /**
         * Returns collection visibility.
         * @public
         * @returns {boolean} -
         */
        getVisibility() {
            return this._visibility;
        }

        /**
         * Sets collection opacity.
         * @public
         * @param {number} opacity - Opacity.
         */
        setOpacity(opacity) {
            this._opacity = opacity;
        }

        /**
         * Sets collection picking ability.
         * @public
         * @param {boolean} enable - Picking enable flag.
         */
        setPickingEnabled(enable) {
            this.billboardHandler.pickingEnabled = enable;
            this.labelHandler.pickingEnabled = enable;
            this.polylineHandler.pickingEnabled = enable;
            this.rayHandler.pickingEnabled = enable;
            this.shapeHandler.pickingEnabled = enable;
            this.pointCloudHandler.pickingEnabled = enable;
            this.stripHandler.pickingEnabled = enable;
            this.geoObjectHandler.pickingEnabled = enable;
        }

        /**
         * Gets collection opacity.
         * @public
         * @returns {number} -
         */
        getOpacity() {
            return this._opacity;
        }

        /**
         * Sets scale by distance parameters.
         * @public
         * @param {number} near - Full scale entity distance.
         * @param {number} far - Zerol scale entity distance.
         * @param {number} [farInvisible] - Entity visibility distance.
         */
        setScaleByDistance(near, far, farInvisible) {
            this.scaleByDistance[0] = near;
            this.scaleByDistance[1] = far;
            this.scaleByDistance[2] = farInvisible || MAX32;
        }

        _addRecursively(entity) {
            // billboard
            entity.billboard && this.billboardHandler.add(entity.billboard);

            // label
            entity.label && this.labelHandler.add(entity.label);

            // shape
            entity.shape && this.shapeHandler.add(entity.shape);

            // polyline
            entity.polyline && this.polylineHandler.add(entity.polyline);

            // ray
            entity.ray && this.rayHandler.add(entity.ray);

            // pointCloud
            entity.pointCloud && this.pointCloudHandler.add(entity.pointCloud);

            // strip
            entity.strip && this.stripHandler.add(entity.strip);

            //geoObject
            entity.geoObject && this.geoObjectHandler.add(entity.geoObject);

            this.events.dispatch(this.events.entityadd, entity);

            for (var i = 0; i < entity.childrenNodes.length; i++) {
                entity.childrenNodes[i]._entityCollection = this;
                entity.childrenNodes[i]._entityCollectionIndex = entity._entityCollectionIndex;
                entity.childrenNodes[i]._pickingColor = entity._pickingColor;
                this._addRecursively(entity.childrenNodes[i]);
            }
        }

        /**
         * Adds entity to the collection and returns collection.
         * @public
         * @param {Entity} entity - Entity.
         * @returns {EntityCollection} -
         */
        add(entity) {
            if (!entity._entityCollection) {
                entity._entityCollection = this;
                entity._entityCollectionIndex = this._entities.length;
                this._entities.push(entity);
                var rn = this.renderNode;
                if (rn) {
                    rn.renderer && rn.renderer.assignPickingColor(entity);
                    if (rn.ellipsoid && entity._cartesian.isZero()) {
                        entity.setCartesian3v(rn.ellipsoid.lonLatToCartesian(entity._lonlat));
                    }
                }
                this._addRecursively(entity);
                entity.setPickingColor();
            }
            return this;
        }

        /**
         * Adds entities array to the collection and returns collection.
         * @public
         * @param {Array.<Entity>} entities - Entities array.
         * @returns {EntityCollection} -
         */
        addEntities(entities) {
            for (let i = 0, len = entities.length; i < len; i++) {
                this.add(entities[i]);
            }
            return this;
        }

        /**
         * Returns true if the entity belongs this collection, otherwise returns false.
         * @public
         * @param {Entity} entity - Entity.
         * @returns {boolean} -
         */
        belongs(entity) {
            return (
                entity._entityCollection &&
                this._renderNodeIndex === entity._entityCollection._renderNodeIndex
            );
        }

        _removeRecursively(entity) {
            entity._entityCollection = null;
            entity._entityCollectionIndex = -1;

            // billboard
            entity.billboard && this.billboardHandler.remove(entity.billboard);

            // label
            entity.label && this.labelHandler.remove(entity.label);

            // shape
            entity.shape && this.shapeHandler.remove(entity.shape);

            // polyline
            entity.polyline && this.polylineHandler.remove(entity.polyline);

            // ray
            entity.ray && this.rayHandler.remove(entity.ray);

            // pointCloud
            entity.pointCloud && this.pointCloudHandler.remove(entity.pointCloud);

            // strip
            entity.strip && this.stripHandler.remove(entity.strip);

            // geoObject
            entity.geoObject && this.geoObjectHandler.remove(entity.geoObject);

            for (var i = 0; i < entity.childrenNodes.length; i++) {
                this._removeRecursively(entity.childrenNodes[i]);
            }
        }

        /**
         * Removes entity from this collection.
         * @public
         * @param {Entity} entity - Entity to remove.
         */
        removeEntity(entity) {
            this._entities.splice(entity._entityCollectionIndex, 1);
            this.reindexEntitiesArray(entity._entityCollectionIndex);

            // clear picking color
            if (this.renderNode && this.renderNode.renderer) {
                this.renderNode.renderer.clearPickingColor(entity);
                entity._pickingColor.clear();
            }

            if (this.belongs(entity)) {
                this._removeRecursively(entity);
            }

            this.events.dispatch(this.events.entityremove, entity);
        }

        _removeEntitySilent(entity) {
            this._entities.splice(entity._entityCollectionIndex, 1);
            this.reindexEntitiesArray(entity._entityCollectionIndex);

            // clear picking color
            if (this.renderNode && this.renderNode.renderer) {
                this.renderNode.renderer.clearPickingColor(entity);
                entity._pickingColor.clear();
            }

            if (this.belongs(entity)) {
                this._removeRecursively(entity);
            }
        }

        /**
         * Creates or refresh collected entities picking color.
         * @public
         */
        createPickingColors() {
            var e = this._entities;
            for (var i = 0; i < e.length; i++) {
                if (!e[i].parent) {
                    this.renderNode.renderer.assignPickingColor(e[i]);
                    e[i].setPickingColor();
                }
            }
        }

        /**
         * Refresh collected entities indexes from startIndex entitytes collection array position.
         * @public
         * @param {number} startIndex - Entities collection array index.
         */
        reindexEntitiesArray(startIndex) {
            var e = this._entities;
            for (var i = startIndex; i < e.length; i++) {
                e[i]._entityCollectionIndex = i;
            }
        }

        /**
         * Adds this collection to render node.
         * @public
         * @param {RenderNode} renderNode - Render node.
         * @param {boolean} [isHidden] - Uses in vector layers that render in planet render specific function.
         * @returns {EntityCollection} -
         */
        addTo(renderNode, isHidden) {
            if (!this.renderNode) {
                this.renderNode = renderNode;
                if (!isHidden) {
                    this._renderNodeIndex = renderNode.entityCollections.length;
                    renderNode.entityCollections.push(this);
                }
                renderNode.ellipsoid && this._updateGeodeticCoordinates(renderNode.ellipsoid);

                this.bindRenderNode(renderNode);

                this.events.dispatch(this.events.add, this);
            }
            return this;
        }

        /**
         * This function is called in the RenderNode assign function.
         * @param {RenderNode} renderNode
         */
        bindRenderNode(renderNode) {
            if (renderNode.renderer) {
                this.billboardHandler.setRenderer(renderNode.renderer);
                this.labelHandler.setRenderer(renderNode.renderer);
                this.rayHandler.setRenderer(renderNode.renderer);

                this.geoObjectHandler.setRenderNode(renderNode);

                this.shapeHandler.setRenderNode(renderNode);
                this.polylineHandler.setRenderNode(renderNode);
                this.pointCloudHandler.setRenderNode(renderNode);
                this.stripHandler.setRenderNode(renderNode);

                this.updateBillboardsTextureAtlas();
                this.updateLabelsFontAtlas();
                this.createPickingColors();
            }
        }

        /**
         * Updates coordiantes all lonLat entities in collection after collecction attached to the planet node.
         * @private
         * @param {Ellipsoid} ellipsoid - Globe ellipsoid.
         */
        _updateGeodeticCoordinates(ellipsoid) {
            var e = this._entities;
            var i = e.length;
            while (i--) {
                var ei = e[i];
                ei._lonlat && ei.setCartesian3v(ellipsoid.lonLatToCartesian(ei._lonlat));
            }
        }

        /**
         * Updates billboard texture atlas.
         * @public
         */
        updateBillboardsTextureAtlas() {
            var b = this.billboardHandler._billboards;
            for (var i = 0; i < b.length; i++) {
                b[i].setSrc(b[i]._src);
            }
        }

        /**
         * Updates labels font atlas.
         * @public
         */
        updateLabelsFontAtlas() {
            if (this.renderNode) {
                var l = [].concat(this.labelHandler._billboards);
                this.labelHandler._billboards = [];
                for (var i = 0; i < l.length; i++) {
                    this.labelHandler.assignFontAtlas(l[i]);
                }
            }
        }

        /**
         * Removes collection from render node.
         * @public
         */
        remove() {
            if (this.renderNode) {
                if (this._renderNodeIndex !== -1) {
                    this.renderNode.entityCollections.splice(this._renderNodeIndex, 1);
                    // reindex in the renderNode
                    for (
                        var i = this._renderNodeIndex;
                        i < this.renderNode.entityCollections.length;
                        i++
                    ) {
                        this.renderNode.entityCollections._renderNodeIndex = i;
                    }
                }
                this.renderNode = null;
                this._renderNodeIndex = -1;
                this.events.dispatch(this.events.remove, this);
            }
        }

        /**
         * Gets entity array.
         * @public
         * @returns {Array.<Entity>} -
         */
        getEntities() {
            return [].concat(this._entities);
        }

        /**
         * Safety entities loop.
         * @public
         * @param {function} callback - Entity callback.
         */
        each(callback) {
            var i = this._entities.length;
            while (i--) {
                var ei = this._entities[i];
                ei && callback(ei);
            }
        }

        /**
         * Removes all entities from colection and clear handlers.
         * @public
         */
        clear() {
            // TODO: Optimize by replace delete
            // code to the clearEntity function.
            this.billboardHandler.clear();
            this.labelHandler.clear();
            this.shapeHandler.clear();
            this.polylineHandler.clear();
            this.rayHandler.clear();
            this.pointCloudHandler.clear();
            this.stripHandler.clear();
            this.geoObjectHandler.clear();

            var i = this._entities.length;
            while (i--) {
                var ei = this._entities[i];
                if (this.renderNode && this.renderNode.renderer) {
                    this.renderNode.renderer.clearPickingColor(ei);
                    ei._pickingColor.clear();
                }
                this._clearEntity(ei);
            }
            this._entities.length = 0;
            this._entities = [];
        }

        /**
         * Clears entity recursevely.
         * @private
         * @param {Entity} entity - Entity to clear.
         */
        _clearEntity(entity) {
            entity._entityCollection = null;
            entity._entityCollectionIndex = -1;
            for (var i = 0; i < entity.childrenNodes.length; i++) {
                this._clearEntity(entity.childrenNodes[i]);
            }
        }
    }

    const EVENT_NAMES$6 = [
        /**
         * Triggered when entity has moved.
         * @event og.EntityCollection#entitymove
         */
        "entitymove",

        /**
         * Triggered when collection entities begin draw.
         * @event og.EntityCollection#draw
         */
        "draw",

        /**
         * Triggered after collection has drawn.
         * @event og.EntityCollection#drawend
         */
        "drawend",

        /**
         * Triggered when added to the render node.
         * @event og.EntityCollection#add
         */
        "add",

        /**
         * Triggered when removed from the render node.
         * @event og.EntityCollection#remove
         */
        "remove",

        /**
         * Triggered when new entity added to the collection.
         * @event og.EntityCollection#entityadd
         */
        "entityadd",

        /**
         * Triggered when entity removes from the collection.
         * @event og.EntityCollection#entityremove
         */
        "entityremove",

        /**
         * Triggered when visibility changes.
         * @event og.EntityCollection#visibilitychange
         */
        "visibilitychange",

        /**
         * Triggered when mouse moves over the entity.
         * @event og.EntityCollection#mousemove
         */
        "mousemove",

        /**
         * Triggered when mouse has entered over the entity.
         * @event og.EntityCollection#mouseenter
         */
        "mouseenter",

        /**
         * Triggered when mouse leaves the entity.
         * @event og.EntityCollection#mouseleave
         */
        "mouseleave",

        /**
         * Mouse left button clicked.
         * @event og.EntityCollection#lclick
         */
        "lclick",

        /**
         * Mouse right button clicked.
         * @event og.EntityCollection#rclick
         */
        "rclick",

        /**
         * Mouse right button clicked.
         * @event og.EntityCollection#mclick
         */
        "mclick",

        /**
         * Mouse left button double click.
         * @event og.EntityCollection#ldblclick
         */
        "ldblclick",

        /**
         * Mouse right button double click.
         * @event og.EntityCollection#rdblclick
         */
        "rdblclick",

        /**
         * Mouse middle button double click.
         * @event og.EntityCollection#mdblclick
         */
        "mdblclick",

        /**
         * Mouse left button up(stop pressing).
         * @event og.EntityCollection#lup
         */
        "lup",

        /**
         * Mouse right button up(stop pressing).
         * @event og.EntityCollection#rup
         */
        "rup",

        /**
         * Mouse middle button up(stop pressing).
         * @event og.EntityCollection#mup
         */
        "mup",

        /**
         * Mouse left button is just pressed down(start pressing).
         * @event og.EntityCollection#ldown
         */
        "ldown",

        /**
         * Mouse right button is just pressed down(start pressing).
         * @event og.EntityCollection#rdown
         */
        "rdown",

        /**
         * Mouse middle button is just pressed down(start pressing).
         * @event og.EntityCollection#mdown
         */
        "mdown",

        /**
         * Mouse left button is pressing.
         * @event og.EntityCollection#lhold
         */
        "lhold",

        /**
         * Mouse right button is pressing.
         * @event og.EntityCollection#rhold
         */
        "rhold",

        /**
         * Mouse middle button is pressing.
         * @event og.EntityCollection#mhold
         */
        "mhold",

        /**
         * Mouse wheel is rotated.
         * @event og.EntityCollection#mousewheel
         */
        "mousewheel",

        /**
         * Triggered when touch moves over the entity.
         * @event og.EntityCollection#touchmove
         */
        "touchmove",

        /**
         * Triggered when entity begins to touch.
         * @event og.EntityCollection#touchstart
         */
        "touchstart",

        /**
         * Triggered when entity ends touching.
         * @event og.EntityCollection#touchend
         */
        "touchend",

        /**
         * Triggered entity double touch.
         * @event og.EntityCollection#doubletouch
         */
        "doubletouch",

        /**
         * Triggered when touching leaves entity.
         * @event og.EntityCollection#touchleave
         */
        "touchleave",

        /**
         * Triggered when touch enters over the entity.
         * @event og.EntityCollection#touchenter
         */
        "touchenter"
    ];

    /**
     * @module og/quadTree/EntityCollectionNode
     */

    class EntityCollectionNode {

        constructor(layer, partId, parent, id, extent, planet, zoom) {
            this.layer = layer;
            this.parentNode = parent;
            this.childrenNodes = [];
            this.partId = partId;
            this.nodeId = partId + id;
            this.state = null;
            this.extent = extent;
            this.count = 0;
            this.deferredEntities = [];
            this.entityCollection = null;
            this.zoom = zoom;
            this._inTheQueue = false;

            this.bsphere = new Sphere$1();

            planet && this._setExtentBounds();
        }

        insertEntity(entity, rightNow) {
            this.buildTree([entity], rightNow);
        }

        _addEntitiesToCollection(entities, rightNow) {
            if (entities.length) {
                var l = this.layer,
                    p = l._planet;

                var ec = this.entityCollection;

                if (!ec) {
                    ec = new EntityCollection$1({
                        pickingEnabled: l._pickingEnabled,
                        labelMaxLetters: l._labelMaxLetters
                    });
                    ec._layer = this.layer;
                    ec.addTo(p, true);
                    ec._quadNode = this;
                    l._bindEventsDefault(ec);
                    this.entityCollection = ec;
                }

                if (rightNow || !l.async) {
                    this.entityCollection.addEntities(entities);
                } else {
                    this.deferredEntities.push.apply(this.deferredEntities, entities);
                }
            }
        }

        _setExtentBounds() {
            if (!this.nodeId) {
                this.bsphere.radius = this.layer._planet.ellipsoid._a;
                this.bsphere.center = new Vec3();
            } else {
                this.bsphere.setFromExtent(this.layer._planet.ellipsoid, this.extent.inverseMercator());
            }
        }

        __setLonLat__(entity) {

            if (entity._lonlat.isZero() && !entity._cartesian.isZero()) {
                entity._lonlat = this.layer._planet.ellipsoid.cartesianToLonLat(entity._cartesian);
            }

            if (Math.abs(entity._lonlat.lat) < MAX_LAT) {
                entity._lonlatMerc = entity._lonlat.forwardMercator();
            } else {
                entity._lonlatMerc = null;
            }
            return entity._lonlatMerc;
        }

        buildTree(entities, rightNow) {

            this.count += entities.length;

            if (entities.length > this.layer._nodeCapacity) {
                var cn = this.childrenNodes;
                if (!cn.length) {
                    this.createChildrenNodes();
                }

                var en_nw = [],
                    en_ne = [],
                    en_sw = [],
                    en_se = [];

                var i = entities.length;
                while (i--) {
                    var ei = entities[i];
                    if (cn[NW].isInside(ei)) {
                        ei._nodePtr = cn[NW];
                        en_nw.push(ei);
                    } else if (cn[NE].isInside(ei)) {
                        ei._nodePtr = cn[NE];
                        en_ne.push(ei);
                    } else if (cn[SW].isInside(ei)) {
                        ei._nodePtr = cn[SW];
                        en_sw.push(ei);
                    } else if (cn[SE].isInside(ei)) {
                        ei._nodePtr = cn[SE];
                        en_se.push(ei);
                    }
                }

                en_nw.length && cn[NW].buildTree(en_nw, rightNow);
                en_ne.length && cn[NE].buildTree(en_ne, rightNow);
                en_sw.length && cn[SW].buildTree(en_sw, rightNow);
                en_se.length && cn[SE].buildTree(en_se, rightNow);

            } else {
                this._addEntitiesToCollection(entities, rightNow);
            }
        }

        isInside(entity) {
            if (entity._lonlatMerc) {
                return this.extent.isInside(entity._lonlatMerc);
            } else {
                return false;
            }
        }

        createChildrenNodes() {
            var l = this.layer;
            var ext = this.extent;
            var size_x = ext.getWidth() * 0.5;
            var size_y = ext.getHeight() * 0.5;
            var ne = ext.northEast,
                sw = ext.southWest;
            var id = this.nodeId * 4 + 1;
            var c = new LonLat(sw.lon + size_x, sw.lat + size_y);
            var nd = this.childrenNodes;
            var p = this.layer._planet;
            var z = this.zoom + 1;

            nd[NW] = new EntityCollectionNode(l, NW, this, id,
                new Extent(new LonLat(sw.lon, sw.lat + size_y), new LonLat(sw.lon + size_x, ne.lat)), p, z);

            nd[NE] = new EntityCollectionNode(l, NE, this, id,
                new Extent(c, new LonLat(ne.lon, ne.lat)), p, z);

            nd[SW] = new EntityCollectionNode(l, SW, this, id,
                new Extent(new LonLat(sw.lon, sw.lat), c), p, z);

            nd[SE] = new EntityCollectionNode(l, SE, this, id,
                new Extent(new LonLat(sw.lon + size_x, sw.lat), new LonLat(ne.lon, sw.lat + size_y)), p, z);
        }

        collectRenderCollectionsPASS1(visibleNodes, outArr) {
            var n = visibleNodes[this.nodeId];
            if (n) {
                var cn = this.childrenNodes;
                if (this.entityCollection) {
                    this.renderCollection(outArr, visibleNodes);
                } else if (cn.length) {
                    if (n.state === RENDERING) {
                        this.layer._secondPASS.push(this);
                    } else {
                        cn[NW].collectRenderCollectionsPASS1(visibleNodes, outArr);
                        cn[NE].collectRenderCollectionsPASS1(visibleNodes, outArr);
                        cn[SW].collectRenderCollectionsPASS1(visibleNodes, outArr);
                        cn[SE].collectRenderCollectionsPASS1(visibleNodes, outArr);
                    }
                }
            }
        }

        collectRenderCollectionsPASS2(visibleNodes, outArr, renderingNodeId) {
            var p = this.layer._planet;
            var cam = p.renderer.activeCamera;

            var altVis = (cam.eye.distance(this.bsphere.center) - this.bsphere.radius <
                VISIBLE_DISTANCE * Math.sqrt(cam._lonLat.height)) || cam._lonLat.height > 10000;

            if (this.count > 0 && altVis &&
                p.renderer.activeCamera.frustum.containsSphere(this.bsphere) > 0) {

                var cn = this.childrenNodes;

                if (this.entityCollection) {
                    this.renderCollection(outArr, visibleNodes, renderingNodeId);
                } else if (cn.length) {
                    cn[NW].collectRenderCollectionsPASS2(visibleNodes, outArr, renderingNodeId);
                    cn[NE].collectRenderCollectionsPASS2(visibleNodes, outArr, renderingNodeId);
                    cn[SW].collectRenderCollectionsPASS2(visibleNodes, outArr, renderingNodeId);
                    cn[SE].collectRenderCollectionsPASS2(visibleNodes, outArr, renderingNodeId);
                }

            }
        }

        applyCollection() {
            this.entityCollection.addEntities(this.deferredEntities);
            this.deferredEntities.length = 0;
            this.deferredEntities = [];
            this._inTheQueue = false;
        }

        traverseTree(callback) {

            var cn = this.childrenNodes;

            if (this.entityCollection) {
                callback(this);
            } else if (cn.length) {
                cn[NW].traverseTree(callback);
                cn[NE].traverseTree(callback);
                cn[SW].traverseTree(callback);
                cn[SE].traverseTree(callback);
            }
        }

        renderCollection(outArr, visibleNodes, renderingNodeId) {

            var l = this.layer;

            l._renderingNodes[this.nodeId] = true;

            if (this.deferredEntities.length && !this._inTheQueue) {
                if (l.async) {
                    l._queueDeferredNode(this);
                } else {
                    this.applyCollection();
                }
            }

            var ec = this.entityCollection;

            ec._fadingOpacity = l._fadingOpacity;
            ec.scaleByDistance = l.scaleByDistance;
            ec.pickingScale = l.pickingScale;
            ec.polygonOffsetUnits = l.polygonOffsetUnits;

            outArr.push(ec);

            if (l.clampToGround || l.relativeToGround) {
                var e = ec._entities;
                var i = e.length;

                if (visibleNodes[this.nodeId] && visibleNodes[this.nodeId].state === RENDERING) {
                    while (i--) {
                        let ei = e[i];
                        this.alignEntityToTheGround(ei, visibleNodes[this.nodeId].segment);
                    }
                } else if (renderingNodeId) {
                    while (i--) {
                        let ei = e[i];
                        this.alignEntityToTheGround(ei, visibleNodes[renderingNodeId].segment);
                    }
                } else {
                    var n = l._planet._renderedNodes;
                    while (i--) {
                        let ei = e[i];
                        let j = n.length;
                        while (j--) {
                            if (n[j].segment.isEntityInside(ei)) {
                                this.alignEntityToTheGround(ei, n[j].segment);
                                break;
                            }
                        }
                    }
                }
            }
        }

        alignEntityToTheGround(entity, segment) {
            var res = new Vec3();
            segment.getEntityTerrainPoint(entity, res);
            entity._setCartesian3vSilent(res.addA(res.normal().scale((Number(this.layer.relativeToGround) && entity._altitude) || 0.0)));
        }

        isVisible() {
            if (this.layer._renderingNodes[this.nodeId]) {
                return true;
            }
            return false;
        }

    }

    class EntityCollectionNodeWGS84 extends EntityCollectionNode {

        constructor(layer, partId, parent, id, extent, planet, zoom) {
            super(layer, partId, parent, id, extent, planet, zoom);
            this.isNorth = false;
        }

        createChildrenNodes() {
            var l = this.layer;
            var ext = this.extent;
            var size_x = ext.getWidth() * 0.5;
            var size_y = ext.getHeight() * 0.5;
            var ne = ext.northEast,
                sw = ext.southWest;
            var id = this.nodeId * 4 + 1;
            var c = new LonLat(sw.lon + size_x, sw.lat + size_y);
            var nd = this.childrenNodes;
            var p = this.layer._planet;
            var z = this.zoom + 1;

            nd[NW] = new EntityCollectionNodeWGS84(l, NW, this, id,
                new Extent(new LonLat(sw.lon, sw.lat + size_y), new LonLat(sw.lon + size_x, ne.lat)), p, z);

            nd[NE] = new EntityCollectionNodeWGS84(l, NE, this, id,
                new Extent(c, new LonLat(ne.lon, ne.lat)), p, z);

            nd[SW] = new EntityCollectionNodeWGS84(l, SW, this, id,
                new Extent(new LonLat(sw.lon, sw.lat), c), p, z);

            nd[SE] = new EntityCollectionNodeWGS84(l, SE, this, id,
                new Extent(new LonLat(sw.lon + size_x, sw.lat), new LonLat(ne.lon, sw.lat + size_y)), p, z);
        }

        _setExtentBounds() {
            if (this.extent.northEast.lat > 0) {
                this.isNorth = true;
            }
            this.bsphere.setFromExtent(this.layer._planet.ellipsoid, this.extent);
        }

        __setLonLat__(entity) {
            if (entity._lonlat.isZero()) {
                entity._lonlat = this.layer._planet.ellipsoid.cartesianToLonLat(entity._cartesian);
            }
            return entity._lonlat;
        }

        isVisible() {
            if (this.isNorth && this.layer._renderingNodesNorth[this.nodeId]) {
                return true;
            } else if (this.layer._renderingNodesSouth[this.nodeId]) {
                return true;
            }
            return false;
        }

        isInside(entity) {
            return this.extent.isInside(entity._lonlat);
        }

        /**
         *
         * @param {*} outArr
         * @param {*} visibleNodes
         * @param {*} renderingNode
         */
        renderCollection(outArr, visibleNodes, renderingNode) {

            if (this.isNorth) {
                this.layer._renderingNodesNorth[this.nodeId] = true;
            } else {
                this.layer._renderingNodesSouth[this.nodeId] = true;
            }

            if (this.deferredEntities.length && !this._inTheQueue) {
                if (this.layer.async) {
                    this.layer._queueDeferredNode(this);
                } else {
                    this.applyCollection();
                }
            }

            this.entityCollection._fadingOpacity = this.layer._fadingOpacity;
            this.entityCollection.scaleByDistance = this.layer.scaleByDistance;
            this.entityCollection.pickingScale = this.layer.pickingScale;

            outArr.push(this.entityCollection);
        }
    }

    /* eslint-disable no-unused-vars */

    // ISC License
    //
    // Copyright (c) 2016, Mapbox
    //
    // Permission to use, copy, modify, and/or distribute this software for any purpose
    // with or without fee is hereby granted, provided that the above copyright notice
    // and this permission notice appear in all copies.
    //
    // THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    // REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
    // FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    // INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
    // OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
    // TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
    // THIS SOFTWARE.
    //
    //https://github.com/mapbox/earcut
    function earcut(data, holeIndices, dim) {

        dim = dim || 2;

        var hasHoles = holeIndices && holeIndices.length,
            outerLen = hasHoles ? holeIndices[0] * dim : data.length,
            outerNode = linkedList(data, 0, outerLen, dim, true),
            triangles = [];

        if (!outerNode) return triangles;

        var minX, minY, maxX, maxY, x, y, size;

        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];

            for (var i = dim; i < outerLen; i += dim) {
                x = data[i];
                y = data[i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
            }

            // minX, minY and size are later used to transform coords into integers for z-order calculation
            size = Math.max(maxX - minX, maxY - minY);
        }

        earcutLinked(outerNode, triangles, dim, minX, minY, size);

        return triangles;
    }

    // create a circular doubly linked list from polygon points in the specified winding order
    function linkedList(data, start, end, dim, clockwise) {
        var i, last;

        if (clockwise === (signedArea(data, start, end, dim) > 0)) {
            for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
        } else {
            for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
        }

        if (last && equals(last, last.next)) {
            removeNode(last);
            last = last.next;
        }

        return last;
    }

    // eliminate colinear or duplicate points
    function filterPoints(start, end) {
        if (!start) return start;
        if (!end) end = start;

        var p = start,
            again;
        do {
            again = false;

            if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                removeNode(p);
                p = end = p.prev;
                if (p === p.next) return null;
                again = true;

            } else {
                p = p.next;
            }
        } while (again || p !== end);

        return end;
    }

    // main ear slicing loop which triangulates a polygon (given as a linked list)
    function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
        if (!ear) return;

        // interlink polygon nodes in z-order
        if (!pass && size) indexCurve(ear, minX, minY, size);

        var stop = ear,
            prev, next;

        // iterate through ears, slicing them one by one
        while (ear.prev !== ear.next) {
            prev = ear.prev;
            next = ear.next;

            if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
                // cut off the triangle
                triangles.push(prev.i / dim);
                triangles.push(ear.i / dim);
                triangles.push(next.i / dim);

                removeNode(ear);

                // skipping the next vertice leads to less sliver triangles
                ear = next.next;
                stop = next.next;

                continue;
            }

            ear = next;

            // if we looped through the whole remaining polygon and can't find any more ears
            if (ear === stop) {
                // try filtering points and slicing again
                if (!pass) {
                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);

                    // if this didn't work, try curing all small self-intersections locally
                } else if (pass === 1) {
                    ear = cureLocalIntersections(ear, triangles, dim);
                    earcutLinked(ear, triangles, dim, minX, minY, size, 2);

                    // as a last resort, try splitting the remaining polygon into two
                } else if (pass === 2) {
                    splitEarcut(ear, triangles, dim, minX, minY, size);
                }

                break;
            }
        }
    }

    // check whether a polygon node forms a valid ear with adjacent nodes
    function isEar(ear) {
        var a = ear.prev,
            b = ear,
            c = ear.next;

        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

        // now make sure we don't have other points inside the potential ear
        var p = ear.next.next;

        while (p !== ear.prev) {
            if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0) return false;
            p = p.next;
        }

        return true;
    }

    function isEarHashed(ear, minX, minY, size) {
        var a = ear.prev,
            b = ear,
            c = ear.next;

        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

        // triangle bbox; min & max are calculated like this for speed
        var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
            minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
            maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
            maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

        // z-order range for the current triangle bbox;
        var minZ = zOrder(minTX, minTY, minX, minY, size),
            maxZ = zOrder(maxTX, maxTY, minX, minY, size);

        // first look for points inside the triangle in increasing z-order
        var p = ear.nextZ;

        while (p && p.z <= maxZ) {
            if (p !== ear.prev && p !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0) return false;
            p = p.nextZ;
        }

        // then look for points in decreasing z-order
        p = ear.prevZ;

        while (p && p.z >= minZ) {
            if (p !== ear.prev && p !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0) return false;
            p = p.prevZ;
        }

        return true;
    }

    // go through all polygon nodes and cure small local self-intersections
    function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
            var a = p.prev,
                b = p.next.next;

            if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

                triangles.push(a.i / dim);
                triangles.push(p.i / dim);
                triangles.push(b.i / dim);

                // remove two nodes involved
                removeNode(p);
                removeNode(p.next);

                p = start = b;
            }
            p = p.next;
        } while (p !== start);

        return p;
    }

    // try splitting polygon into two and triangulate them independently
    function splitEarcut(start, triangles, dim, minX, minY, size) {
        // look for a valid diagonal that divides the polygon into two
        var a = start;
        do {
            var b = a.next.next;
            while (b !== a.prev) {
                if (a.i !== b.i && isValidDiagonal(a, b)) {
                    // split the polygon in two by the diagonal
                    var c = splitPolygon(a, b);

                    // filter colinear points around the cuts
                    a = filterPoints(a, a.next);
                    c = filterPoints(c, c.next);

                    // run earcut on each half
                    earcutLinked(a, triangles, dim, minX, minY, size);
                    earcutLinked(c, triangles, dim, minX, minY, size);
                    return;
                }
                b = b.next;
            }
            a = a.next;
        } while (a !== start);
    }

    // link every hole into the outer loop, producing a single-ring polygon without holes
    function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [],
            i, len, start, end, list;

        for (i = 0, len = holeIndices.length; i < len; i++) {
            start = holeIndices[i] * dim;
            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            list = linkedList(data, start, end, dim, false);
            if (list === list.next) list.steiner = true;
            queue.push(getLeftmost(list));
        }

        queue.sort(compareX);

        // process holes from left to right
        for (i = 0; i < queue.length; i++) {
            eliminateHole(queue[i], outerNode);
            outerNode = filterPoints(outerNode, outerNode.next);
        }

        return outerNode;
    }

    function compareX(a, b) {
        return a.x - b.x;
    }

    // find a bridge between vertices that connects hole with an outer ring and and link it
    function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);
        if (outerNode) {
            var b = splitPolygon(outerNode, hole);
            filterPoints(b, b.next);
        }
    }

    // David Eberly's algorithm for finding a bridge between hole and outer polygon
    function findHoleBridge(hole, outerNode) {
        var p = outerNode,
            hx = hole.x,
            hy = hole.y,
            qx = -Infinity,
            m;

        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {
            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    if (x === hx) {
                        if (hy === p.y) return p;
                        if (hy === p.next.y) return p.next;
                    }
                    m = p.x < p.next.x ? p : p.next;
                }
            }
            p = p.next;
        } while (p !== outerNode);

        if (!m) return null;

        if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point

        var stop = m,
            mx = m.x,
            my = m.y,
            tanMin = Infinity,
            tan;

        p = m.next;

        while (p !== stop) {
            if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                    m = p;
                    tanMin = tan;
                }
            }

            p = p.next;
        }

        return m;
    }

    // interlink polygon nodes in z-order
    function indexCurve(start, minX, minY, size) {
        var p = start;
        do {
            if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
        } while (p !== start);

        p.prevZ.nextZ = null;
        p.prevZ = null;

        sortLinked(p);
    }

    // Simon Tatham's linked list merge sort algorithm
    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
    function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize,
            inSize = 1;

        do {
            p = list;
            list = null;
            tail = null;
            numMerges = 0;

            while (p) {
                numMerges++;
                q = p;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q) break;
                }
                qSize = inSize;

                while (pSize > 0 || (qSize > 0 && q)) {

                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    } else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }

                    if (tail) tail.nextZ = e;
                    else list = e;

                    e.prevZ = tail;
                    tail = e;
                }

                p = q;
            }

            tail.nextZ = null;
            inSize *= 2;

        } while (numMerges > 1);

        return list;
    }

    // z-order of a point given coords and size of the data bounding box
    function zOrder(x, y, minX, minY, size) {
        // coords are transformed into non-negative 15-bit integer range
        x = 32767 * (x - minX) / size;
        y = 32767 * (y - minY) / size;

        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;

        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;

        return x | (y << 1);
    }

    // find the leftmost node of a polygon ring
    function getLeftmost(start) {
        var p = start,
            leftmost = start;
        do {
            if (p.x < leftmost.x) leftmost = p;
            p = p.next;
        } while (p !== start);

        return leftmost;
    }

    // check if a point lies within a convex triangle
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
            (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
            (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }

    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
    function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
            locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
    }

    // signed area of a triangle
    function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }

    // check if two points are equal
    function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }

    // check if two segments intersect
    function intersects(p1, q1, p2, q2) {
        if ((equals(p1, q1) && equals(p2, q2)) ||
            (equals(p1, q2) && equals(p2, q1))) return true;
        return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
            area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
    }

    // check if a polygon diagonal intersects any polygon segments
    function intersectsPolygon(a, b) {
        var p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
            p = p.next;
        } while (p !== a);

        return false;
    }

    // check if a polygon diagonal is locally inside the polygon
    function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ?
            area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
            area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }

    // check if the middle point of a polygon diagonal is inside the polygon
    function middleInside(a, b) {
        var p = a,
            inside = false,
            px = (a.x + b.x) / 2,
            py = (a.y + b.y) / 2;
        do {
            if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                inside = !inside;
            p = p.next;
        } while (p !== a);

        return inside;
    }

    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
    // if one belongs to the outer ring and another to a hole, it merges it into a single ring
    function splitPolygon(a, b) {
        var a2 = new Node$2(a.i, a.x, a.y),
            b2 = new Node$2(b.i, b.x, b.y),
            an = a.next,
            bp = b.prev;

        a.next = b;
        b.prev = a;

        a2.next = an;
        an.prev = a2;

        b2.next = a2;
        a2.prev = b2;

        bp.next = b2;
        b2.prev = bp;

        return b2;
    }

    // create a node and optionally link it with previous one (in a circular doubly linked list)
    function insertNode(i, x, y, last) {
        var p = new Node$2(i, x, y);

        if (!last) {
            p.prev = p;
            p.next = p;

        } else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
        }
        return p;
    }

    function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;

        if (p.prevZ) p.prevZ.nextZ = p.nextZ;
        if (p.nextZ) p.nextZ.prevZ = p.prevZ;
    }

    function Node$2(i, x, y) {
        // vertice index in coordinates array
        this.i = i;

        // vertex coordinates
        this.x = x;
        this.y = y;

        // previous and next vertice nodes in a polygon ring
        this.prev = null;
        this.next = null;

        // z-order curve value
        this.z = null;

        // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null;

        // indicates whether this is a steiner point
        this.steiner = false;
    }

    function signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
            j = i;
        }
        return sum;
    }

    // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
    function flatten(data) {
        var dim = data[0][0].length,
            result = { vertices: [], holes: [], dimensions: dim },
            holeIndex = 0;

        for (var i = 0; i < data.length; i++) {
            for (var j = 0; j < data[i].length; j++) {
                for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
            }
            if (i > 0) {
                holeIndex += data[i - 1].length;
                result.holes.push(holeIndex);
            }
        }
        return result;
    }

    /**
     * @module og/entity/GeometryHandler
     */

    const POLYVERTICES_BUFFER = 0;
    const POLYINDEXES_BUFFER = 1;
    const POLYCOLORS_BUFFER = 2;
    const LINEVERTICES_BUFFER = 3;
    const LINEINDEXES_BUFFER = 4;
    const LINEORDERS_BUFFER = 5;
    const LINECOLORS_BUFFER = 6;
    const LINETHICKNESS_BUFFER = 7;
    const LINESTROKES_BUFFER = 8;
    const LINESTROKECOLORS_BUFFER = 9;
    const POLYPICKINGCOLORS_BUFFER = 10;
    const LINEPICKINGCOLORS_BUFFER = 11;

    function doubleToTwoFloats(v, high, low) {
        let x = v[0],
            y = v[1];

        if (x >= 0.0) {
            let doubleHigh = Math.floor(x / 65536.0) * 65536.0;
            high.x = Math.fround(doubleHigh);
            low.x = Math.fround(x - doubleHigh);
        } else {
            let doubleHigh = Math.floor(-x / 65536.0) * 65536.0;
            high.x = Math.fround(-doubleHigh);
            low.x = Math.fround(x + doubleHigh);
        }

        if (y >= 0.0) {
            let doubleHigh = Math.floor(y / 65536.0) * 65536.0;
            high.y = Math.fround(doubleHigh);
            low.y = Math.fround(y - doubleHigh);
        } else {
            let doubleHigh = Math.floor(-y / 65536.0) * 65536.0;
            high.y = Math.fround(-doubleHigh);
            low.y = Math.fround(y + doubleHigh);
        }
    }

    let tempHigh = new Vec2(),
        tempLow = new Vec2(),
        tempHighLow = new Vec2();

    class GeometryHandler {
        constructor(layer) {
            this.__staticId = GeometryHandler._staticCounter++;

            this._layer = layer;

            this._handler = null;

            this._geometries = [];

            this._updatedGeometryArr = [];
            this._updatedGeometry = {};

            this._removeGeometryExtentArr = [];
            this._removeGeometryExtents = {};

            // Polygon arrays
            this._polyVerticesHighMerc = [];
            this._polyVerticesLowMerc = [];
            this._polyColors = [];
            this._polyPickingColors = [];
            this._polyIndexes = [];

            // Line arrays
            this._lineVerticesHighMerc = [];
            this._lineVerticesLowMerc = [];
            this._lineOrders = [];
            this._lineIndexes = [];
            this._lineColors = [];
            this._linePickingColors = [];
            this._lineThickness = [];
            this._lineStrokes = [];
            this._lineStrokeColors = [];

            // Buffers
            this._polyVerticesHighBufferMerc = null;
            this._polyVerticesLowBufferMerc = null;
            this._polyColorsBuffer = null;
            this._polyPickingColorsBuffer = null;
            this._polyIndexesBuffer = null;

            this._lineVerticesHighBufferMerc = null;
            this._lineVerticesLowBufferMerc = null;
            this._lineColorsBuffer = null;
            this._linePickingColorsBuffer = null;
            this._lineThicknessBuffer = null;
            this._lineStrokesBuffer = null;
            this._lineStrokeColorsBuffer = null;
            this._lineOrdersBuffer = null;
            this._lineIndexesBuffer = null;

            this._buffersUpdateCallbacks = [];
            this._buffersUpdateCallbacks[POLYVERTICES_BUFFER] = this.createPolyVerticesBuffer;
            this._buffersUpdateCallbacks[POLYINDEXES_BUFFER] = this.createPolyIndexesBuffer;
            this._buffersUpdateCallbacks[POLYCOLORS_BUFFER] = this.createPolyColorsBuffer;
            this._buffersUpdateCallbacks[LINEVERTICES_BUFFER] = this.createLineVerticesBuffer;
            this._buffersUpdateCallbacks[LINEINDEXES_BUFFER] = this.createLineIndexesBuffer;
            this._buffersUpdateCallbacks[LINEORDERS_BUFFER] = this.createLineOrdersBuffer;
            this._buffersUpdateCallbacks[LINECOLORS_BUFFER] = this.createLineColorsBuffer;
            this._buffersUpdateCallbacks[LINETHICKNESS_BUFFER] = this.createLineThicknessBuffer;
            this._buffersUpdateCallbacks[LINESTROKES_BUFFER] = this.createLineStrokesBuffer;
            this._buffersUpdateCallbacks[LINESTROKECOLORS_BUFFER] = this.createLineStrokeColorsBuffer;
            this._buffersUpdateCallbacks[POLYPICKINGCOLORS_BUFFER] = this.createPolyPickingColorsBuffer;
            this._buffersUpdateCallbacks[LINEPICKINGCOLORS_BUFFER] = this.createLinePickingColorsBuffer;

            this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
        }

        static get _staticCounter() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set _staticCounter(n) {
            this._counter = n;
        }

        static appendLineData(
            pathArr,
            isClosed,
            color,
            pickingColor,
            thickness,
            strokeColor,
            strokeSize,
            outVerticesHigh,
            outVerticesLow,
            outOrders,
            outIndexes,
            outColors,
            outPickingColors,
            outThickness,
            outStrokeColors,
            outStrokes,
            outVerticesHigh2,
            outVerticesLow2
        ) {
            var index = 0;

            if (outIndexes.length > 0) {
                index = outIndexes[outIndexes.length - 5] + 9;
                outIndexes.push(index, index);
            } else {
                outIndexes.push(0, 0);
            }

            var t = thickness,
                c = [color.x, color.y, color.z, color.w],
                s = strokeSize,
                sc = [strokeColor.x, strokeColor.y, strokeColor.z, strokeColor.w],
                p = [pickingColor.x, pickingColor.y, pickingColor.z, 1.0];

            for (var j = 0; j < pathArr.length; j++) {
                var path = pathArr[j];

                if (path.length === 0) {
                    continue;
                }

                var startIndex = index;
                var last;
                if (isClosed) {
                    last = path[path.length - 1];
                } else {
                    let p0 = path[0],
                        p1 = path[1];

                    if (!p1) {
                        p1 = p0;
                    }

                    last = [p0[0] + p0[0] - p1[0], p0[1] + p0[1] - p1[1]];
                }

                doubleToTwoFloats(last, tempHigh, tempLow);

                outVerticesHigh.push(
                    tempHigh.x,
                    tempHigh.y,
                    tempHigh.x,
                    tempHigh.y,
                    tempHigh.x,
                    tempHigh.y,
                    tempHigh.x,
                    tempHigh.y
                );
                outVerticesLow.push(
                    tempLow.x,
                    tempLow.y,
                    tempLow.x,
                    tempLow.y,
                    tempLow.x,
                    tempLow.y,
                    tempLow.x,
                    tempLow.y
                );

                outVerticesHigh2.push(
                    tempHigh.x,
                    tempHigh.y,
                    tempHigh.x,
                    tempHigh.y,
                    tempHigh.x,
                    tempHigh.y,
                    tempHigh.x,
                    tempHigh.y
                );
                outVerticesLow2.push(
                    tempLow.x,
                    tempLow.y,
                    tempLow.x,
                    tempLow.y,
                    tempLow.x,
                    tempLow.y,
                    tempLow.x,
                    tempLow.y
                );

                outOrders.push(1, -1, 2, -2);

                outThickness.push(t, t, t, t);
                outStrokes.push(s, s, s, s);
                outColors.push(
                    c[0],
                    c[1],
                    c[2],
                    c[3],
                    c[0],
                    c[1],
                    c[2],
                    c[3],
                    c[0],
                    c[1],
                    c[2],
                    c[3],
                    c[0],
                    c[1],
                    c[2],
                    c[3]
                );
                outStrokeColors.push(
                    sc[0],
                    sc[1],
                    sc[2],
                    sc[3],
                    sc[0],
                    sc[1],
                    sc[2],
                    sc[3],
                    sc[0],
                    sc[1],
                    sc[2],
                    sc[3],
                    sc[0],
                    sc[1],
                    sc[2],
                    sc[3]
                );
                outPickingColors.push(
                    p[0],
                    p[1],
                    p[2],
                    p[3],
                    p[0],
                    p[1],
                    p[2],
                    p[3],
                    p[0],
                    p[1],
                    p[2],
                    p[3],
                    p[0],
                    p[1],
                    p[2],
                    p[3]
                );

                for (var i = 0; i < path.length; i++) {
                    var cur = path[i];

                    doubleToTwoFloats(cur, tempHigh, tempLow);

                    outVerticesHigh.push(
                        tempHigh.x,
                        tempHigh.y,
                        tempHigh.x,
                        tempHigh.y,
                        tempHigh.x,
                        tempHigh.y,
                        tempHigh.x,
                        tempHigh.y
                    );
                    outVerticesLow.push(
                        tempLow.x,
                        tempLow.y,
                        tempLow.x,
                        tempLow.y,
                        tempLow.x,
                        tempLow.y,
                        tempLow.x,
                        tempLow.y
                    );

                    outVerticesHigh2.push(
                        tempHigh.x,
                        tempHigh.y,
                        tempHigh.x,
                        tempHigh.y,
                        tempHigh.x,
                        tempHigh.y,
                        tempHigh.x,
                        tempHigh.y
                    );
                    outVerticesLow2.push(
                        tempLow.x,
                        tempLow.y,
                        tempLow.x,
                        tempLow.y,
                        tempLow.x,
                        tempLow.y,
                        tempLow.x,
                        tempLow.y
                    );

                    outOrders.push(1, -1, 2, -2);
                    outThickness.push(t, t, t, t);
                    outStrokes.push(s, s, s, s);
                    outColors.push(
                        c[0],
                        c[1],
                        c[2],
                        c[3],
                        c[0],
                        c[1],
                        c[2],
                        c[3],
                        c[0],
                        c[1],
                        c[2],
                        c[3],
                        c[0],
                        c[1],
                        c[2],
                        c[3]
                    );
                    outStrokeColors.push(
                        sc[0],
                        sc[1],
                        sc[2],
                        sc[3],
                        sc[0],
                        sc[1],
                        sc[2],
                        sc[3],
                        sc[0],
                        sc[1],
                        sc[2],
                        sc[3],
                        sc[0],
                        sc[1],
                        sc[2],
                        sc[3]
                    );
                    outPickingColors.push(
                        p[0],
                        p[1],
                        p[2],
                        p[3],
                        p[0],
                        p[1],
                        p[2],
                        p[3],
                        p[0],
                        p[1],
                        p[2],
                        p[3],
                        p[0],
                        p[1],
                        p[2],
                        p[3]
                    );
                    outIndexes.push(index++, index++, index++, index++);
                }

                var first;
                if (isClosed) {
                    first = path[0];
                    outIndexes.push(startIndex, startIndex + 1, startIndex + 1, startIndex + 1);
                } else {
                    let p0 = path[path.length - 1],
                        p1 = path[path.length - 2];

                    if (!p1) {
                        p1 = p0;
                    }

                    first = [p0[0] + p0[0] - p1[0], p0[1] + p0[1] - p1[1]];
                    outIndexes.push(index - 1, index - 1, index - 1, index - 1);
                }

                doubleToTwoFloats(first, tempHigh, tempLow);

                outVerticesHigh.push(
                    tempHigh.x,
                    tempHigh.y,
                    tempHigh.x,
                    tempHigh.y,
                    tempHigh.x,
                    tempHigh.y,
                    tempHigh.x,
                    tempHigh.y
                );
                outVerticesLow.push(
                    tempLow.x,
                    tempLow.y,
                    tempLow.x,
                    tempLow.y,
                    tempLow.x,
                    tempLow.y,
                    tempLow.x,
                    tempLow.y
                );

                outVerticesHigh2.push(
                    tempHigh.x,
                    tempHigh.y,
                    tempHigh.x,
                    tempHigh.y,
                    tempHigh.x,
                    tempHigh.y,
                    tempHigh.x,
                    tempHigh.y
                );
                outVerticesLow2.push(
                    tempLow.x,
                    tempLow.y,
                    tempLow.x,
                    tempLow.y,
                    tempLow.x,
                    tempLow.y,
                    tempLow.x,
                    tempLow.y
                );

                outOrders.push(1, -1, 2, -2);
                outThickness.push(t, t, t, t);
                outStrokes.push(s, s, s, s);
                outColors.push(
                    c[0],
                    c[1],
                    c[2],
                    c[3],
                    c[0],
                    c[1],
                    c[2],
                    c[3],
                    c[0],
                    c[1],
                    c[2],
                    c[3],
                    c[0],
                    c[1],
                    c[2],
                    c[3]
                );
                outStrokeColors.push(
                    sc[0],
                    sc[1],
                    sc[2],
                    sc[3],
                    sc[0],
                    sc[1],
                    sc[2],
                    sc[3],
                    sc[0],
                    sc[1],
                    sc[2],
                    sc[3],
                    sc[0],
                    sc[1],
                    sc[2],
                    sc[3]
                );
                outPickingColors.push(
                    p[0],
                    p[1],
                    p[2],
                    p[3],
                    p[0],
                    p[1],
                    p[2],
                    p[3],
                    p[0],
                    p[1],
                    p[2],
                    p[3],
                    p[0],
                    p[1],
                    p[2],
                    p[3]
                );

                if (j < pathArr.length - 1) {
                    index += 8;
                    outIndexes.push(index, index);
                }
            }
        }

        assignHandler(handler) {
            this._handler = handler;
            this.refresh();
        }

        /**
         * @public
         * @param {Geometry} geometry - Geometry object.
         */
        add(geometry) {
            //
            // Triangulates polygon and sets geometry data.
            if (geometry._handlerIndex === -1) {
                geometry._handler = this;
                geometry._handlerIndex = this._geometries.length;
                this._geometries.push(geometry);

                let pickingColor = geometry._entity._pickingColor.scaleTo(1 / 255);

                geometry._polyVerticesHighMerc = [];
                geometry._polyVerticesLowMerc = [];
                geometry._lineVerticesHighMerc = [];
                geometry._lineVerticesLowMerc = [];

                if (geometry._type === GeometryType.POLYGON) {
                    let coordinates = geometry._coordinates;
                    let ci = [];
                    for (let j = 0; j < coordinates.length; j++) {
                        ci[j] = [];
                        for (var k = 0; k < coordinates[j].length; k++) {
                            ci[j][k] = [
                                forward_lon(coordinates[j][k][0]),
                                forward_lat(coordinates[j][k][1])
                            ];
                        }
                    }

                    let data = flatten(ci);
                    let indexes = earcut(data.vertices, data.holes, 2);

                    geometry._polyVerticesHandlerIndex = this._polyVerticesHighMerc.length;
                    geometry._polyIndexesHandlerIndex = this._polyIndexes.length;

                    for (let i = 0; i < indexes.length; i++) {
                        this._polyIndexes.push(indexes[i] + geometry._polyVerticesHandlerIndex * 0.5);
                    }

                    var color = geometry._style.fillColor;

                    let verticesHigh = [],
                        verticesLow = [];

                    for (let i = 0; i < data.vertices.length * 0.5; i++) {
                        this._polyColors.push(color.x, color.y, color.z, color.w);
                        this._polyPickingColors.push(
                            pickingColor.x,
                            pickingColor.y,
                            pickingColor.z,
                            1.0
                        );
                    }

                    for (let i = 0; i < data.vertices.length; i++) {
                        doubleToTwoFloatsV2(data.vertices[i], tempHighLow);
                        verticesHigh[i] = tempHighLow.x;
                        verticesLow[i] = tempHighLow.y;
                    }

                    geometry._polyVerticesHighMerc = verticesHigh;
                    geometry._polyVerticesLowMerc = verticesLow;

                    this._polyVerticesHighMerc.push.apply(this._polyVerticesHighMerc, verticesHigh);
                    this._polyVerticesLowMerc.push.apply(this._polyVerticesLowMerc, verticesLow);

                    geometry._polyVerticesLength = data.vertices.length;
                    geometry._polyIndexesLength = indexes.length;

                    // Creates polygon stroke data
                    geometry._lineVerticesHandlerIndex = this._lineVerticesHighMerc.length;
                    geometry._lineOrdersHandlerIndex = this._lineOrders.length;
                    geometry._lineIndexesHandlerIndex = this._lineIndexes.length;
                    geometry._lineColorsHandlerIndex = this._lineColors.length;
                    geometry._lineThicknessHandlerIndex = this._lineThickness.length;

                    GeometryHandler.appendLineData(
                        ci,
                        true,
                        geometry._style.lineColor,
                        pickingColor,
                        geometry._style.lineWidth,
                        geometry._style.strokeColor,
                        geometry._style.strokeWidth,
                        this._lineVerticesHighMerc,
                        this._lineVerticesLowMerc,
                        this._lineOrders,
                        this._lineIndexes,
                        this._lineColors,
                        this._linePickingColors,
                        this._lineThickness,
                        this._lineStrokeColors,
                        this._lineStrokes,
                        geometry._lineVerticesHighMerc,
                        geometry._lineVerticesLowMerc
                    );

                    geometry._lineVerticesLength =
                        this._lineVerticesHighMerc.length - geometry._lineVerticesHandlerIndex;
                    geometry._lineOrdersLength =
                        this._lineOrders.length - geometry._lineOrdersHandlerIndex;
                    geometry._lineIndexesLength =
                        this._lineIndexes.length - geometry._lineIndexesHandlerIndex;
                    geometry._lineColorsLength =
                        this._lineColors.length - geometry._lineColorsHandlerIndex;
                    geometry._lineThicknessLength =
                        this._lineThickness.length - geometry._lineThicknessHandlerIndex;
                } else if (geometry._type === GeometryType.MULTIPOLYGON) {
                    let coordinates = geometry._coordinates;
                    let vertices = [],
                        indexes = [];

                    // Creates polygon stroke data
                    geometry._lineVerticesHandlerIndex = this._lineVerticesHighMerc.length;
                    geometry._lineOrdersHandlerIndex = this._lineOrders.length;
                    geometry._lineIndexesHandlerIndex = this._lineIndexes.length;
                    geometry._lineColorsHandlerIndex = this._lineColors.length;
                    geometry._lineThicknessHandlerIndex = this._lineThickness.length;

                    for (var i = 0; i < coordinates.length; i++) {
                        let cci = coordinates[i];
                        let ci = [];
                        for (let j = 0; j < cci.length; j++) {
                            ci[j] = [];
                            for (let k = 0; k < coordinates[i][j].length; k++) {
                                ci[j][k] = [
                                    forward_lon(cci[j][k][0]),
                                    forward_lat(cci[j][k][1])
                                ];
                            }
                        }
                        let data = flatten(ci);
                        let dataIndexes = earcut(data.vertices, data.holes, 2);

                        for (let j = 0; j < dataIndexes.length; j++) {
                            indexes.push(dataIndexes[j] + vertices.length * 0.5);
                        }

                        vertices.push.apply(vertices, data.vertices);

                        GeometryHandler.appendLineData(
                            ci,
                            true,
                            geometry._style.lineColor,
                            pickingColor,
                            geometry._style.lineWidth,
                            geometry._style.strokeColor,
                            geometry._style.strokeWidth,
                            this._lineVerticesHighMerc,
                            this._lineVerticesLowMerc,
                            this._lineOrders,
                            this._lineIndexes,
                            this._lineColors,
                            this._linePickingColors,
                            this._lineThickness,
                            this._lineStrokeColors,
                            this._lineStrokes,
                            geometry._lineVerticesHighMerc,
                            geometry._lineVerticesLowMerc
                        );
                    }

                    geometry._polyVerticesHandlerIndex = this._polyVerticesHighMerc.length;
                    geometry._polyIndexesHandlerIndex = this._polyIndexes.length;

                    for (let i = 0; i < indexes.length; i++) {
                        this._polyIndexes.push(indexes[i] + geometry._polyVerticesHandlerIndex * 0.5);
                    }

                    let color = geometry._style.fillColor;

                    let verticesHigh = [],
                        verticesLow = [];

                    for (let i = 0; i < vertices.length * 0.5; i++) {
                        this._polyColors.push(color.x, color.y, color.z, color.w);
                        this._polyPickingColors.push(
                            pickingColor.x,
                            pickingColor.y,
                            pickingColor.z,
                            1.0
                        );
                    }

                    for (let i = 0; i < vertices.length; i++) {
                        doubleToTwoFloatsV2(vertices[i], tempHighLow);
                        verticesHigh[i] = tempHighLow.x;
                        verticesLow[i] = tempHighLow.y;
                    }

                    geometry._polyVerticesHighMerc = verticesHigh;
                    geometry._polyVerticesLowMerc = verticesLow;

                    this._polyVerticesHighMerc.push.apply(this._polyVerticesHighMerc, verticesHigh);
                    this._polyVerticesLowMerc.push.apply(this._polyVerticesLowMerc, verticesLow);

                    geometry._polyVerticesLength = vertices.length;
                    geometry._polyIndexesLength = indexes.length;

                    geometry._lineVerticesLength =
                        this._lineVerticesHighMerc.length - geometry._lineVerticesHandlerIndex;
                    geometry._lineOrdersLength =
                        this._lineOrders.length - geometry._lineOrdersHandlerIndex;
                    geometry._lineIndexesLength =
                        this._lineIndexes.length - geometry._lineIndexesHandlerIndex;
                    geometry._lineColorsLength =
                        this._lineColors.length - geometry._lineColorsHandlerIndex;
                    geometry._lineThicknessLength =
                        this._lineThickness.length - geometry._lineThicknessHandlerIndex;
                } else if (geometry._type === GeometryType.LINESTRING) {
                    let coordinates = geometry._coordinates;
                    let ci = new Array(coordinates.length);
                    for (let j = 0; j < coordinates.length; j++) {
                        ci[j] = [
                            forward_lon(coordinates[j][0]),
                            forward_lat(coordinates[j][1])
                        ];
                    }

                    // Creates polygon stroke data
                    geometry._lineVerticesHandlerIndex = this._lineVerticesHighMerc.length;
                    geometry._lineOrdersHandlerIndex = this._lineOrders.length;
                    geometry._lineIndexesHandlerIndex = this._lineIndexes.length;
                    geometry._lineColorsHandlerIndex = this._lineColors.length;
                    geometry._lineThicknessHandlerIndex = this._lineThickness.length;

                    GeometryHandler.appendLineData(
                        [ci],
                        false,
                        geometry._style.lineColor,
                        pickingColor,
                        geometry._style.lineWidth,
                        geometry._style.strokeColor,
                        geometry._style.strokeWidth,
                        this._lineVerticesHighMerc,
                        this._lineVerticesLowMerc,
                        this._lineOrders,
                        this._lineIndexes,
                        this._lineColors,
                        this._linePickingColors,
                        this._lineThickness,
                        this._lineStrokeColors,
                        this._lineStrokes,
                        geometry._lineVerticesHighMerc,
                        geometry._lineVerticesLowMerc
                    );

                    geometry._lineVerticesLength =
                        this._lineVerticesHighMerc.length - geometry._lineVerticesHandlerIndex;
                    geometry._lineOrdersLength =
                        this._lineOrders.length - geometry._lineOrdersHandlerIndex;
                    geometry._lineIndexesLength =
                        this._lineIndexes.length - geometry._lineIndexesHandlerIndex;
                    geometry._lineColorsLength =
                        this._lineColors.length - geometry._lineColorsHandlerIndex;
                    geometry._lineThicknessLength =
                        this._lineThickness.length - geometry._lineThicknessHandlerIndex;
                } else if (geometry._type === GeometryType.MULTILINESTRING) {
                    let coordinates = geometry._coordinates;
                    let ci = [];
                    for (let j = 0; j < coordinates.length; j++) {
                        ci[j] = [];
                        for (let k = 0; k < coordinates[j].length; k++) {
                            ci[j][k] = [
                                forward_lon(coordinates[j][k][0]),
                                forward_lat(coordinates[j][k][1])
                            ];
                        }
                    }

                    // Creates polygon stroke data
                    geometry._lineVerticesHandlerIndex = this._lineVerticesHighMerc.length;
                    geometry._lineOrdersHandlerIndex = this._lineOrders.length;
                    geometry._lineIndexesHandlerIndex = this._lineIndexes.length;
                    geometry._lineColorsHandlerIndex = this._lineColors.length;
                    geometry._lineThicknessHandlerIndex = this._lineThickness.length;

                    GeometryHandler.appendLineData(
                        ci,
                        false,
                        geometry._style.lineColor,
                        pickingColor,
                        geometry._style.lineWidth,
                        geometry._style.strokeColor,
                        geometry._style.strokeWidth,
                        this._lineVerticesHighMerc,
                        this._lineVerticesLowMerc,
                        this._lineOrders,
                        this._lineIndexes,
                        this._lineColors,
                        this._linePickingColors,
                        this._lineThickness,
                        this._lineStrokeColors,
                        this._lineStrokes,
                        geometry._lineVerticesHighMerc,
                        geometry._lineVerticesLowMerc
                    );

                    geometry._lineVerticesLength =
                        this._lineVerticesHighMerc.length - geometry._lineVerticesHandlerIndex;
                    geometry._lineOrdersLength =
                        this._lineOrders.length - geometry._lineOrdersHandlerIndex;
                    geometry._lineIndexesLength =
                        this._lineIndexes.length - geometry._lineIndexesHandlerIndex;
                    geometry._lineColorsLength =
                        this._lineColors.length - geometry._lineColorsHandlerIndex;
                    geometry._lineThicknessLength =
                        this._lineThickness.length - geometry._lineThicknessHandlerIndex;
                }

                // Refresh visibility
                this.setGeometryVisibility(geometry);

                !this._updatedGeometry[geometry._id] && this._updatedGeometryArr.push(geometry);
                this._updatedGeometry[geometry._id] = true;
                this.refresh();
            }
        }

        remove(geometry) {
            var index = geometry._handlerIndex;
            if (index !== -1) {
                this._geometries.splice(index, 1);

                // polygon
                // this._polyVerticesLonLat.splice(geometry._polyVerticesHandlerIndex, geometry._polyVerticesLength);
                this._polyVerticesHighMerc.splice(
                    geometry._polyVerticesHandlerIndex,
                    geometry._polyVerticesLength
                );
                this._polyVerticesLowMerc.splice(
                    geometry._polyVerticesHandlerIndex,
                    geometry._polyVerticesLength
                );

                this._polyColors.splice(
                    geometry._polyVerticesHandlerIndex * 2,
                    geometry._polyVerticesLength * 2
                );
                this._polyPickingColors.splice(
                    geometry._polyVerticesHandlerIndex * 2,
                    geometry._polyVerticesLength * 2
                );
                this._polyIndexes.splice(
                    geometry._polyIndexesHandlerIndex,
                    geometry._polyIndexesLength
                );
                var di = geometry._polyVerticesLength * 0.5;
                for (var i = geometry._polyIndexesHandlerIndex; i < this._polyIndexes.length; i++) {
                    this._polyIndexes[i] -= di;
                }

                // line
                // this._lineVerticesLonLat.splice(geometry._lineVerticesHandlerIndex, geometry._lineVerticesLength);
                this._lineVerticesHighMerc.splice(
                    geometry._lineVerticesHandlerIndex,
                    geometry._lineVerticesLength
                );
                this._lineVerticesLowMerc.splice(
                    geometry._lineVerticesHandlerIndex,
                    geometry._lineVerticesLength
                );
                this._lineOrders.splice(geometry._lineOrdersHandlerIndex, geometry._lineOrdersLength);
                this._lineColors.splice(geometry._lineColorsHandlerIndex, geometry._lineColorsLength);
                this._linePickingColors.splice(
                    geometry._lineColorsHandlerIndex,
                    geometry._lineColorsLength
                );
                this._lineStrokeColors.splice(
                    geometry._lineColorsHandlerIndex,
                    geometry._lineColorsLength
                );
                this._lineThickness.splice(
                    geometry._lineThicknessHandlerIndex,
                    geometry._lineThicknessLength
                );
                this._lineStrokes.splice(
                    geometry._lineThicknessHandlerIndex,
                    geometry._lineThicknessLength
                );
                this._lineIndexes.splice(
                    geometry._lineIndexesHandlerIndex,
                    geometry._lineIndexesLength
                );
                di = geometry._lineVerticesLength * 0.5;
                for (let i = geometry._lineIndexesHandlerIndex; i < this._lineIndexes.length; i++) {
                    this._lineIndexes[i] -= di;
                }

                // reindex
                var g = this._geometries;
                for (let i = index; i < g.length; i++) {
                    var gi = g[i];
                    gi._handlerIndex = i;
                    gi._polyVerticesHandlerIndex -= geometry._polyVerticesLength;
                    gi._polyIndexesHandlerIndex -= geometry._polyIndexesLength;

                    gi._lineVerticesHandlerIndex -= geometry._lineVerticesLength;
                    gi._lineOrdersHandlerIndex -= geometry._lineOrdersLength;
                    gi._lineColorsHandlerIndex -= geometry._lineColorsLength;
                    gi._lineThicknessHandlerIndex -= geometry._lineThicknessLength;
                    gi._lineIndexesHandlerIndex -= geometry._lineIndexesLength;
                }

                geometry._pickingReady = false;

                geometry._handler = null;
                geometry._handlerIndex = -1;

                geometry._polyVerticesHighMerc = [];
                geometry._polyVerticesLowMerc = [];
                geometry._polyVerticesLength = -1;
                geometry._polyIndexesLength = -1;
                geometry._polyVerticesHandlerIndex = -1;
                geometry._polyIndexesHandlerIndex = -1;

                geometry._lineVerticesHighMerc = [];
                geometry._lineVerticesLowMerc = [];
                geometry._lineVerticesLength = -1;
                geometry._lineOrdersLength = -1;
                geometry._lineIndexesLength = -1;
                geometry._lineColorsLength = -1;
                geometry._lineThicknessLength = -1;
                geometry._lineVerticesHandlerIndex = -1;
                geometry._lineOrdersHandlerIndex = -1;
                geometry._lineIndexesHandlerIndex = -1;
                geometry._lineThicknessHandlerIndex = -1;
                geometry._lineColorsHandlerIndex = -1;

                !this._removeGeometryExtents[geometry._id] &&
                    this._removeGeometryExtentArr.push(geometry.getExtent());
                this._removeGeometryExtents[geometry._id] = true;

                this.refresh();
            }
        }

        _refreshRecursevely(geometry, treeNode) {
            if (treeNode.ready) {
                var lid = this._layer._id;
                for (var i = 0; i < treeNode.nodes.length; i++) {
                    var ni = treeNode.nodes[i];
                    if (geometry._extent.overlaps(ni.segment.getExtentLonLat())) {
                        this._refreshRecursevely(geometry, ni);
                        var m = ni.segment.materials[lid];
                        if (m && m.isReady) {
                            if (m.segment.node.getState() !== RENDERING) {
                                m.layer.clearMaterial(m);
                            } else {
                                m.pickingReady = m.pickingReady && geometry._pickingReady;
                                m.isReady = false;
                                m._updateTexture = m.texture;
                                m._updatePickingMask = m.pickingMask;
                            }
                            geometry._pickingReady = true;
                        }
                    }
                }
            }
        }

        _refreshRecursevelyExt(extent, treeNode) {
            if (treeNode.ready) {
                var lid = this._layer._id;
                for (var i = 0; i < treeNode.nodes.length; i++) {
                    var ni = treeNode.nodes[i];
                    if (extent.overlaps(ni.segment.getExtentLonLat())) {
                        this._refreshRecursevelyExt(extent, ni);
                        var m = ni.segment.materials[lid];
                        if (m && m.isReady) {
                            m.layer.clearMaterial(m);
                            // m.pickingReady = false;
                            // m.isReady = false;
                            // m._updateTexture = m.texture;
                            // m._updatePickingMask = m.pickingMask;
                        }
                    }
                }
            }
        }

        _refreshPlanetNode(treeNode) {
            var i = 0;

            var e = this._removeGeometryExtentArr;
            for (i = 0; i < e.length; i++) {
                this._refreshRecursevelyExt(e[i], treeNode);
            }

            var g = this._updatedGeometryArr;
            for (i = 0; i < g.length; i++) {
                this._refreshRecursevely(g[i], treeNode);
            }
        }

        _updatePlanet() {
            var p = this._layer._planet;
            if (p) {
                this._refreshPlanetNode(p._quadTree);
                this._refreshPlanetNode(p._quadTreeNorth);
                this._refreshPlanetNode(p._quadTreeSouth);
            }
            this._updatedGeometryArr.length = 0;
            this._updatedGeometryArr = [];
            this._updatedGeometry = {};

            this._removeGeometryExtentArr.length = 0;
            this._removeGeometryExtentArr = [];
            this._removeGeometryExtents = {};
        }

        refresh() {
            var i = this._changedBuffers.length;
            while (i--) {
                this._changedBuffers[i] = true;
            }
        }

        update() {
            if (this._handler) {
                var needUpdate = false;
                var i = this._changedBuffers.length;
                while (i--) {
                    if (this._changedBuffers[i]) {
                        needUpdate = true;
                        this._buffersUpdateCallbacks[i].call(this);
                        this._changedBuffers[i] = false;
                    }
                }
                needUpdate && this._updatePlanet();
            }
        }

        setGeometryVisibility(geometry) {
            var v = geometry._visibility ? 1.0 : 0.0;

            var a = this._polyVerticesHighMerc,
                b = this._polyVerticesLowMerc;

            var l = geometry._polyVerticesLength;
            var ind = geometry._polyVerticesHandlerIndex;
            for (var i = 0; i < l; i++) {
                a[ind + i] = geometry._polyVerticesHighMerc[i] * v;
                b[ind + i] = geometry._polyVerticesLowMerc[i] * v;
            }

            a = this._lineVerticesHighMerc;
            b = this._lineVerticesLowMerc;
            l = geometry._lineVerticesLength;
            ind = geometry._lineVerticesHandlerIndex;
            for (i = 0; i < l; i++) {
                a[ind + i] = geometry._lineVerticesHighMerc[i] * v;
                b[ind + i] = geometry._lineVerticesLowMerc[i] * v;
            }

            this._changedBuffers[POLYVERTICES_BUFFER] = true;
            this._changedBuffers[LINEVERTICES_BUFFER] = true;

            !this._updatedGeometry[geometry._id] && this._updatedGeometryArr.push(geometry);
            this._updatedGeometry[geometry._id] = true;
        }

        setPolyColorArr(geometry, color) {
            var index = geometry._polyVerticesHandlerIndex * 2, // ... / 2 * 4
                size = index + geometry._polyVerticesLength * 2; // ... / 2 * 4
            var a = this._polyColors;
            for (var i = index; i < size; i += 4) {
                a[i] = color.x;
                a[i + 1] = color.y;
                a[i + 2] = color.z;
                a[i + 3] = color.w;
            }
            this._changedBuffers[POLYCOLORS_BUFFER] = true;
            !this._updatedGeometry[geometry._id] && this._updatedGeometryArr.push(geometry);
            this._updatedGeometry[geometry._id] = true;
        }

        setLineStrokeColorArr(geometry, color) {
            var index = geometry._lineColorsHandlerIndex,
                size = index + geometry._lineColorsLength;
            var a = this._lineStrokeColors;
            for (var i = index; i < size; i += 4) {
                a[i] = color.x;
                a[i + 1] = color.y;
                a[i + 2] = color.z;
                a[i + 3] = color.w;
            }
            this._changedBuffers[LINESTROKECOLORS_BUFFER] = true;
            !this._updatedGeometry[geometry._id] && this._updatedGeometryArr.push(geometry);
            this._updatedGeometry[geometry._id] = true;
        }

        setLineColorArr(geometry, color) {
            var index = geometry._lineColorsHandlerIndex,
                size = index + geometry._lineColorsLength;
            var a = this._lineColors;
            for (var i = index; i < size; i += 4) {
                a[i] = color.x;
                a[i + 1] = color.y;
                a[i + 2] = color.z;
                a[i + 3] = color.w;
            }
            this._changedBuffers[LINECOLORS_BUFFER] = true;
            !this._updatedGeometry[geometry._id] && this._updatedGeometryArr.push(geometry);
            this._updatedGeometry[geometry._id] = true;
        }

        setLineStrokeArr(geometry, width) {
            var index = geometry._lineStrokesHandlerIndex,
                size = index + geometry._lineStrokesLength;
            var a = this._lineStrokes;
            for (var i = index; i < size; i++) {
                a[i] = width;
            }
            this._changedBuffers[LINESTROKES_BUFFER] = true;
            !this._updatedGeometry[geometry._id] && this._updatedGeometryArr.push(geometry);
            this._updatedGeometry[geometry._id] = true;
        }

        setLineThicknessArr(geometry, width) {
            var index = geometry._lineThicknessHandlerIndex,
                size = index + geometry._lineThicknessLength;
            var a = this._lineThickness;
            for (var i = index; i < size; i++) {
                a[i] = width;
            }
            this._changedBuffers[LINETHICKNESS_BUFFER] = true;
            !this._updatedGeometry[geometry._id] && this._updatedGeometryArr.push(geometry);
            this._updatedGeometry[geometry._id] = true;
        }

        bringToFront(geometry) {
            var polyIndexes = this._polyIndexes.splice(
                geometry._polyIndexesHandlerIndex,
                geometry._polyIndexesLength
            );
            var lineIndexes = this._lineIndexes.splice(
                geometry._lineIndexesHandlerIndex,
                geometry._lineIndexesLength
            );

            this._geometries.splice(geometry._handlerIndex, 1);

            var g = this._geometries;
            for (var i = geometry._handlerIndex; i < g.length; i++) {
                var gi = g[i];
                gi._handlerIndex = i;
                gi._polyIndexesHandlerIndex -= geometry._polyIndexesLength;
                gi._lineIndexesHandlerIndex -= geometry._lineIndexesLength;
            }

            geometry._polyIndexesHandlerIndex = this._polyIndexes.length;
            geometry._lineIndexesHandlerIndex = this._lineIndexes.length;

            geometry._handlerIndex = this._geometries.length;
            this._geometries.push(geometry);

            this._polyIndexes.push.apply(this._polyIndexes, polyIndexes);
            this._lineIndexes.push.apply(this._lineIndexes, lineIndexes);

            this._changedBuffers[POLYINDEXES_BUFFER] = true;
            this._changedBuffers[LINEINDEXES_BUFFER] = true;

            !this._updatedGeometry[geometry._id] && this._updatedGeometryArr.push(geometry);
            this._updatedGeometry[geometry._id] = true;
        }

        createPolyVerticesBuffer() {
            var h = this._handler;
            h.gl.deleteBuffer(this._polyVerticesHighBufferMerc);
            this._polyVerticesHighBufferMerc = h.createArrayBuffer(
                new Float32Array(this._polyVerticesHighMerc),
                2,
                this._polyVerticesHighMerc.length / 2
            );

            h.gl.deleteBuffer(this._polyVerticesLowBufferMerc);
            this._polyVerticesLowBufferMerc = h.createArrayBuffer(
                new Float32Array(this._polyVerticesLowMerc),
                2,
                this._polyVerticesLowMerc.length / 2
            );
        }

        createPolyIndexesBuffer() {
            var h = this._handler;
            h.gl.deleteBuffer(this._polyIndexesBuffer);
            this._polyIndexesBuffer = h.createElementArrayBuffer(
                new Uint32Array(this._polyIndexes),
                1,
                this._polyIndexes.length
            );
        }

        createPolyColorsBuffer() {
            var h = this._handler;
            h.gl.deleteBuffer(this._polyColorsBuffer);
            this._polyColorsBuffer = h.createArrayBuffer(
                new Float32Array(this._polyColors),
                4,
                this._polyColors.length / 4
            );
        }

        createPolyPickingColorsBuffer() {
            var h = this._handler;
            h.gl.deleteBuffer(this._polyPickingColorsBuffer);
            this._polyPickingColorsBuffer = h.createArrayBuffer(
                new Float32Array(this._polyPickingColors),
                4,
                this._polyPickingColors.length / 4
            );
        }

        createLineVerticesBuffer() {
            var h = this._handler;
            h.gl.deleteBuffer(this._lineVerticesHighBufferMerc);
            this._lineVerticesHighBufferMerc = h.createArrayBuffer(
                new Float32Array(this._lineVerticesHighMerc),
                2,
                this._lineVerticesHighMerc.length / 2
            );

            h.gl.deleteBuffer(this._lineVerticesLowBufferMerc);
            this._lineVerticesLowBufferMerc = h.createArrayBuffer(
                new Float32Array(this._lineVerticesLowMerc),
                2,
                this._lineVerticesLowMerc.length / 2
            );
        }

        createLineIndexesBuffer() {
            var h = this._handler;
            h.gl.deleteBuffer(this._lineIndexesBuffer);
            this._lineIndexesBuffer = h.createElementArrayBuffer(
                new Uint32Array(this._lineIndexes),
                1,
                this._lineIndexes.length
            );
        }

        createLineOrdersBuffer() {
            var h = this._handler;
            h.gl.deleteBuffer(this._lineOrdersBuffer);
            this._lineOrdersBuffer = h.createArrayBuffer(
                new Float32Array(this._lineOrders),
                1,
                this._lineOrders.length / 2
            );
        }

        createLineColorsBuffer() {
            var h = this._handler;
            h.gl.deleteBuffer(this._lineColorsBuffer);
            this._lineColorsBuffer = h.createArrayBuffer(
                new Float32Array(this._lineColors),
                4,
                this._lineColors.length / 4
            );
        }

        createLinePickingColorsBuffer() {
            var h = this._handler;
            h.gl.deleteBuffer(this._linePickingColorsBuffer);
            this._linePickingColorsBuffer = h.createArrayBuffer(
                new Float32Array(this._linePickingColors),
                4,
                this._linePickingColors.length / 4
            );
        }

        createLineThicknessBuffer() {
            var h = this._handler;
            h.gl.deleteBuffer(this._lineThicknessBuffer);
            this._lineThicknessBuffer = h.createArrayBuffer(
                new Float32Array(this._lineThickness),
                1,
                this._lineThickness.length
            );
        }

        createLineStrokesBuffer() {
            var h = this._handler;
            h.gl.deleteBuffer(this._lineStrokesBuffer);
            this._lineStrokesBuffer = h.createArrayBuffer(
                new Float32Array(this._lineStrokes),
                1,
                this._lineStrokes.length
            );
        }

        createLineStrokeColorsBuffer() {
            var h = this._handler;
            h.gl.deleteBuffer(this._lineStrokeColorsBuffer);
            this._lineStrokeColorsBuffer = h.createArrayBuffer(
                new Float32Array(this._lineStrokeColors),
                4,
                this._lineStrokeColors.length / 4
            );
        }
    }

    class QueueArray {
        /**
         *
         * @param {number} [size]
         */
        constructor(size = 2048) {
            this._size = size;
            this._array = new Array(this._size);
            this._popIndex = parseInt(this._size * 0.5);
            this._shiftIndex = this._popIndex;
            this.length = 0;
        }

        reset() {
            this._popIndex = parseInt(this._size * 0.5);
            this._shiftIndex = this._popIndex;
            this.length = 0;
        }

        clear() {
            this._array.length = 0;
            this._array = new Array(this._size);
            this._popIndex = parseInt(this._size * 0.5);
            this._shiftIndex = this._popIndex;
            this.length = 0;
        }

        push(data) {
            this.length++;
            this._array[this._popIndex++] = data;
        }

        pop() {
            if (this.length) {
                this.length--;
                var res = this._array[--this._popIndex];
                this._array[this._popIndex] = null;
                if (!this._array[this._popIndex - 1]) {
                    this._popIndex = parseInt(this._size * 0.5);
                    this._shiftIndex = this._popIndex;
                }
                return res;
            }
            return undefined;
        }

        unshift(data) {
            this.length++;
            this._array[--this._shiftIndex] = data;
        }

        shift() {
            if (this.length) {
                this.length--;
                var res = this._array[this._shiftIndex];
                this._array[this._shiftIndex++] = null;
                if (!this._array[this._shiftIndex]) {
                    this._popIndex = parseInt(this._size * 0.5);
                    this._shiftIndex = this._popIndex;
                }
                return res;
            }
            return undefined;
        }

        each(callback) {
            for (var i = this._shiftIndex; i < this._popIndex; i++) {
                callback(this._array[i]);
            }
        }
    }

    /**
     * @module og/layer/Vector
     */

    /**
     * Creates entity instance array.
     * @param {Entity[]} entities - Entity array.
     * @returns {Entity[]} - Entity array.
     */
    function _entitiesConstructor(entities) {
        var res = [];
        for (var i = 0; i < entities.length; i++) {
            var ei = entities[i];
            if (ei.instanceName === "Entity") {
                res.push(ei);
            } else {
                res.push(new Entity$1(ei));
            }
        }
        return res;
    }

    /**
     * Vector layer represents alternative entities store. Used for geospatial data rendering like
     * points, lines, polygons, geometry objects etc.
     * @class
     * @extends {Layer}
     * @param {string} [name="noname"] - Layer name.
     * @param {Object} [options] - Layer options:
     * @param {number} [options.minZoom=0] - Minimal visible zoom. 0 is default
     * @param {number} [options.maxZoom=50] - Maximal visible zoom. 50 is default.
     * @param {string} [options.attribution] - Layer attribution.
     * @param {string} [options.zIndex=0] - Layer Z-order index. 0 is default.
     * @param {boolean} [options.visibility=true] - Layer visibility. True is default.
     * @param {boolean} [options.isBaseLayer=false] - Layer base layer. False is default.
     * @param {Array.<Entity>} [options.entities] - Entities array.
     * @param {Array.<number>} [options.scaleByDistance] - Scale by distance parameters. (exactly 3 entries)
     *      First index - near distance to the entity, after entity becomes full scale.
     *      Second index - far distance to the entity, when entity becomes zero scale.
     *      Third index - far distance to the entity, when entity becomes invisible.
     * @param {number} [options.nodeCapacity=30] - Maximum entities quantity in the tree node. Rendering optimization parameter. 30 is default.
     * @param {boolean} [options.async=true] - Asynchronous vector data handling before rendering. True for optimization huge data.
     * @param {boolean} [options.clampToGround = false] - Clamp vector data to the ground.
     * @param {boolean} [options.relativeToGround = false] - Place vector data relative to the ground relief.
     * @param {Number} [options.polygonOffsetUnits=0.0] - The multiplier by which an implementation-specific value is multiplied with to create a constant depth offset.
     *
     * @fires og.layer.Vector#entitymove
     * @fires og.layer.Vector#draw
     * @fires og.layer.Vector#add
     * @fires og.layer.Vector#remove
     * @fires og.layer.Vector#entityadd
     * @fires og.layer.Vector#entityremove
     * @fires og.layer.Vector#visibilitychange
     */
    class Vector extends Layer$1 {
        /**
         * @param {string} name
         * @param {*} [options]
         */
        constructor(name, options = {}) {
            super(name, options);

            this.events.registerNames(EVENT_NAMES$5);

            this.isVector = true;

            this._hasImageryTiles = false;

            /**
             * First index - near distance to the entity, after that entity becomes full scale.
             * Second index - far distance to the entity, when entity becomes zero scale.
             * Third index - far distance to the entity, when entity becomes invisible.
             * @public
             * @type {Array.<number>} - (exactly 3 entries)
             */
            this.scaleByDistance = options.scaleByDistance || [MAX32, MAX32, MAX32];

            this.pickingScale = options.pickingScale || 1;

            /**
             * Asynchronous data handling before rendering.
             * @public
             * @type {boolean}
             */
            this.async = options.async !== undefined ? options.async : true;

            /**
             * Vector data clamp to ground flag.
             * @public
             * @type {boolean}
             */
            this.clampToGround = options.clampToGround || false;

            /**
             * Sets vector data relative to the ground relief.
             * @public
             * @type {boolean}
             */
            this.relativeToGround = options.relativeToGround || false;

            /**
             * Maximum entities quantity in the tree node.
             * @private
             */
            this._nodeCapacity = options.nodeCapacity || 30;

            /**
             * Stored entities.
             * @private
             */
            this._entities = _entitiesConstructor(options.entities || []);

            this._stripEntityCollection = new EntityCollection$1({
                pickingEnabled: this.pickingEnabled
            });
            this._bindEventsDefault(this._stripEntityCollection);

            this._polylineEntityCollection = new EntityCollection$1({
                pickingEnabled: this.pickingEnabled
            });
            this._bindEventsDefault(this._polylineEntityCollection);

            this._geometryHandler = new GeometryHandler(this);

            this._entityCollectionsTree = null;
            this._entityCollectionsTreeNorth = null;
            this._entityCollectionsTreeSouth = null;

            this._renderingNodes = {};
            this._renderingNodesNorth = {};
            this._renderingNodesSouth = {};

            this._counter = 0;
            this._deferredEntitiesPendingQueue = new QueueArray();

            this._pendingsQueue = [];

            // Creates collections tree
            this.setEntities(this._entities);

            /**
             * Specifies the scale Units for gl.polygonOffset function to calculate depth values, 0.0 is default.
             * @public
             * @type {Number}
             */
            this.polygonOffsetUnits =
                options.polygonOffsetUnits != undefined ? options.polygonOffsetUnits : 0.0;

            this.pickingEnabled = this._pickingEnabled;
        }

        get instanceName() {
            return "Vector";
        }

        _bindPicking() {
            this._pickingColor.clear();
        }

        /**
         * Adds layer to the planet.
         * @public
         * @param {Planet} planet - Planet scene object.
         * @returns {layer.Vector} -
         */
        addTo(planet) {
            if (!this._planet) {
                this._assignPlanet(planet);
                this._geometryHandler.assignHandler(planet.renderer.handler);
                this._polylineEntityCollection.addTo(planet, true);
                this._stripEntityCollection.addTo(planet, true);
                this.setEntities(this._entities);
            }
            return this;
        }

        /**
         * Returns stored entities.
         * @public
         * @returns {Array.<Entity>} -
         */
        getEntities() {
            return [].concat(this._entities);
        }

        //_fitExtent(entity) {
        //    var ee = entity.getExtent(),
        //        e = this._extent,
        //        maxLon = -180, maxLat = -90,
        //        minLon = 180, minLat = 90;

        //    if (this._entities.length !== 0) {
        //        maxLon = e.southWest.lon;
        //        minLon = e.northEast.lon;
        //        maxLat = e.northEast.lat;
        //        minLat = e.southWest.lat;
        //    }

        //    if (ee.southWest.lon < minLon) {
        //        e.southWest.lon = ee.southWest.lon;
        //    }
        //    if (ee.southWest.lat < minLat) {
        //        e.southWest.lat = ee.southWest.lat;
        //    }
        //    if (ee.northEast.lon > maxLon) {
        //        e.northEast.lon = ee.northEast.lon;
        //    }
        //    if (ee.northEast.lat > maxLat) {
        //        e.northEast.lat = ee.northEast.lat;
        //    }
        //    this.setExtent(this._extent);
        //}

        /**
         * Adds entity to the layer.
         * @public
         * @param {Entity} entity - Entity.
         * @param {boolean} [rightNow] - Entity insertion option. False is deafult.
         * @returns {layer.Vector} - Returns this layer.
         */
        add(entity, rightNow) {
            if (!(entity._layer || entity._entityCollection)) {
                entity._layer = this;
                entity._layerIndex = this._entities.length;
                //this._fitExtent(entity);
                this._entities.push(entity);
                this._proceedEntity(entity, rightNow);
            }
            return this;
        }

        /**
         * Adds entity to the layer in the index position.
         * @public
         * @param {Entity} entity - Entity.
         * @param {Number} index - Index position.
         * @param {boolean} [rightNow] - Entity insertion option. False is deafult.
         * @returns {layer.Vector} - Returns this layer.
         */
        insert(entity, index, rightNow) {
            if (!(entity._layer || entity._entityCollection)) {
                entity._layer = this;
                entity._layerIndex = index;
                //this._fitExtent(entity);
                this._entities.splice(index, 0, entity);
                for (let i = index + 1, len = this._entities.length; i < len; i++) {
                    this._entities[i]._layerIndex = i;
                }

                this._proceedEntity(entity, rightNow);
            }

            return this;
        }

        _proceedEntity(entity, rightNow) {
            let temp = this._hasImageryTiles;

            //
            // ...pointCloud, shape, model etc.
            //

            if (entity.strip) {
                this._stripEntityCollection.add(entity);
            }

            if (entity.polyline || entity.ray) {
                this._polylineEntityCollection.add(entity);
            }

            if (entity.geometry) {
                this._hasImageryTiles = true;
                if (this._planet) {
                    this._planet.renderer.assignPickingColor(entity);
                    this._geometryHandler.add(entity.geometry);
                }
            }

            if (entity.billboard || entity.label) {
                if (this._planet) {
                    if (entity._cartesian.isZero() && !entity._lonlat.isZero()) {
                        entity._setCartesian3vSilent(
                            this._planet.ellipsoid.lonLatToCartesian(entity._lonlat)
                        );
                    } else {
                        entity._lonlat = this._planet.ellipsoid.cartesianToLonLat(entity._cartesian);
                    }

                    // north tree
                    if (entity._lonlat.lat > MAX_LAT) {
                        this._entityCollectionsTreeNorth.__setLonLat__(entity);
                        this._entityCollectionsTreeNorth.insertEntity(entity, rightNow);
                    } else if (entity._lonlat.lat < MIN_LAT) {
                        // south tree
                        this._entityCollectionsTreeSouth.__setLonLat__(entity);
                        this._entityCollectionsTreeSouth.insertEntity(entity, rightNow);
                    } else {
                        this._entityCollectionsTree.__setLonLat__(entity);
                        this._entityCollectionsTree.insertEntity(entity, rightNow);
                    }
                }
            }

            if (this._planet && this._hasImageryTiles !== temp) {
                this._planet.updateVisibleLayers();
            }

            this.events.dispatch(this.events.entityadd, entity);
        }

        /**
         * Adds entity array to the layer.
         * @public
         * @param {Array.<Entity>} entities - Entities array.
         * @param {boolean} [rightNow] - Entity insertion option. False is deafult.
         * @returns {layer.Vector} - Returns this layer.
         */
        addEntities(entities, rightNow) {
            var i = entities.length;
            while (i--) {
                this.add(entities[i], rightNow);
            }
            return this;
        }

        /**
         * Remove entity from layer.
         * TODO: memory leaks.
         * @public
         * @param {Entity} entity - Entity to remove.
         * @returns {layer.Vector} - Returns this layer.
         */
        removeEntity(entity) {
            if (entity._layer && this.isEqual(entity._layer)) {
                this._entities.splice(entity._layerIndex, 1);
                this._reindexEntitiesArray(entity._layerIndex);
                entity._layer = null;
                entity._layerIndex = -1;

                if (entity._entityCollection) {
                    entity._entityCollection._removeEntitySilent(entity);
                    let node = entity._nodePtr;
                    while (node) {
                        node.count--;
                        node = node.parentNode;
                    }
                    if (
                        entity._nodePtr &&
                        entity._nodePtr.count === 0 &&
                        entity._nodePtr.deferredEntities.length === 0
                    ) {
                        entity._nodePtr.entityCollection = null;
                        //
                        // ...
                        //
                    }
                } else if (entity._nodePtr && entity._nodePtr.deferredEntities.length) {
                    var defEntities = entity._nodePtr.deferredEntities;
                    var j = defEntities.length;
                    while (j--) {
                        if (defEntities[j].id === entity.id) {
                            defEntities.splice(j, 1);
                            let node = entity._nodePtr;
                            while (node) {
                                node.count--;
                                node = node.parentNode;
                            }
                            break;
                        }
                    }
                }

                if (entity.geometry) {
                    if (this._planet) {
                        this._geometryHandler.remove(entity.geometry);
                        this._planet.renderer.clearPickingColor(entity);
                    }
                }

                entity._nodePtr && (entity._nodePtr = null);
                this.events.dispatch(this.events.entityremove, entity);
            }
            return this;
        }

        /**
         * Set layer picking events active.
         * @public
         * @param {boolean} picking - Picking enable flag.
         */
        set pickingEnabled(picking) {
            this._pickingEnabled = picking;

            this._stripEntityCollection.setPickingEnabled(picking);

            this._polylineEntityCollection.setPickingEnabled(picking);

            this._entityCollectionsTree &&
                this._entityCollectionsTree.traverseTree(function (node) {
                    node.entityCollection.setPickingEnabled(picking);
                });

            this._entityCollectionsTreeNorth &&
                this._entityCollectionsTreeNorth.traverseTree(function (node) {
                    node.entityCollection.setPickingEnabled(picking);
                });

            this._entityCollectionsTreeSouth &&
                this._entityCollectionsTreeSouth.traverseTree(function (node) {
                    node.entityCollection.setPickingEnabled(picking);
                });
        }

        /**
         * Refresh collected entities indexes from startIndex entitytes collection array position.
         * @public
         * @param {number} startIndex - Entity array index.
         */
        _reindexEntitiesArray(startIndex) {
            var e = this._entities;
            for (var i = startIndex; i < e.length; i++) {
                e[i]._layerIndex = i;
            }
        }

        /**
         * Removes entities from layer.
         * @public
         * @param {Array.<Entity>} entities - Entity array.
         * @returns {layer.Vector} - Returns this layer.
         */
        removeEntities(entities) {
            var i = entities.length;
            while (i--) {
                this.removeEntity(entities[i]);
            }
            return this;
        }

        /**
         * Sets scale by distance parameters.
         * @public
         * @param {number} near - Full scale entity distance.
         * @param {number} far - Zerol scale entity distance.
         * @param {number} [farInvisible] - Entity visibility distance.
         * @returns {layer.Vector} -
         */
        setScaleByDistance(near, far, farInvisible) {
            this.scaleByDistance[0] = near;
            this.scaleByDistance[1] = far;
            this.scaleByDistance[2] = farInvisible || MAX32;
            return this;
        }

        /**
         * TODO: Clear the layer.
         * @public
         */
        clear() {
            let temp = new Array(this._entities.length);

            for (let i = 0; i < temp.length; i++) {
                temp[i] = this._entities[i];
            }

            let i = this._entities.length;
            while (i--) {
                this._entities[i].remove();
            }

            this._entities.length = 0;
            this._entities = [];
            for (let i = 0; i < temp.length; i++) {
                this._entities[i] = temp[i];
            }

            this._entityCollectionsTree = null;
            this._entityCollectionsTreeNorth = null;
            this._entityCollectionsTreeSouth = null;
        }

        /**
         * Safety entities loop.
         * @public
         * @param {callback} callback - Entity callback.
         */
        each(callback) {
            var e = this._entities;
            var i = e.length;
            while (i--) {
                callback(e[i], i);
            }
        }

        /**
         * Removes current entities from layer and adds new entities.
         * @public
         * @param {Array.<Entity>} entities - New entity array.
         * @returns {layer.Vector} - Returns layer instance.
         */
        setEntities(entities) {
            let temp = new Array(entities.length);
            for (let i = 0, len = entities.length; i < len; i++) {
                temp[i] = entities[i];
            }

            this.clear();

            //var e = this._extent;

            this._entities = new Array(temp.length);

            var entitiesForTree = [];

            for (var i = 0; i < temp.length; i++) {
                var ei = temp[i];

                ei._layer = this;
                ei._layerIndex = i;

                if (ei.strip) {
                    this._stripEntityCollection.add(ei);
                } else if (ei.polyline || ei.ray) {
                    this._polylineEntityCollection.add(ei);
                } else if (ei.billboard || ei.label || ei.shape) {
                    entitiesForTree.push(ei);
                }

                if (ei.geometry) {
                    this._hasImageryTiles = true;
                    if (this._planet) {
                        this._planet.renderer.assignPickingColor(ei);
                        this._geometryHandler.add(ei.geometry);
                    }
                }

                this._entities[i] = ei;

                //var ext = ei.getExtent();
                //if (ext.northEast.lon > e.northEast.lon) e.northEast.lon = ext.northEast.lon;
                //if (ext.northEast.lat > e.northEast.lat) e.northEast.lat = ext.northEast.lat;
                //if (ext.southWest.lon < e.southWest.lon) e.southWest.lon = ext.southWest.lon;
                //if (ext.southWest.lat < e.southWest.lat) e.southWest.lat = ext.southWest.lat;
            }

            this._createEntityCollectionsTree(entitiesForTree);

            return this;
        }

        _createEntityCollectionsTree(entitiesForTree) {
            if (this._planet) {
                this._entityCollectionsTree = new EntityCollectionNode(
                    this,
                    NW,
                    null,
                    0,
                    Extent.createFromArray([-20037508.34, -20037508.34, 20037508.34, 20037508.34]),
                    this._planet,
                    0
                );
                this._entityCollectionsTreeNorth = new EntityCollectionNodeWGS84(
                    this,
                    NW,
                    null,
                    0,
                    Extent.createFromArray([-180, MAX_LAT, 180, 90]),
                    this._planet,
                    0
                );
                this._entityCollectionsTreeSouth = new EntityCollectionNodeWGS84(
                    this,
                    NW,
                    null,
                    0,
                    Extent.createFromArray([-180, -90, 180, MIN_LAT]),
                    this._planet,
                    0
                );

                for (let i = 0, len = entitiesForTree.length; i < len; i++) {
                    let entity = entitiesForTree[i];
                    // north tree
                    if (entity._lonlat.lat > MAX_LAT) {
                        this._entityCollectionsTreeNorth.__setLonLat__(entity);
                    } else if (entity._lonlat.lat < MIN_LAT) {
                        // south tree
                        this._entityCollectionsTreeSouth.__setLonLat__(entity);
                    } else {
                        this._entityCollectionsTree.__setLonLat__(entity);
                    }
                }

                this._entityCollectionsTree.buildTree(entitiesForTree);
                this._entityCollectionsTreeNorth.buildTree(entitiesForTree);
                this._entityCollectionsTreeSouth.buildTree(entitiesForTree);
            }
        }

        _bindEventsDefault(entityCollection) {
            var ve = this.events;
            entityCollection.events.on("entitymove", function (e) {
                ve.dispatch(ve.entitymove, e);
            });
            entityCollection.events.on("mousemove", function (e) {
                ve.dispatch(ve.mousemove, e);
            });
            entityCollection.events.on("mouseenter", function (e) {
                ve.dispatch(ve.mouseenter, e);
            });
            entityCollection.events.on("mouseleave", function (e) {
                ve.dispatch(ve.mouseleave, e);
            });
            entityCollection.events.on("lclick", function (e) {
                ve.dispatch(ve.lclick, e);
            });
            entityCollection.events.on("rclick", function (e) {
                ve.dispatch(ve.rclick, e);
            });
            entityCollection.events.on("mclick", function (e) {
                ve.dispatch(ve.mclick, e);
            });
            entityCollection.events.on("ldblclick", function (e) {
                ve.dispatch(ve.ldblclick, e);
            });
            entityCollection.events.on("rdblclick", function (e) {
                ve.dispatch(ve.rdblclick, e);
            });
            entityCollection.events.on("mdblclick", function (e) {
                ve.dispatch(ve.mdblclick, e);
            });
            entityCollection.events.on("lup", function (e) {
                ve.dispatch(ve.lup, e);
            });
            entityCollection.events.on("rup", function (e) {
                ve.dispatch(ve.rup, e);
            });
            entityCollection.events.on("mup", function (e) {
                ve.dispatch(ve.mup, e);
            });
            entityCollection.events.on("ldown", function (e) {
                ve.dispatch(ve.ldown, e);
            });
            entityCollection.events.on("rdown", function (e) {
                ve.dispatch(ve.rdown, e);
            });
            entityCollection.events.on("mdown", function (e) {
                ve.dispatch(ve.mdown, e);
            });
            entityCollection.events.on("lhold", function (e) {
                ve.dispatch(ve.lhold, e);
            });
            entityCollection.events.on("rhold", function (e) {
                ve.dispatch(ve.rhold, e);
            });
            entityCollection.events.on("mhold", function (e) {
                ve.dispatch(ve.mhold, e);
            });
            entityCollection.events.on("mousewheel", function (e) {
                ve.dispatch(ve.mousewheel, e);
            });
            entityCollection.events.on("touchmove", function (e) {
                ve.dispatch(ve.touchmove, e);
            });
            entityCollection.events.on("touchstart", function (e) {
                ve.dispatch(ve.touchstart, e);
            });
            entityCollection.events.on("touchend", function (e) {
                ve.dispatch(ve.touchend, e);
            });
            entityCollection.events.on("doubletouch", function (e) {
                ve.dispatch(ve.doubletouch, e);
            });
            entityCollection.events.on("touchleave", function (e) {
                ve.dispatch(ve.touchleave, e);
            });
            entityCollection.events.on("touchenter", function (e) {
                ve.dispatch(ve.touchenter, e);
            });
        }

        _collectStripCollectionPASS(outArr) {
            var ec = this._stripEntityCollection;

            ec._fadingOpacity = this._fadingOpacity;
            ec.scaleByDistance = this.scaleByDistance;
            ec.pickingScale = this.pickingScale;
            ec.polygonOffsetUnits = this.polygonOffsetUnits;

            outArr.push(ec);
            //
            // ...TODO: extent
            //
        }

        _collectPolylineCollectionPASS(outArr) {
            var ec = this._polylineEntityCollection;

            ec._fadingOpacity = this._fadingOpacity;
            ec.scaleByDistance = this.scaleByDistance;
            ec.pickingScale = this.pickingScale;
            ec.polygonOffsetUnits = this.polygonOffsetUnits;

            outArr.push(ec);

            if (this.clampToGround || this.relativeToGround) {
                let rtg = Number(this.relativeToGround);

                var nodes = this._planet._renderedNodes;
                var visibleExtent = this._planet.getViewExtent();
                var e = ec._entities;
                var e_i = e.length;
                let res = new Vec3();

                while (e_i--) {
                    var p = e[e_i].polyline;
                    if (visibleExtent.overlaps(p._extent)) {
                        // TODO:this works only for mercator area.
                        // needs to be working on poles.
                        let coords = p._pathLonLatMerc,
                            c_j = coords.length;
                        while (c_j--) {
                            var c_j_h = coords[c_j].length;
                            while (c_j_h--) {
                                let ll = coords[c_j][c_j_h],
                                    n_k = nodes.length;
                                while (n_k--) {
                                    var seg = nodes[n_k].segment;
                                    if (seg._extent.isInside(ll)) {
                                        let cart = p._path3v[c_j][c_j_h];
                                        seg.getTerrainPoint(cart, ll, res);
                                        p.setPoint3v(
                                            res.addA(res.normal().scale((rtg && p.altitude) || 0.0)),
                                            c_j_h,
                                            c_j,
                                            true
                                        );
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        collectVisibleCollections(outArr) {
            var p = this._planet;

            if (
                (this._fading && this._fadingOpacity > 0.0) ||
                (this.minZoom <= this._planet.maxCurrZoom && this.maxZoom >= p.maxCurrZoom)
            ) {
                this._renderingNodes = {};
                this._renderingNodesNorth = {};
                this._renderingNodesSouth = {};

                // Common collections first
                this._collectStripCollectionPASS(outArr);

                this._collectPolylineCollectionPASS(outArr);

                // Merc nodes
                this._secondPASS = [];
                this._entityCollectionsTree.collectRenderCollectionsPASS1(p._visibleNodes, outArr);
                var i = this._secondPASS.length;
                while (i--) {
                    this._secondPASS[i].collectRenderCollectionsPASS2(
                        p._visibleNodes,
                        outArr,
                        this._secondPASS[i].nodeId
                    );
                }

                // North nodes
                this._secondPASS = [];
                this._entityCollectionsTreeNorth.collectRenderCollectionsPASS1(
                    p._visibleNodesNorth,
                    outArr
                );
                i = this._secondPASS.length;
                while (i--) {
                    this._secondPASS[i].collectRenderCollectionsPASS2(
                        p._visibleNodesNorth,
                        outArr,
                        this._secondPASS[i].nodeId
                    );
                }

                // South nodes
                this._secondPASS = [];
                this._entityCollectionsTreeSouth.collectRenderCollectionsPASS1(
                    p._visibleNodesSouth,
                    outArr
                );
                i = this._secondPASS.length;
                while (i--) {
                    this._secondPASS[i].collectRenderCollectionsPASS2(
                        p._visibleNodesSouth,
                        outArr,
                        this._secondPASS[i].nodeId
                    );
                }
            }
        }

        _queueDeferredNode(node) {
            if (this._visibility) {
                node._inTheQueue = true;
                if (this._counter >= 1) {
                    this._deferredEntitiesPendingQueue.push(node);
                } else {
                    this._execDeferredNode(node);
                }
            }
        }

        _execDeferredNode(node) {
            this._counter++;
            var that = this;
            setTimeout(function () {
                node.applyCollection();
                that._counter--;
                if (that._deferredEntitiesPendingQueue.length && that._counter < 1) {
                    while (that._deferredEntitiesPendingQueue.length) {
                        var n = that._deferredEntitiesPendingQueue.pop();
                        n._inTheQueue = false;
                        if (n.isVisible()) {
                            that._execDeferredNode(n);
                            return;
                        }
                    }
                }
            }, 0);
        }

        /**
         * Start to load tile material.
         * @public
         * @virtual
         * @param {Segment.Material} material - Current material.
         */
        loadMaterial(material) {
            var seg = material.segment;

            if (this._isBaseLayer) {
                material.texture = seg._isNorth
                    ? seg.planet.solidTextureOne
                    : seg.planet.solidTextureTwo;
            } else {
                material.texture = seg.planet.transparentTexture;
            }

            if (this._planet.layerLock.isFree()) {
                material.isReady = false;
                material.isLoading = true;
                this._planet._vectorTileCreator.add(material);
            }
        }

        /**
         * Abort exact material loading.
         * @public
         * @param {Material} material - Segment material.
         */
        abortMaterialLoading(material) {
            material.isLoading = false;
            material.isReady = false;
        }

        applyMaterial(material) {
            if (material.isReady) {
                return [0, 0, 1, 1];
            } else {
                !material.isLoading && this.loadMaterial(material);

                var segment = material.segment;
                var pn = segment.node,
                    notEmpty = false;

                var mId = this._id;
                var psegm = material;

                while (pn.parentNode) {
                    if (psegm && psegm.isReady) {
                        notEmpty = true;
                        break;
                    }
                    pn = pn.parentNode;
                    psegm = pn.segment.materials[mId];
                }

                if (notEmpty) {
                    material.appliedNodeId = pn.nodeId;
                    material.texture = psegm.texture;
                    material.pickingMask = psegm.pickingMask;
                    var dZ2 = 1.0 / (2 << (segment.tileZoom - pn.segment.tileZoom - 1));
                    return [
                        segment.tileX * dZ2 - pn.segment.tileX,
                        segment.tileY * dZ2 - pn.segment.tileY,
                        dZ2,
                        dZ2
                    ];
                } else {
                    if (material.textureExists && material._updateTexture) {
                        material.texture = material._updateTexture;
                        material.pickingMask = material._updatePickingMask;
                    } else {
                        material.texture = segment.planet.transparentTexture;
                        material.pickingMask = segment.planet.transparentTexture;
                    }
                    return [0, 0, 1, 1];
                }
            }
        }

        clearMaterial(material) {
            if (material.isReady) {
                var gl = material.segment.handler.gl;

                material.isReady = false;
                material.pickingReady = false;

                var t = material.texture;
                material.texture = null;
                t && !t.default && gl.deleteTexture(t);

                t = material.pickingMask;
                material.pickingMask = null;
                t && !t.default && gl.deleteTexture(t);

                t = material._updateTexture;
                material._updateTexture = null;
                t && !t.default && gl.deleteTexture(t);

                t = material._updatePickingMask;
                material._updatePickingMask = null;
                t && !t.default && gl.deleteTexture(t);
            }

            this.abortMaterialLoading(material);

            material.isLoading = false;
            material.textureExists = false;
        }

        update() {
            this._geometryHandler.update();
            this.events.dispatch(this.events.draw, this);
        }
    }

    const EVENT_NAMES$5 = [
        /**
         * Triggered when entity has moved.
         * @event og.layer.Vector#draw
         */
        "entitymove",

        /**
         * Triggered when layer begin draw.
         * @event og.layer.Vector#draw
         */
        "draw",

        /**
         * Triggered when new entity added to the layer.
         * @event og.layer.Vector#entityadd
         */
        "entityadd",

        /**
         * Triggered when entity removes from the collection.
         * @event og.layer.Vector#entityremove
         */
        "entityremove"
    ];

    if (window && !('createImageBitmap' in window)) {
        window.createImageBitmap = function (blob) {
            return new Promise((resolve, reject) => {
                let img = document.createElement('img');
                img.addEventListener('load', function () {
                    resolve(this);
                });
                img.src = URL.createObjectURL(blob);
            });
        };
    }

    class Loader {

        constructor(maxRequests = 24) {

            this.MAX_REQUESTS = maxRequests;

            this.events = new Events(["loadend", "layerloadend"]);

            this._loading = 0;

            this._queue = [];//new QueueArray();

            this._senderRequestCounter = [];

            this._promises = {
                'json': r => r.json(),
                'blob': r => r.blob(),
                'arrayBuffer': r => r.arrayBuffer(),
                'imageBitmap': r => r.blob().then(createImageBitmap),
                'text': r => r.text()
            };
        }

        load(params, callback) {
            if (params.sender) {
                if (!this._senderRequestCounter[params.sender._id]) {
                    this._senderRequestCounter[params.sender._id] = {
                        sender: params.sender,
                        counter: 0,
                        __requestCounterFrame__: null
                    };
                }
                this._senderRequestCounter[params.sender._id].counter++;
            }
            this._queue.push({ 'params': params, 'callback': callback });
            this._exec();
        }

        fetch(params) {
            return fetch(
                params.src,
                params.options || {}
            )
                .then(response => {
                    if (!response.ok) {
                        throw Error(`Unable to load '${params.src}'`);
                    }
                    return this._promises[params.type || "blob"](response);
                })

                .then(data => {
                    return { 'status': "ready", 'data': data };

                })

                .catch(err => {
                    return { 'status': "error", 'msg': err.toString() };
                });
        }

        isIdle(sender) {
            let request = this._senderRequestCounter[sender._id];
            return request && request.counter === 0 && (!sender._planet || sender._planet._terrainCompletedActivated);

        }

        _checkLoadend(request, sender) {
            if (request.counter === 0 && (sender._planet._terrainCompletedActivated || !sender._planet)) {
                sender.events.dispatch(sender.events.loadend, sender);
                this.events.dispatch(this.events.layerloadend, sender);
                request.__requestCounterFrame__ = null;
            } else {
                request.__requestCounterFrame__ = requestAnimationFrame(() => {
                    this._checkLoadend(request, sender);
                });
            }
        }

        _handleResponse(q, response) {
            q.callback(response);
            let sender = q.params.sender;
            if (sender && (sender.events.loadend.handlers.length || this.events.layerloadend.handlers.length)) {
                let request = this._senderRequestCounter[sender._id];
                if (request && request.counter > 0) {
                    request.counter--;
                    cancelAnimationFrame(request.__requestCounterFrame__);
                    request.__requestCounterFrame__ = requestAnimationFrame(() => {
                        this._checkLoadend(request, sender);
                    });
                }
            }
            this._exec();
        }

        _exec() {

            if (this._queue.length > 0 && this._loading < this.MAX_REQUESTS) {

                let q = this._queue.pop(),
                    p = q.params;

                if (!p.filter || p.filter(p)) {

                    this._loading++;

                    return fetch(p.src, p.options || {})
                        .then(response => {
                            if (!response.ok) {
                                throw Error(`Unable to load '${p.src}'`);
                            }
                            return this._promises[p.type || "blob"](response);
                        })
                        .then(data => {
                            this._loading--;
                            this._handleResponse(q, { status: "ready", data: data });
                        })
                        .catch(err => {
                            this._loading--;
                            this._handleResponse(q, { status: "error", msg: err.toString() });
                        });

                } else {
                    this._handleResponse(q, { status: "abort" });
                }
            } else if (this._loading === 0) {
                this.events.dispatch(this.events.loadend);
            }
        }

        abort() {
            for (let i = 0, len = this._queue.length; i < len; i++) {
                let qi = this._queue[i];
                let sender = qi.params.sender;
                if (sender && this._senderRequestCounter[sender._id]) {
                    this._senderRequestCounter[sender._id].counter = 0;
                    cancelAnimationFrame(this._senderRequestCounter[sender._id].__requestCounterFrame__);
                    this._senderRequestCounter[sender._id].__requestCounterFrame__ = null;
                }
                qi.callback({ 'status': "abort" });
                this._queue[i] = null;
            }
            this._queue = [];
            this._loading = 0;
        }
    }

    /**
     * @module og/proj/Proj
     */

    /**
     * Projection units: 'degrees', 'ft', 'm' or 'km'.
     * @enum {string}
     * @api
     */
    const Units = {
        DEGREES: "degrees",
        FEET: "ft",
        METERS: "m",
        KILOMETERS: "km"
    };

    let _counter = 0;
    class Proj {
        constructor(options) {
            /**
             * @public
             * @type {string}
             */
            this.code = options.code;

            /**
             * @public
             * @type {proj.Units}
             */
            this.units = /** @type {Units} */ (options.units);

            /**
             * Projection identifier, especially usefull for comparison.
             * @const
             * @type {integer}
             */
            this.id = _counter++;
        }

        /**
         * Compare projections.
         * @public
         * @param {Proj} proj - Projetion object.
         * @returns {boolean}
         */
        equal(proj) {
            return proj.id === this.id;
        }
    }

    /**
     * @module og/proj/EPSG3857
     */

    /**
     * EPSG:3857 projection object.
     * @type {Proj}
     */
    const EPSG3857 = new Proj({ code: "epsg:3857", units: Units.METERS });

    /**
     * @module og/proj/EPSG4326
     */

    /**
     * EPSG:4326 projection object.
     * @type {Proj}
     */
    const EPSG4326 = new Proj({ code: "epsg:4326", units: Units.DEGREES });

    let _tempHigh$2 = new Vec3(),
        _tempLow$2 = new Vec3();

    const _vertOrder = [
        { x: 0, y: 0 },
        { x: 1, y: 0 },
        { x: 0, y: 1 },
        { x: 1, y: 1 }
    ];
    const _neGridSize = Math.sqrt(_vertOrder.length) - 1;

    let BOUNDS = {
        xmin: 0.0,
        ymin: 0.0,
        zmin: 0.0,
        xmax: 0.0,
        ymax: 0.0,
        zmax: 0.0
    };

    /**
     * Quad tree planet segment node.
     * @constructor
     * @param {Segment|og.planetSegment.SegmentLonLat} segmentPrototype - Planet segment node constructor.
     * @param {RenderNode} planet - Planet render node.
     * @param {number} partId - NorthEast, SouthWest etc.
     * @param {quadTree.Node} parent - Parent of this node.
     * @param {number} id - Tree node identifier (id * 4 + 1);
     * @param {number} tileZoom - Deep index of the quad tree.
     * @param {Extent} extent - Planet segment extent.
     */
    class Node$1 {

        constructor(SegmentPrototype, planet, partId, parent, id, tileZoom, extent) {
            this.SegmentPrototype = SegmentPrototype;
            planet._createdNodesCount++;
            this.planet = planet;
            this.parentNode = parent;
            this.partId = partId;
            this.nodeId = partId + id;
            this.state = null;
            this.appliedTerrainNodeId = -1;
            this.sideSize = [1, 1, 1, 1];
            this.sideSizeLog2 = [0, 0, 0, 0];
            this.ready = false;
            this.neighbors = [[], [], [], []];
            this.equalizedNeighborId = [-1, -1, -1, -1];
            this.equalizedNeighborGridSize = [-1, -1, -1, -1];
            this.nodes = [null, null, null, null];
            this.segment = new SegmentPrototype(this, planet, tileZoom, extent);
            this._cameraInside = false;
            this.inFrustum = 0;
            this.createBounds();
        }

        createChildrenNodes() {
            this.ready = true;

            var p = this.planet;
            var ps = this.segment;
            var ext = ps._extent;
            var size_x = ext.getWidth() * 0.5;
            var size_y = ext.getHeight() * 0.5;
            var ne = ext.northEast,
                sw = ext.southWest;
            var z = ps.tileZoom + 1;
            var id = this.nodeId * 4 + 1;
            var c = new LonLat(sw.lon + size_x, sw.lat + size_y);
            var nd = this.nodes;

            nd[NW] = new Node$1(this.SegmentPrototype, p, NW, this, id, z, new Extent(new LonLat(sw.lon, sw.lat + size_y), new LonLat(sw.lon + size_x, ne.lat)));
            nd[NE] = new Node$1(this.SegmentPrototype, p, NE, this, id, z, new Extent(c, new LonLat(ne.lon, ne.lat)));
            nd[SW] = new Node$1(this.SegmentPrototype, p, SW, this, id, z, new Extent(new LonLat(sw.lon, sw.lat), c));
            nd[SE] = new Node$1(this.SegmentPrototype, p, SE, this, id, z, new Extent(new LonLat(sw.lon + size_x, sw.lat), new LonLat(ne.lon, sw.lat + size_y)));
        }

        createBounds() {
            let seg = this.segment;
            seg._setExtentLonLat();
            if (seg.tileZoom === 0) {
                seg.setBoundingSphere(0.0, 0.0, 0.0, new Vec3(0.0, 0.0, seg.planet.ellipsoid._a));
            } else if (seg.tileZoom < seg.planet.terrain.minZoom) {
                seg.createBoundsByExtent();
            } else {
                seg.createBoundsByParent();
            }

            let x = seg.bsphere.center.x,
                y = seg.bsphere.center.y,
                z = seg.bsphere.center.z;

            let length = 1.0 / Math.sqrt(x * x + y * y + z * z);
            seg.centerNormal.x = x * length;
            seg.centerNormal.y = y * length;
            seg.centerNormal.z = z * length;
        }

        getState() {
            if (this.state === -1) {
                return this.state;
            }
            var pn = this.parentNode;
            while (pn) {
                if (pn.state !== WALKTHROUGH) {
                    return NOTRENDERING;
                }
                pn = pn.parentNode;
            }
            return this.state;
        }

        /**
         * Returns the same deep existent neighbour node.
         * @public
         * @param {Number} side - Neighbour side index e.g. og.quadTree.N, og.quadTree.W etc.
         * @returns {quadTree.Node} -
         */
        getEqualNeighbor(side) {
            var pn = this;
            var part = NEIGHBOUR[side][pn.partId];
            if (part !== -1) {
                return pn.parentNode.nodes[part];
            } else {
                var pathId = [];
                while (pn.parentNode) {
                    pathId.push(pn.partId);
                    part = NEIGHBOUR[side][pn.partId];
                    pn = pn.parentNode;
                    if (part !== -1) {
                        var i = pathId.length;
                        side = OPSIDE[side];
                        while (pn && i--) {
                            part = OPPART[side][pathId[i]];
                            pn = pn.nodes[part];
                        }
                        return pn;
                    }
                }
            }
        }

        isBrother(node) {
            return !(this.parentNode || node.parentNode) || this.parentNode.id === node.parentNode.id;
        }

        renderTree(cam, maxZoom, terrainReadySegment, stopLoading) {
            if (this.planet._renderedNodes.length >= MAX_RENDERED_NODES) {
                return;
            }

            this.state = WALKTHROUGH;

            this.neighbors[0] = null;
            this.neighbors[1] = null;
            this.neighbors[2] = null;
            this.neighbors[3] = null;

            this.neighbors[0] = [];
            this.neighbors[1] = [];
            this.neighbors[2] = [];
            this.neighbors[3] = [];

            let seg = this.segment,
                planet = this.planet;

            this._cameraInside = false;

            let insideLonLat = null;

            // Search a node which the camera is flying over.
            if (!this.parentNode || this.parentNode._cameraInside) {
                let inside;
                if (Math.abs(cam._lonLat.lat) <= MAX_LAT && seg._projection.id === EPSG3857.id) {
                    inside = seg._extent.isInside(cam._lonLatMerc);
                    insideLonLat = cam._lonLatMerc;
                } else if (seg._projection.id === EPSG4326.id) {
                    inside = seg._extent.isInside(cam._lonLat);
                    insideLonLat = cam._lonLat;
                }

                if (inside) {
                    cam._insideSegmentPosition.lon = insideLonLat.lon;
                    cam._insideSegmentPosition.lat = insideLonLat.lat;
                    cam._insideSegment = seg;
                    this._cameraInside = true;
                }
            }

            this.inFrustum = 0;

            let frustums = cam.frustums,
                numFrustums = frustums.length;

            if (seg.tileZoom < 6) {
                for (let i = 0; i < numFrustums; i++) {
                    if (frustums[i].containsSphere(seg.bsphere)) {
                        this.inFrustum |= 1 << i;
                    }
                }
            } else {
                let commonFrustumFlag = 1 << (numFrustums - 1 - 1);
                for (let i = 0; commonFrustumFlag && i < numFrustums; i++) {
                    if (seg.terrainReady) {
                        if (frustums[i].containsBox(seg.bbox)) {
                            commonFrustumFlag >>= 1;
                            this.inFrustum |= 1 << i;
                        }
                    } else {
                        if (frustums[i].containsSphere(seg.bsphere)) {
                            commonFrustumFlag >>= 1;
                            this.inFrustum |= 1 << i;
                        }
                    }
                }
            }

            if (this.inFrustum || this._cameraInside || seg.tileZoom < 3) {
                let h = cam._lonLat.height;

                let eye = cam.eye;
                let horizonDist = eye.length2() - this.planet.ellipsoid._b2;

                let altVis = seg.tileZoom > 19 ||
                    (seg.tileZoom < 4 && !seg.terrainReady) ||
                    seg.tileZoom < 2;

                if (h > 21000) {
                    altVis = altVis || eye.distance2(seg._sw) < horizonDist
                        || eye.distance2(seg._nw) < horizonDist
                        || eye.distance2(seg._ne) < horizonDist
                        || eye.distance2(seg._se) < horizonDist;
                } else {
                    altVis = altVis || cam.eye.distance(seg.bsphere.center) - seg.bsphere.radius < VISIBLE_DISTANCE * Math.sqrt(h);
                }

                if ((this.inFrustum && (altVis || h > 10000.0)) || this._cameraInside) {
                    seg._collectVisibleNodes();
                }

                if (seg.tileZoom < 2 && seg.normalMapReady) {
                    this.traverseNodes(cam, maxZoom, terrainReadySegment, stopLoading);
                } else if (seg.terrainReady && (
                    !maxZoom && cam.projectedSize(seg.bsphere.center, seg._plainRadius) < planet._lodSize ||
                    maxZoom && ((seg.tileZoom === maxZoom) || !altVis))) {

                    if (altVis) {
                        seg.passReady = true;
                        this.renderNode(this.inFrustum, !this.inFrustum, terrainReadySegment, stopLoading);
                    } else {
                        this.state = NOTRENDERING;
                    }

                } else if (
                    seg.terrainReady &&
                    seg.tileZoom < planet.terrain._maxNodeZoom &&
                    (!maxZoom || cam.projectedSize(seg.bsphere.center, seg.bsphere.radius) > this.planet._maxLodSize)) {
                    this.traverseNodes(cam, maxZoom, seg, stopLoading);
                } else if (altVis) {
                    seg.passReady = maxZoom ? seg.terrainReady : false;
                    this.renderNode(this.inFrustum, !this.inFrustum, terrainReadySegment, stopLoading);
                } else {
                    this.state = NOTRENDERING;
                }
            } else {
                this.state = NOTRENDERING;
            }
        }

        traverseNodes(cam, maxZoom, terrainReadySegment, stopLoading) {
            if (!this.ready) {
                this.createChildrenNodes();
            }

            let n = this.nodes;

            n[0].renderTree(cam, maxZoom, terrainReadySegment, stopLoading);
            n[1].renderTree(cam, maxZoom, terrainReadySegment, stopLoading);
            n[2].renderTree(cam, maxZoom, terrainReadySegment, stopLoading);
            n[3].renderTree(cam, maxZoom, terrainReadySegment, stopLoading);
        }

        renderNode(inFrustum, onlyTerrain, terrainReadySegment, stopLoading) {
            var seg = this.segment;

            // Create and load terrain data
            if (!seg.terrainReady) {
                if (!seg.initialized) {
                    seg.initialize();
                }

                this.whileTerrainLoading(terrainReadySegment, stopLoading);

                if (!seg.plainProcessing) {
                    seg.createPlainSegmentAsync();
                }

                if (seg.plainReady && !stopLoading) {
                    seg.loadTerrain();
                }
            }

            // Create normal map texture
            if (seg.planet.lightEnabled && !seg.normalMapReady /*&& !seg.parentNormalMapReady*/) {
                this.whileNormalMapCreating();
            }

            if (onlyTerrain) {
                this.state = -1;
                return;
            }

            // Calculate minimal and maximal zoom index on the screen
            if (!this._cameraInside && seg.tileZoom > this.planet.maxCurrZoom) {
                this.planet.maxCurrZoom = seg.tileZoom;
            }

            if (seg.tileZoom < this.planet.minCurrZoom) {
                this.planet.minCurrZoom = seg.tileZoom;
            }

            seg._addViewExtent();

            // Finally this node proceeds to rendering.
            this.addToRender(inFrustum);
        }

        /**
         * Seraching for neighbours and pickup current node to render processing.
         * @public
         */
        addToRender(inFrustum) {
            this.state = RENDERING;

            var nodes = this.planet._renderedNodes;

            for (var i = nodes.length - 1; i >= 0; --i) {
                var ni = nodes[i];

                var cs = this.getCommonSide(ni);

                if (cs !== -1) {
                    var opcs = OPSIDE[cs];

                    if (this.neighbors[cs].length === 0 || ni.neighbors[opcs].length === 0) {
                        var ap = this.segment;
                        var bp = ni.segment;
                        var ld = ap.gridSize / (bp.gridSize * Math.pow(2, bp.tileZoom - ap.tileZoom));

                        let cs_size = ap.gridSize,
                            opcs_size = bp.gridSize;

                        if (ld > 1) {
                            cs_size = Math.ceil(ap.gridSize / ld);
                            opcs_size = bp.gridSize;
                        } else if (ld < 1) {
                            cs_size = ap.gridSize;
                            opcs_size = Math.ceil(bp.gridSize * ld);
                        }

                        this.sideSize[cs] = cs_size;
                        ni.sideSize[opcs] = opcs_size;

                        this.sideSizeLog2[cs] = Math.log2(cs_size);
                        ni.sideSizeLog2[opcs] = Math.log2(opcs_size);
                    }

                    this.neighbors[cs].push(ni);
                    ni.neighbors[opcs].push(this);
                }
            }

            nodes.push(this);

            if (!this.segment.terrainReady) {
                this.planet._renderCompleted = false;
                this.planet._terrainCompleted = false;
            }

            let k = 0,
                rf = this.planet._renderedNodesInFrustum;
            while (inFrustum) {
                if (inFrustum & 1) {
                    rf[k].push(this);
                }
                k++;
                inFrustum >>= 1;
            }
        }

        getCommonSide(node) {
            var as = this.segment,
                bs = node.segment;

            if (as.tileZoom === bs.tileZoom && as._tileGroup === bs._tileGroup) {
                return as.getNeighborSide(bs);
            } else {
                var a = as._extentLonLat,
                    b = bs._extentLonLat;

                var a_ne = a.northEast,
                    a_sw = a.southWest,
                    b_ne = b.northEast,
                    b_sw = b.southWest;

                var a_ne_lon = a_ne.lon,
                    a_ne_lat = a_ne.lat,
                    a_sw_lon = a_sw.lon,
                    a_sw_lat = a_sw.lat,
                    b_ne_lon = b_ne.lon,
                    b_ne_lat = b_ne.lat,
                    b_sw_lon = b_sw.lon,
                    b_sw_lat = b_sw.lat;

                if (as._tileGroup === bs._tileGroup) {
                    if (
                        a_ne_lon === b_sw_lon &&
                        ((a_ne_lat <= b_ne_lat && a_sw_lat >= b_sw_lat) ||
                            (a_ne_lat >= b_ne_lat && a_sw_lat <= b_sw_lat))
                    ) {
                        return E;
                    } else if (
                        a_sw_lon === b_ne_lon &&
                        ((a_ne_lat <= b_ne_lat && a_sw_lat >= b_sw_lat) ||
                            (a_ne_lat >= b_ne_lat && a_sw_lat <= b_sw_lat))
                    ) {
                        return W;
                    } else if (
                        a_ne_lat === b_sw_lat &&
                        ((a_sw_lon >= b_sw_lon && a_ne_lon <= b_ne_lon) ||
                            (a_sw_lon <= b_sw_lon && a_ne_lon >= b_ne_lon))
                    ) {
                        return N;
                    } else if (
                        a_sw_lat === b_ne_lat &&
                        ((a_sw_lon >= b_sw_lon && a_ne_lon <= b_ne_lon) ||
                            (a_sw_lon <= b_sw_lon && a_ne_lon >= b_ne_lon))
                    ) {
                        return S;
                    } else if (
                        bs.tileX === 0 &&
                        as.tileX === Math.pow(2, as.tileZoom) - 1 &&
                        ((a_ne_lat <= b_ne_lat && a_sw_lat >= b_sw_lat) ||
                            (a_ne_lat >= b_ne_lat && a_sw_lat <= b_sw_lat))
                    ) {
                        return E;
                    } else if (
                        as.tileX === 0 &&
                        bs.tileX === Math.pow(2, bs.tileZoom) - 1 &&
                        ((a_ne_lat <= b_ne_lat && a_sw_lat >= b_sw_lat) ||
                            (a_ne_lat >= b_ne_lat && a_sw_lat <= b_sw_lat))
                    ) {
                        return W;
                    }
                }

                if (
                    as._tileGroup === 0 &&
                    bs._tileGroup === 1 &&
                    as.tileY === 0 &&
                    bs.tileY === Math.pow(2, bs.tileZoom) - 1 &&
                    ((a_sw_lon >= b_sw_lon && a_ne_lon <= b_ne_lon) ||
                        (a_sw_lon <= b_sw_lon && a_ne_lon >= b_ne_lon))
                ) {
                    return N;
                } else if (
                    as._tileGroup === 2 &&
                    bs._tileGroup === 0 &&
                    as.tileY === 0 &&
                    bs.tileY === Math.pow(2, bs.tileZoom) - 1 &&
                    ((a_sw_lon >= b_sw_lon && a_ne_lon <= b_ne_lon) ||
                        (a_sw_lon <= b_sw_lon && a_ne_lon >= b_ne_lon))
                ) {
                    return N;
                } else if (
                    bs._tileGroup === 1 &&
                    as._tileGroup === 0 &&
                    as.tileY === Math.pow(2, as.tileZoom) - 1 &&
                    bs.tileY === 0 &&
                    ((a_sw_lon >= b_sw_lon && a_ne_lon <= b_ne_lon) ||
                        (a_sw_lon <= b_sw_lon && a_ne_lon >= b_ne_lon))
                ) {
                    return S;
                } else if (
                    as._tileGroup === 1 &&
                    bs._tileGroup === 0 &&
                    as.tileY === Math.pow(2, as.tileZoom) - 1 &&
                    bs.tileY === 0 &&
                    ((a_sw_lon >= b_sw_lon && a_ne_lon <= b_ne_lon) ||
                        (a_sw_lon <= b_sw_lon && a_ne_lon >= b_ne_lon))
                ) {
                    return S;
                }
            }

            return -1;
        }

        // TODO: test test test
        ___getCommonSide___(b) {
            var a = this,
                as = a.segment,
                bs = b.segment;

            if (as.tileZoom === bs.tileZoom) {
                return as.getNeighborSide(bs);
            } else if (as.tileZoom > bs.tileZoom) {
                let dz = as.tileZoom - bs.tileZoom,
                    i = dz,
                    p = this;

                while (i--) {
                    p = p.parentNode;
                }

                let side = p.segment.getNeighborSide(bs);

                if (side !== -1) {
                    i = dz;
                    p = this;
                    let _n = true;

                    while (i--) {
                        _n = _n && COMSIDE[p.partId][side];
                    }

                    if (_n) {
                        return side;
                    }
                }
            } else {
                let dz = bs.tileZoom - as.tileZoom,
                    i = dz,
                    p = b;

                while (i--) {
                    p = p.parentNode;
                }

                let side = p.segment.getNeighborSide(as);

                if (side !== -1) {
                    i = dz;
                    p = b;
                    let _n = true;

                    while (i--) {
                        _n = _n && COMSIDE[p.partId][side];
                    }

                    if (_n) {
                        return OPSIDE[side];
                    }
                }
            }

            return -1;
        }

        whileNormalMapCreating() {
            var seg = this.segment;
            var maxZ = this.planet.terrain.maxZoom;

            if (seg.tileZoom <= maxZ && !seg.terrainIsLoading && seg.terrainReady && !seg._inTheQueue) {
                seg.planet._normalMapCreator.queue(seg);
            }

            var pn = this;

            while (pn.parentNode && !pn.segment.normalMapReady) {
                pn = pn.parentNode;
            }

            var dZ2 = 2 << (seg.tileZoom - pn.segment.tileZoom - 1);

            seg.normalMapTexture = pn.segment.normalMapTexture;
            seg.normalMapTextureBias[0] = seg.tileX - pn.segment.tileX * dZ2;
            seg.normalMapTextureBias[1] = seg.tileY - pn.segment.tileY * dZ2;
            seg.normalMapTextureBias[2] = 1.0 / dZ2;

            if (seg.tileZoom > maxZ) {
                if (pn.segment.tileZoom === maxZ) {
                    seg.parentNormalMapReady = true;
                }
            }
        }

        whileTerrainLoading(terrainReadySegment, stopLoading) {
            const seg = this.segment;
            const terrain = this.planet.terrain;

            let pn = this;

            if (terrainReadySegment && terrainReadySegment.terrainReady) {
                pn = terrainReadySegment.node;
            } else {
                while (pn.parentNode && !pn.segment.terrainReady) {
                    pn = pn.parentNode;
                }
            }

            if (pn.segment.terrainReady && this.appliedTerrainNodeId !== pn.nodeId) {
                let dZ2 = 2 << (seg.tileZoom - pn.segment.tileZoom - 1),
                    offsetX = seg.tileX - pn.segment.tileX * dZ2,
                    offsetY = seg.tileY - pn.segment.tileY * dZ2;

                let pseg = pn.segment;

                let tempVertices, tempVerticesHigh, tempVerticesLow, noDataVertices;

                this.appliedTerrainNodeId = pn.nodeId;

                let gridSize = pn.segment.gridSize / dZ2,
                    gridSizeExt = pn.segment.fileGridSize / dZ2;

                BOUNDS.xmin = MAX;
                BOUNDS.xmax = MIN;
                BOUNDS.ymin = MAX;
                BOUNDS.ymax = MIN;
                BOUNDS.zmin = MAX;
                BOUNDS.zmax = MIN;

                if (gridSize >= 1) {
                    seg.gridSize = gridSize;

                    let len = (gridSize + 1) * (gridSize + 1) * 3;
                    tempVertices = new Float64Array(len);
                    tempVerticesHigh = new Float32Array(len);
                    tempVerticesLow = new Float32Array(len);

                    if (pseg.noDataVertices) {
                        noDataVertices = new Uint8Array(len / 3);
                    }

                    getMatrixSubArrayBoundsExt(
                        pseg.terrainVertices,
                        pseg.terrainVerticesHigh,
                        pseg.terrainVerticesLow,
                        pseg.noDataVertices,
                        pseg.gridSize,
                        gridSize * offsetY,
                        gridSize * offsetX,
                        gridSize,
                        tempVertices,
                        tempVerticesHigh,
                        tempVerticesLow,
                        BOUNDS,
                        noDataVertices
                    );
                } else if (gridSizeExt >= 1) {
                    seg.gridSize = gridSizeExt;

                    let len = (gridSizeExt + 1) * (gridSizeExt + 1) * 3;
                    tempVertices = new Float64Array(len);
                    tempVerticesHigh = new Float32Array(len);
                    tempVerticesLow = new Float32Array(len);

                    if (pseg.noDataVertices) {
                        noDataVertices = new Uint8Array(len / 3);
                    }

                    getMatrixSubArrayBoundsExt(
                        pseg.normalMapVertices,
                        pseg.normalMapVerticesHigh,
                        pseg.normalMapVerticesLow,
                        pseg.noDataVertices,
                        pn.segment.fileGridSize,
                        gridSizeExt * offsetY,
                        gridSizeExt * offsetX,
                        gridSizeExt,
                        tempVertices,
                        tempVerticesHigh,
                        tempVerticesLow,
                        BOUNDS,
                        noDataVertices
                    );
                } else {
                    seg.gridSize = _neGridSize;

                    let i0 = Math.floor(gridSize * offsetY),
                        j0 = Math.floor(gridSize * offsetX);

                    let bigOne;
                    if (pseg.gridSize === 1) {
                        bigOne = pseg.terrainVertices;
                    } else {
                        bigOne = getMatrixSubArray(pseg.terrainVertices, pseg.gridSize, i0, j0, 1);
                    }

                    let insideSize = 1.0 / gridSize;

                    let t_i0 = offsetY - insideSize * i0,
                        t_j0 = offsetX - insideSize * j0;

                    let v_lt = new Vec3(bigOne[0], bigOne[1], bigOne[2]),
                        v_rb = new Vec3(bigOne[9], bigOne[10], bigOne[11]);

                    let vn = new Vec3(bigOne[3] - bigOne[0], bigOne[4] - bigOne[1], bigOne[5] - bigOne[2]),
                        vw = new Vec3(bigOne[6] - bigOne[0], bigOne[7] - bigOne[1], bigOne[8] - bigOne[2]),
                        ve = new Vec3(
                            bigOne[3] - bigOne[9],
                            bigOne[4] - bigOne[10],
                            bigOne[5] - bigOne[11]
                        ),
                        vs = new Vec3(
                            bigOne[6] - bigOne[9],
                            bigOne[7] - bigOne[10],
                            bigOne[8] - bigOne[11]
                        );

                    let coords = new Vec3();

                    tempVertices = new Float64Array(3 * _vertOrder.length);
                    tempVerticesHigh = new Float32Array(3 * _vertOrder.length);
                    tempVerticesLow = new Float32Array(3 * _vertOrder.length);

                    for (var i = 0; i < _vertOrder.length; i++) {
                        let vi_y = _vertOrder[i].y + t_i0,
                            vi_x = _vertOrder[i].x + t_j0;

                        let vi_x_is = vi_x * gridSize,
                            vi_y_is = vi_y * gridSize;

                        if (vi_y + vi_x < insideSize) {
                            coords = vn.scaleTo(vi_x_is).addA(vw.scaleTo(vi_y_is)).addA(v_lt);
                        } else {
                            coords = vs
                                .scaleTo(1 - vi_x_is)
                                .addA(ve.scaleTo(1 - vi_y_is))
                                .addA(v_rb);
                        }

                        Vec3.doubleToTwoFloats(coords, _tempHigh$2, _tempLow$2);

                        let i3 = i * 3;

                        tempVertices[i3] = coords.x;
                        tempVertices[i3 + 1] = coords.y;
                        tempVertices[i3 + 2] = coords.z;

                        tempVerticesHigh[i3] = _tempHigh$2.x;
                        tempVerticesHigh[i3 + 1] = _tempHigh$2.y;
                        tempVerticesHigh[i3 + 2] = _tempHigh$2.z;

                        tempVerticesLow[i3] = _tempLow$2.x;
                        tempVerticesLow[i3 + 1] = _tempLow$2.y;
                        tempVerticesLow[i3 + 2] = _tempLow$2.z;

                        if (coords.x < BOUNDS.xmin) BOUNDS.xmin = coords.x;
                        if (coords.x > BOUNDS.xmax) BOUNDS.xmax = coords.x;
                        if (coords.y < BOUNDS.ymin) BOUNDS.ymin = coords.y;
                        if (coords.y > BOUNDS.ymax) BOUNDS.ymax = coords.y;
                        if (coords.z < BOUNDS.zmin) BOUNDS.zmin = coords.z;
                        if (coords.z > BOUNDS.zmax) BOUNDS.zmax = coords.z;
                    }
                }

                seg.readyToEngage = true;

                seg.terrainVertices = tempVertices;
                seg.terrainVerticesHigh = tempVerticesHigh;
                seg.terrainVerticesLow = tempVerticesLow;

                seg.tempVertices = tempVertices;
                seg.tempVerticesHigh = tempVerticesHigh;
                seg.tempVerticesLow = tempVerticesLow;

                seg.noDataVertices = noDataVertices;

                seg.setBoundingVolume(
                    BOUNDS.xmin,
                    BOUNDS.ymin,
                    BOUNDS.zmin,
                    BOUNDS.xmax,
                    BOUNDS.ymax,
                    BOUNDS.zmax
                );

                if (seg.tileZoom > terrain.maxZoom) {
                    if (pn.segment.tileZoom >= terrain.maxZoom) {
                        //TODO: find better place for this
                        seg._plainRadius = pn.segment._plainRadius / dZ2;

                        seg.terrainReady = true;
                        seg.terrainIsLoading = false;

                        seg.terrainVertices = tempVertices;
                        seg.terrainVerticesHigh = tempVerticesHigh;
                        seg.terrainVerticesLow = tempVerticesLow;

                        this.appliedTerrainNodeId = this.nodeId;

                        if (pn.segment.terrainExists) {
                            seg.terrainExists = true;
                            seg.normalMapVertices = tempVertices;
                            seg.fileGridSize = Math.sqrt(tempVertices.length / 3) - 1;

                            let fgs = Math.sqrt(pseg.normalMapNormals.length / 3) - 1,
                                fgsZ = fgs / dZ2;

                            if (fgs > 1) {
                                seg.normalMapNormals = getMatrixSubArray(
                                    pseg.normalMapNormals,
                                    fgs,
                                    fgsZ * offsetY,
                                    fgsZ * offsetX,
                                    fgsZ
                                );
                            } else {
                                // TODO: interpolation
                                seg.normalMapNormals = pseg.normalMapNormals;
                            }
                        }
                    } else {
                        pn = this;
                        while (pn.parentNode && pn.segment.tileZoom !== terrain.maxZoom) {
                            pn = pn.parentNode;
                        }

                        let pns = pn.segment;

                        if (!pns.initialized) {
                            pns.initialize();
                        }

                        if (!pns.plainProcessing) {
                            pn.segment.createPlainSegmentAsync();
                        }

                        if (pns.plainReady && !stopLoading) {
                            pns.loadTerrain(true);
                        }
                    }
                }
            }
        }

        destroy() {
            this.state = NOTRENDERING;
            this.segment.destroySegment();
            var n = this.neighbors;
            n[N] && n[N].neighbors && (n[N].neighbors[S] = []);
            n[E] && n[E].neighbors && (n[E].neighbors[W] = []);
            n[S] && n[S].neighbors && (n[S].neighbors[N] = []);
            n[W] && n[W].neighbors && (n[W].neighbors[E] = []);
            this.neighbors = null;
            this.parentNode = null;
            this.sideSize = null;
            this.sideSizeLog2 = null;
            this.segment = null;
        }

        clearTree() {
            var state = this.getState();

            if (state === NOTRENDERING) {
                this.destroyBranches();
            } else if (state === RENDERING) {
                this.destroyBranches();
            } else {
                for (var i = 0; i < this.nodes.length; i++) {
                    this.nodes[i] && this.nodes[i].clearTree();
                }
            }
        }

        clearBranches() {
            for (let i = 0; i < this.nodes.length; i++) {
                this.nodes[i].clearBranches();
                this.nodes[i].segment.deleteMaterials();
            }
        }

        destroyBranches() {
            if (this.ready) {
                var nodesToRemove = [],
                    i;

                for (i = 0; i < this.nodes.length; i++) {
                    nodesToRemove[i] = this.nodes[i];
                }

                this.ready = false;
                this.nodes.length = 0;

                for (i = 0; i < nodesToRemove.length; i++) {
                    nodesToRemove[i].destroyBranches();
                    nodesToRemove[i].destroy();
                    nodesToRemove[i] = null;
                }

                nodesToRemove.length = 0;
                nodesToRemove = null;
            }
        }

        traverseTree(callback) {
            callback(this);
            if (this.ready) {
                for (var i = 0; i < this.nodes.length; i++) {
                    this.nodes[i].traverseTree(callback);
                }
            }
        }

        getOffsetOppositeNeighbourSide(neighbourNode, side) {
            let pNode = this,
                neighbourZoom = neighbourNode.segment.tileZoom,
                offset = 0;

            while (pNode.segment.tileZoom > neighbourZoom) {
                offset += PARTOFFSET[pNode.partId][side] / (1 << (pNode.segment.tileZoom - neighbourZoom));
                pNode = pNode.parentNode;
            }

            return offset;
        }
    }

    /**
     * @module og/utils/NormalMapCreator
     */

    class NormalMapCreator {

        constructor(planet, options) {
            options = options || {};

            this._minTabelSize = options.minTableSize || 1;
            this._maxTableSize = options.maxTableSize || 8;

            this._planet = planet;
            this._handler = planet.renderer.handler;
            this._verticesBufferArray = [];
            this._indexBufferArray = [];
            this._positionBuffer = null;
            this._framebuffer = null;
            this._normalMapVerticesTexture = null;

            this._width = options.width || 128;
            this._height = options.height || 128;

            this._queue = new QueueArray(1024);

            this._lock = new Lock();

            this._init();
        }

        _init() {

            /*==================================================================================
             * http://www.sunsetlakesoftware.com/2013/10/21/optimizing-gaussian-blurs-mobile-gpu
             *=================================================================================*/
            var normalMapBlur = new Program("normalMapBlur", {
                attributes: {
                    a_position: { type: types$1.VEC2, enableArray: true }
                },
                uniforms: {
                    s_texture: { type: types$1.SAMPLER2D }
                },
                vertexShader:
                    `attribute vec2 a_position;
                       attribute vec2 a_texCoord;

                      varying vec2 blurCoordinates[5];

                      void main() {
                          vec2 vt = a_position * 0.5 + 0.5;` +
                    (" ") +
                    `gl_Position = vec4(a_position, 0.0, 1.0);
                          blurCoordinates[0] = vt;
                          blurCoordinates[1] = vt + ` +
                    (1.0 / this._width) * 1.407333 +
                    ";" +
                    "blurCoordinates[2] = vt - " +
                    (1.0 / this._height) * 1.407333 +
                    ";" +
                    "blurCoordinates[3] = vt + " +
                    (1.0 / this._width) * 3.294215 +
                    ";" +
                    "blurCoordinates[4] = vt - " +
                    (1.0 / this._height) * 3.294215 +
                    ";" +
                    "}",
                fragmentShader: `precision lowp float;
                        uniform sampler2D s_texture;
                        
                        varying vec2 blurCoordinates[5];
                        
                        void main() {
                            lowp vec4 sum = vec4(0.0);
                            //if(blurCoordinates[0].x <= 0.01 || blurCoordinates[0].x >= 0.99 ||
                            //    blurCoordinates[0].y <= 0.01 || blurCoordinates[0].y >= 0.99){
                            //    sum = texture2D(s_texture, blurCoordinates[0]);
                            //} else {
                                sum += texture2D(s_texture, blurCoordinates[0]) * 0.204164;
                                sum += texture2D(s_texture, blurCoordinates[1]) * 0.304005;
                                sum += texture2D(s_texture, blurCoordinates[2]) * 0.304005;
                                sum += texture2D(s_texture, blurCoordinates[3]) * 0.093913;
                                sum += texture2D(s_texture, blurCoordinates[4]) * 0.093913;
                            //}
                            gl_FragColor = sum;
                        }`
            });

            var normalMap = new Program("normalMap", {
                attributes: {
                    a_position: { type: types$1.VEC2, enableArray: true },
                    a_normal: { type: types$1.VEC3, enableArray: true }
                },
                vertexShader: `attribute vec2 a_position;
                      attribute vec3 a_normal;
                      
                      varying vec3 v_color;
                      
                      void main() {
                          gl_Position = vec4(a_position, 0, 1);
                          v_color = normalize(a_normal) * 0.5 + 0.5;
                      }`,
                fragmentShader: `precision highp float;
                        
                        varying vec3 v_color;
                        
                        void main () {
                            gl_FragColor = vec4(v_color, 1.0);
                        }`
            });

            this._handler.addProgram(normalMapBlur);
            this._handler.addProgram(normalMap);

            //create hidden handler buffer
            this._framebuffer = new Framebuffer(this._handler, {
                width: this._width,
                height: this._height,
                useDepth: false
            });

            this._framebuffer.init();

            this._normalMapVerticesTexture = this._handler.createEmptyTexture_l(this._width, this._height);

            //create vertices hasharray for different grid size segments from 2^4(16) to 2^7(128)
            for (var p = this._minTabelSize; p <= this._maxTableSize; p++) {
                var gs = Math.pow(2, p);
                var gs2 = gs / 2;
                var vertices = new Float32Array((gs + 1) * (gs + 1) * 2);

                for (var i = 0; i <= gs; i++) {
                    for (var j = 0; j <= gs; j++) {
                        let ind = (i * (gs + 1) + j) * 2;
                        vertices[ind] = -1 + j / gs2;
                        vertices[ind + 1] = -1 + i / gs2;
                    }
                }

                this._verticesBufferArray[gs] = this._handler.createArrayBuffer(
                    vertices,
                    2,
                    vertices.length / 2
                );
                this._indexBufferArray[gs] =
                    this._planet._indexesCache[Math.log2(gs)][Math.log2(gs)][Math.log2(gs)][Math.log2(gs)][
                        Math.log2(gs)
                    ].buffer;
            }

            //create 2d screen square buffer
            var positions = new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0]);

            this._positionBuffer = this._handler.createArrayBuffer(positions, 2, positions.length / 2);
        }

        _drawNormalMapBlur(segment) {
            var normals = segment.normalMapNormals;
            if (
                segment.node &&
                segment.node.getState() !== NOTRENDERING &&
                normals &&
                normals.length
            ) {
                var size = normals.length / 3;
                var gridSize = Math.sqrt(size) - 1;

                let indBuf = this._verticesBufferArray[gridSize];

                if (indBuf) {
                    if (segment.planet.terrain.equalizeNormals) {
                        segment._normalMapEdgeEqualize(N);
                        segment._normalMapEdgeEqualize(S);
                        segment._normalMapEdgeEqualize(W);
                        segment._normalMapEdgeEqualize(E);
                    }

                    var outTexture = segment.normalMapTexturePtr;

                    var h = this._handler;
                    var gl = h.gl;

                    var _normalsBuffer = h.createArrayBuffer(normals, 3, size, gl.DYNAMIC_DRAW);

                    var f = this._framebuffer;
                    var p = h.programs.normalMap;
                    var sha = p._program.attributes;

                    f.bindOutputTexture(this._normalMapVerticesTexture);

                    p.activate();

                    gl.bindBuffer(gl.ARRAY_BUFFER, indBuf);
                    gl.vertexAttribPointer(sha.a_position, indBuf.itemSize, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, _normalsBuffer);
                    gl.vertexAttribPointer(sha.a_normal, _normalsBuffer.itemSize, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBufferArray[gridSize]);
                    gl.drawElements(
                        gl.TRIANGLE_STRIP,
                        this._indexBufferArray[gridSize].numItems,
                        gl.UNSIGNED_INT,
                        0
                    );

                    gl.deleteBuffer(_normalsBuffer);

                    //
                    // blur pass
                    //
                    f.bindOutputTexture(outTexture);

                    p = h.programs.normalMapBlur;

                    p.activate();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this._positionBuffer);
                    gl.vertexAttribPointer(
                        p._program.attributes.a_position,
                        this._positionBuffer.itemSize,
                        gl.FLOAT,
                        false,
                        0,
                        0
                    );
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, this._normalMapVerticesTexture);
                    gl.uniform1i(p._program.uniforms.s_texture, 0);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, this._positionBuffer.numItems);
                    return true;
                } else {
                    return true;
                }
            }
            return false;
        }

        _drawNormalMapNoBlur(segment) {
            var normals = segment.normalMapNormals;
            if (
                segment.node &&
                segment.node.getState() !== NOTRENDERING &&
                normals &&
                normals.length
            ) {
                var size = normals.length / 3;
                var gridSize = Math.sqrt(size) - 1;

                let indBuf = this._verticesBufferArray[gridSize];

                if (indBuf) {
                    if (segment.planet.terrain.equalizeNormals) {
                        segment._normalMapEdgeEqualize(N);
                        segment._normalMapEdgeEqualize(S);
                        segment._normalMapEdgeEqualize(W);
                        segment._normalMapEdgeEqualize(E);
                    }

                    var outTexture = segment.normalMapTexturePtr;

                    var h = this._handler;
                    var gl = h.gl;

                    var _normalsBuffer = h.createArrayBuffer(normals, 3, size, gl.DYNAMIC_DRAW);

                    var f = this._framebuffer;
                    var p = h.programs.normalMap;
                    var sha = p._program.attributes;

                    f.bindOutputTexture(outTexture);

                    p.activate();

                    gl.bindBuffer(gl.ARRAY_BUFFER, indBuf);
                    gl.vertexAttribPointer(sha.a_position, indBuf.itemSize, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, _normalsBuffer);
                    gl.vertexAttribPointer(sha.a_normal, _normalsBuffer.itemSize, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBufferArray[gridSize]);
                    gl.drawElements(
                        gl.TRIANGLE_STRIP,
                        this._indexBufferArray[gridSize].numItems,
                        gl.UNSIGNED_INT,
                        0
                    );

                    gl.deleteBuffer(_normalsBuffer);

                    return true;
                } else {
                    return true;
                }
            }
            return false;
        }

        _drawNormalMap(segment) {
            let t = segment.planet.terrain;

            if (t.isBlur(segment)) {
                return this._drawNormalMapBlur(segment);
            } else {
                return this._drawNormalMapNoBlur(segment);
            }
        }

        drawSingle(segment) {
            var h = this._handler,
                gl = h.gl;

            this._framebuffer.activate();

            gl.disable(gl.CULL_FACE);
            gl.disable(gl.DEPTH_TEST);

            if (segment.terrainReady && this._drawNormalMap(segment)) {
                segment.normalMapReady = true;
                segment.normalMapTexture = segment.normalMapTexturePtr;
                segment.normalMapTextureBias[0] = 0;
                segment.normalMapTextureBias[1] = 0;
                segment.normalMapTextureBias[2] = 1;
            }
            segment._inTheQueue = false;

            gl.disable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);

            this._framebuffer.deactivate();
        }

        frame() {
            if (this._queue.length) {
                var h = this._handler,
                    gl = h.gl;

                this._framebuffer.activate();

                gl.disable(gl.CULL_FACE);
                gl.disable(gl.DEPTH_TEST);

                var deltaTime = 0,
                    startTime = window.performance.now();

                while (this._lock.isFree() && this._queue.length && deltaTime < 0.25) {
                    var segment = this._queue.shift();
                    if (segment.terrainReady && this._drawNormalMap(segment)) {
                        segment.normalMapReady = true;
                        segment.normalMapTexture = segment.normalMapTexturePtr;
                        segment.normalMapTextureBias[0] = 0;
                        segment.normalMapTextureBias[1] = 0;
                        segment.normalMapTextureBias[2] = 1;
                    }
                    segment._inTheQueue = false;
                    deltaTime = window.performance.now() - startTime;
                }

                gl.disable(gl.BLEND);
                gl.enable(gl.DEPTH_TEST);
                gl.enable(gl.CULL_FACE);

                this._framebuffer.deactivate();
            }
        }

        queue(segment) {
            segment._inTheQueue = true;
            this._queue.push(segment);
        }

        unshift(segment) {
            segment._inTheQueue = true;
            this._queue.unshift(segment);
        }

        remove(segment) {
            //...
        }

        clear() {
            while (this._queue.length) {
                var s = this._queue.pop();
                s._inTheQueue = false;
            }
        }

        /**
         * Set activity off
         * @public
         */
        lock(key) {
            this._lock.lock(key);
        }

        /**
         * Set activity on
         * @public
         */
        free(key) {
            this._lock.free(key);
        }

    }

    function planeNormalize(plane) {
        var t = 1.0 / Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
        plane[0] *= t;
        plane[1] *= t;
        plane[2] *= t;
        plane[3] *= t;
    }

    /**
     * Frustum object, part of the camera object.
     * @class
     */
    class Frustum {
        /**
         * @param {*} options
         */
        constructor(options = {}) {
            /**
             * Frustum planes.
             * @private
             * @type {Array.<Array.<number>>}
             */
            this._f = new Array(6);
            for (var i = 0; i < 6; i++) {
                this._f[i] = new Array(4);
            }

            /**
             * Camera projection matrix.
             * @protected
             * @type {Mat4}
             */
            this._projectionMatrix = new Mat4();

            /**
             * Camera inverse projection matrix.
             * @protected
             * @type {Mat4}
             */
            this._inverseProjectionMatrix = new Mat4();

            /**
             * Product of projection and view matrices.
             * @protected
             * @type {Mat4}
             */
            this._projectionViewMatrix = new Mat4();

            /**
             * Inverse projectionView Matrix.
             * @protected
             * @type {Mat4}
             */
            this._inverseProjectionViewMatrix = new Mat4();

            /**
             * Projection frustum left value.
             * @public
             */
            this.left = 0.0;
            /**
             * Projection frustum right value.
             * @public
             */
            this.right = 0.0;
            /**
             * Projection frustum bottom value.
             * @public
             */
            this.bottom = 0.0;
            /**
             * Projection frustum top value.
             * @public
             */
            this.top = 0.0;
            /**
             * Projection frustum near value.
             * @public
             */
            this.near = 0.0;
            /**
             * Projection frustum far value.
             * @public
             */
            this.far = 0.0;

            this._cameraFrustumIndex =
                options.cameraFrustumIndex != undefined ? options.cameraFrustumIndex : -1;

            this.setProjectionMatrix(
                options.fov || 30.0,
                options.aspect || 1.0,
                options.near || 1.0,
                options.far || 1000.0
            );
        }

        getRightPlane() {
            return this._f[0];
        }

        getLeftPlane() {
            return this._f[1];
        }

        getBottomPlane() {
            return this._f[2];
        }

        getTopPlane() {
            return this._f[3];
        }

        getBackwardPlane() {
            return this._f[4];
        }

        getForwardPlane() {
            return this._f[5];
        }

        getProjectionViewMatrix() {
            return this._projectionViewMatrix._m;
        }

        getProjectionMatrix() {
            return this._projectionMatrix._m;
        }

        getInverseProjectionMatrix() {
            return this._inverseProjectionMatrix._m;
        }

        /**
         * Sets up camera projection matrix.
         * @public
         * @param {nnumber} angle - Camera's view angle.
         * @param {number} aspect - Screen aspect ration.
         * @param {number} near - Near camera distance.
         * @param {number} far - Far camera distance.
         */
        setProjectionMatrix(angle, aspect, near, far) {
            this.top = near * Math.tan((angle * Math.PI) / 360);
            this.bottom = -this.top;
            this.right = this.top * aspect;
            this.left = -this.right;
            this.near = near;
            this.far = far;

            this._projectionMatrix.setPerspective(
                this.left,
                this.right,
                this.bottom,
                this.top,
                near,
                far
            );
            this._projectionMatrix.inverseTo(this._inverseProjectionMatrix);
        }

        /**
         * Camera's projection matrix values.
         * @public
         * @param {Mat4} projectionView - projectionView matrix.
         */
        setViewMatrix(viewMatrix) {
            this._projectionViewMatrix = this._projectionMatrix.mul(viewMatrix);
            this._projectionViewMatrix.inverseTo(this._inverseProjectionViewMatrix);

            let m = this._projectionViewMatrix._m;

            /* Right */
            this._f[0][0] = m[3] - m[0];
            this._f[0][1] = m[7] - m[4];
            this._f[0][2] = m[11] - m[8];
            this._f[0][3] = m[15] - m[12];
            planeNormalize(this._f[0]);

            /* Left */
            this._f[1][0] = m[3] + m[0];
            this._f[1][1] = m[7] + m[4];
            this._f[1][2] = m[11] + m[8];
            this._f[1][3] = m[15] + m[12];
            planeNormalize(this._f[1]);

            /* Bottom */
            this._f[2][0] = m[3] + m[1];
            this._f[2][1] = m[7] + m[5];
            this._f[2][2] = m[11] + m[9];
            this._f[2][3] = m[15] + m[13];
            planeNormalize(this._f[2]);

            /* Top */
            this._f[3][0] = m[3] - m[1];
            this._f[3][1] = m[7] - m[5];
            this._f[3][2] = m[11] - m[9];
            this._f[3][3] = m[15] - m[13];
            planeNormalize(this._f[3]);

            /* Backward */
            this._f[4][0] = m[3] - m[2];
            this._f[4][1] = m[7] - m[6];
            this._f[4][2] = m[11] - m[10];
            this._f[4][3] = m[15] - m[14];
            planeNormalize(this._f[4]);

            /* Forward */
            this._f[5][0] = m[3] + m[2];
            this._f[5][1] = m[7] + m[6];
            this._f[5][2] = m[11] + m[10];
            this._f[5][3] = m[15] + m[14];
            planeNormalize(this._f[5]);
        }

        /**
         * Returns true if a point in the frustum.
         * @public
         * @param {Vec3} point - Cartesian point.
         * @returns {boolean} -
         */
        containsPoint(point) {
            var d;
            for (var p = 0; p < 6; p++) {
                d = point.dotArr(this._f[p]) + this._f[p][3];
                if (d <= 0) {
                    return false;
                }
            }
            return true;
        }

        /**
         * Returns true if the frustum contains a bonding sphere, but bottom plane exclude.
         * @public
         * @param {Sphere} sphere - Bounding sphere.
         * @returns {boolean} -
         */
        containsSphereBottomExc(sphere) {
            var r = -sphere.radius,
                f = this._f;
            if (sphere.center.dotArr(f[0]) + f[0][3] <= r) return false;
            if (sphere.center.dotArr(f[1]) + f[1][3] <= r) return false;
            if (sphere.center.dotArr(f[3]) + f[3][3] <= r) return false;
            if (sphere.center.dotArr(f[4]) + f[4][3] <= r) return false;
            if (sphere.center.dotArr(f[5]) + f[5][3] <= r) return false;
            return true;
        }

        containsSphereButtom(sphere) {
            var r = -sphere.radius,
                f = this._f;
            if (sphere.center.dotArr(f[2]) + f[2][3] <= r) return false;
            return true;
        }

        /**
         * Returns true if the frustum contains a bonding sphere.
         * @public
         * @param {Sphere} sphere - Bounding sphere.
         * @returns {boolean} -
         */
        containsSphere(sphere) {
            var r = -sphere.radius,
                f = this._f;
            if (sphere.center.dotArr(f[0]) + f[0][3] <= r) return false;
            if (sphere.center.dotArr(f[1]) + f[1][3] <= r) return false;
            if (sphere.center.dotArr(f[2]) + f[2][3] <= r) return false;
            if (sphere.center.dotArr(f[3]) + f[3][3] <= r) return false;
            if (sphere.center.dotArr(f[4]) + f[4][3] <= r) return false;
            if (sphere.center.dotArr(f[5]) + f[5][3] <= r) return false;
            return true;
        }

        /**
         * Returns true if the frustum contains a bonding sphere.
         * @public
         * @param {Vec3} center - Sphere center.
         * @param {number} radius - Sphere radius.
         * @returns {boolean} -
         */
        containsSphere2(center, radius) {
            var r = -radius;
            if (center.dotArr(this._f[0]) + this._f[0][3] <= r) return false;
            if (center.dotArr(this._f[1]) + this._f[1][3] <= r) return false;
            if (center.dotArr(this._f[2]) + this._f[2][3] <= r) return false;
            if (center.dotArr(this._f[3]) + this._f[3][3] <= r) return false;
            if (center.dotArr(this._f[4]) + this._f[4][3] <= r) return false;
            if (center.dotArr(this._f[5]) + this._f[5][3] <= r) return false;
            return true;
        }

        /**
         * Returns true if the frustum contains a bounding box.
         * @public
         * @param {Box} box - Bounding box.
         * @returns {boolean} -
         */
        containsBox(box) {
            var result = true,
                cout,
                cin;

            for (var i = 0; i < 6; i++) {
                cout = 0;
                cin = 0;

                for (var k = 0; k < 8 && (cin === 0 || cout === 0); k++) {
                    var d = box.vertices[k].dotArr(this._f[i]) + this._f[i][3];
                    if (d < 0) {
                        cout++;
                    } else {
                        cin++;
                    }
                }

                if (cin === 0) {
                    return false;
                } else if (cout > 0) {
                    result = true;
                }
            }

            return result;
        }
    }

    /**
     * Camera class.
     * @class
     * @param {Renderer} [renderer] - Renderer uses the camera instance.
     * @param {Object} [options] - Camera options:
     * @param {Object} [options.name] - Camera name.
     * @param {number} [options.viewAngle=38] - Camera angle of view. Default is 30.0
     * @param {number} [options.near=1] - Camera near plane distance. Default is 1.0
     * @param {number} [options.far=og.math.MAX] - Camera far plane distance. Deafult is og.math.MAX
     * @param {Vec3} [options.eye=[0,0,0]] - Camera eye position. Default (0,0,0)
     * @param {Vec3} [options.look=[0,0,0]] - Camera look position. Default (0,0,0)
     * @param {Vec3} [options.up=[0,1,0]] - Camera eye position. Default (0,1,0)
     *
     * @fires og.Camera#viewchange
     */
    class Camera {
        /**
         * @param {Renderer} [renderer] - Renderer uses the camera instance.
         * @param {Object} [options] - Camera options:
         */
        constructor(renderer, options) {
            /**
             * Assigned renderer
             * @public
             * @type {Renderer}
             */
            this.renderer = renderer;

            /**
             * Camera events handler
             * @public
             * @type {Events}
             */
            this.events = new Events(EVENT_NAMES$4, this);

            /**
             * Camera position.
             * @public
             * @type {Vec3}
             */
            this.eye = new Vec3();

            /**
             * Camera RTE high position
             * @public
             * @type {Vec3}
             */
            this.eyeHigh = new Float32Array(3);

            /**
             * Camera RTE low position
             * @public
             * @type {Vec3}
             */
            this.eyeLow = new Float32Array(3);

            /**
             * Aspect ratio.
             * @protected
             * @type {Number}
             */
            this._aspect = options.aspect || this.renderer.handler.getClientAspect();

            /**
             * Camera view angle in degrees
             * @protected
             * @type {Number}
             */
            this._viewAngle = options.viewAngle || 38.0;

            /**
             * Camera normal matrix.
             * @protected
             * @type {Mat3}
             */
            this._normalMatrix = new Mat3();

            /**
             * Camera view matrix.
             * @protected
             * @type {Mat4}
             */
            this._viewMatrix = new Mat4();

            /**
             * Camera right vector.
             * @protected
             * @type {Vec3}
             */
            this._r = new Vec3(1.0, 0.0, 0.0); // up x n

            /**
             * Camera up vector.
             * @protected
             * @type {Vec3}
             */
            this._u = new Vec3(0.0, 1.0, 0.0); // n x u - UP

            /**
             * Camera forward vector.
             * @protected
             * @type {Vec3}
             */
            this._b = new Vec3(0.0, 0.0, 1.0); // eye - look - FORWARD

            // Previous frame values
            this._pu = this._r.clone();
            this._pv = this._u.clone();
            this._pn = this._b.clone();
            this._peye = this.eye.clone();
            this.isMoved = false;

            this._tanViewAngle_hrad = 0.0;
            this._tanViewAngle_hradOneByHeight = 0.0;

            this.frustums = [];

            this.nearFarArr = [];

            this.frustumColors = [];

            if (options.frustums) {
                for (let i = 0, len = options.frustums.length; i < len; i++) {
                    let fi = options.frustums[i];

                    let fr = new Frustum({
                        fov: this._viewAngle,
                        aspect: this._aspect,
                        near: fi[0],
                        far: fi[1]
                    });

                    fr._cameraFrustumIndex = this.frustums.length;
                    this.frustums.push(fr);
                    this.renderer.assignPickingColor(fr);
                    this.nearFarArr.push.apply(this.nearFarArr, [fi[0], fi[1]]);
                    this.frustumColors.push.apply(this.frustumColors, fr._pickingColorU);
                }
            } else {
                let near = 1.0,
                    far = 10000.0;

                let fr = new Frustum({
                    fov: this._viewAngle,
                    aspect: this._aspect,
                    near: near,
                    far: far
                });

                fr._cameraFrustumIndex = this.frustums.length;
                this.frustums.push(fr);
                this.renderer.assignPickingColor(fr);
                this.nearFarArr = new Array([near, far]);
                this.frustumColors.push.apply(this.frustumColors, fr._pickingColorU);
            }

            this.FARTHEST_FRUSTUM_INDEX = this.frustums.length - 1;

            this._currentFrustum = 0;

            renderer && this._init(options);
        }

        checkMoveEnd() {
            var u = this._r,
                v = this._u,
                n = this._b,
                eye = this.eye;

            if (this._peye.equal(eye) && this._pu.equal(u) && this._pv.equal(v) && this._pn.equal(n)) {
                if (this.isMoved) {
                    this.events.dispatch(this.events.moveend, this);
                }
                this.isMoved = false;
            } else {
                this.isMoved = true;
            }

            this._pu.copy(u);
            this._pv.copy(v);
            this._pn.copy(n);
            this._peye.copy(eye);
        }

        /**
         * Camera initialization.
         * @public
         * @param {Renderer} renderer - OpenGlobus renderer object.
         * @param {Object} [options] - Camera options:
         * @param {number} [options.viewAngle] - Camera angle of view. Default is 30.0
         * @param {number} [options.near] - Camera near plane distance. Default is 1.0
         * @param {number} [options.far] - Camera far plane distance. Deafult is og.math.MAX
         * @param {Vec3} [options.eye] - Camera eye position. Default (0,0,0)
         * @param {Vec3} [options.look] - Camera look position. Default (0,0,0)
         * @param {Vec3} [options.up] - Camera eye position. Default (0,1,0)
         */
        _init(options) {
            this._setProj(this._viewAngle, this._aspect);

            this.set(
                options.eye || new Vec3(0.0, 0.0, 1.0),
                options.look || new Vec3(),
                options.up || new Vec3(0.0, 1.0, 0.0)
            );
        }

        getUp() {
            return this._u.clone();
        }

        getDown() {
            return this._u.negateTo();
        }

        getRight() {
            return this._r.clone();
        }

        getLeft() {
            return this._r.negateTo();
        }

        getForward() {
            return this._b.negateTo();
        }

        getBackward() {
            return this._b.clone();
        }

        /**
         * Updates camera view space
         * @public
         * @virtual
         */
        update() {
            var u = this._r,
                v = this._u,
                n = this._b,
                eye = this.eye;

            Vec3.doubleToTwoFloat32Array(eye, this.eyeHigh, this.eyeLow);

            this._viewMatrix.set([
                u.x,
                v.x,
                n.x,
                0.0,
                u.y,
                v.y,
                n.y,
                0.0,
                u.z,
                v.z,
                n.z,
                0.0,
                -eye.dot(u),
                -eye.dot(v),
                -eye.dot(n),
                1.0
            ]);

            this._normalMatrix = this._viewMatrix.toMatrix3(); // this._viewMatrix.toInverseMatrix3().transposeTo();

            for (let i = 0, len = this.frustums.length; i < len; i++) {
                this.frustums[i].setViewMatrix(this._viewMatrix);
            }

            this.events.dispatch(this.events.viewchange, this);
        }

        /**
         * Refresh camera matrices
         * @public
         */
        refresh() {
            this._setProj(this._viewAngle, this._aspect);
            this.update();
        }

        /**
         * Sets aspect ratio
         * @public
         * @param {Number} aspect - Camera aspect ratio
         */
        setAspectRatio(aspect) {
            this._aspect = aspect;
            this.refresh();
        }

        /**
         * Returns aspect ratio
         * @public
         * @returns {number} - Aspect ratio
         */
        getAspectRatio() {
            return this._aspect;
        }

        /**
         * Sets up camera projection
         * @public
         * @param {nnumber} angle - Camera's view angle
         * @param {number} aspect - Screen aspect ration
         */
        _setProj(angle, aspect) {
            this._viewAngle = angle;
            this._aspect = aspect;
            this._tanViewAngle_hrad = Math.tan(angle * RADIANS_HALF);
            this._tanViewAngle_hradOneByHeight =
                this._tanViewAngle_hrad * this.renderer.handler._oneByHeight;
            var c = this.renderer.handler.canvas;
            this._projSizeConst = Math.min(c.clientWidth < 256 ? 256 : c.clientWidth, c.clientHeight < 256 ? 256 : c.clientHeight) / (angle * RADIANS);
            for (let i = 0, len = this.frustums.length; i < len; i++) {
                this.frustums[i].setProjectionMatrix(
                    angle,
                    aspect,
                    this.frustums[i].near,
                    this.frustums[i].far
                );
            }
        }

        /**
         * Sets camera view angle in degrees
         * @public
         * @param {number} angle - View angle
         */
        setViewAngle(angle) {
            this._viewAngle = angle;
            this.refresh();
        }

        /**
         * Gets camera view angle in degrees
         * @public
         * @returns {number} angle -
         */
        getViewAngle() {
            return this._viewAngle;
        }

        /**
         * Sets camera to eye position
         * @public
         * @param {Vec3} eye - Camera position
         * @param {Vec3} look - Look point
         * @param {Vec3} up - Camera up vector
         * @returns {Camera} - This camera
         */
        set(eye, look, up) {
            this.eye.x = eye.x;
            this.eye.y = eye.y;
            this.eye.z = eye.z;
            look = look || this._b;
            up = up || this._u;
            this._b.x = eye.x - look.x;
            this._b.y = eye.y - look.y;
            this._b.z = eye.z - look.z;
            this._r.copy(up.cross(this._b));
            this._b.normalize();
            this._r.normalize();
            this._u.copy(this._b.cross(this._r));
            return this;
        }

        /**
         * Sets camera look point
         * @public
         * @param {Vec3} look - Look point
         * @param {Vec3} [up] - Camera up vector otherwise camera current up vector(this._u)
         */
        look(look, up) {
            this._b.set(this.eye.x - look.x, this.eye.y - look.y, this.eye.z - look.z);
            this._r.copy((up || this._u).cross(this._b));
            this._b.normalize();
            this._r.normalize();
            this._u.copy(this._b.cross(this._r));
        }

        /**
         * Slides camera to vector d - (du, dv, dn)
         * @public
         * @param {number} du - delta X
         * @param {number} dv - delta Y
         * @param {number} dn - delta Z
         */
        slide(du, dv, dn) {
            this.eye.x += du * this._r.x + dv * this._u.x + dn * this._b.x;
            this.eye.y += du * this._r.y + dv * this._u.y + dn * this._b.y;
            this.eye.z += du * this._r.z + dv * this._u.z + dn * this._b.z;
        }

        /**
         * Roll the camera to the angle in degrees
         * @public
         * @param {number} angle - Delta roll angle in degrees
         */
        roll(angle) {
            var cs = Math.cos(RADIANS * angle);
            var sn = Math.sin(RADIANS * angle);
            var t = this._r.clone();
            this._r.set(
                cs * t.x - sn * this._u.x,
                cs * t.y - sn * this._u.y,
                cs * t.z - sn * this._u.z
            );
            this._u.set(
                sn * t.x + cs * this._u.x,
                sn * t.y + cs * this._u.y,
                sn * t.z + cs * this._u.z
            );
        }

        /**
         * Pitch the camera to the angle in degrees
         * @public
         * @param {number} angle - Delta pitch angle in degrees
         */
        pitch(angle) {
            var cs = Math.cos(RADIANS * angle);
            var sn = Math.sin(RADIANS * angle);
            var t = this._b.clone();
            this._b.set(
                cs * t.x - sn * this._u.x,
                cs * t.y - sn * this._u.y,
                cs * t.z - sn * this._u.z
            );
            this._u.set(
                sn * t.x + cs * this._u.x,
                sn * t.y + cs * this._u.y,
                sn * t.z + cs * this._u.z
            );
        }

        /**
         * Yaw the camera to the angle in degrees
         * @public
         * @param {number} angle - Delta yaw angle in degrees
         */
        yaw(angle) {
            var cs = Math.cos(RADIANS * angle);
            var sn = Math.sin(RADIANS * angle);
            var t = this._r.clone();
            this._r.set(
                cs * t.x - sn * this._b.x,
                cs * t.y - sn * this._b.y,
                cs * t.z - sn * this._b.z
            );
            this._b.set(
                sn * t.x + cs * this._b.x,
                sn * t.y + cs * this._b.y,
                sn * t.z + cs * this._b.z
            );
        }

        /**
         * Returns normal vector direction to to the unprojected screen point from camera eye
         * @public
         * @param {number} x - Scren X coordinate
         * @param {number} y - Scren Y coordinate
         * @returns {Vec3} - Direction vector
         */
        unproject(x, y) {
            var c = this.renderer.handler.canvas,
                w = c.width * 0.5,
                h = c.height * 0.5;

            var px = (x - w) / w,
                py = -(y - h) / h;

            var world1 = this.frustums[0]._inverseProjectionViewMatrix.mulVec4(new Vec4(px, py, -1.0, 1.0)).affinity(),
                world2 = this.frustums[0]._inverseProjectionViewMatrix.mulVec4(new Vec4(px, py, 0.0, 1.0)).affinity();

            return world2.subA(world1).toVec3().normalize();
        }

        /**
         * Gets projected 3d point to the 2d screen coordiantes
         * @public
         * @param {Vec3} v - Cartesian 3d coordiantes
         * @returns {Vec2} - Screen point coordinates
         */
        project(v) {
            var r = this.frustums[0]._projectionViewMatrix.mulVec4(v.toVec4()),
                c = this.renderer.handler.canvas;
            return new Vec2((1 + r.x / r.w) * c.width * 0.5, (1 - r.y / r.w) * c.height * 0.5);
        }

        /**
         * Rotates camera around center point
         * @public
         * @param {number} angle - Rotation angle in radians
         * @param {boolean} isArc - If true camera up vector gets from current up vector every frame,
         * otherwise up is always input parameter.
         * @param {Vec3} center - Point that the camera rotates around
         * @param {Vecto3} [up] - Camera up vector
         */
        rotateAround(angle, isArc, center, up) {
            center = center || Vec3.ZERO;
            up = up || Vec3.UP;

            var rot = new Mat4().setRotation(isArc ? this._u : up, angle);
            var tr = new Mat4().setIdentity().translate(center);
            var ntr = new Mat4().setIdentity().translate(center.negateTo());

            var trm = tr.mul(rot).mul(ntr);

            this.eye = trm.mulVec3(this.eye);
            this._u = rot.mulVec3(this._u).normalize();
            this._r = rot.mulVec3(this._r).normalize();
            this._b = rot.mulVec3(this._b).normalize();
        }

        /**
         * Rotates camera around center point by horizontal.
         * @public
         * @param {number} angle - Rotation angle in radians.
         * @param {boolaen} isArc - If true camera up vector gets from current up vector every frame,
         * otherwise up is always input parameter.
         * @param {Vec3} center - Point that the camera rotates around.
         * @param {Vec3} [up] - Camera up vector.
         */
        rotateHorizontal(angle, isArc, center, up = Vec3.ZERO) {
            this.rotateAround(angle, isArc, center, up);
        }

        /**
         * Rotates camera around center point by vecrtical.
         * @param {number} angle - Rotation angle in radians.
         * @param {Vec3} center - Point that the camera rotates around.
         */
        rotateVertical(angle, center) {
            this.rotateAround(angle, false, center, this._r);
        }

        /**
         * Gets 3d size factor. Uses in LOD distance calculation.
         * @public
         * @param {Vec3} p - Far point.
         * @param {Vec3} r - Far point.
         * @returns {number} - Size factor.
         */
        projectedSize(p, r) {
            return Math.atan(r / this.eye.distance(p)) * this._projSizeConst;
        }

        /**
         * Returns normal matrix.
         * @public
         * @returns {Mat3} - Normal matrix.
         */
        getNormalMatrix() {
            return this._normalMatrix._m;
        }

        /**
         * Returns model matrix.
         * @public
         * @returns {Mat4} - View matrix.
         */
        getViewMatrix() {
            return this._viewMatrix._m;
        }

        setCurrentFrustum(k) {
            this._currentFrustum = k;
        }

        getCurrentFrustum() {
            return this._currentFrustum;
        }

        get frustum() {
            return this.frustums[this._currentFrustum];
        }

        /**
         * Returns projection matrix.
         * @public
         * @returns {Mat4} - Projection matrix.
         */
        getProjectionMatrix() {
            return this.frustum._projectionMatrix._m;
        }

        /**
         * Returns projection and model matrix product.
         * @public
         * @return {Mat4} - Projection-view matrix.
         */
        getProjectionViewMatrix() {
            return this.frustum._projectionViewMatrix._m;
        }

        /**
         * Returns inverse projection and model matrix product.
         * @public
         * @returns {Mat4} - Inversed projection-view matrix.
         */
        getInverseProjectionViewMatrix() {
            return this.frustum._inverseProjectionViewMatrix._m;
        }

        /**
         * Returns inverse projection matrix.
         * @public
         * @returns {Mat4} - Inversed projection-view matrix.
         */
        getInverseProjectionMatrix() {
            return this.frustum._inverseProjectionMatrix._m;
        }
    }

    const EVENT_NAMES$4 = [
        /**
         * When camera has been updated.
         * @event og.Camera#viewchange
         */
        "viewchange",

        /**
         * Camera is stopped.
         * @event og.Camera#moveend
         */
        "moveend"
    ];

    /**
     * @module og/camera/PlanetCamera
     */

    /**
     * Planet camera.
     * @class
     * @extends {Camera}
     * @param {RenderNode} planet - Planet render node.
     * @param {Object} [options] - Planet camera options:
     * @param {Object} [options.name] - Camera name.
     * @param {number} [options.viewAngle=37] - Camera angle of view. Default is 35.0
     * @param {number} [options.near] - Camera near plane distance. Default is 1.0
     * @param {number} [options.far] - Camera far plane distance. Deafult is og.math.MAX
     * @param {number} [options.minAltitude] - Minimal altitude for the camera. Deafult is 5
     * @param {number} [options.maxAltitude] - Maximal altitude for the camera. Deafult is 20000000
     * @param {Vec3} [options.eye] - Camera eye position. Default (0,0,0)
     * @param {Vec3} [options.look] - Camera look position. Default (0,0,0)
     * @param {Vec3} [options.up] - Camera eye position. Default (0,1,0)
     */
    class PlanetCamera extends Camera {
        /**
         * @param {RenderNode} planet - Planet render node.
         * @param {Object} [options] - Planet camera options:
         */
        constructor(planet, options) {
            super(planet.renderer, {
                frustums: [
                    [1, 100 + 0.075],
                    [100, 1000 + 0.075],
                    [1000, 1e6 + 10000],
                    [1e6, 1e9]
                ], //[[1, 1e3 + 100], [1e3, 1e6 + 10000], [1e6, 1e9]]*/
                ...options
            }
            );
            /**
             * Assigned camera's planet.
             * @public
             * @type {Planet}
             */
            this.planet = planet;

            /**
             * Minimal alltitude that camera can reach over the terrain.
             * @public
             * @type {number}
             */
            this.minAltitude = options.minAltitude || 5;

            /**
             * Maximal alltitude that camera can reach over the globe.
             * @public
             * @type {number}
             */
            this.maxAltitude = options.maxAltitude || 20000000;

            /**
             * Current geographical degree position.
             * @protected
             * @type {LonLat}
             */
            this._lonLat = this.planet.ellipsoid.cartesianToLonLat(this.eye);

            /**
             * Current geographical mercator position.
             * @protected
             * @type {LonLat}
             */
            this._lonLatMerc = this._lonLat.forwardMercator();

            /**
             * Current altitude.
             * @protected
             * @type {number}
             */
            this._terrainAltitude = this._lonLat.height;

            /**
             * Cartesian coordinates on the terrain.
             * @protected
             * @type {Vec3}
             */
            this._terrainPoint = new Vec3();

            /**
             * Quad node that camera flies over.
             * @protected
             * @type {quadTree.Node}
             */
            this._insideSegment = null;

            /**
             * Coordinates that depends on what segment class we are fling over.
             * It can be WGS84 or Mercator coordinates. Gets in og.quadTree.Node
             * @protected
             * @type {LonLat}
             */
            this._insideSegmentPosition = new LonLat();

            this.slope = 0;

            this._keyLock = new Key();

            // Camera's flying frames
            this._framesArr = [];
            this._framesCounter = 0;
            this._numFrames = 50;
            this._completeCallback = null;
            this._flying = false;
        }

        /**
         * Updates camera view space.
         * @public
         * @virtual
         */
        update() {
            this.events.stopPropagation();

            let maxAlt = this.maxAltitude + this.planet.ellipsoid._a;

            if (this.eye.length() > maxAlt) {
                this.eye.copy(this.eye.normal().scale(maxAlt));
            }

            super.update();
            this.updateGeodeticPosition();
            this.eyeNorm = this.eye.normal();
            this.slope = this._b.dot(this.eyeNorm);
            this.events.dispatch(this.events.viewchange, this);
        }

        updateGeodeticPosition() {
            this._lonLat = this.planet.ellipsoid.cartesianToLonLat(this.eye);
            if (Math.abs(this._lonLat.lat) <= MAX_LAT) {
                this._lonLatMerc = this._lonLat.forwardMercator();
            }
        }

        /**
         * Sets altitude over the terrain.
         * @public
         * @param {number} alt - Altitude over the terrain.
         */
        setAltitude(alt) {
            var n = this.eye.normal();
            var t = this._terrainPoint;
            this.eye.x = n.x * alt + t.x;
            this.eye.y = n.y * alt + t.y;
            this.eye.z = n.z * alt + t.z;
            this._terrainAltitude = alt;
        }

        /**
         * Gets altitude over the terrain.
         * @public
         */
        getAltitude() {
            return this._terrainAltitude;
        }

        /**
         * Places camera to view to the geographical point.
         * @public
         * @param {LonLat} lonlat - New camera and camera view position.
         * @param {LonLat} [lookLonLat] - Look up coordinates.
         * @param {Vec3} [up] - Camera UP vector. Default (0,1,0)
         */
        setLonLat(lonlat, lookLonLat, up) {
            this.stopFlying();
            this._lonLat.set(lonlat.lon, lonlat.lat, lonlat.height || this._lonLat.height);
            var el = this.planet.ellipsoid;
            var newEye = el.lonLatToCartesian(this._lonLat);
            var newLook = lookLonLat ? el.lonLatToCartesian(lookLonLat) : Vec3.ZERO;
            this.set(newEye, newLook, up || Vec3.UP);
            this.update();
        }

        /**
         * Returns camera geographical position.
         * @public
         * @returns {LonLat}
         */
        getLonLat() {
            return this._lonLat;
        }

        /**
         * Returns camera height.
         * @public
         * @returns {number}
         */
        getHeight() {
            return this._lonLat.height;
        }

        /**
         * Gets position by viewable extent.
         * @public
         * @param {Extent} extent - Viewable extent.
         * @param {Number} height - Camera height
         * @returns {Vec3}
         */
        getExtentPosition(extent, height) {
            var north = extent.getNorth();
            var south = extent.getSouth();
            var east = extent.getEast();
            var west = extent.getWest();

            if (west > east) {
                east += 360;
            }

            var e = this.planet.ellipsoid;

            var cart = new LonLat(east, north);
            var northEast = e.lonLatToCartesian(cart);
            cart.lat = south;
            var southEast = e.lonLatToCartesian(cart);
            cart.lon = west;
            var southWest = e.lonLatToCartesian(cart);
            cart.lat = north;
            var northWest = e.lonLatToCartesian(cart);

            var center = Vec3.sub(northEast, southWest).scale(0.5).addA(southWest);

            var mag = center.length();
            if (mag < 0.000001) {
                cart.lon = (east + west) * 0.5;
                cart.lat = (north + south) * 0.5;
                center = e.lonLatToCartesian(cart);
            }

            northWest.subA(center);
            southEast.subA(center);
            northEast.subA(center);
            southWest.subA(center);

            var direction = center.normal(); // ellipsoid.getSurfaceNormal(center).negate().normalize();
            var right = direction.cross(Vec3.UP).normalize();
            var up = right.cross(direction).normalize();

            var _h = Math.max(
                Math.abs(up.dot(northWest)),
                Math.abs(up.dot(southEast)),
                Math.abs(up.dot(northEast)),
                Math.abs(up.dot(southWest))
            );

            var _w = Math.max(
                Math.abs(right.dot(northWest)),
                Math.abs(right.dot(southEast)),
                Math.abs(right.dot(northEast)),
                Math.abs(right.dot(southWest))
            );

            var tanPhi = Math.tan(this._viewAngle * RADIANS * 0.5);
            var tanTheta = this._aspect * tanPhi;
            var d = Math.max(_w / tanTheta, _h / tanPhi);

            center.normalize();
            center.scale(mag + d + (height || 0));

            return center;
        }

        /**
         * View current extent.
         * @public
         * @param {Extent} extent - Current extent.
         */
        viewExtent(extent, height) {
            this.stopFlying();
            this.set(this.getExtentPosition(extent, height), Vec3.ZERO, Vec3.UP);
            this.update();
        }

        /**
         * Flies to the current extent.
         * @public
         * @param {Extent} extent - Current extent.
         * @param {Vec3} [up] - Camera UP in the end of flying. Default - (0,1,0)
         * @param {Number} [ampl] - Altitude amplitude factor.
         * @param {cameraCallback} [completeCallback] - Callback that calls after flying when flying is finished.
         * @param {cameraCallback} [startCallback] - Callback that calls befor the flying begins.
         * @param [frameCallback]
         */
        flyExtent(extent, height, up, ampl, completeCallback, startCallback, frameCallback) {
            this.flyCartesian(
                this.getExtentPosition(extent, height),
                Vec3.ZERO,
                up,
                ampl,
                completeCallback,
                startCallback,
                frameCallback
            );
        }

        viewDistance(cartesian, distance = 10000.0) {
            let p0 = this.eye.add(this.getForward().scaleTo(distance));
            let _rot = Quat.getRotationBetweenVectors(p0.normal(), cartesian.normal());
            if (_rot.isZero()) {
                let newPos = cartesian.add(this.getBackward().scaleTo(distance));
                this.set(newPos, cartesian);
            } else {
                let newPos = cartesian.add(_rot.mulVec3(this.getBackward()).scale(distance)),
                    newUp = _rot.mulVec3(this.getUp());
                this.set(newPos, cartesian, newUp);
            }
            this.update();
        }

        flyDistance(
            cartesian,
            distance = 10000.0,
            ampl = 0.0,
            completeCallback,
            startCallback,
            frameCallback
        ) {
            let p0 = this.eye.add(this.getForward().scaleTo(distance));
            let _rot = Quat.getRotationBetweenVectors(p0.normal(), cartesian.normal());
            if (_rot.isZero()) {
                let newPos = cartesian.add(this.getBackward().scaleTo(distance));
                this.set(newPos, cartesian);
            } else {
                let newPos = cartesian.add(_rot.mulVec3(this.getBackward()).scale(distance)),
                    newUp = _rot.mulVec3(this.getUp());
                this.flyCartesian(
                    newPos,
                    cartesian,
                    newUp,
                    ampl,
                    completeCallback,
                    startCallback,
                    frameCallback
                );
            }
        }

        /**
         * Flies to the cartesian coordinates.
         * @public
         * @param {Vec3} cartesian - Finish cartesian coordinates.
         * @param {Vec3} [look] - Camera LOOK in the end of flying. Default - (0,0,0)
         * @param {Vec3} [up] - Camera UP vector in the end of flying. Default - (0,1,0)
         * @param {Number} [ampl=1.0] - Altitude amplitude factor.
         * @param {cameraCallback} [completeCallback] - Callback that calls after flying when flying is finished.
         * @param {cameraCallback} [startCallback] - Callback that calls befor the flying begins.
         * @param [frameCallback]
         */
        flyCartesian(cartesian, look = Vec3.ZERO, up = Vec3.UP, ampl = 1.0, completeCallback = () => { }, startCallback = () => { }, frameCallback = () => { }) {

            this.stopFlying();

            look = look || Vec3.ZERO;
            up = up || Vec3.UP;

            this._completeCallback = completeCallback;

            this._frameCallback = frameCallback;

            if (startCallback) {
                startCallback.call(this);
            }

            if (look instanceof LonLat) {
                look = this.planet.ellipsoid.lonLatToCartesian(look);
            }

            var ground_a = this.planet.ellipsoid.lonLatToCartesian(
                new LonLat(this._lonLat.lon, this._lonLat.lat)
            );
            var v_a = this._u,
                n_a = this._b;

            var lonlat_b = this.planet.ellipsoid.cartesianToLonLat(cartesian);
            var up_b = up;
            var ground_b = this.planet.ellipsoid.lonLatToCartesian(
                new LonLat(lonlat_b.lon, lonlat_b.lat, 0)
            );
            var eye_b = cartesian;
            var n_b = Vec3.sub(eye_b, look);
            var u_b = up_b.cross(n_b);
            n_b.normalize();
            u_b.normalize();
            var v_b = n_b.cross(u_b);

            var an = ground_a.normal();
            var bn = ground_b.normal();
            var anbn = 1.0 - an.dot(bn);
            var hM_a = ampl * SQRT_HALF * Math.sqrt(anbn > 0.0 ? anbn : 0.0);

            var maxHeight = 6639613;
            var currMaxHeight = Math.max(this._lonLat.height, lonlat_b.height);
            if (currMaxHeight > maxHeight) {
                maxHeight = currMaxHeight;
            }
            var max_h = currMaxHeight + 2.5 * hM_a * (maxHeight - currMaxHeight);
            var zero = Vec3.ZERO;

            // camera path and orientations calculation
            for (var i = 0; i <= this._numFrames; i++) {
                var d = 1 - i / this._numFrames;
                d = d * d * (3 - 2 * d);
                d *= d;

                // Error here
                var g_i = ground_a.smerp(ground_b, d).normalize();
                var ground_i = this.planet.getRayIntersectionEllipsoid(new Ray$1(zero, g_i));
                var t = 1 - d;
                var height_i =
                    this._lonLat.height * d * d * d +
                    max_h * 3 * d * d * t +
                    max_h * 3 * d * t * t +
                    lonlat_b.height * t * t * t;

                var eye_i = ground_i.addA(g_i.scale(height_i));
                var up_i = v_a.smerp(v_b, d);
                var look_i = Vec3.add(eye_i, n_a.smerp(n_b, d).negateTo());

                var n = new Vec3(eye_i.x - look_i.x, eye_i.y - look_i.y, eye_i.z - look_i.z);
                var u = up_i.cross(n);
                n.normalize();
                u.normalize();

                var v = n.cross(u);
                this._framesArr[i] = {
                    eye: eye_i,
                    n: n,
                    u: u,
                    v: v
                };
            }

            this._framesCounter = this._numFrames;
            this._flying = true;
        }

        /**
         * Flies to the geo coordiantes.
         * @public
         * @param {LonLat} lonlat - Finish coordinates.
         * @param {Vec3} [look] - Camera LOOK in the end of flying. Default - (0,0,0)
         * @param {Vec3} [up] - Camera UP vector in the end of flying. Default - (0,1,0)
         * @param {Number} [ampl] - Altitude amplitude factor.
         * @param {cameraCallback} [completeCallback] - Callback that calls after flying when flying is finished.
         * @param {cameraCallback} [startCallback] - Callback that calls befor the flying begins.
         */
        flyLonLat(lonlat, look, up, ampl, completeCallback, startCallback) {
            var _lonlat = new LonLat(lonlat.lon, lonlat.lat, lonlat.height || this._lonLat.height);
            this.flyCartesian(
                this.planet.ellipsoid.lonLatToCartesian(_lonlat),
                look,
                up,
                ampl,
                completeCallback,
                startCallback
            );
        }

        /**
         * Breaks the flight.
         * @public
         */
        stopFlying() {
            this.planet.layerLock.free(this._keyLock);
            this.planet.terrainLock.free(this._keyLock);
            this.planet._normalMapCreator.free(this._keyLock);

            this._flying = false;
            this._framesArr.length = 0;
            this._framesArr = [];
            this._framesCounter = -1;
            this._frameCallback = null;
        }

        /**
         * Returns camera is flying.
         * @public
         * @returns {boolean}
         */
        isFlying() {
            return this._flying;
        }

        /**
         * Rotates around planet to the left.
         * @public
         * @param {number} angle - Rotation angle.
         * @param {boolean} [spin] - If its true rotates around globe spin.
         */
        rotateLeft(angle, spin) {
            this.rotateHorizontal(angle * RADIANS, spin ^ true, Vec3.ZERO);
            this.update();
        }

        /**
         * Rotates around planet to the right.
         * @public
         * @param {number} angle - Rotation angle.
         * @param {boolean} [spin] - If its true rotates around globe spin.
         */
        rotateRight(angle, spin) {
            this.rotateHorizontal(-angle * RADIANS, spin ^ true, Vec3.ZERO);
            this.update();
        }

        /**
         * Rotates around planet to the north pole.
         * @public
         * @param {number} angle - Rotation angle.
         */
        rotateUp(angle) {
            this.rotateVertical(angle * RADIANS, Vec3.ZERO);
            this.update();
        }

        /**
         * Rotates around planet to the south pole.
         * @public
         * @param {number} angle - Rotation angle.
         */
        rotateDown(angle) {
            this.rotateVertical(-angle * RADIANS, Vec3.ZERO);
            this.update();
        }

        rotateVertical(angle, center, minSlope = 0) {
            var rot = new Mat4().setRotation(this._r, angle);
            var tr = new Mat4().setIdentity().translate(center);
            var ntr = new Mat4().setIdentity().translate(center.negateTo());
            var trm = tr.mul(rot).mul(ntr);

            let eye = trm.mulVec3(this.eye);
            let u = rot.mulVec3(this._u).normalize();
            let r = rot.mulVec3(this._r).normalize();
            let b = rot.mulVec3(this._b).normalize();

            let eyeNorm = eye.normal();
            let slope = b.dot(eyeNorm);

            if (minSlope) {
                let dSlope = slope - this.slope;

                if (slope < minSlope && dSlope < 0) return;

                if (
                    (slope > 0.1 && u.dot(eyeNorm) > 0) ||
                    this.slope <= 0.1 ||
                    this._u.dot(this.eye.normal()) <= 0.0
                ) {
                    this.eye = eye;
                    this._u = u;
                    this._r = r;
                    this._b = b;
                }
            } else {
                this.eye = eye;
                this._u = u;
                this._r = r;
                this._b = b;
            }
        }

        /**
         * Prepare camera to the frame. Used in render node frame function.
         * @public
         */
        checkFly() {
            if (this._flying) {
                var c = this._numFrames - this._framesCounter;

                this.planet.layerLock.lock(this._keyLock);
                this.planet.terrainLock.lock(this._keyLock);
                this.planet._normalMapCreator.lock(this._keyLock);

                this.eye = this._framesArr[c].eye;
                this._r = this._framesArr[c].u;
                this._u = this._framesArr[c].v;
                this._b = this._framesArr[c].n;

                if (this._frameCallback) {
                    this._frameCallback();
                }

                this.update();

                this._framesCounter--;

                if (this._framesCounter < 0) {
                    this.stopFlying();
                    if (this._completeCallback) {
                        this._completeCallback();
                        this._completeCallback = null;
                    }
                }
            }
        }

        checkTerrainCollision() {
            this._terrainAltitude = this._lonLat.height;
            if (this._insideSegment && this._insideSegment.planet) {
                this._terrainAltitude = this._insideSegment.getTerrainPoint(
                    this.eye,
                    this._insideSegmentPosition,
                    this._terrainPoint
                );
                if (this._terrainAltitude < this.minAltitude) {
                    this.setAltitude(this.minAltitude);
                }
            }
        }

        getSurfaceVisibleDistance(d) {
            let R = this.planet.ellipsoid._a;
            return R * Math.acos(R / (R + this._lonLat.height + d));
        }

        getHeading() {
            let u = this.eye.normal();
            let f = Vec3.proj_b_to_plane(
                this.slope >= 0.97 ? this.getUp() : this.getForward(),
                u
            ).normalize(),
                n = Vec3.proj_b_to_plane(Vec3.UP, u).normalize();
            let res = Math.sign(u.dot(f.cross(n))) * Math.acos(f.dot(n)) * DEGREES;
            if (res < 0.0) {
                return 360.0 + res;
            }
            return res;
        }

        isVisible(poi) {
            let e = this.eye.length();
            return this.eye.distance(poi) < Math.sqrt(e * e - this.planet.ellipsoid._a2);
        }
    }

    /**
     * @module og/scene/BaseNode
     */

    /**
     * Scene node base class.
     * @class
     * @param {string} name - Node name.
     */
    class BaseNode {
        constructor(name) {
            /**
             * Node name.
             * @public
             * @type {string}
             */
            this.name = name;

            /**
             * Top scene tree node pointer.
             * @public
             * @type {RenderNode}
             */
            this.topNode = this;

            this._dictionary = [];
            this._dictionary[name] = this;

            /**
             * Children nodes.
             * @public
             * @type {Array.<RenderNode>}
             */
            this.childNodes = [];

            /**
             * Parent node pointer.
             * @public
             * @type {RenderNode}
             */
            this.parentNode = null;

            this.__staticId = BaseNode._staticCounter++;
        }

        static get _staticCounter() {
            if (!this.__counter__ && this.__counter__ !== 0) {
                this.__counter__ = 0;
            }
            return this.__counter__;
        }

        static set _staticCounter(n) {
            this.__counter__ = n;
        }

        /**
         * Adds node to the current hierarchy.
         * @public
         * @type {BaseNode}
         */
        addNode(node) {
            if (this.parentNode == null) {
                node.topNode = this;
            } else {
                node.topNode = this.topNode;
            }
            node.parentNode = this;
            node._dictionary = this.topNode._dictionary;
            this.childNodes.push(node);
            this.topNode._dictionary[node.name] = node;
        }

        /**
         * Destroy node.
         * @public
         */
        destroy() {
            for (var i = 0; i < this.childNodes.length; i++) {
                this.childNodes[i].destroy();
            }
            this._clear();
        }

        /**
         * Gets node by name in the current.
         * @public
         * @param {string} name - Node name.
         * @return {RenderNode} Node object in the current node.
         */
        getNodeByName(name) {
            return this._dictionary[name];
        }

        /**
         * Clear current node.
         * @protected
         */
        _clear() {
            this.name = "";
            this.parentNode = null;
            this.topNode = null;
            this.childNodes.length = 0;
        }

        isEqual(node) {
            return node.__staticId === this.__staticId;
        }
    }

    /**
     * Render node is a logical part of a render mechanism. Represents scene rendering.
     * Forexample one scene node for rendering the Earth, another one for rendering the Moon, another node for rendering stars etc.
     * Each render node has own model view space defined with matrices(scale, rotation, translation, transformation).
     * There are collections of ligh sources, entities and so on in the node.
     * Access to the node is renderer.renderNodes["Earth"]
     * @class
     * @extends {RenderNode}
     * @param {string} name - Node name.
     */
    class RenderNode extends BaseNode {
        constructor(name) {
            super(name);

            /**
             * Renderer that calls frame() callback.
             * @public
             * @type {Renderer}
             */
            this.renderer = null;

            this.drawMode = null;

            /** Show rendering.
             * @public
             */
            this.show = true;

            this._isActive = true;

            /**
             * Lighting calculations.
             * @public
             * @type {boolean}
             */
            this.lightEnabled = false;

            /**
             * Point light array.
             * @private
             * @type {Array.<LightSource>}
             */
            this._lights = [];
            this._lightsTransformedPositions = [];
            this._lightsParamsv = [];
            this._lightsParamsf = [];
            this._lightsNames = [];

            /**
             * Entity collection array.
             * @public
             * @type {Array.<EntityCollection>}
             */
            this.entityCollections = [];

            this._pickingId = -1;

            this.events = new Events(null, this);
        }

        /**
         * Adds node to the current hierarchy.
         * @public
         * @type {RenderNode}
         */
        addNode(node) {
            super.addNode(node);
            node.assign(this.renderer);
        }

        /**
         * Assign render node with renderer.
         * @public
         * @param {Renderer} renderer - Redner node's renderer.
         */
        assign(renderer) {
            this.renderer = renderer;
            this._pickingId = renderer.addPickingCallback(this, this._entityCollectionPickingCallback);

            for (var i = 0; i < this.entityCollections.length; i++) {
                this.entityCollections[i].bindRenderNode(this);
            }

            this.init && this.init();
        }

        onremove() {
            //virtual
        }

        remove() {
            var r = this.renderer,
                n = this.name;

            if (r) {
                if (r.renderNodes[n] && r.renderNodes[n].isEqual(this)) {
                    r.renderNodes[n] = null;
                    delete r.renderNodes[n];
                }

                for (var i = 0; i < r._renderNodesArr.length; i++) {
                    if (r._renderNodesArr[i].isEqual(this)) {
                        r._renderNodesArr.splice(i, 1);
                        break;
                    }
                }
                r.removePickingCallback(this._pickingId);
                this._pickingId = -1;
                this.onremove && this.onremove();
            }
        }

        /**
         * Adds entity collection.
         * @public
         * @param {EntityCollection} entityCollection - Entity collection.
         * @param {boolean} [isHidden] - If it's true that this collection has specific rendering.
         * @returns {RenderNode} -
         */
        addEntityCollection(entityCollection, isHidden) {
            entityCollection.addTo(this, isHidden);
            return this;
        }

        /**
         * Removes entity collection.
         * @public
         * @param {EntityCollection} entityCollection - Entity collection for remove.
         */
        removeEntityCollection(entityCollection) {
            entityCollection.remove();
        }

        /**
         * Adds point light source.
         * @public
         * @param {LightSource} light - Light source.
         * @returns {RenderNode}
         */
        addLight(light) {
            light.addTo(this);
            return this;
        }

        /**
         * Gets light object by its name.
         * @public
         * @param {string} name - Point light name.
         * @returns {LightSource}
         */
        getLightByName(name) {
            var li = this._lightsNames.indexOf(name);
            return this._lights[li];
        }

        /**
         * Removes light source.
         * @public
         * @param {LightSource} light - Light source object.
         */
        removeLight(light) {
            light.remove();
        }

        /**
         * Calls render frame node's callback. Used in renderer.
         * @public
         */
        drawNode(frustum, frustumIndex) {
            this._isActive && this._drawNodes(frustum, frustumIndex);
        }

        /**
         * Gets render node activity.
         * @public
         * @returns {Boolean} -
         */
        isActive() {
            return this._isActive;
        }

        /**
         * Rendering activation.
         * @public
         * @param {boolean} isActive - Activation flag.
         */
        setActive(isActive) {
            this._isActive = isActive;

            if (this.renderer) {
                if (this._isActive && this._pickingId === -1) {
                    this._pickingId = this.renderer.addPickingCallback(
                        this,
                        this._entityCollectionPickingCallback
                    );
                } else if (!this._isActive && this._pickingId !== -1) {
                    this.renderer.removePickingCallback(this._pickingId);
                    this._pickingId = -1;
                }
            }

            for (var i = 0; i < this.childNodes.length; i++) {
                this.childNodes[i].setActive(isActive);
            }
        }

        /**
         * Sets draw mode
         * @public
         * @param {Number} mode - Draw mode, such as gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.LINES etc.
         */
        setDrawMode(mode) {
            this.drawMode = mode;
            for (var i = 0; i < this.childNodes.length; i++) {
                this.childNodes[i].setDrawMode(mode);
            }
        }

        /**
         * IMPORTANT: This function have to be called manualy in each render node frame callback, before drawing scene geometry.
         * @public
         */
        transformLights() {
            var r = this.renderer;
            for (var i = 0; i < this._lights.length; i++) {
                var ii = i * 4;
                var tp;
                if (this._lights[i].directional) {
                    tp = r.activeCamera._normalMatrix.mulVec(this._lights[i]._position);
                    this._lightsTransformedPositions[ii + 3] = 0;
                } else {
                    tp = r.activeCamera._viewMatrix.mulVec3(this._lights[i]._position);
                    this._lightsTransformedPositions[ii + 3] = 1;
                }
                this._lightsTransformedPositions[ii] = tp.x;
                this._lightsTransformedPositions[ii + 1] = tp.y;
                this._lightsTransformedPositions[ii + 2] = tp.z;
            }
        }

        updateBillboardsTexCoords() {
            for (var i = 0; i < this.entityCollections.length; i++) {
                this.entityCollections[i].billboardHandler.refreshTexCoordsArr();
            }
        }

        /**
         * @private
         */
        _drawNodes() {
            for (var i = 0; i < this.childNodes.length; i++) {
                if (this.childNodes[i]._isActive) {
                    this.childNodes[i]._drawNodes();
                }
            }

            if (this.show) {
                if (this.frame) {
                    //this.lightEnabled && this.transformLights();
                    this.frame();
                }
                this.drawEntityCollections(this.entityCollections);
            }
        }

        drawEntityCollections(ec) {
            this.renderer.enqueueEntityCollectionsToDraw(ec);
        }

        /**
         * Draw entity collections picking frame.
         * @public
         * @param {Array<og.EntityCollection>} ec - Entity collection array.
         */
        drawPickingEntityCollections(ec) {
            if (ec.length) {
                var gl = this.renderer.handler.gl;

                gl.disable(gl.CULL_FACE);

                // billoard pass
                var i = ec.length;
                while (i--) {
                    ec[i]._fadingOpacity && ec[i].billboardHandler.drawPicking();
                }

                // geoObject pass
                i = ec.length;
                while (i--) {
                    ec[i]._fadingOpacity && ec[i].geoObjectHandler.drawPicking();
                }

                // label pass
                i = ec.length;
                while (i--) {
                    ec[i]._fadingOpacity && ec[i].labelHandler.drawPicking();
                }

                // ray pass
                i = ec.length;
                while (i--) {
                    ec[i]._fadingOpacity && ec[i].rayHandler.drawPicking();
                }

                gl.enable(gl.CULL_FACE);

                // polylines pass
                i = ec.length;
                while (i--) {
                    ec[i]._visibility && ec[i].polylineHandler.drawPicking();
                }

                //shapes pass
                i = ec.length;
                while (i--) {
                    ec[i]._visibility && ec[i].shapeHandler.drawPicking();
                }

                //Strip pass
                i = ec.length;
                while (i--) {
                    ec[i]._visibility && ec[i].stripHandler.drawPicking();
                }

                // //pointClouds pass
                // i = ec.length;
                // while (i--) {
                //    ec[i]._visibility && ec[i].pointCloudHandler.drawPicking();
                // }
            }
        }

        /**
         * Picking entity frame callback
         * @private
         */
        _entityCollectionPickingCallback() {
            this.drawPickingEntityCollections(this.entityCollections);
        }
    }

    /**
     * @module og/bv/Box
     */

    /**
     * Bounding box class.
     * @class
     */
    class Box {
        /**
         *
         * @param {*} boundsArr
         */
        constructor(boundsArr = [0, 0, 0, 0, 0, 0]) {
            /**
             * Vertices array.
             * @public
             * @type{Array.<Vec3>}
             */
            this.vertices = [
                new Vec3(),
                new Vec3(),
                new Vec3(),
                new Vec3(),
                new Vec3(),
                new Vec3(),
                new Vec3(),
                new Vec3()
            ];

            if (boundsArr) {
                this.setFromBoundsArr(boundsArr);
            }
        }

        copy(bbox) {
            for (let i = 0, len = this.vertices.length; i < len; i++) {
                this.vertices[i].copy(bbox.vertices[i]);
            }
        }

        /**
         * Sets bounding box coordinates by the bounds array.
         * @param {Array.<number>} bounds - Bounds is an array where [minX, minY, minZ, maxX, maxY, maxZ]
         */
        setFromBoundsArr(bounds) {
            var xmin = bounds[0],
                xmax = bounds[3],
                ymin = bounds[1],
                ymax = bounds[4],
                zmin = bounds[2],
                zmax = bounds[5];

            var v = this.vertices;

            v[0].set(xmin, ymin, zmin);
            v[1].set(xmax, ymin, zmin);
            v[2].set(xmax, ymin, zmax);
            v[3].set(xmin, ymin, zmax);
            v[4].set(xmin, ymax, zmin);
            v[5].set(xmax, ymax, zmin);
            v[6].set(xmax, ymax, zmax);
            v[7].set(xmin, ymax, zmax);
        }

        /**
         * Sets bounding box coordiantes by ellipsoid geodetic extend.
         * @param {Ellipsoid} ellipsoid - Ellipsoid.
         * @param {Extent} extent - Geodetic extent.
         */
        setFromExtent(ellipsoid, extent) {
            this.setFromBoundsArr(extent.getCartesianBounds(ellipsoid));
        }
    }

    class Slice {
        constructor(segment) {
            this.segment = segment;
            this.layers = [];
            this.tileOffsetArr = new Float32Array(segment.planet.SLICE_SIZE_4);
            this.layerOpacityArr = new Float32Array(segment.planet.SLICE_SIZE);
            this.init();
        }

        init() {}

        clear() {
            this.layers = null;
            this.tileOffsetArr = null;
            this.layerOpacityArr = null;
            //this.visibleExtentOffsetArr = null;
        }

        append(layer, material) {
            let n = this.layers.length;

            this.layers.push(layer);

            this.layerOpacityArr[n] = layer.opacity;

            let n4 = n * 4;

            let arr = layer.applyMaterial(material);
            this.tileOffsetArr[n4] = arr[0];
            this.tileOffsetArr[n4 + 1] = arr[1];
            this.tileOffsetArr[n4 + 2] = arr[2];
            this.tileOffsetArr[n4 + 3] = arr[3];

            //arr = this.segment._getLayerExtentOffset(layer);
            //slice.visibleExtentOffsetArr[n4] = arr[0];
            //slice.visibleExtentOffsetArr[n4 + 1] = arr[1];
            //slice.visibleExtentOffsetArr[n4 + 2] = arr[2];
            //slice.visibleExtentOffsetArr[n4 + 3] = arr[3];

        }
    }

    var _tempHigh$1 = new Vec3();
    var _tempLow$1 = new Vec3();

    let _v0 = new Vec3(),
        _v1 = new Vec3(),
        _v2 = new Vec3(),
        _v3 = new Vec3();

    let _ray = new Ray$1(),
        _rayEx = new Ray$1();

    window.ELLNORM = false;

    const _S = new Array(4);
    _S[N] = 0;
    _S[E] = 1;
    _S[S] = 1;
    _S[W] = 0;

    const _V = new Array(4);
    _V[N] = false;
    _V[E] = true;
    _V[S] = false;
    _V[W] = true;

    /**
     * Planet segment Web Mercator tile class that stored and rendered with quad tree.
     * @class
     * @param {quadTree.Node} node - Segment node.
     * @param {Planet} planet - Current planet scene.
     * @param {Number} tileZoom - Zoom index.
     * @param {Extent} extent - Segment extent.
     */
    class Segment {
        /**
         * @param {quadTree.Node} node - Segment node.
         * @param {Planet} planet - Current planet scene.
         * @param {number} tileZoom - Zoom index.
         * @param {Extent} extent - Segment extent.
         */
        constructor(node, planet, tileZoom, extent) {
            this.isPole = false;

            this._tileGroup = 0;

            this._projection = EPSG3857;

            /**
             * Quad tree node of the segment.
             * @type {quadTree.Node}
             */
            this.node = node;

            /**
             * Planet pointer.
             * @type {Planet}
             */
            this.planet = planet;

            /**
             * WebGl handler pointer.
             * @type {Handler}
             */
            this.handler = planet.renderer.handler;

            /**
             * Segment bounding sphere
             * @type {Sphere}
             */
            this.bsphere = new Sphere$1();

            this._plainRadius = 0;

            /**
             * Segment bounding box.
             * @type {Box}
             */
            this.bbox = new Box();

            //this._swNorm = null;
            //this._nwNorm = null;
            //this._seNorm = null;
            //this._neNorm = null;

            this._sw = new Vec3();
            this._nw = new Vec3();
            this._se = new Vec3();
            this._ne = new Vec3();

            this.centerNormal = new Vec3();

            /**
             * Geographical extent.
             * @type {Extent}
             */
            this._extent = extent;

            this._extentLonLat = null;

            /**
             * Vertices grid size.
             * @type {number}
             */
            this.gridSize = planet.terrain.gridSizeByZoom[tileZoom];

            this.fileGridSize = 0;

            /**
             * Tile zoom index.
             * @type {number}
             */
            this.tileZoom = tileZoom;

            /**
             * Horizontal tile index.
             * @type {number}
             */
            this.tileX = 0;

            this.tileXE = 0;

            this.tileXW = 0;

            this.tileYN = 0;

            this.tileYS = 0;

            /**
             * Vertical tile index.
             * @type {number}
             */
            this.tileY = 0;

            this.tileIndex = "";

            this._assignTileIndexes();

            /**
             * Texture materials array.
             * @type {Array.<planetSegment.Material>}
             */
            this.materials = [];

            /**
             * Plain segment vertices was created.
             * @type {boolean}
             */
            this.plainReady = false;

            /**
             * Segment is ready to create plain vertices.
             * @type {boolean}
             */
            this.initialized = false;

            /**
             * Normal map is allready made.
             * @type {boolean}
             */
            this.normalMapReady = false;

            /**
             * Parent normal map is made allready(optimization parameter).
             * @type {boolean}
             */
            this.parentNormalMapReady = false;

            /**
             * Terrain is allready applied flag.
             * @type {boolean}
             */
            this.terrainReady = false;

            /**
             * Terrain is loading now flag.
             * @type {boolean}
             */
            this.terrainIsLoading = false;

            /**
             * Terrain existing flag.
             * @type {boolean}
             */
            this.terrainExists = false;

            /**
             * Means that tree passage reach the segment, and the segment terrain is ready.
             * @type {boolean}
             */
            this.passReady = false;

            this.plainVertices = null;
            this.plainVerticesHigh = null;
            this.plainVerticesLow = null;

            this.plainNormals = null;

            this.terrainVertices = null;
            this.terrainVerticesHigh = null;
            this.terrainVerticesLow = null;
            this.noDataVertices = null;

            this.tempVertices = null;
            this.tempVerticesHigh = null;
            this.tempVerticesLow = null;

            this.normalMapTexture = null;
            this.normalMapTextureBias = new Float32Array(3);
            this.normalMapVertices = null;
            this.normalMapVerticesHigh = null;
            this.normalMapVerticesLow = null;
            this.normalMapNormals = null;

            this.vertexNormalBuffer = null;
            this.vertexPositionBuffer = null;
            this.vertexPositionBufferHigh = null;
            this.vertexPositionBufferLow = null;
            this.vertexTextureCoordBuffer = null;

            this._globalTextureCoordinates = new Float32Array(4);
            this._inTheQueue = false;
            this._appliedNeighborsZoom = [0, 0, 0, 0];

            this._slices = [];

            this._indexBuffer = null;

            this.readyToEngage = false;

            this.plainProcessing = false;
        }

        /**
         * Returns entity terrain point.
         * @public
         * @param {Entity} entity - Entity.
         * @param {Vec3} res - Point coordinates.
         * @param {Vec3} [normal] - Terrain point normal.
         * @returns {Vec3} -
         */
        getEntityTerrainPoint(entity, res, normal) {
            return this.getTerrainPoint(entity._cartesian, entity._lonlatMerc, res, normal);
        }

        isEntityInside(e) {
            return this._extentLonLat.isInside(e._lonlat);
        }

        /**
         * Returns distance from object to terrain coordinates and terrain point that calculates out in the res parameter.
         * @public
         * @param {Vec3} xyz - Cartesian object position.
         * @param {LonLat} insideSegmentPosition - Geodetic object position.
         * @param {Vec3} [res] - Result cartesian coordiantes on the terrain.
         * @param {Vec3} [normal] - Terrain point normal.
         * @returns {number} -
         */
        getTerrainPoint(xyz, insideSegmentPosition, res, normal) {
            var verts = this.tempVertices;

            _ray.set(xyz, xyz.negateTo());

            if (verts) {
                var ne = this._extent.northEast,
                    sw = this._extent.southWest,
                    size = Math.sqrt(verts.length / 3) - 1;

                var xmax = ne.lon,
                    ymax = ne.lat,
                    xmin = sw.lon,
                    ymin = sw.lat,
                    x = insideSegmentPosition.lon,
                    y = insideSegmentPosition.lat;

                var sxn = xmax - xmin,
                    syn = ymax - ymin;

                var qx = sxn / size,
                    qy = syn / size;

                var xn = x - xmin,
                    yn = y - ymin;

                var indX = Math.floor(xn / qx),
                    indY = Math.floor(size - yn / qy);

                if (verts && verts.length) {
                    var ind_v0 = ((size + 1) * indY + indX) * 3;
                    var ind_v2 = ((size + 1) * (indY + 1) + indX) * 3;

                    _v0.set(verts[ind_v0], verts[ind_v0 + 1], verts[ind_v0 + 2]);
                    _v1.set(verts[ind_v0 + 3], verts[ind_v0 + 4], verts[ind_v0 + 5]);
                    _v2.set(verts[ind_v2], verts[ind_v2 + 1], verts[ind_v2 + 2]);

                    let d = _ray.hitTriangle(_v0, _v1, _v2, res, normal);

                    if (d === Ray$1.INSIDE) {
                        return xyz.distance(res);
                    } else if (d === Ray$1.AWAY) {
                        _rayEx.set(xyz, xyz);
                        let d = _rayEx.hitTriangle(_v0, _v1, _v2, res, normal);
                        if (d === Ray$1.INSIDE) {
                            return -xyz.distance(res);
                        }
                    }

                    _v3.set(verts[ind_v2 + 3], verts[ind_v2 + 4], verts[ind_v2 + 5]);

                    d = _ray.hitTriangle(_v1, _v3, _v2, res, normal);
                    if (d === Ray$1.INSIDE) {
                        return xyz.distance(res);
                    } else if (d === Ray$1.AWAY) {
                        _rayEx.set(xyz, xyz);
                        let d = _rayEx.hitTriangle(_v1, _v3, _v2, res, normal);
                        if (d === Ray$1.INSIDE) {
                            return -xyz.distance(res);
                        }
                    }

                    if (d === Ray$1.AWAY) {
                        return -xyz.distance(res);
                    }

                    return xyz.distance(res);
                }

                res.copy(this.planet.ellipsoid.hitRay(_ray.origin, _ray.direction));
                normal && normal.copy(xyz.normal());
                return xyz.distance(res);
            } else {
                normal && normal.copy(xyz.normal());
                return xyz.distance(this.planet.ellipsoid.hitRay(_ray.origin, _ray.direction));
            }
        }

        /**
         * Project wgs86 to segment native projection.
         * @public
         * @param {LonLat} lonlat - Coordinates to project.
         * @returns {LonLat} -
         */
        projectNative(lonlat) {
            return lonlat.forwardMercator();
        }

        /**
         *
         * @param {boolean} forceLoading
         */
        loadTerrain(forceLoading) {
            if (this.tileZoom < this.planet.terrain.minZoom) {
                this.terrainIsLoading = true;

                this.elevationsNotExists();

                if (!this._inTheQueue) {
                    this.planet._normalMapCreator.queue(this);
                }
            } else {
                if (this.tileZoom > this.planet.terrain.maxZoom) {
                    this.elevationsNotExists();
                } else if (!this.terrainIsLoading && !this.terrainReady) {
                    this.planet.terrain.loadTerrain(this, forceLoading);
                }
            }
        }

        /**
         * Terrain obtained from server.
         * @param {Float32Array} elevations - Elevation data.
         */
        elevationsExists(elevations) {
            if (this.plainReady && this.terrainIsLoading) {
                this.planet._terrainWorker.make(this, elevations);

                this.plainVerticesHigh = null;
                this.plainVerticesLow = null;

                this.normalMapVerticesHigh = null;
                this.normalMapVerticesLow = null;

                if (!this.planet.terrain.equalizeVertices) {
                    this.tempVerticesHigh = null;
                    this.tempVerticesLow = null;
                }
            }
        }

        _checkEqualization(neighborSide, neigborNode) {
            return (
                neigborNode && this.tileZoom >= neigborNode.segment.tileZoom

                //&&
                //(
                //    this.node.equalizedNeighborId[neighborSide] !== neigborNode.appliedTerrainNodeId ||
                //    this.node.equalizedNeighborGridSize[neighborSide] !== neigborNode.segment.gridSize
                //||

                //    neigborNode.equalizedNeighborId[OPSIDE[neighborSide]] !== this.node.appliedTerrainNodeId ||
                //    neigborNode.equalizedNeighborGridSize[OPSIDE[neighborSide]] !== this.gridSize
                //)
            );
        }

        equalize() {
            if (this.tileZoom < 8 || this.gridSize < 2) {
                return;
            }

            this.readyToEngage = true;
            let nn = this.node.neighbors;
            let v = this.tempVertices,
                vHigh = this.tempVerticesHigh,
                vLow = this.tempVerticesLow;
            let gs = this.gridSize,
                gsOne = gs + 1;

            let n = nn[N][0];
            if (this._checkEqualization(N, n)) {
                //this.node.equalizedNeighborId[N] = n.appliedTerrainNodeId;
                //this.node.equalizedNeighborGridSize[N] = n.segment.gridSize;

                //n.equalizedNeighborId[OPSIDE[N]] = this.node.appliedTerrainNodeId;
                //n.equalizedNeighborGridSize[OPSIDE[N]] = this.gridSize;

                this.readyToEngage = true;

                let offset = this.node.getOffsetOppositeNeighbourSide(n, N);

                let nv = n.segment.tempVertices,
                    nvHigh = n.segment.tempVerticesHigh,
                    nvLow = n.segment.tempVerticesLow;

                let n_gs = n.segment.gridSize,
                    n_gsOne = n_gs + 1;

                let dz = 1 / (1 << (this.tileZoom - n.segment.tileZoom));

                let inc = Math.max(gs / (n_gs * dz), 1),
                    n_inc = Math.max((n_gs * dz) / gs, 1),
                    n_offset = offset * n_gs;

                for (let k = 0, nk = n_offset; k < gsOne; k += inc, nk += n_inc) {
                    const index = k * 3;
                    const n_index = (n_gsOne * n_gs + nk) * 3;

                    v[index] = nv[n_index];
                    v[index + 1] = nv[n_index + 1];
                    v[index + 2] = nv[n_index + 2];

                    vHigh[index] = nvHigh[n_index];
                    vHigh[index + 1] = nvHigh[n_index + 1];
                    vHigh[index + 2] = nvHigh[n_index + 2];

                    vLow[index] = nvLow[n_index];
                    vLow[index + 1] = nvLow[n_index + 1];
                    vLow[index + 2] = nvLow[n_index + 2];
                }
            }

            n = nn[E][0];
            if (this._checkEqualization(E, n)) {
                //this.node.equalizedNeighborId[E] = n.appliedTerrainNodeId;
                //this.node.equalizedNeighborGridSize[E] = n.segment.gridSize;

                //n.equalizedNeighborId[OPSIDE[E]] = this.node.appliedTerrainNodeId;
                //n.equalizedNeighborGridSize[OPSIDE[E]] = this.gridSize;

                this.readyToEngage = true;

                let offset = this.node.getOffsetOppositeNeighbourSide(n, E);

                let nv = n.segment.tempVertices,
                    nvHigh = n.segment.tempVerticesHigh,
                    nvLow = n.segment.tempVerticesLow;

                let n_gs = n.segment.gridSize,
                    n_gsOne = n_gs + 1;

                let dz = 1 / (1 << (this.tileZoom - n.segment.tileZoom));

                let inc = Math.max(gs / (n_gs * dz), 1),
                    n_inc = Math.max((n_gs * dz) / gs, 1),
                    n_offset = offset * n_gs;

                for (let k = 0, nk = n_offset; k < gsOne; k += inc, nk += n_inc) {
                    const index = (gsOne * k + gs) * 3;
                    const n_index = n_gsOne * nk * 3;

                    v[index] = nv[n_index];
                    v[index + 1] = nv[n_index + 1];
                    v[index + 2] = nv[n_index + 2];

                    vHigh[index] = nvHigh[n_index];
                    vHigh[index + 1] = nvHigh[n_index + 1];
                    vHigh[index + 2] = nvHigh[n_index + 2];

                    vLow[index] = nvLow[n_index];
                    vLow[index + 1] = nvLow[n_index + 1];
                    vLow[index + 2] = nvLow[n_index + 2];
                }
            }

            n = nn[S][0];
            if (this._checkEqualization(S, n)) {
                //this.node.equalizedNeighborId[S] = n.appliedTerrainNodeId;
                //this.node.equalizedNeighborGridSize[S] = n.segment.gridSize;

                //n.equalizedNeighborId[OPSIDE[S]] = this.node.appliedTerrainNodeId;
                //n.equalizedNeighborGridSize[OPSIDE[S]] = this.gridSize;

                this.readyToEngage = true;

                let offset = this.node.getOffsetOppositeNeighbourSide(n, S);

                let nv = n.segment.tempVertices,
                    nvHigh = n.segment.tempVerticesHigh,
                    nvLow = n.segment.tempVerticesLow;

                let n_gs = n.segment.gridSize; // n_gsOne = n_gs + 1;

                let dz = 1 / (1 << (this.tileZoom - n.segment.tileZoom));

                let inc = Math.max(gs / (n_gs * dz), 1),
                    n_inc = Math.max((n_gs * dz) / gs, 1),
                    n_offset = offset * n_gs;

                for (let k = 0, nk = n_offset; k < gsOne; k += inc, nk += n_inc) {
                    const index = (gsOne * gs + k) * 3;
                    const n_index = nk * 3;

                    v[index] = nv[n_index];
                    v[index + 1] = nv[n_index + 1];
                    v[index + 2] = nv[n_index + 2];

                    vHigh[index] = nvHigh[n_index];
                    vHigh[index + 1] = nvHigh[n_index + 1];
                    vHigh[index + 2] = nvHigh[n_index + 2];

                    vLow[index] = nvLow[n_index];
                    vLow[index + 1] = nvLow[n_index + 1];
                    vLow[index + 2] = nvLow[n_index + 2];
                }
            }

            n = nn[W][0];
            if (this._checkEqualization(W, n)) {
                //this.node.equalizedNeighborId[W] = n.appliedTerrainNodeId;
                //this.node.equalizedNeighborGridSize[W] = n.segment.gridSize;

                //n.equalizedNeighborId[OPSIDE[W]] = this.node.appliedTerrainNodeId;
                //n.equalizedNeighborGridSize[OPSIDE[W]] = this.gridSize;

                this.readyToEngage = true;

                let offset = this.node.getOffsetOppositeNeighbourSide(n, W);

                let nv = n.segment.tempVertices,
                    nvHigh = n.segment.tempVerticesHigh,
                    nvLow = n.segment.tempVerticesLow;

                let n_gs = n.segment.gridSize,
                    n_gsOne = n_gs + 1;

                let dz = 1 / (1 << (this.tileZoom - n.segment.tileZoom));

                let inc = Math.max(gs / (n_gs * dz), 1),
                    n_inc = Math.max((n_gs * dz) / gs, 1),
                    n_offset = offset * n_gs;

                for (let k = 0, nk = n_offset; k < gsOne; k += inc, nk += n_inc) {
                    const index = gsOne * k * 3;
                    const n_index = (n_gsOne * nk + n_gs) * 3;

                    v[index] = nv[n_index];
                    v[index + 1] = nv[n_index + 1];
                    v[index + 2] = nv[n_index + 2];

                    vHigh[index] = nvHigh[n_index];
                    vHigh[index + 1] = nvHigh[n_index + 1];
                    vHigh[index + 2] = nvHigh[n_index + 2];

                    vLow[index] = nvLow[n_index];
                    vLow[index + 1] = nvLow[n_index + 1];
                    vLow[index + 2] = nvLow[n_index + 2];
                }
            }
        }

        engage() {
            this.readyToEngage = false;
            this.createCoordsBuffers(this.tempVerticesHigh, this.tempVerticesLow, this.gridSize);
        }

        _plainSegmentWorkerCallback(data) {
            this.plainProcessing = false;

            if (this.initialized && !this.terrainReady) {
                this.plainVertices = data.plainVertices;
                this.plainVerticesHigh = data.plainVerticesHigh;
                this.plainVerticesLow = data.plainVerticesLow;

                this.plainNormals = data.plainNormals;

                this.normalMapNormals = data.normalMapNormals;
                this.normalMapVertices = data.normalMapVertices;
                this.normalMapVerticesHigh = data.normalMapVerticesHigh;
                this.normalMapVerticesLow = data.normalMapVerticesLow;

                this.terrainVertices = this.plainVertices;
                this.terrainVerticesHigh = this.plainVerticesHigh;
                this.terrainVerticesLow = this.plainVerticesLow;

                this.fileGridSize = Math.sqrt(data.normalMapVertices.length / 3) - 1;

                this._plainRadius = data.plainRadius;

                this.plainReady = true;
            }
        }

        _terrainWorkerCallback(data) {
            if (this.plainReady) {
                this.readyToEngage = true;

                this.normalMapNormals = null;

                this.normalMapVertices = null;
                this.normalMapVerticesHigh = null;
                this.normalMapVerticesLow = null;

                this.terrainVertices = null;
                this.terrainVerticesHigh = null;
                this.terrainVerticesLow = null;
                this.noDataVertices = null;

                this.tempVertices = null;
                this.tempVerticesHigh = null;
                this.tempVerticesLow = null;

                this.normalMapNormals = data.normalMapNormals;
                this.normalMapVertices = data.normalMapVertices;
                this.normalMapVerticesHigh = data.normalMapVerticesHigh;
                this.normalMapVerticesLow = data.normalMapVerticesLow;

                this.terrainVertices = data.terrainVertices;
                this.terrainVerticesHigh = data.terrainVerticesHigh;
                this.terrainVerticesLow = data.terrainVerticesLow;

                this.noDataVertices = data.noDataVertices;

                this.tempVertices = this.terrainVertices;
                this.tempVerticesHigh = this.terrainVerticesHigh;
                this.tempVerticesLow = this.terrainVerticesLow;

                this.setBoundingVolumeArr(data.bounds);

                //var b = data.bounds;

                //this.setBoundingSphere(
                //    b[0] + (b[1] - b[0]) * 0.5,
                //    b[2] + (b[3] - b[2]) * 0.5,
                //    b[4] + (b[5] - b[4]) * 0.5,
                //    new Vec3(b[0], b[2], b[4])
                //);

                this.gridSize = Math.sqrt(this.terrainVertices.length / 3) - 1;
                this.node.appliedTerrainNodeId = this.node.nodeId;

                this.terrainReady = true;
                this.terrainIsLoading = false;
                this.parentNormalMapReady = true;
                this.terrainExists = true;

                if (!this.normalMapTexturePtr) {
                    var nmc = this.planet._normalMapCreator;
                    this.normalMapTexturePtr = this.planet.renderer.handler.createEmptyTexture_l(
                        nmc._width,
                        nmc._height
                    );
                }

                if (this.planet.lightEnabled) {
                    this.planet._normalMapCreator.queue(this);
                }
            }
        }

        /**
         * Terrain is not obtained or not exists on the server.
         */
        elevationsNotExists() {
            if (this.planet && this.tileZoom <= this.planet.terrain.maxZoom) {
                if (this.plainReady && this.terrainIsLoading) {
                    this.terrainIsLoading = false;

                    this.node.appliedTerrainNodeId = this.node.nodeId;

                    if (this.planet.lightEnabled && !this._inTheQueue) {
                        this.planet._normalMapCreator.queue(this);
                    }

                    this.readyToEngage = true;
                }

                this.terrainVertices = this.plainVertices;
                this.terrainVerticesHigh = this.plainVerticesHigh;
                this.terrainVerticesLow = this.plainVerticesLow;

                this.tempVertices = this.terrainVertices;
                this.tempVerticesHigh = this.terrainVerticesHigh;
                this.tempVerticesLow = this.terrainVerticesLow;

                this.noDataVertices = null;

                this.fileGridSize = Math.sqrt(this.terrainVertices.length / 3) - 1;
                this.gridSize = this.fileGridSize;
                this.terrainReady = true;
                this.terrainExists = false;
            }
        }
        _normalMapEdgeEqualize(side) {
            let nn = this.node.neighbors;
            let n = nn[side][0];
            let maxZ = this.planet.terrain.maxZoom;

            if (this.tileZoom === maxZ) {
                if (!(nn[0].length || nn[1].length || nn[2].length || nn[3].length)) {
                    n = this.node.getEqualNeighbor(side);
                }
            }

            let b = n && n.segment,
                s = this;

            if (
                n &&
                b &&
                b.terrainReady &&
                b.terrainExists &&
                b.tileZoom <= maxZ &&
                s._appliedNeighborsZoom[side] !== b.tileZoom
            ) {
                s._appliedNeighborsZoom[side] = b.tileZoom;

                let seg_a = s.normalMapNormals,
                    seg_b = b.normalMapNormals;

                if (!(seg_a && seg_b)) return;

                let seg_a_raw = s.normalMapNormals,
                    seg_b_raw = b.normalMapNormals;

                // let seg_a_verts = s.terrainVertices,
                //     seg_b_verts = s.terrainVertices;

                let s_gs = Math.sqrt(seg_a.length / 3),
                    // b_gs = Math.sqrt(seg_b.length / 3),
                    s_gs1 = s_gs - 1;
                // b_gs1 = b_gs - 1;

                const i_a = s_gs1 * _S[side];

                let nx, ny, nz, q;

                if (s.tileZoom === b.tileZoom) {
                    const i_b = s_gs1 - i_a;

                    if (_V[side]) {
                        for (let k = 0; k < s_gs; k++) {
                            let vInd_a = (k * s_gs + i_a) * 3,
                                vInd_b = (k * s_gs + i_b) * 3;

                            nx = seg_a_raw[vInd_a] + seg_b_raw[vInd_b];
                            ny = seg_a_raw[vInd_a + 1] + seg_b_raw[vInd_b + 1];
                            nz = seg_a_raw[vInd_a + 2] + seg_b_raw[vInd_b + 2];

                            q = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);

                            seg_b[vInd_b] = seg_a[vInd_a] = nx * q;
                            seg_b[vInd_b + 1] = seg_a[vInd_a + 1] = ny * q;
                            seg_b[vInd_b + 2] = seg_a[vInd_a + 2] = nz * q;
                        }
                    } else {
                        for (let k = 0; k < s_gs; k++) {
                            let vInd_a = (i_a * s_gs + k) * 3,
                                vInd_b = (i_b * s_gs + k) * 3;

                            nx = seg_a_raw[vInd_a] + seg_b_raw[vInd_b];
                            ny = seg_a_raw[vInd_a + 1] + seg_b_raw[vInd_b + 1];
                            nz = seg_a_raw[vInd_a + 2] + seg_b_raw[vInd_b + 2];

                            q = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);

                            seg_b[vInd_b] = seg_a[vInd_a] = nx * q;
                            seg_b[vInd_b + 1] = seg_a[vInd_a + 1] = ny * q;
                            seg_b[vInd_b + 2] = seg_a[vInd_a + 2] = nz * q;
                        }
                    }

                    if (!b._inTheQueue && b._appliedNeighborsZoom[OPSIDE[side]] !== s.tileZoom) {
                        b._appliedNeighborsZoom[OPSIDE[side]] = s.tileZoom;
                        s.planet._normalMapCreator.queue(b);
                    }
                }
            }
        }

        applyTerrain(elevations) {
            if (elevations) {
                this.elevationsExists(elevations);
            } else {
                this.elevationsNotExists();
            }
        }

        /**
         * Delete segment gl buffers.
         */
        deleteBuffers() {
            var gl = this.handler.gl;
            gl.deleteBuffer(this.vertexNormalBuffer);
            gl.deleteBuffer(this.vertexPositionBuffer);
            gl.deleteBuffer(this.vertexPositionBufferHigh);
            gl.deleteBuffer(this.vertexPositionBufferLow);

            this.vertexNormalBuffer = null;
            this.vertexPositionBuffer = null;
            this.vertexPositionBufferHigh = null;
            this.vertexPositionBufferLow = null;
            this.vertexTextureCoordBuffer = null;
        }

        /**
         * Delete materials.
         */
        deleteMaterials() {
            var m = this.materials;
            for (var i = 0; i < m.length; i++) {
                var mi = m[i];
                if (mi) {
                    mi.clear();
                }
            }
            this.materials.length = 0;
        }

        /**
         * Delete elevation data.
         */
        deleteElevations() {
            this.terrainExists = false;
            this.terrainReady = false;
            this.terrainIsLoading = false;

            this.normalMapVertices = null;
            this.normalMapVerticesHigh = null;
            this.normalMapVerticesLow = null;

            this.normalMapNormals = null;

            this.tempVertices = null;
            this.tempVerticesHigh = null;
            this.tempVerticesLow = null;

            this.terrainVertices = null;
            this.terrainVerticesHigh = null;
            this.terrainVerticesLow = null;
            this.noDataVertices = null;

            this.plainVertices = null;
            this.plainVerticesHigh = null;
            this.plainVerticesLow = null;

            this.plainNormals = null;

            if (this.normalMapReady) {
                this.handler.gl.deleteTexture(this.normalMapTexture);
            }
            this.normalMapReady = false;
            this.parentNormalMapReady = false;
            this._appliedNeighborsZoom = [0, 0, 0, 0];
            this.normalMapTextureBias[0] = 0;
            this.normalMapTextureBias[1] = 0;
            this.normalMapTextureBias[2] = 1;
            this._inTheQueue = false;
        }

        /**
         * Clear but not destroy segment data.
         */
        clearSegment() {
            this.plainReady = false;
            this.initialized = false;
            this.deleteBuffers();
            this.deleteMaterials();
            this.deleteElevations();
        }

        /**
         * Removes cache records.
         */
        _freeCache() {
            this.planet._quadTreeNodesCacheMerc[this.tileIndex] = null;
            delete this.planet._quadTreeNodesCacheMerc[this.tileIndex];
        }

        /**
         * Clear and destroy all segment data.
         */
        destroySegment() {
            this._freeCache();

            this.clearSegment();

            var i = this._slices.length;
            while (i--) {
                this._slices[i].clear();
            }

            this._slices = null;

            this.node = null;

            this.planet = null;
            this.handler = null;
            this.bbox = null;
            this.bsphere = null;
            this._extent = null;

            this.materials = null;

            this.plainVertices = null;
            this.plainVerticesHigh = null;
            this.plainVerticesLow = null;
            this.plainNormals = null;

            this.terrainVertices = null;
            this.terrainVerticesHigh = null;
            this.terrainVerticesLow = null;
            this.noDataVertices = null;

            this.tempVertices = null;
            this.tempVerticesHigh = null;
            this.tempVerticesLow = null;

            this.normalMapTexture = null;
            this.normalMapTextureBias = null;
            this.normalMapVertices = null;
            this.normalMapVerticesHigh = null;
            this.normalMapVerticesLow = null;
            this.normalMapNormals = null;

            this.vertexNormalBuffer = null;
            this.vertexPositionBuffer = null;
            this.vertexPositionBufferHigh = null;
            this.vertexPositionBufferLow = null;
            this.vertexTextureCoordBuffer = null;

            this._projection = null;
            this._appliedNeighborsZoom = null;

            this._globalTextureCoordinates = null;
        }

        _setExtentLonLat() {
            this._extentLonLat = this._extent.inverseMercator();
        }

        /**
         * Creates bound volumes by segment geographical extent.
         */
        createBoundsByExtent() {
            var ellipsoid = this.planet.ellipsoid,
                extent = this._extentLonLat;

            var coord_sw = ellipsoid.geodeticToCartesian(extent.southWest.lon, extent.southWest.lat);
            var coord_ne = ellipsoid.geodeticToCartesian(extent.northEast.lon, extent.northEast.lat);

            var coord_nw = ellipsoid.geodeticToCartesian(
                extent.southWest.lon,
                extent.northEast.lat
            );
            var coord_se = ellipsoid.geodeticToCartesian(
                extent.northEast.lon,
                extent.southWest.lat
            );

            this._sw.copy(coord_sw);
            this._nw.copy(coord_nw);
            this._ne.copy(coord_ne);
            this._se.copy(coord_se);

            this.setBoundingVolume3v(coord_sw, coord_ne);
        }

        createBoundsByParent() {
            let pn = this.node;

            while (pn.parentNode && !pn.segment.terrainReady) {
                pn = pn.parentNode;
            }

            let dZ2 = 1 << (this.tileZoom - pn.segment.tileZoom);

            let offsetX = this.tileX - pn.segment.tileX * dZ2,
                offsetY = this.tileY - pn.segment.tileY * dZ2;

            if (pn.segment.terrainReady && pn.segment.tileZoom >= this.planet.terrain.minZoom) {
                let gridSize = pn.segment.gridSize / dZ2;

                if (gridSize >= 1.0) {
                    //
                    // (*) Actually, we get parent whole bounding volume
                    //
                    this.bsphere.center.x = pn.segment.bsphere.center.x;
                    this.bsphere.center.y = pn.segment.bsphere.center.y;
                    this.bsphere.center.z = pn.segment.bsphere.center.z;
                    this.bsphere.radius = pn.segment.bsphere.radius;

                    let i0 = gridSize * offsetY;
                    let j0 = gridSize * offsetX;

                    let pnGsOne = pn.segment.gridSize + 1;

                    let ind_sw = 3 * ((i0 + gridSize) * pnGsOne + j0),
                        ind_nw = 3 * (i0 * pnGsOne + j0),
                        ind_ne = 3 * (i0 * pnGsOne + j0 + gridSize),
                        ind_se = 3 * ((i0 + gridSize) * pnGsOne + j0 + gridSize);

                    let pVerts = pn.segment.tempVertices;

                    let v_sw = new Vec3(pVerts[ind_sw], pVerts[ind_sw + 1], pVerts[ind_sw + 2]),
                        v_ne = new Vec3(pVerts[ind_ne], pVerts[ind_ne + 1], pVerts[ind_ne + 2]);

                    // check for segment zoom
                    let v_nw = new Vec3(pVerts[ind_nw], pVerts[ind_nw + 1], pVerts[ind_nw + 2]),
                        v_se = new Vec3(pVerts[ind_se], pVerts[ind_se + 1], pVerts[ind_se + 2]);

                    this._sw.copy(v_sw);
                    this._nw.copy(v_nw);
                    this._ne.copy(v_ne);
                    this._se.copy(v_se);

                } else {
                    let pseg = pn.segment;

                    let i0 = Math.floor(gridSize * offsetY),
                        j0 = Math.floor(gridSize * offsetX);

                    let insideSize = 1.0 / gridSize;

                    let t_i0 = offsetY - insideSize * i0,
                        t_j0 = offsetX - insideSize * j0;

                    let bigOne;
                    if (pseg.gridSize === 1) {
                        bigOne = pseg.tempVertices;
                    } else {
                        bigOne = getMatrixSubArray(pseg.tempVertices, pseg.gridSize, i0, j0, 1);
                    }

                    let v_lt = new Vec3(bigOne[0], bigOne[1], bigOne[2]),
                        v_rb = new Vec3(bigOne[9], bigOne[10], bigOne[11]);

                    let vn = new Vec3(
                        bigOne[3] - bigOne[0],
                        bigOne[4] - bigOne[1],
                        bigOne[5] - bigOne[2]
                    ),
                        vw = new Vec3(
                            bigOne[6] - bigOne[0],
                            bigOne[7] - bigOne[1],
                            bigOne[8] - bigOne[2]
                        ),
                        ve = new Vec3(
                            bigOne[3] - bigOne[9],
                            bigOne[4] - bigOne[10],
                            bigOne[5] - bigOne[11]
                        ),
                        vs = new Vec3(
                            bigOne[6] - bigOne[9],
                            bigOne[7] - bigOne[10],
                            bigOne[8] - bigOne[11]
                        );

                    let vi_y = t_i0,
                        vi_x = t_j0;

                    let coords_lt, coords_rb;

                    if (vi_y + vi_x < insideSize) {
                        coords_lt = Vec3.add(
                            vn.scaleTo(vi_x / insideSize),
                            vw.scaleTo(vi_y / insideSize)
                        ).addA(v_lt);
                    } else {
                        coords_lt = Vec3.add(
                            vs.scaleTo(1 - vi_x / insideSize),
                            ve.scaleTo(1 - vi_y / insideSize)
                        ).addA(v_rb);
                    }

                    vi_y = t_i0 + 1;
                    vi_x = t_j0 + 1;

                    if (vi_y + vi_x < insideSize) {
                        coords_rb = Vec3.add(
                            vn.scaleTo(vi_x / insideSize),
                            vw.scaleTo(vi_y / insideSize)
                        ).addA(v_lt);
                    } else {
                        coords_rb = Vec3.add(
                            vs.scaleTo(1 - vi_x / insideSize),
                            ve.scaleTo(1 - vi_y / insideSize)
                        ).addA(v_rb);
                    }

                    this.setBoundingVolume3v(coords_lt, coords_rb);
                }
            } else {
                this.createBoundsByExtent();
            }
        }

        setBoundingSphere(x, y, z, v) {
            this.bsphere.center.x = x;
            this.bsphere.center.y = y;
            this.bsphere.center.z = z;
            this.bsphere.radius = this.bsphere.center.distance(v);
        }

        setBoundingVolume(xmin, ymin, zmin, xmax, ymax, zmax) {
            this.bbox.setFromBoundsArr([xmin, ymin, zmin, xmax, ymax, zmax]);

            let x = xmin + (xmax - xmin) * 0.5,
                y = ymin + (ymax - ymin) * 0.5,
                z = zmin + (zmax - zmin) * 0.5;

            this.bsphere.center.set(x, y, z);
            this.bsphere.radius = this.bsphere.center.distance(new Vec3(xmin, ymin, zmin));
        }

        setBoundingVolume3v(vmin, vmax) {
            this.bbox.setFromBoundsArr([vmin.x, vmin.y, vmin.z, vmax.x, vmax.y, vmax.z]);

            let x = vmin.x + (vmax.x - vmin.x) * 0.5,
                y = vmin.y + (vmax.y - vmin.y) * 0.5,
                z = vmin.z + (vmax.z - vmin.z) * 0.5;

            this.bsphere.center.set(x, y, z);
            this.bsphere.radius = this.bsphere.center.distance(new Vec3(vmin.x, vmin.y, vmin.z));
        }

        setBoundingVolumeArr(bounds) {
            this.bbox.setFromBoundsArr(bounds);

            let x = bounds[0] + (bounds[3] - bounds[0]) * 0.5,
                y = bounds[1] + (bounds[4] - bounds[1]) * 0.5,
                z = bounds[2] + (bounds[5] - bounds[2]) * 0.5;

            this.bsphere.center.set(x, y, z);
            this.bsphere.radius = this.bsphere.center.distance(
                new Vec3(bounds[0], bounds[1], bounds[2])
            );
        }

        createCoordsBuffers(verticesHigh, verticesLow, gridSize) {
            var gsgs = (gridSize + 1) * (gridSize + 1);
            var h = this.handler;

            if (this.vertexPositionBufferHigh && this.vertexPositionBufferHigh.numItems === gsgs) {
                h.setStreamArrayBuffer(this.vertexPositionBufferHigh, verticesHigh);
                h.setStreamArrayBuffer(this.vertexPositionBufferLow, verticesLow);
            } else {
                h.gl.deleteBuffer(this.vertexPositionBufferHigh);
                h.gl.deleteBuffer(this.vertexPositionBufferLow);

                this.vertexTextureCoordBuffer =
                    this.planet._textureCoordsBufferCache[Math.log2(gridSize)];

                //this.vertexPositionBufferHigh = h.createStreamArrayBuffer(3, gsgs);
                //h.setStreamArrayBuffer(this.vertexPositionBufferHigh, verticesHigh);
                //this.vertexPositionBufferLow = h.createStreamArrayBuffer(3, gsgs);
                //h.setStreamArrayBuffer(this.vertexPositionBufferLow, verticesLow);

                // It works, but I'm not sure that it is correct and better use the comment above
                this.vertexPositionBufferHigh = h.createArrayBuffer(verticesHigh, 3, gsgs);
                this.vertexPositionBufferLow = h.createArrayBuffer(verticesLow, 3, gsgs);
            }
        }

        _addViewExtent() {
            var ext = this._extentLonLat;

            var viewExt = this.planet._viewExtent;

            if (ext.southWest.lon < viewExt.southWest.lon) {
                viewExt.southWest.lon = ext.southWest.lon;
            }

            if (ext.northEast.lon > viewExt.northEast.lon) {
                viewExt.northEast.lon = ext.northEast.lon;
            }

            if (ext.southWest.lat < viewExt.southWest.lat) {
                viewExt.southWest.lat = ext.southWest.lat;
            }

            if (ext.northEast.lat > viewExt.northEast.lat) {
                viewExt.northEast.lat = ext.northEast.lat;
            }
        }

        _assignTileIndexes() {
            this._tileGroup = 0;
            var tileZoom = this.tileZoom;
            var extent = this._extent;
            var pole = POLE;
            this.tileX = Math.round(
                Math.abs(-pole - extent.southWest.lon) / (extent.northEast.lon - extent.southWest.lon)
            );
            this.tileY = Math.round(
                Math.abs(pole - extent.northEast.lat) / (extent.northEast.lat - extent.southWest.lat)
            );
            var p2 = Math.pow(2, tileZoom);
            this.tileXE = (this.tileX + 1) % p2;
            this.tileXW = (p2 + this.tileX - 1) % p2;

            this.tileYN = this.tileY - 1;
            this.tileYS = this.tileY + 1;

            this.tileIndex = Layer$1.getTileIndex(this.tileX, this.tileY, tileZoom);
            this.planet._quadTreeNodesCacheMerc[this.tileIndex] = this.node;
        }

        initialize() {
            var p = this.planet;
            var n = this.node;

            n.sideSize[0] =
                n.sideSize[1] =
                n.sideSize[2] =
                n.sideSize[3] =
                this.gridSize =
                p.terrain.gridSizeByZoom[this.tileZoom] || p.terrain.plainGridSize;

            n.sideSizeLog2[0] =
                n.sideSizeLog2[1] =
                n.sideSizeLog2[2] =
                n.sideSizeLog2[3] =
                Math.log2(p.terrain.gridSizeByZoom[this.tileZoom] || p.terrain.plainGridSize);

            if (this.tileZoom <= p.terrain.maxZoom) {
                var nmc = this.planet._normalMapCreator;
                this.normalMapTexturePtr = p.renderer.handler.createEmptyTexture_l(
                    nmc._width,
                    nmc._height
                );
            }

            this.normalMapTexture = this.planet.transparentTexture;

            this._assignGlobalTextureCoordinates();

            this.initialized = true;
        }

        _assignGlobalTextureCoordinates() {
            var e = this._extent;
            this._globalTextureCoordinates[0] =
                (e.southWest.lon + POLE) * ONE_BY_POLE_DOUBLE;
            this._globalTextureCoordinates[1] =
                (POLE - e.northEast.lat) * ONE_BY_POLE_DOUBLE;
            this._globalTextureCoordinates[2] =
                (e.northEast.lon + POLE) * ONE_BY_POLE_DOUBLE;
            this._globalTextureCoordinates[3] =
                (POLE - e.southWest.lat) * ONE_BY_POLE_DOUBLE;
        }

        createPlainSegmentAsync() {
            let p = this.planet,
                t = p.terrain;

            if (t.isReady() && this.tileZoom <= t.maxZoom && !this.plainReady) {
                this.plainProcessing = true;
                p._plainSegmentWorker.make(this);
            }
        }

        createPlainSegment() {
            this.initialize();
            this._createPlainVertices();
            this.readyToEngage = true;
        }

        _createPlainVertices() {
            var gridSize = this.planet.terrain.gridSizeByZoom[this.tileZoom];

            var e = this._extent,
                fgs = this.planet.terrain.plainGridSize;
            var lonSize = e.getWidth();
            var llStep = lonSize / Math.max(fgs, gridSize);
            var esw_lon = e.southWest.lon,
                ene_lat = e.northEast.lat;
            var dg = Math.max(fgs / gridSize, 1),
                gs = Math.max(fgs, gridSize) + 1;
            var r2 = this.planet.ellipsoid._invRadii2;
            var ind = 0,
                nmInd = 0;
            const gsgs = gs * gs;

            var gridSize3 = (gridSize + 1) * (gridSize + 1) * 3;

            this.plainNormals = new Float32Array(gridSize3);
            this.plainVertices = new Float64Array(gridSize3);
            this.plainVerticesHigh = new Float32Array(gridSize3);
            this.plainVerticesLow = new Float32Array(gridSize3);

            this.normalMapNormals = new Float32Array(gsgs * 3);
            this.normalMapVertices = new Float64Array(gsgs * 3);
            this.normalMapVerticesHigh = new Float32Array(gsgs * 3);
            this.normalMapVerticesLow = new Float32Array(gsgs * 3);

            var verts = this.plainVertices,
                vertsHigh = this.plainVerticesHigh,
                vertsLow = this.plainVerticesLow,
                norms = this.plainNormals,
                nmVerts = this.normalMapVertices,
                nmVertsHigh = this.normalMapVerticesHigh,
                nmVertsLow = this.normalMapVerticesLow,
                nmNorms = this.normalMapNormals;

            for (var k = 0; k < gsgs; k++) {
                var j = k % gs,
                    i = ~~(k / gs);

                var v = this.planet.ellipsoid.lonLatToCartesian(
                    LonLat.inverseMercator(esw_lon + j * llStep, ene_lat - i * llStep)
                );
                var nx = v.x * r2.x,
                    ny = v.y * r2.y,
                    nz = v.z * r2.z;
                var l = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);
                var nxl = nx * l,
                    nyl = ny * l,
                    nzl = nz * l;

                Vec3.doubleToTwoFloats(v, _tempHigh$1, _tempLow$1);

                nmVerts[nmInd] = v.x;
                nmVertsHigh[nmInd] = _tempHigh$1.x;
                nmVertsLow[nmInd] = _tempLow$1.x;
                nmNorms[nmInd++] = nxl;

                nmVerts[nmInd] = v.y;
                nmVertsHigh[nmInd] = _tempHigh$1.y;
                nmVertsLow[nmInd] = _tempLow$1.y;
                nmNorms[nmInd++] = nyl;

                nmVerts[nmInd] = v.z;
                nmVertsHigh[nmInd] = _tempHigh$1.z;
                nmVertsLow[nmInd] = _tempLow$1.z;
                nmNorms[nmInd++] = nzl;

                if (i % dg === 0 && j % dg === 0) {
                    verts[ind] = v.x;
                    vertsHigh[ind] = _tempHigh$1.x;
                    vertsLow[ind] = _tempLow$1.x;
                    norms[ind++] = nxl;

                    verts[ind] = v.y;
                    vertsHigh[ind] = _tempHigh$1.y;
                    vertsLow[ind] = _tempLow$1.y;
                    norms[ind++] = nyl;

                    verts[ind] = v.z;
                    vertsHigh[ind] = _tempHigh$1.z;
                    vertsLow[ind] = _tempLow$1.z;
                    norms[ind++] = nzl;
                }
            }

            this.terrainVertices = verts;
            this.terrainVerticesHigh = vertsHigh;
            this.terrainVerticesLow = vertsLow;

            this.plainReady = true;
        }

        /**
         * Gets specific layer material.
         * @public
         * @param {Layer} layer - Layer object.
         * @returns {planetSegment.Material} - Segment material.
         */
        getMaterialByLayer(layer) {
            return this.materials[layer._id];
        }

        _getLayerExtentOffset(layer) {
            var v0s = layer._extentMerc;
            var v0t = this._extent;
            var sSize_x = v0s.northEast.lon - v0s.southWest.lon;
            var sSize_y = v0s.northEast.lat - v0s.southWest.lat;
            var dV0s_x = (v0t.southWest.lon - v0s.southWest.lon) / sSize_x;
            var dV0s_y = (v0s.northEast.lat - v0t.northEast.lat) / sSize_y;
            var dSize_x = (v0t.northEast.lon - v0t.southWest.lon) / sSize_x;
            var dSize_y = (v0t.northEast.lat - v0t.southWest.lat) / sSize_y;
            return [dV0s_x, dV0s_y, dSize_x, dSize_y];
        }

        screenRendering(sh, layerSlice, sliceIndex, defaultTexture, isOverlay) {
            var gl = this.handler.gl;
            var sha = sh.attributes,
                shu = sh.uniforms;

            var pm = this.materials,
                p = this.planet;

            var currHeight, li;
            if (layerSlice) {
                li = layerSlice[0];
                currHeight = li._height;
            } else {
                currHeight = 0;
            }

            // First always draw whole planet base layer segment with solid texture.
            gl.activeTexture(gl.TEXTURE0 + p.SLICE_SIZE + 2);
            gl.bindTexture(gl.TEXTURE_2D, defaultTexture || this.getDefaultTexture());
            gl.uniform1i(shu.defaultTexture, p.SLICE_SIZE + 2);

            var n = 0,
                i = 0;

            var notEmpty = false;

            var slice = this._slices[sliceIndex];

            if (!slice) {
                slice = this._slices[sliceIndex] = new Slice(this);
            } else {
                //TODO: optimization!!!
                slice.layers = [];
            }

            this._indexBuffer = this._getIndexBuffer();

            while (li) {
                if (
                    this.layerOverlap(li) &&
                    ((li._fading && li._fadingOpacity > 0.0) ||
                        ((li.minZoom >= p.minCurrZoom || li.maxZoom >= p.minCurrZoom) &&
                            (li.minZoom <= p.maxCurrZoom || li.maxZoom <= p.maxCurrZoom)))
                ) {
                    notEmpty = true;

                    var m = pm[li._id];

                    if (!m) {
                        m = pm[li._id] = li.createMaterial(this);
                    }

                    if (!m.isReady) {
                        this.planet._renderCompleted = false;
                        this.planet._terrainReady = false;
                    }

                    slice.append(li, m);

                    p._samplerArr[n] = n;

                    gl.activeTexture(gl.TEXTURE0 + n);
                    gl.bindTexture(gl.TEXTURE_2D, m.texture || p.transparentTexture);

                    n++;
                }
                i++;
                li = layerSlice[i];
            }

            if (notEmpty || !isOverlay) {
                gl.uniform1i(shu.samplerCount, n);
                gl.uniform1f(shu.height, currHeight);
                gl.uniform1iv(shu.samplerArr, p._samplerArr);

                //slice.uniform(gl, shu);

                gl.uniform4fv(shu.tileOffsetArr, slice.tileOffsetArr);
                gl.uniform1fv(shu.layerOpacityArr, slice.layerOpacityArr);
                //gl.uniform4fv(shu.visibleExtentOffsetArr, slice.visibleExtentOffsetArr);

                // bind normalmap texture
                if (p.lightEnabled) {
                    gl.activeTexture(gl.TEXTURE0 + p.SLICE_SIZE + 3);
                    gl.bindTexture(gl.TEXTURE_2D, this.normalMapTexture || p.transparentTexture);
                    gl.uniform1i(shu.uNormalMap, p.SLICE_SIZE + 3);

                    gl.uniform3fv(shu.uNormalMapBias, this.normalMapTextureBias);

                    // bind segment specular and night material texture coordinates
                    gl.uniform4fv(shu.uGlobalTextureCoord, this._globalTextureCoordinates);
                }

                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferHigh);
                gl.vertexAttribPointer(sha.aVertexPositionHigh, this.vertexPositionBufferHigh.itemSize, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferLow);
                gl.vertexAttribPointer(sha.aVertexPositionLow, this.vertexPositionBufferLow.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexTextureCoordBuffer);
                gl.vertexAttribPointer(sha.aTextureCoord, 2, gl.UNSIGNED_SHORT, true, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
                gl.drawElements(p.drawMode, this._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
            }
        }

        heightPickingRendering(sh, layerSlice) {
            var gl = this.handler.gl;
            var sha = sh.attributes,
                shu = sh.uniforms;

            this.materials;
                this.planet;

            var currHeight;
            if (layerSlice) {
                currHeight = layerSlice[0]._height;
            } else {
                currHeight = 0;
            }

            gl.uniform1f(shu.height, currHeight);

            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferHigh);
            gl.vertexAttribPointer(sha.aVertexPositionHigh, this.vertexPositionBufferHigh.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferLow);
            gl.vertexAttribPointer(sha.aVertexPositionLow, this.vertexPositionBufferLow.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP, this._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
        }

        colorPickingRendering(sh, layerSlice, sliceIndex, defaultTexture, isOverlay) {
            var gl = this.handler.gl;
            var sha = sh.attributes,
                shu = sh.uniforms;

            var pm = this.materials,
                p = this.planet;

            var currHeight;
            if (layerSlice) {
                currHeight = layerSlice[0]._height;
            } else {
                currHeight = 0;
            }

            var notEmpty = false;

            var slice = this._slices[sliceIndex];

            let len = slice.layers.length;

            for (let n = 0; n < len; n++) {
                notEmpty = true;

                var li = slice.layers[n];
                var n4 = n * 4;

                p._pickingColorArr[n4] = li._pickingColor.x / 255.0;
                p._pickingColorArr[n4 + 1] = li._pickingColor.y / 255.0;
                p._pickingColorArr[n4 + 2] = li._pickingColor.z / 255.0;
                p._pickingColorArr[n4 + 3] = li._pickingEnabled;

                p._samplerArr[n] = n;
                gl.activeTexture(gl.TEXTURE0 + n);
                gl.bindTexture(gl.TEXTURE_2D, pm[li._id].texture || this.planet.transparentTexture);

                p._pickingMaskArr[n] = n + p.SLICE_SIZE;
                gl.activeTexture(gl.TEXTURE0 + n + p.SLICE_SIZE);
                gl.bindTexture(gl.TEXTURE_2D, pm[li._id].pickingMask || this.planet.transparentTexture);
            }

            if (notEmpty || !isOverlay) {
                gl.uniform1i(shu.samplerCount, len);
                gl.uniform1f(shu.height, currHeight);
                gl.uniform1iv(shu.samplerArr, p._samplerArr);
                gl.uniform1iv(shu.pickingMaskArr, p._pickingMaskArr);
                gl.uniform4fv(shu.pickingColorArr, p._pickingColorArr);

                //slice.uniform(gl, shu);

                gl.uniform4fv(shu.tileOffsetArr, slice.tileOffsetArr);
                gl.uniform1fv(shu.layerOpacityArr, slice.layerOpacityArr);
                //gl.uniform4fv(shu.visibleExtentOffsetArr, slice.visibleExtentOffsetArr);

                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferHigh);
                gl.vertexAttribPointer(sha.aVertexPositionHigh, this.vertexPositionBufferHigh.itemSize, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferLow);
                gl.vertexAttribPointer(sha.aVertexPositionLow, this.vertexPositionBufferLow.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexTextureCoordBuffer);
                gl.vertexAttribPointer(sha.aTextureCoord, 2, gl.UNSIGNED_SHORT, true, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
                gl.drawElements(gl.TRIANGLE_STRIP, this._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
            }
        }

        depthRendering(sh, layerSlice) {
            var gl = this.handler.gl;
            var sha = sh.attributes,
                shu = sh.uniforms;

            var currHeight;
            if (layerSlice) {
                currHeight = layerSlice[0]._height;
            } else {
                currHeight = 0;
            }

            gl.uniform1f(shu.height, currHeight);

            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferHigh);
            gl.vertexAttribPointer(sha.aVertexPositionHigh, this.vertexPositionBufferHigh.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferLow);
            gl.vertexAttribPointer(sha.aVertexPositionLow, this.vertexPositionBufferLow.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP, this._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
        }

        _getIndexBuffer() {
            var s = this.node.sideSizeLog2;
            var cache = this.planet._indexesCache[Math.log2(this.gridSize)][s[0]][s[1]][s[2]][s[3]];
            if (!cache.buffer) {
                let indexes = getInstance().createSegmentIndexes(Math.log2(this.gridSize), [s[0], s[1], s[2], s[3]]);
                cache.buffer = this.planet.renderer.handler.createElementArrayBuffer(indexes, 1);
                this.planet._indexesCacheToRemoveCounter++;
                indexes = null;
            }
            return cache.buffer;
        }

        _collectVisibleNodes() {
            this.planet._visibleNodes[this.node.nodeId] = this.node;
        }

        layerOverlap(layer) {
            return this._extent.overlaps(layer._extentMerc);
        }

        getDefaultTexture() {
            return this.planet.solidTextureOne;
        }

        getExtentLonLat() {
            return this._extentLonLat;
        }

        getExtentMerc() {
            return this._extent;
        }

        getExtent() {
            return this._extent;
        }

        getNodeState() {
            var vn = this.planet._visibleNodes[this.node.nodeId];
            return (vn && vn.state) || NOTRENDERING;
        }

        getNeighborSide(b) {
            if (this.tileY === b.tileY) {
                if (this.tileX === b.tileXE) {
                    return W;
                } else if (this.tileX === b.tileXW) {
                    return E;
                }
            } else if (this.tileX === b.tileX) {
                if (this.tileY === b.tileYS) {
                    return N;
                } else if (this.tileY === b.tileYN) {
                    return S;
                }
            }

            return -1;
        }
    }

    const _heightLat = 90.0 - MAX_LAT;
    const _maxPoleZoom = 7;
    const _pieceSize = _heightLat / Math.pow(2, _maxPoleZoom);

    let _tempHigh = new Vec3(),
        _tempLow = new Vec3();

    /**
     * Planet segment Web Mercator tile class that stored and rendered with quad tree.
     * @class
     * @extends {Segment}
     * @param {quadNode.Node} node - Quad tree segment node.
     * @param {Planet} planet - Scene planet.
     * @param {Number} tileZoom - Segment tile zoom index.
     * @param {Extent} extent - Segment WGS84 extent.
     */
    class SegmentLonLat extends Segment {
        /**
         * @param {quadTree.Node} node - Segment node.
         * @param {Planet} planet - Current planet scene.
         * @param {number} tileZoom - Zoom index.
         * @param {Extent} extent - Segment extent.
         */
        constructor(node, planet, tileZoom, extent) {
            super(node, planet, tileZoom, extent);

            // TODO:
            // be carefull with functions in constructor _assignTileIndexes
            // this._isNorth = false;

            this._projection = EPSG4326;

            this._extentMerc = new Extent(
                extent.southWest.forwardMercatorEPS01(),
                extent.northEast.forwardMercatorEPS01()
            );
            this.isPole = true;
        }

        _setExtentLonLat() {
            this._extentLonLat = this._extent;
        }

        projectNative(coords) {
            return coords;
        }

        getTerrainPoint(xyz, insideSegmentPosition, res, normal) {
            res.copy(this.planet.ellipsoid.hitRay(xyz, xyz.negateTo().normalize()));
            if (normal) {
                normal.copy(res.normal());
            }
            return xyz.length() - res.length();
        }

        acceptForRendering(camera) {
            var maxPoleZoom;
            var lat = this._extent.northEast.lat;
            if (this._isNorth) {
                //north pole limits
                let Yz = Math.floor((90.0 - lat) / _pieceSize);
                maxPoleZoom = Math.floor(Yz / 16) + 7;
            } else {
                //south pole limits
                let Yz = Math.floor((MIN_LAT - lat) / _pieceSize);
                maxPoleZoom = 12 - Math.floor(Yz / 16);
            }
            return (
                Segment.prototype.acceptForRendering.call(this, camera) || this.tileZoom >= maxPoleZoom
            );
        }

        _assignTileIndexes() {
            var tileZoom = this.tileZoom;
            var extent = this._extent;

            this.tileX = Math.round(
                Math.abs(-180.0 - extent.southWest.lon) / (extent.northEast.lon - extent.southWest.lon)
            );

            var lat = extent.northEast.lat;

            if (lat > 0) {
                //north pole
                this._isNorth = true;
                this._tileGroup = 1;
                this.tileY = Math.round((90.0 - lat) / (extent.northEast.lat - extent.southWest.lat));
            } else {
                //south pole
                this._tileGroup = 2;
                this.tileY = Math.round(
                    (MIN_LAT - lat) / (extent.northEast.lat - extent.southWest.lat)
                );
            }

            var p2 = 1 << tileZoom;
            this.tileXE = (this.tileX + 1) % p2;
            this.tileXW = (p2 + this.tileX - 1) % p2;

            this.tileYN = this.tileY - 1;
            this.tileYS = this.tileY + 1;

            this.tileIndex = Layer$1.getTileIndex(this.tileX, this.tileY, tileZoom);
        }

        _createPlainVertices() {
            var gridSize = this.planet.terrain.gridSizeByZoom[this.tileZoom];

            var e = this._extent,
                fgs = this.planet.terrain.plainGridSize;
            var lonSize = e.getWidth();
            var latSize = e.getHeight();
            var llStep = lonSize / Math.max(fgs, gridSize);
            var ltStep = latSize / gridSize;
            var esw_lon = e.southWest.lon,
                ene_lat = e.northEast.lat;
            var dg = Math.max(fgs / gridSize, 1),
                gs = Math.max(fgs, gridSize) + 1;
            var r2 = this.planet.ellipsoid._invRadii2;
            var ind = 0,
                nmInd = 0;
            const gsgs = gs * gs;

            var gridSize3 = (gridSize + 1) * (gridSize + 1) * 3;

            this.plainNormals = new Float32Array(gridSize3);
            this.plainVertices = new Float64Array(gridSize3);
            this.plainVerticesHigh = new Float32Array(gridSize3);
            this.plainVerticesLow = new Float32Array(gridSize3);

            this.normalMapNormals = new Float32Array(gsgs * 3);
            this.normalMapVertices = new Float64Array(gsgs * 3);
            this.normalMapVerticesHigh = new Float32Array(gsgs * 3);
            this.normalMapVerticesLow = new Float32Array(gsgs * 3);

            let xmin = 549755748352.0,
                xmax = -549755748352.0,
                ymin = 549755748352.0,
                ymax = -549755748352.0,
                zmin = 549755748352.0,
                zmax = -549755748352.0;

            var verts = this.plainVertices,
                vertsHigh = this.plainVerticesHigh,
                vertsLow = this.plainVerticesLow,
                norms = this.plainNormals,
                nmVerts = this.normalMapVertices,
                nmVertsHigh = this.normalMapVerticesHigh,
                nmVertsLow = this.normalMapVerticesLow,
                nmNorms = this.normalMapNormals;

            for (var k = 0; k < gsgs; k++) {
                var j = k % gs,
                    i = ~~(k / gs);

                var v = this.planet.ellipsoid.lonLatToCartesian(
                    new LonLat(esw_lon + j * llStep, ene_lat - i * ltStep)
                );
                var nx = v.x * r2.x,
                    ny = v.y * r2.y,
                    nz = v.z * r2.z;
                var l = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);
                var nxl = nx * l,
                    nyl = ny * l,
                    nzl = nz * l;

                Vec3.doubleToTwoFloats(v, _tempHigh, _tempLow);

                nmVerts[nmInd] = v.x;
                nmVertsHigh[nmInd] = _tempHigh.x;
                nmVertsLow[nmInd] = _tempLow.x;
                nmNorms[nmInd++] = nxl;

                nmVerts[nmInd] = v.y;
                nmVertsHigh[nmInd] = _tempHigh.y;
                nmVertsLow[nmInd] = _tempLow.y;
                nmNorms[nmInd++] = nyl;

                nmVerts[nmInd] = v.z;
                nmVertsHigh[nmInd] = _tempHigh.z;
                nmVertsLow[nmInd] = _tempLow.z;
                nmNorms[nmInd++] = nzl;

                if (i % dg === 0 && j % dg === 0) {
                    verts[ind] = v.x;
                    vertsHigh[ind] = _tempHigh.x;
                    vertsLow[ind] = _tempLow.x;
                    norms[ind++] = nxl;

                    verts[ind] = v.y;
                    vertsHigh[ind] = _tempHigh.y;
                    vertsLow[ind] = _tempLow.y;
                    norms[ind++] = nyl;

                    verts[ind] = v.z;
                    vertsHigh[ind] = _tempHigh.z;
                    vertsLow[ind] = _tempLow.z;
                    norms[ind++] = nzl;

                    if (v.x < xmin) xmin = v.x;
                    if (v.x > xmax) xmax = v.x;
                    if (v.y < ymin) ymin = v.y;
                    if (v.y > ymax) ymax = v.y;
                    if (v.z < zmin) zmin = v.z;
                    if (v.z > zmax) zmax = v.z;
                }
            }

            this.terrainVertices = verts;
            this.terrainVerticesHigh = vertsHigh;
            this.terrainVerticesLow = vertsLow;

            //store raw normals
            this.normalMapNormalsRaw = new Float32Array(nmNorms.length);
            this.normalMapNormalsRaw.set(nmNorms);

            let x = (xmax - xmin) * 0.5,
                y = (ymax - ymin) * 0.5,
                z = (zmax - zmin) * 0.5;

            this._plainRadius = Math.sqrt(x * x + y * y + z * z);

            this.plainReady = true;
        }

        _assignGlobalTextureCoordinates() {
            var e = this._extent;
            this._globalTextureCoordinates[0] = (e.southWest.lon + 180.0) / 360.0;
            this._globalTextureCoordinates[1] = (90 - e.northEast.lat) / 180.0;
            this._globalTextureCoordinates[2] = (e.northEast.lon + 180.0) / 360.0;
            this._globalTextureCoordinates[3] = (90 - e.southWest.lat) / 180.0;
        }

        _collectVisibleNodes() {
            if (this._isNorth) {
                this.planet._visibleNodesNorth[this.node.nodeId] = this.node;
            } else {
                this.planet._visibleNodesSouth[this.node.nodeId] = this.node;
            }
        }

        _getLayerExtentOffset(layer) {
            var v0s = layer._extent;
            var v0t = this._extent;
            var sSize_x = v0s.northEast.lon - v0s.southWest.lon;
            var sSize_y = v0s.northEast.lat - v0s.southWest.lat;
            var dV0s_x = (v0t.southWest.lon - v0s.southWest.lon) / sSize_x;
            var dV0s_y = (v0s.northEast.lat - v0t.northEast.lat) / sSize_y;
            var dSize_x = (v0t.northEast.lon - v0t.southWest.lon) / sSize_x;
            var dSize_y = (v0t.northEast.lat - v0t.southWest.lat) / sSize_y;
            return [dV0s_x, dV0s_y, dSize_x, dSize_y];
        }

        layerOverlap(layer) {
            return this._extent.overlaps(layer._extent);
        }

        getDefaultTexture() {
            return this._isNorth ? this.planet.solidTextureOne : this.planet.solidTextureTwo;
        }

        getExtentLonLat() {
            return this._extent;
        }

        getExtentMerc() {
            return this._extentMerc;
        }

        getNodeState() {
            var vn;
            if (this._isNorth) {
                vn = this.planet._visibleNodesNorth[this.node.nodeId];
            } else {
                vn = this.planet._visibleNodesSouth[this.node.nodeId];
            }
            return (vn && vn.state) || NOTRENDERING;
        }

        _freeCache() {
            //empty for a time
        }
    }

    class PlainSegmentWorker {
        constructor(numWorkers = 2) {
            this._id = 0;
            this._segments = {};

            this._workerQueue = [];

            var elevationProgramm = new Blob([_programm$1], { type: "application/javascript" });

            let _this = this;

            for (let i = 0; i < numWorkers; i++) {
                let w = new Worker(URL.createObjectURL(elevationProgramm));

                w.onmessage = function (e) {
                    _this._segments[e.data.id]._plainSegmentWorkerCallback(e.data);

                    e.data.plainVertices = null;
                    e.data.plainVerticesHigh = null;
                    e.data.plainVerticesLow = null;
                    e.data.plainNormals = null;
                    e.data.normalMapNormals = null;
                    e.data.normalMapVertices = null;
                    e.data.normalMapVerticesHigh = null;
                    e.data.normalMapVerticesLow = null;

                    _this._segments[e.data.id] = null;
                    delete _this._segments[e.data.id];

                    _this._workerQueue.unshift(this);
                    _this.check();
                };

                this._workerQueue.push(w);
            }

            this._pendingQueue = [];
        }

        check() {
            if (this._pendingQueue.length) {
                this.make(this._pendingQueue.pop());
            }
        }

        setGeoid(geoid) {

            let model = null;

            if (geoid.model) {
                let m = geoid.model;
                model = {
                    scale: m.scale,
                    offset: m.offset,
                    width: m.width,
                    height: m.height,
                    rlonres: m.rlonres,
                    rlatres: m.rlatres,
                    i: m.i
                };

                this._workerQueue.forEach((w) => {
                    let rawfile = new Uint8Array(m.rawfile.length);
                    rawfile.set(m.rawfile);

                    w.postMessage(
                        {
                            model: model,
                            rawfile: rawfile
                        },
                        [rawfile.buffer]
                    );
                });
            } else {
                this._workerQueue.forEach((w) => {
                    w.postMessage(
                        {
                            model: null
                        }
                    );
                });
            }
        }

        make(segment) {
            if (segment.initialized) {
                if (this._workerQueue.length) {
                    let w = this._workerQueue.pop();

                    this._segments[this._id] = segment;

                    let params = new Float64Array([
                        this._id++,
                        segment._projection.id === EPSG4326.id ? 1.0 : 0.0,
                        segment.planet.terrain.gridSizeByZoom[segment.tileZoom],
                        segment.planet.terrain.plainGridSize,
                        segment._extent.southWest.lon,
                        segment._extent.southWest.lat,
                        segment._extent.northEast.lon,
                        segment._extent.northEast.lat,
                        segment.planet.ellipsoid._e2,
                        segment.planet.ellipsoid._a,
                        segment.planet.ellipsoid._invRadii2.x,
                        segment.planet.ellipsoid._invRadii2.y,
                        segment.planet.ellipsoid._invRadii2.z,
                        segment.planet._heightFactor
                    ]);

                    w.postMessage(
                        {
                            params: params
                        },
                        [params.buffer]
                    );
                } else {
                    this._pendingQueue.push(segment);
                }
            } else {
                this.check();
            }
        }
    }

    const _programm$1 = `
    'use strict';
    
    let model = null;

    let cached_ix = null;
    let cached_iy = null;
    let v00 = null;
    let v01 = null;
    let v10 = null;
    let v11 = null;
    let t = null;

    function rawval(ix, iy) {

        if (iy < 0) {
            iy = -iy;
            ix += model.width / 2;
        } else if (iy >= model.height) {
            iy = 2 * (model.height - 1) - iy;
            ix += model.width / 2;
        }

        if (ix < 0) {
            ix += model.width;
        } else if (ix >= model.width) {
            ix -= model.width;
        }

        var k = (iy * model.width + ix) * 2 + model.i;

        return (model.rawfile[k] << 8) | model.rawfile[k + 1];
    };

    function getHeightMSL(lon, lat) {

        if (!model) return 0;

        if (lon < 0) lon += 360.0;

        var fy = (90 - lat) * model.rlatres;
        var fx = lon * model.rlonres;
        var iy = Math.floor(fy);
        var ix = Math.floor(fx);

        fx -= ix;
        fy -= iy;

        if (iy === (model.height - 1)) {
            iy--;
        }

        if ((cached_ix !== ix) || (cached_iy !== iy)) {

            cached_ix = ix;
            cached_iy = iy;

            v00 = rawval(ix, iy);
            v01 = rawval(ix + 1, iy);
            v10 = rawval(ix, iy + 1);
            v11 = rawval(ix + 1, iy + 1);
        }

        let h = null;

        var a = (1 - fx) * v00 + fx * v01;
        var b = (1 - fx) * v10 + fx * v11;

        h = (1 - fy) * a + fy * b;

        return model.offset + model.scale * h;
    };

    const HALF_PI = Math.PI * 0.5;
    const POLE = 20037508.34;
    const PI_BY_POLE = Math.PI / POLE;
    const INV_POLE_BY_180 = 180.0 / POLE;
    const INV_PI_BY_180 = 180.0 / Math.PI;
    const INV_PI_BY_180_HALF_PI = INV_PI_BY_180 * HALF_PI;
    const RADIANS = Math.PI / 180.0;
    const INV_PI_BY_360 = INV_PI_BY_180 * 2.0;

    let E2 = 0.0,
        A = 0.0;

    let _projFunc = null;

    const Vec3 = function (x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    };

    var lonLatToCartesian = function (lon, lat, heightFactor, res) {

        let h = getHeightMSL(lon, lat) * heightFactor;

        let latrad = RADIANS * lat,
            lonrad = RADIANS * lon;

        let slt = Math.sin(latrad);

        let N = A / Math.sqrt(1.0 - E2 * slt * slt);
        let nc = (N + h) * Math.cos(latrad);       
        
        res.x = nc * Math.sin(lonrad);
        res.y = (N * (1.0 - E2) + h) * slt;
        res.z = nc * Math.cos(lonrad);
    };

    var lonLatToCartesianInverse = function (lon, lat, heightFactor, res){
        lonLatToCartesian(
            lon * INV_POLE_BY_180,
            INV_PI_BY_360 * Math.atan(Math.exp(lat * PI_BY_POLE)) - INV_PI_BY_180_HALF_PI,
            heightFactor,
            res);
    };

    var v = new Vec3(0.0, 0.0, 0.0);
    var _tempHigh = new Vec3(0.0, 0.0, 0.0);
    var _tempLow = new Vec3(0.0, 0.0, 0.0);

    var doubleToTwoFloats = function(v, high, low) {

        let x = v.x, y = v.y, z = v.z;
    
        if (x >= 0.0) {
            var doubleHigh = Math.floor(x / 65536.0) * 65536.0;
            high.x = Math.fround(doubleHigh);
            low.x = Math.fround(x - doubleHigh);
        } else {
            var doubleHigh = Math.floor(-x / 65536.0) * 65536.0;
            high.x = Math.fround(-doubleHigh);
            low.x = Math.fround(x + doubleHigh);
        }

        if (y >= 0.0) {
            var doubleHigh = Math.floor(y / 65536.0) * 65536.0;
            high.y = Math.fround(doubleHigh);
            low.y = Math.fround(y - doubleHigh);
        } else {
            var doubleHigh = Math.floor(-y / 65536.0) * 65536.0;
            high.y = Math.fround(-doubleHigh);
            low.y = Math.fround(y + doubleHigh);
        }

        if (z >= 0.0) {
            var doubleHigh = Math.floor(z / 65536.0) * 65536.0;
            high.z = Math.fround(doubleHigh);
            low.z = Math.fround(z - doubleHigh);
        } else {
            var doubleHigh = Math.floor(-z / 65536.0) * 65536.0;
            high.z = Math.fround(-doubleHigh);
            low.z = Math.fround(z + doubleHigh);
        }
    };

    self.onmessage = function (msg) {
        if(msg.data.model) {
            model = msg.data.model;
            model.rawfile = msg.data.rawfile;
        } else if(msg.data.params) {

            let xmin = 549755748352.0, xmax = -549755748352.0, 
                ymin = 549755748352.0, ymax = -549755748352.0, 
                zmin = 549755748352.0, zmax = -549755748352.0;

            E2 = msg.data.params[8];
            A = msg.data.params[9];

            let gridSize = msg.data.params[2],
                fgs = msg.data.params[3],
                r2_x = msg.data.params[10],
                r2_y = msg.data.params[11],
                r2_z = msg.data.params[12];

            let heightFactor =  msg.data.params[13];
        
            if(msg.data.params[1] === 0.0){
                _projFunc = lonLatToCartesianInverse;
            }else{
                _projFunc = lonLatToCartesian;
            }

            let maxFgs = Math.max(fgs, gridSize);
            let llStep = (msg.data.params[6] - msg.data.params[4]) / maxFgs;
            let ltStep = (msg.data.params[7] - msg.data.params[5]) / maxFgs;

            let esw_lon = msg.data.params[4],
                ene_lat = msg.data.params[7];

            let dg = Math.max(fgs / gridSize, 1.0),
                gs = maxFgs + 1;
            
            const gsgs = gs * gs;

            const gridSize3 = (gridSize + 1) * (gridSize + 1) * 3;

            let plainNormals = new Float32Array(gridSize3);

            let plainVertices = new Float64Array(gridSize3);
            let plainVerticesHigh = new Float32Array(gridSize3);
            let plainVerticesLow = new Float32Array(gridSize3);

            let normalMapNormals = new Float32Array(gsgs * 3);

            let normalMapVertices = new Float64Array(gsgs * 3);
            let normalMapVerticesHigh = new Float32Array(gsgs * 3);
            let normalMapVerticesLow = new Float32Array(gsgs * 3);

            let ind = 0,
                nmInd = 0;

            for (let k = 0; k < gsgs; k++) {

                let j = k % gs,
                    i = ~~(k / gs);

                _projFunc(esw_lon + j * llStep, ene_lat - i * ltStep, heightFactor, v);

                let nx = v.x * r2_x, ny = v.y * r2_y, nz = v.z * r2_z;
                let l = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);            
                let nxl = nx * l,
                    nyl = ny * l,
                    nzl = nz * l;

                doubleToTwoFloats(v, _tempHigh, _tempLow);

                normalMapVertices[nmInd] = v.x;
                normalMapVerticesHigh[nmInd] = _tempHigh.x;
                normalMapVerticesLow[nmInd] = _tempLow.x;
                normalMapNormals[nmInd++] = nxl;

                normalMapVertices[nmInd] = v.y;
                normalMapVerticesHigh[nmInd] = _tempHigh.y;
                normalMapVerticesLow[nmInd] = _tempLow.y;
                normalMapNormals[nmInd++] = nyl;

                normalMapVertices[nmInd] = v.z;
                normalMapVerticesHigh[nmInd] = _tempHigh.z;
                normalMapVerticesLow[nmInd] = _tempLow.z;
                normalMapNormals[nmInd++] = nzl;

                if (i % dg === 0 && j % dg === 0) {
                    plainVertices[ind] = v.x;
                    plainVerticesHigh[ind] = _tempHigh.x;
                    plainVerticesLow[ind] = _tempLow.x;
                    plainNormals[ind++] = nxl;

                    plainVertices[ind] = v.y;
                    plainVerticesHigh[ind] = _tempHigh.y;
                    plainVerticesLow[ind] = _tempLow.y;
                    plainNormals[ind++] = nyl;

                    plainVertices[ind] = v.z;
                    plainVerticesHigh[ind] = _tempHigh.z;
                    plainVerticesLow[ind] = _tempLow.z;
                    plainNormals[ind++] = nzl;

                    if (v.x < xmin) xmin = v.x; if (v.x > xmax) xmax = v.x;
                    if (v.y < ymin) ymin = v.y; if (v.y > ymax) ymax = v.y;
                    if (v.z < zmin) zmin = v.z; if (v.z > zmax) zmax = v.z;
                }
            }

            let x = (xmax - xmin) * 0.5,
                y = (ymax - ymin) * 0.5,
                z = (zmax - zmin) * 0.5;

            let plainRadius = Math.sqrt(x * x + y * y + z * z);

            self.postMessage({
                id: msg.data.params[0],
                plainVertices: plainVertices,
                plainVerticesHigh: plainVerticesHigh,
                plainVerticesLow: plainVerticesLow,
                plainNormals: plainNormals,
                normalMapNormals: normalMapNormals,
                normalMapVertices: normalMapVertices,
                normalMapVerticesHigh: normalMapVerticesHigh,
                normalMapVerticesLow: normalMapVerticesLow,
                plainRadius: plainRadius
             }, [
                plainVertices.buffer,
                plainVerticesHigh.buffer,
                plainVerticesLow.buffer,
                plainNormals.buffer,
                normalMapNormals.buffer,
                normalMapVertices.buffer,
                normalMapVerticesHigh.buffer,
                normalMapVerticesLow.buffer
            ]);
        }
    }`;

    // import { QueueArray } from '../QueueArray.js';

    class TerrainWorker {
        constructor(numWorkers = 2) {
            this._id = 0;
            this._segments = {};

            this._workerQueue = [];//new QueueArray(numWorkers);
            var elevationProgramm = new Blob([_programm], { type: 'application/javascript' });

            var that = this;

            for (let i = 0; i < numWorkers; i++) {
                var w = new Worker(URL.createObjectURL(elevationProgramm));
                w.onmessage = function (e) {

                    that._segments[e.data.id]._terrainWorkerCallback(e.data);
                    that._segments[e.data.id] = null;

                    e.data.normalMapNormals = null;
                    e.data.normalMapVertices = null;
                    e.data.normalMapVerticesHigh = null;
                    e.data.normalMapVerticesLow = null;
                    e.data.terrainVertices = null;
                    e.data.terrainVerticesHigh = null;
                    e.data.terrainVerticesLow = null;

                    delete that._segments[e.data.id];

                    that._workerQueue.unshift(this);
                    that.check();
                };

                this._workerQueue.push(w);
            }

            this._pendingQueue = [];//new QueueArray(512);
        }

        check() {
            if (this._pendingQueue.length) {
                var p = this._pendingQueue.pop();
                this.make(p.segment, p.elevations);
            }
        }

        make(segment, elevations) {

            if (segment.plainReady && segment.terrainIsLoading) {

                var _elevations = new Float32Array(elevations.length);
                _elevations.set(elevations);

                if (this._workerQueue.length) {

                    var w = this._workerQueue.pop();

                    this._segments[this._id] = segment;

                    w.postMessage({
                        'elevations': _elevations,
                        'this_plainVertices': segment.plainVertices,
                        'this_plainNormals': segment.plainNormals,
                        'this_normalMapVertices': segment.normalMapVertices,
                        'this_normalMapNormals': segment.normalMapNormals,
                        'heightFactor': segment.planet._heightFactor,
                        'gridSize': segment.planet.terrain.gridSizeByZoom[segment.tileZoom],
                        'noDataValues': segment.planet.terrain.noDataValues,
                        'id': this._id++
                    }, [
                            _elevations.buffer,
                            segment.plainVertices.buffer,
                            segment.plainNormals.buffer,
                            segment.normalMapVertices.buffer,
                            segment.normalMapNormals.buffer
                        ]);

                } else {
                    this._pendingQueue.push({ 'segment': segment, 'elevations': _elevations });
                }
            } else {
                this.check();
            }
        }
    }

    const _programm =
        `'use strict';
    //
    //Terrain worker
    //

    function binarySearchFast(arr, x) {
        let start = 0,
            end = arr.length - 1;
        while (start <= end) {
            let k = Math.floor((start + end) * 0.5); 
            if (arr[k] === x)
                return k;
            else if (arr[k] < x)
                start = k + 1;
            else
                end = k - 1;
        }
        return -1;
    };

    function checkNoDataValue(noDataValues, value) {
        return binarySearchFast(noDataValues, value) !== -1;
    };


    var Vec3 = function(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    };

    var doubleToTwoFloats = function(v, high, low) {

        let x = v.x, y = v.y, z = v.z;
    
        if (x >= 0.0) {
            var doubleHigh = Math.floor(x / 65536.0) * 65536.0;
            high.x = Math.fround(doubleHigh);
            low.x = Math.fround(x - doubleHigh);
        } else {
            var doubleHigh = Math.floor(-x / 65536.0) * 65536.0;
            high.x = Math.fround(-doubleHigh);
            low.x = Math.fround(x + doubleHigh);
        }

        if (y >= 0.0) {
            var doubleHigh = Math.floor(y / 65536.0) * 65536.0;
            high.y = Math.fround(doubleHigh);
            low.y = Math.fround(y - doubleHigh);
        } else {
            var doubleHigh = Math.floor(-y / 65536.0) * 65536.0;
            high.y = Math.fround(-doubleHigh);
            low.y = Math.fround(y + doubleHigh);
        }

        if (z >= 0.0) {
            var doubleHigh = Math.floor(z / 65536.0) * 65536.0;
            high.z = Math.fround(doubleHigh);
            low.z = Math.fround(z - doubleHigh);
        } else {
            var doubleHigh = Math.floor(-z / 65536.0) * 65536.0;
            high.z = Math.fround(-doubleHigh);
            low.z = Math.fround(z + doubleHigh);
        }
    };

    Vec3.prototype.sub = function(v) {
        return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);
    };

    Vec3.prototype.add = function(v) {
        return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);
    };

    Vec3.prototype.cross = function(v) {
        return new Vec3(
            this.y * v.z - this.z * v.y,
            this.z * v.x - this.x * v.z,
            this.x * v.y - this.y * v.x
        );
    };

    Vec3.prototype.normalize = function(v) {
        var x = this.x, y = this.y, z = this.z;
        var length = 1.0 / Math.sqrt(x * x + y * y + z * z);
        this.x = x * length;
        this.y = y * length;
        this.z = z * length;
        return this;
    };

    Vec3.prototype.distance = function(v) {
        return this.sub(v).length();
    };

    Vec3.prototype.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    };

    var blerp = function(x, y, fQ11, fQ21, fQ12, fQ22) {
        return (fQ11 * (1.0 - x) * (1.0 - y) + fQ21 * x * (1.0 - y) + fQ12 * (1.0 - x) * y + fQ22 * x * y);
    };
    
    var slice = function (t, h1, h0) {
      return t * (h1 - h0);
    };

    var _tempVec = new Vec3(0.0, 0.0, 0.0);

    var _tempHigh = new Vec3(0.0, 0.0, 0.0),
        _tempLow = new Vec3(0.0, 0.0, 0.0);

    self.onmessage = function (e) {
        var elevations = e.data.elevations,
            this_plainVertices = e.data.this_plainVertices,
            this_plainNormals = e.data.this_plainNormals,
            this_normalMapVertices = e.data.this_normalMapVertices,
            this_normalMapNormals = e.data.this_normalMapNormals,
            heightFactor =  e.data.heightFactor,
            gridSize = e.data.gridSize,
            noDataValues = e.data.noDataValues,
            id = e.data.id;
        
        var xmin = 549755748352.0, xmax = -549755748352.0, 
            ymin = 549755748352.0, ymax = -549755748352.0, 
            zmin = 549755748352.0, zmax = -549755748352.0;

        const fileGridSize = Math.sqrt(elevations.length) - 1;

        const fileGridSize_one = fileGridSize + 1;
        const fileGridSize_one_x2 = fileGridSize_one * fileGridSize_one;
        const tgs = gridSize;
        const dg = fileGridSize / tgs;
        const gs = tgs + 1;
        const hf = heightFactor;

        var nmvInd = 0,
            vInd = 0,
            noDataInd = 0;

        var gsgs3 = gs * gs * 3;

        var terrainVertices = new Float64Array(gsgs3),
            terrainVerticesHigh = new Float32Array(gsgs3),
            terrainVerticesLow = new Float32Array(gsgs3),
            noDataVertices = new Uint8Array(gs * gs);

        var normalMapNormals,
            normalMapVertices,
            normalMapVerticesHigh,
            normalMapVerticesLow;

        var nv = this_normalMapVertices,
            nn = this_normalMapNormals;

        if (fileGridSize >= tgs) {

            normalMapNormals = new Float32Array(fileGridSize_one_x2 * 3);
            normalMapVertices = new Float64Array(fileGridSize_one_x2 * 3);
            normalMapVerticesHigh = new Float32Array(fileGridSize_one_x2 * 3);
            normalMapVerticesLow = new Float32Array(fileGridSize_one_x2 * 3);

            for (var k = 0; k < fileGridSize_one_x2; k++) {

                var j = k % fileGridSize_one,
                    i = ~~(k / fileGridSize_one);

                //
                // V0
                //
                var hInd0 = k;
                var vInd0 = hInd0 * 3;
                var currElv = elevations[hInd0];
                if(checkNoDataValue(noDataValues, currElv)) {
                    currElv = 0.0;
                }
                var h0 = hf * currElv;
                var v0 = new Vec3(nv[vInd0] + h0 * nn[vInd0], nv[vInd0 + 1] + h0 * nn[vInd0 + 1], nv[vInd0 + 2] + h0 * nn[vInd0 + 2]);
                                
                doubleToTwoFloats(v0, _tempHigh, _tempLow);

                normalMapVertices[vInd0] = v0.x;
                normalMapVertices[vInd0 + 1] = v0.y;
                normalMapVertices[vInd0 + 2] = v0.z;

                normalMapVerticesHigh[vInd0] = _tempHigh.x;
                normalMapVerticesHigh[vInd0 + 1] = _tempHigh.y;
                normalMapVerticesHigh[vInd0 + 2] = _tempHigh.z;

                normalMapVerticesLow[vInd0] = _tempLow.x;
                normalMapVerticesLow[vInd0 + 1] = _tempLow.y;
                normalMapVerticesLow[vInd0 + 2] = _tempLow.z;

                //
                // The vertex goes into screen buffer
                if (i % dg === 0 && j % dg === 0) {

                    let currVert = new Vec3(nv[vInd0], nv[vInd0 + 1], nv[vInd0 + 2]);
                    let nextVert = new Vec3(nv[vInd0 + 3], nv[vInd0 + 4], nv[vInd0 + 5]);

                    let nextElv =  elevations[hInd0 + 1];
                    if(checkNoDataValue(noDataValues, nextElv)) {
                        nextElv = 0.0;
                    }
                    
                    let eps = false;
                    if(noDataValues.length === 0){
                        let step = currVert.distance(nextVert);
                        let deltaElv = Math.abs(currElv - nextElv);
                        eps = ((deltaElv / step) > 10.0) || (currElv < -5000);
                    }

                    if(eps){
                        noDataVertices[noDataInd] = 1;
                    } else {
                        noDataVertices[noDataInd] = 0;
                        if (v0.x < xmin) xmin = v0.x; if (v0.x > xmax) xmax = v0.x;
                        if (v0.y < ymin) ymin = v0.y; if (v0.y > ymax) ymax = v0.y;
                        if (v0.z < zmin) zmin = v0.z; if (v0.z > zmax) zmax = v0.z;
                    }

                    terrainVerticesHigh[vInd] = _tempHigh.x;
                    terrainVerticesLow[vInd] = _tempLow.x;
                    terrainVertices[vInd++] = v0.x;

                    terrainVerticesHigh[vInd] = _tempHigh.y;
                    terrainVerticesLow[vInd] = _tempLow.y;
                    terrainVertices[vInd++] = v0.y;

                    terrainVerticesHigh[vInd] = _tempHigh.z;
                    terrainVerticesLow[vInd] = _tempLow.z;
                    terrainVertices[vInd++] = v0.z;

                    noDataInd++;
                }

                if (i !== fileGridSize && j !== fileGridSize) {

                    //
                    //  V1
                    //
                    var hInd1 = k + 1;
                    var vInd1 = hInd1 * 3;
                    var elv = elevations[hInd1];
                    if(checkNoDataValue(noDataValues, elv)) {
                        elv = 0.0;
                    }
                    var h1 = hf * elv;
                    var v1 = new Vec3(nv[vInd1] + h1 * nn[vInd1], nv[vInd1 + 1] + h1 * nn[vInd1 + 1], nv[vInd1 + 2] + h1 * nn[vInd1 + 2]);

                    doubleToTwoFloats(v1, _tempHigh, _tempLow);

                    normalMapVertices[vInd1] = v1.x;
                    normalMapVertices[vInd1 + 1] = v1.y;
                    normalMapVertices[vInd1 + 2] = v1.z;

                    normalMapVerticesHigh[vInd1] = _tempHigh.x;
                    normalMapVerticesHigh[vInd1 + 1] = _tempHigh.y;
                    normalMapVerticesHigh[vInd1 + 2] = _tempHigh.z;

                    normalMapVerticesLow[vInd1] = _tempLow.x;
                    normalMapVerticesLow[vInd1 + 1] = _tempLow.y;
                    normalMapVerticesLow[vInd1 + 2] = _tempLow.z;

                    //
                    //  V2
                    //
                    var hInd2 = k + fileGridSize_one;
                    var vInd2 = hInd2 * 3;
                    var elv = elevations[hInd2];
                    if(checkNoDataValue(noDataValues, elv)) {
                        elv = 0.0;
                    }
                    var h2 = hf * elv;
                    var v2 = new Vec3(nv[vInd2] + h2 * nn[vInd2], nv[vInd2 + 1] + h2 * nn[vInd2 + 1], nv[vInd2 + 2] + h2 * nn[vInd2 + 2]);

                    doubleToTwoFloats(v2, _tempHigh, _tempLow);

                    normalMapVertices[vInd2] = v2.x;
                    normalMapVertices[vInd2 + 1] = v2.y;
                    normalMapVertices[vInd2 + 2] = v2.z;

                    normalMapVerticesHigh[vInd2] = _tempHigh.x;
                    normalMapVerticesHigh[vInd2 + 1] = _tempHigh.y;
                    normalMapVerticesHigh[vInd2 + 2] = _tempHigh.z;

                    normalMapVerticesLow[vInd2] = _tempLow.x;
                    normalMapVerticesLow[vInd2 + 1] = _tempLow.y;
                    normalMapVerticesLow[vInd2 + 2] = _tempLow.z;

                    //
                    //  V3
                    //
                    var hInd3 = k + fileGridSize_one + 1;
                    var vInd3 = hInd3 * 3;
                    var elv = elevations[hInd3];
                    if(checkNoDataValue(noDataValues, elv)) {
                        elv = 0.0;
                    }
                    var h3 = hf * elv;
                    var v3 = new Vec3(nv[vInd3] + h3 * nn[vInd3], nv[vInd3 + 1] + h3 * nn[vInd3 + 1], nv[vInd3 + 2] + h3 * nn[vInd3 + 2]);

                    doubleToTwoFloats(v3, _tempHigh, _tempLow);

                    normalMapVertices[vInd3] = v3.x;
                    normalMapVertices[vInd3 + 1] = v3.y;
                    normalMapVertices[vInd3 + 2] = v3.z;

                    normalMapVerticesHigh[vInd3] = _tempHigh.x;
                    normalMapVerticesHigh[vInd3 + 1] = _tempHigh.y;
                    normalMapVerticesHigh[vInd3 + 2] = _tempHigh.z;

                    normalMapVerticesLow[vInd3] = _tempLow.x;
                    normalMapVerticesLow[vInd3 + 1] = _tempLow.y;
                    normalMapVerticesLow[vInd3 + 2] = _tempLow.z;

                    //
                    // Normal
                    //
                    var e10 = v1.sub(v0),
                        e20 = v2.sub(v0),
                        e30 = v3.sub(v0);
                    var sw = e20.cross(e30).normalize();
                    var ne = e30.cross(e10).normalize();
                    var n0 = ne.add(sw).normalize();

                    normalMapNormals[vInd0] += n0.x;
                    normalMapNormals[vInd0 + 1] += n0.y;
                    normalMapNormals[vInd0 + 2] += n0.z;

                    normalMapNormals[vInd1] += ne.x;
                    normalMapNormals[vInd1 + 1] += ne.y;
                    normalMapNormals[vInd1 + 2] += ne.z;

                    normalMapNormals[vInd2] += sw.x;
                    normalMapNormals[vInd2 + 1] += sw.y;
                    normalMapNormals[vInd2 + 2] += sw.z;

                    normalMapNormals[vInd3] += n0.x;
                    normalMapNormals[vInd3 + 1] += n0.y;
                    normalMapNormals[vInd3 + 2] += n0.z;
                }
            }

        } else {

            normalMapNormals = new Float32Array(gsgs3);
            normalMapVertices = new Float64Array(gsgs3);
            normalMapVerticesHigh = new Float32Array(gsgs3);
            normalMapVerticesLow = new Float32Array(gsgs3);
            normalMapNormals = new Float32Array(gsgs3);

            var oneSize = tgs / fileGridSize;
            var h, inside_i, inside_j, v_i, v_j;
            var gsgs = gsgs3 / 3;
            var fgsOne = fileGridSize + 1;

            for(let i = 0; i < gsgs; i++) {
                let ii = Math.floor(i / gs),
                    ij = i % gs;
              
                let qii = ii % oneSize,
                    qij = ij % oneSize;

                let hlt_ind = Math.floor(ii / oneSize) * fgsOne + Math.floor(ij / oneSize);

                if (ij === tgs) {
                    hlt_ind -= 1;
                    qij = oneSize;
                }

                if (ii === tgs) {
                    hlt_ind -= fgsOne;
                    qii = oneSize;
                }

                let hrt_ind = hlt_ind + 1,
                    hlb_ind = hlt_ind + fgsOne,
                    hrb_ind = hlb_ind + 1;

                let h_lt = elevations[hlt_ind],
                    h_rt = elevations[hrt_ind],
                    h_lb = elevations[hlb_ind],
                    h_rb = elevations[hrb_ind];

                if(checkNoDataValue(noDataValues, h_lt)) {
                    h_lt = 0.0;
                }

                if(checkNoDataValue(noDataValues, h_rt)) {
                    h_rt = 0.0;
                }

                if(checkNoDataValue(noDataValues, h_lb)) {
                    h_lb = 0.0;
                }

                if(checkNoDataValue(noDataValues, h_rb)) {
                    h_rb = 0.0;
                }

                let hi = blerp(qij / oneSize, qii / oneSize, h_lt, h_rt, h_lb, h_rb);

                let i3 = i * 3;

                _tempVec.x = this_plainVertices[i3] + hi * this_plainNormals[i3],
                _tempVec.y = this_plainVertices[i3 + 1] + hi * this_plainNormals[i3 + 1],
                _tempVec.z = this_plainVertices[i3 + 2] + hi * this_plainNormals[i3 + 2];

                doubleToTwoFloats(_tempVec, _tempHigh, _tempLow);

                terrainVertices[i3] = _tempVec.x;
                terrainVertices[i3 + 1] = _tempVec.y;
                terrainVertices[i3 + 2] = _tempVec.z;

                terrainVerticesHigh[i3] = _tempHigh.x;
                terrainVerticesHigh[i3 + 1] = _tempHigh.y;
                terrainVerticesHigh[i3 + 2] = _tempHigh.z;

                terrainVerticesLow[i3] = _tempLow.x;
                terrainVerticesLow[i3 + 1] = _tempLow.y;
                terrainVerticesLow[i3 + 2] = _tempLow.z;

                if (_tempVec.x < xmin) xmin = _tempVec.x; if (_tempVec.x > xmax) xmax = _tempVec.x;
                if (_tempVec.y < ymin) ymin = _tempVec.y; if (_tempVec.y > ymax) ymax = _tempVec.y;
                if (_tempVec.z < zmin) zmin = _tempVec.z; if (_tempVec.z > zmax) zmax = _tempVec.z;
            }

            normalMapVertices.set(terrainVertices);
            normalMapVerticesHigh.set(terrainVerticesHigh);
            normalMapVerticesLow.set(terrainVerticesLow);

            for(var k=0;k < gsgs; k++) {

                var j = k % gs,
                    i = ~~(k / gs);

                if (i !== tgs && j !== tgs) {
                    var v0ind = k * 3,
                        v1ind = v0ind + 3,
                        v2ind = v0ind + gs * 3,
                        v3ind = v2ind + 3;


                    var v0 = new Vec3(terrainVertices[v0ind], terrainVertices[v0ind + 1], terrainVertices[v0ind + 2]),
                        v1 = new Vec3(terrainVertices[v1ind], terrainVertices[v1ind + 1], terrainVertices[v1ind + 2]),
                        v2 = new Vec3(terrainVertices[v2ind], terrainVertices[v2ind + 1], terrainVertices[v2ind + 2]),
                        v3 = new Vec3(terrainVertices[v3ind], terrainVertices[v3ind + 1], terrainVertices[v3ind + 2]);

                    var e10 = v1.sub(v0).normalize(),
                        e20 = v2.sub(v0).normalize(),
                        e30 = v3.sub(v0).normalize();

                    var sw = e20.cross(e30).normalize();
                    var ne = e30.cross(e10).normalize();
                    var n0 = ne.add(sw).normalize();

                    normalMapNormals[v0ind] += n0.x;
                    normalMapNormals[v0ind + 1] += n0.y;
                    normalMapNormals[v0ind + 2] += n0.z;

                    normalMapNormals[v1ind] += ne.x;
                    normalMapNormals[v1ind + 1] += ne.y;
                    normalMapNormals[v1ind + 2] += ne.z;

                    normalMapNormals[v2ind] += sw.x;
                    normalMapNormals[v2ind + 1] += sw.y;
                    normalMapNormals[v2ind + 2] += sw.z;

                    normalMapNormals[v3ind] += n0.x;
                    normalMapNormals[v3ind + 1] += n0.y;
                    normalMapNormals[v3ind + 2] += n0.z;
                }
            }
        }

        self.postMessage({
                id: id,
                normalMapNormals: normalMapNormals,
                normalMapVertices: normalMapVertices,
                normalMapVerticesHigh: normalMapVerticesHigh,
                normalMapVerticesLow: normalMapVerticesLow,
                terrainVertices: terrainVertices,
                terrainVerticesHigh: terrainVerticesHigh,
                terrainVerticesLow: terrainVerticesLow,
                noDataVertices: noDataVertices,
                //bounds: [xmin, xmax, ymin, ymax, zmin, zmax]
                bounds: [xmin, ymin, zmin, xmax, ymax, zmax]
             }, [
                    normalMapNormals.buffer, 
                    normalMapVertices.buffer, 
                    normalMapVerticesHigh.buffer, 
                    normalMapVerticesLow.buffer, 
                    terrainVertices.buffer,
                    terrainVerticesHigh.buffer,
                    terrainVerticesLow.buffer,
                    noDataVertices.buffer
            ]);
    }`;

    /**
     * @module og/utils/VectorTileCreator
     */

    let tempArr = new Float32Array(2);

    class VectorTileCreator {

        constructor(planet, maxFrames = 5, width = 256, height = 256) {

            this._width = width;
            this._height = height;
            this._handler = planet.renderer.handler;
            this._planet = planet;
            this._framebuffer = null;
            this.MAX_FRAMES = maxFrames;
            this._currentFrame = 0;
            this._queue = [];
            this._initialize();
        }

        _initialize() {

            //Line
            if (!this._handler.programs.vectorTileLineRasterization) {
                this._handler.addProgram(new Program("vectorTileLineRasterization", {
                    uniforms: {
                        'viewport': "vec2",
                        'thicknessOutline': "float",
                        'alpha': "float",
                        'extentParamsHigh': "vec4",
                        'extentParamsLow': "vec4"
                    },
                    attributes: {
                        'prevHigh': "vec2",
                        'currentHigh': "vec2",
                        'nextHigh': "vec2",

                        'prevLow': "vec2",
                        'currentLow': "vec2",
                        'nextLow': "vec2",

                        'order': "float",
                        'color': "vec4",
                        'thickness': "float"
                    },
                    vertexShader:
                        `attribute vec2 prevHigh;
                attribute vec2 currentHigh;
                attribute vec2 nextHigh;

                attribute vec2 prevLow;
                attribute vec2 currentLow;
                attribute vec2 nextLow;

                attribute float order;
                attribute float thickness;
                attribute vec4 color;
                uniform float thicknessOutline;
                uniform vec2 viewport;
                uniform vec4 extentParamsHigh;
                uniform vec4 extentParamsLow;
                varying vec4 vColor;
                
                vec2 proj(vec2 coordHigh, vec2 coordLow) {
                    vec2 highDiff = coordHigh - extentParamsHigh.xy;
                    vec2 lowDiff = coordLow - extentParamsLow.xy;
                    return vec2(-1.0 + (highDiff + lowDiff) * extentParamsHigh.zw) * vec2(1.0, -1.0);
                }
                
                void main(){
                    vColor = color;

                    vec2 vNext = proj(nextHigh, nextLow),
                         vCurrent = proj(currentHigh, currentLow),
                         vPrev = proj(prevHigh, prevLow);

                    vec2 _next = vNext;
                    vec2 _prev = vPrev;
                    vec2 _current = vCurrent;

                    if(_prev == _current){
                        if(_next == _current){
                            _next = _current + vec2(1.0, 0.0);
                            _prev = _current - _next;
                        }else{
                            _prev = _current + normalize(_current - _next);
                        }
                    }

                    if(_next == _current){
                        _next = _current + normalize(_current - _prev);
                    }

                    vec2 sNext = _next;
                    vec2 sCurrent = _current;
                    vec2 sPrev = _prev;
                    
                    vec2 dirNext = normalize(sNext - sCurrent);
                    vec2 dirPrev = normalize(sPrev - sCurrent);
                    float dotNP = dot(dirNext, dirPrev);
                    
                    vec2 normalNext = normalize(vec2(-dirNext.y, dirNext.x));
                    vec2 normalPrev = normalize(vec2(dirPrev.y, -dirPrev.x));
                    vec2 d = (thickness + thicknessOutline) * 0.5 * sign(order) / viewport;
                    
                    vec2 m;
                    if(dotNP >= 0.99991){
                        m = sCurrent - normalPrev * d;
                    }else{
                        vec2 dir = normalPrev + normalNext;
                        m = sCurrent + dir * d / (dirNext.x * dir.y - dirNext.y * dir.x);
                        
                        if( dotNP > 0.5 && dot(dirNext + dirPrev, m - sCurrent) < 0.0 ){
                            float occw = order * sign(dirNext.x * dirPrev.y - dirNext.y * dirPrev.x);
                            if(occw == -1.0){
                                m = sCurrent + normalPrev * d;
                            }else if(occw == 1.0){
                                m = sCurrent + normalNext * d;
                            }else if(occw == -2.0){
                                m = sCurrent + normalNext * d;
                            }else if(occw == 2.0){
                                m = sCurrent + normalPrev * d;
                            }
                        }else if(distance(sCurrent, m) > min(distance(sCurrent, sNext), distance(sCurrent, sPrev))){
                            m = sCurrent + normalNext * d;
                        }
                    }
                    gl_Position = vec4(m.x, m.y, 0.0, 1.0);
                }`,
                    fragmentShader: `precision highp float;
                uniform float alpha;
                varying vec4 vColor;
                void main() {
                    gl_FragColor = vec4(vColor.rgb, alpha * vColor.a);
                }`
                }));
            }

            //Polygon
            if (!this._handler.programs.vectorTilePolygonRasterization) {
                this._handler.addProgram(new Program("vectorTilePolygonRasterization", {
                    uniforms: {
                        'extentParamsHigh': "vec4",
                        'extentParamsLow': "vec4"
                    },
                    attributes: {
                        'coordinatesHigh': "vec2",
                        'coordinatesLow': "vec2",
                        'colors': "vec4"
                    },
                    vertexShader:
                        `attribute vec2 coordinatesHigh;
                attribute vec2 coordinatesLow; 
                attribute vec4 colors; 
                uniform vec4 extentParamsHigh; 
                uniform vec4 extentParamsLow; 
                varying vec4 color;

                vec2 proj(vec2 coordHigh, vec2 coordLow) {
                    vec2 highDiff = coordHigh - extentParamsHigh.xy;
                    vec2 lowDiff = coordLow - extentParamsLow.xy;
                    return vec2(-1.0 + (highDiff + lowDiff) * extentParamsHigh.zw) * vec2(1.0, -1.0);
                }

                void main() { 
                    color = colors;
                    gl_Position = vec4(proj(coordinatesHigh, coordinatesLow), 0.0, 1.0); 
                }`,
                    fragmentShader:
                        `precision highp float;
                varying vec4 color;
                void main () {  
                    gl_FragColor = color; 
                }`
                }));
            }

            this._framebuffer = new Framebuffer(this._handler, {
                width: this._width,
                height: this._height,
                useDepth: false
            });
            this._framebuffer.init();
        }

        frame() {
            if (this._planet.layerLock.isFree() && this._queue.length) {
                var h = this._handler,
                    gl = h.gl;

                gl.disable(gl.CULL_FACE);
                gl.disable(gl.DEPTH_TEST);
                gl.enable(gl.BLEND);
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

                var hLine = h.programs.vectorTileLineRasterization,
                    hPoly = h.programs.vectorTilePolygonRasterization;

                var _w = this._width,
                    _h = this._height,
                    width = _w,
                    height = _h,
                    _w2 = width << 1,
                    _h2 = height << 1;

                var pickingMask = null,
                    texture = null;

                // var prevLayerId = -1;

                var extentParamsHigh = new Float32Array(4);
                var extentParamsLow = new Float32Array(4);

                var f = this._framebuffer.activate();

                var deltaTime = 0,
                    startTime = window.performance.now();

                while (this._planet.layerLock.isFree() && this._queue.length && deltaTime < 0.25) {
                    var material = this._queue.shift();
                    if (material.isLoading && material.segment.node.getState() === RENDERING) {

                        if (material.segment.tileZoom <= 3) {
                            width = _w2;
                            height = _h2;
                        } else {
                            width = _w;
                            height = _h;
                        }

                        texture = material._updateTexture || h.createEmptyTexture_l(width, height);

                        f.setSize(width, height);

                        f.bindOutputTexture(texture);

                        gl.clearColor(0.0, 0.0, 0.0, 0.0);
                        gl.clear(gl.COLOR_BUFFER_BIT);

                        var extent = material.segment.getExtentMerc();

                        doubleToTwoFloats2(extent.southWest.lon, tempArr);
                        extentParamsHigh[0] = tempArr[0];
                        extentParamsLow[0] = tempArr[1];

                        doubleToTwoFloats2(extent.southWest.lat, tempArr);
                        extentParamsHigh[1] = tempArr[0];
                        extentParamsLow[1] = tempArr[1];

                        extentParamsHigh[2] = 2.0 / extent.getWidth();
                        extentParamsHigh[3] = 2.0 / extent.getHeight();

                        hPoly.activate();
                        var sh = hPoly._program;
                        var sha = sh.attributes,
                            shu = sh.uniforms;

                        var geomHandler = material.layer._geometryHandler;

                        //=========================================
                        //Polygon rendering
                        //=========================================
                        gl.uniform4fv(shu.extentParamsHigh, extentParamsHigh);
                        gl.uniform4fv(shu.extentParamsLow, extentParamsLow);

                        gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._polyVerticesHighBufferMerc);
                        gl.vertexAttribPointer(sha.coordinatesHigh, geomHandler._polyVerticesHighBufferMerc.itemSize, gl.FLOAT, false, 0, 0);

                        gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._polyVerticesLowBufferMerc);
                        gl.vertexAttribPointer(sha.coordinatesLow, geomHandler._polyVerticesLowBufferMerc.itemSize, gl.FLOAT, false, 0, 0);

                        gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._polyColorsBuffer);
                        gl.vertexAttribPointer(sha.colors, geomHandler._polyColorsBuffer.itemSize, gl.FLOAT, false, 0, 0);

                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geomHandler._polyIndexesBuffer);

                        gl.drawElements(gl.TRIANGLES, geomHandler._polyIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);

                        //Polygon picking PASS
                        if (material.layer._pickingEnabled) {
                            if (!material.pickingReady) {
                                if (material._updatePickingMask) {
                                    pickingMask = material._updatePickingMask;
                                } else {
                                    pickingMask = h.createEmptyTexture_n(width, height);
                                }

                                f.bindOutputTexture(pickingMask);

                                gl.clearColor(0.0, 0.0, 0.0, 0.0);
                                gl.clear(gl.COLOR_BUFFER_BIT);

                                gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._polyPickingColorsBuffer);
                                gl.vertexAttribPointer(sha.colors, geomHandler._polyPickingColorsBuffer.itemSize, gl.FLOAT, false, 0, 0);

                                gl.drawElements(gl.TRIANGLES, geomHandler._polyIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
                            } else {
                                pickingMask = material.pickingMask;
                            }
                        }

                        //=========================================
                        //Strokes and linestrings rendering
                        //=========================================
                        f.bindOutputTexture(texture);

                        hLine.activate();
                        sh = hLine._program;
                        sha = sh.attributes;
                        shu = sh.uniforms;

                        gl.uniform2fv(shu.viewport, [width, height]);

                        gl.uniform4fv(shu.extentParamsHigh, extentParamsHigh);
                        gl.uniform4fv(shu.extentParamsLow, extentParamsLow);

                        //vertex
                        var mb = geomHandler._lineVerticesHighBufferMerc;
                        gl.bindBuffer(gl.ARRAY_BUFFER, mb);

                        gl.vertexAttribPointer(sha.prevHigh, mb.itemSize, gl.FLOAT, false, 8, 0);
                        gl.vertexAttribPointer(sha.currentHigh, mb.itemSize, gl.FLOAT, false, 8, 32);
                        gl.vertexAttribPointer(sha.nextHigh, mb.itemSize, gl.FLOAT, false, 8, 64);

                        mb = geomHandler._lineVerticesLowBufferMerc;
                        gl.bindBuffer(gl.ARRAY_BUFFER, mb);

                        gl.vertexAttribPointer(sha.prevLow, mb.itemSize, gl.FLOAT, false, 8, 0);
                        gl.vertexAttribPointer(sha.currentLow, mb.itemSize, gl.FLOAT, false, 8, 32);
                        gl.vertexAttribPointer(sha.nextLow, mb.itemSize, gl.FLOAT, false, 8, 64);

                        //order
                        gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._lineOrdersBuffer);
                        gl.vertexAttribPointer(sha.order, geomHandler._lineOrdersBuffer.itemSize, gl.FLOAT, false, 4, 0);

                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geomHandler._lineIndexesBuffer);

                        //PASS - stroke
                        gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._lineStrokesBuffer);
                        gl.vertexAttribPointer(sha.thickness, geomHandler._lineStrokesBuffer.itemSize, gl.FLOAT, false, 0, 0);

                        gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._lineStrokeColorsBuffer);
                        gl.vertexAttribPointer(sha.color, geomHandler._lineStrokeColorsBuffer.itemSize, gl.FLOAT, false, 0, 0);

                        //Antialias pass
                        gl.uniform1f(shu.thicknessOutline, 2);
                        gl.uniform1f(shu.alpha, 0.54);
                        gl.drawElements(gl.TRIANGLE_STRIP, geomHandler._lineIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
                        //
                        //Aliased pass
                        gl.uniform1f(shu.thicknessOutline, 1);
                        gl.uniform1f(shu.alpha, 1.0);
                        gl.drawElements(gl.TRIANGLE_STRIP, geomHandler._lineIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);

                        //PASS - inside line
                        gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._lineThicknessBuffer);
                        gl.vertexAttribPointer(sha.thickness, geomHandler._lineThicknessBuffer.itemSize, gl.FLOAT, false, 0, 0);

                        gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._lineColorsBuffer);
                        gl.vertexAttribPointer(sha.color, geomHandler._lineColorsBuffer.itemSize, gl.FLOAT, false, 0, 0);

                        //Antialias pass
                        gl.uniform1f(shu.thicknessOutline, 2);
                        gl.uniform1f(shu.alpha, 0.54);
                        gl.drawElements(gl.TRIANGLE_STRIP, geomHandler._lineIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
                        //
                        //Aliased pass
                        gl.uniform1f(shu.thicknessOutline, 1);
                        gl.uniform1f(shu.alpha, 1.0);
                        gl.drawElements(gl.TRIANGLE_STRIP, geomHandler._lineIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);

                        if (material.layer._pickingEnabled && !material.pickingReady) {
                            f.bindOutputTexture(pickingMask);
                            gl.uniform1f(shu.thicknessOutline, 8);
                            gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._linePickingColorsBuffer);
                            gl.vertexAttribPointer(sha.color, geomHandler._linePickingColorsBuffer.itemSize, gl.FLOAT, false, 0, 0);
                            gl.drawElements(gl.TRIANGLE_STRIP, geomHandler._lineIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
                        }

                        material.applyTexture(texture, pickingMask);

                    } else {
                        material.isLoading = false;
                    }

                    deltaTime = window.performance.now() - startTime;
                    // prevLayerId = material.layer._id;
                }

                gl.disable(gl.BLEND);
                gl.enable(gl.DEPTH_TEST);
                gl.enable(gl.CULL_FACE);

                f.deactivate();
            }
        }

        add(material) {
            this._queue.push(material);
        }

        remove(material) {
            //...
        }
    }

    /**
     * @module og/ellipsoid/Ellipsoid
     */

    /**
     * Class represents a plant ellipsoid.
     * @class
     * @param {number} equatorialSize - Equatorial ellipsoid size.
     * @param {number} polarSize - Polar ellipsoid size.
     */
    class Ellipsoid {
        /**
         * @param {number} equatorialSize - Equatorial ellipsoid size.
         * @param {number} polarSize - Polar ellipsoid size.
         */
        constructor(equatorialSize, polarSize) {
            this._a = equatorialSize;
            this._b = polarSize;
            this._flattening = (equatorialSize - polarSize) / equatorialSize;
            this._f = 1 / this._flattening;

            this._a2 = equatorialSize * equatorialSize;
            this._b2 = polarSize * polarSize;

            var qa2b2 = Math.sqrt(this._a2 - this._b2);

            this._e = qa2b2 / equatorialSize;
            this._e2 = this._e * this._e;
            this._e22 = this._e2 * this._e2;

            this._k = qa2b2 / polarSize;
            this._k2 = this._k * this._k;

            this._radii = new Vec3(equatorialSize, polarSize, equatorialSize);
            this._radii2 = new Vec3(this._a2, this._b2, this._a2);
            this._invRadii = new Vec3(1.0 / equatorialSize, 1.0 / polarSize, 1.0 / equatorialSize);
            this._invRadii2 = new Vec3(1.0 / this._a2, 1.0 / this._b2, 1.0 / this._a2);
        }

        static getRelativeBearing(a, b) {
            let a_y = Math.cos(a),
                a_x = Math.sin(a),
                b_y = Math.cos(b),
                b_x = Math.sin(b);
            let c = a_y * b_x - b_y * a_x,
                d = a_x * b_x + a_y * b_y;
            if (c > 0.0) {
                return Math.acos(d);
            }
            return -Math.acos(d);
        }

        /**
         * Returns the distance travelling from ‘this’ point to destination point along a rhumb line.
         *
         * @param   {LonLat} start coordinates.
         * @param   {LonLat} end coordinates
         * @returns {number} Distance in m between this point and destination point (same units as radius).
         */
        rhumbDistanceTo(startLonLat, endLonLat) {
            const f1 = startLonLat.lat * RADIANS;
            const f2 = endLonLat.lat * RADIANS;
            const df = f2 - f1;
            let d = Math.abs(endLonLat.lon - startLonLat.lon) * RADIANS;
            if (Math.abs(d) > Math.PI) d = d > 0 ? -(2 * Math.PI - d) : (2 * Math.PI + d);
            const dd = Math.log(Math.tan(f2 / 2 + Math.PI / 4) / Math.tan(f1 / 2 + Math.PI / 4));
            const q = Math.abs(dd) > 10e-12 ? df / dd : Math.cos(f1);
            const t = Math.sqrt(df * df + q * q * d * d); // angular distance in radians
            return t * this._a;
        }

        /**
         * Returns the midpoint between two points on the great circle.
         * @param   {LonLat} lonLat1 - Longitude/latitude of first point.
         * @param   {LonLat} lonLat2 - Longitude/latitude of second point.
         * @return {LonLat} Midpoint between points.
         */
        static getMiddlePointOnGreatCircle(lonLat1, lonLat2) {
            var f1 = lonLat1.lat * RADIANS,
                l1 = lonLat1.lon * RADIANS;
            var f2 = lonLat2.lat * RADIANS;
            var dl = (lonLat2.lon - lonLat1.lon) * RADIANS;

            var Bx = Math.cos(f2) * Math.cos(dl);
            var By = Math.cos(f2) * Math.sin(dl);

            var x = Math.sqrt((Math.cos(f1) + Bx) * (Math.cos(f1) + Bx) + By * By);
            var y = Math.sin(f1) + Math.sin(f2);
            var f3 = Math.atan2(y, x);

            var l3 = l1 + Math.atan2(By, Math.cos(f1) + Bx);

            return new LonLat(((l3 * DEGREES + 540) % 360) - 180, f3 * DEGREES);
        }

        /**
         * Returns the point at given fraction between two points on the great circle.
         * @param   {LonLat} lonLat1 - Longitude/Latitude of source point.
         * @param   {LonLat} lonLat2 - Longitude/Latitude of destination point.
         * @param   {number} fraction - Fraction between the two points (0 = source point, 1 = destination point).
         * @returns {LonLat} Intermediate point between points.
         */
        static getIntermediatePointOnGreatCircle(lonLat1, lonLat2, fraction) {
            var f1 = lonLat1.lat * RADIANS,
                l1 = lonLat1.lon * RADIANS;
            var f2 = lonLat2.lat * RADIANS,
                l2 = lonLat2.lon * RADIANS;

            var sinf1 = Math.sin(f1),
                cosf1 = Math.cos(f1),
                sinl1 = Math.sin(l1),
                cosl1 = Math.cos(l1);
            var sinf2 = Math.sin(f2),
                cosf2 = Math.cos(f2),
                sinl2 = Math.sin(l2),
                cosl2 = Math.cos(l2);

            var df = f2 - f1,
                dl = l2 - l1;
            var a =
                Math.sin(df / 2) * Math.sin(df / 2) +
                Math.cos(f1) * Math.cos(f2) * Math.sin(dl / 2) * Math.sin(dl / 2);
            var d = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            var A = Math.sin((1 - fraction) * d) / Math.sin(d);
            var B = Math.sin(fraction * d) / Math.sin(d);

            var x = A * cosf1 * cosl1 + B * cosf2 * cosl2;
            var y = A * cosf1 * sinl1 + B * cosf2 * sinl2;
            var z = A * sinf1 + B * sinf2;

            var f3 = Math.atan2(z, Math.sqrt(x * x + y * y));
            var l3 = Math.atan2(y, x);

            return new LonLat(((l3 * DEGREES + 540) % 360) - 180, f3 * DEGREES);
        }

        static getRhumbBearing(lonLat1, lonLat2) {
            var dLon = (lonLat2.lon - lonLat1.lon) * RADIANS;
            var dPhi = Math.log(
                Math.tan((lonLat2.lat * RADIANS) / 2 + Math.PI / 4) /
                Math.tan((lonLat1.lat * RADIANS) / 2 + Math.PI / 4)
            );
            if (Math.abs(dLon) > Math.PI) {
                if (dLon > 0) {
                    dLon = (2 * Math.PI - dLon) * -1;
                } else {
                    dLon = 2 * Math.PI + dLon;
                }
            }
            return (Math.atan2(dLon, dPhi) * DEGREES + 360) % 360;
        }

        static getBearing(lonLat1, lonLat2) {
            var f1 = lonLat1.lat * RADIANS,
                l1 = lonLat1.lon * RADIANS;
            var f2 = lonLat2.lat * RADIANS,
                l2 = lonLat2.lon * RADIANS;
            var y = Math.sin(l2 - l1) * Math.cos(f2);
            var x = Math.cos(f1) * Math.sin(f2) - Math.sin(f1) * Math.cos(f2) * Math.cos(l2 - l1);
            return Math.atan2(y, x) * DEGREES;
        }

        /**
         * Returns the (initial) bearing from source to destination point on the great circle.
         * @param {LonLat} lonLat1 - Longitude/latitude of source point.
         * @param {LonLat} lonLat2 - Longitude/latitude of destination point.
         * @return {number} Initial bearing in degrees from north.
         */
        static getInitialBearing(lonLat1, lonLat2) {
            var f1 = lonLat1.lat * RADIANS,
                f2 = lonLat2.lat * RADIANS;
            var dl = (lonLat2.lon - lonLat1.lon) * RADIANS;
            var y = Math.sin(dl) * Math.cos(f2);
            var x = Math.cos(f1) * Math.sin(f2) - Math.sin(f1) * Math.cos(f2) * Math.cos(dl);
            var D = Math.atan2(y, x);
            return (D * DEGREES + 360) % 360;
        }

        /**
         * Returns the point of intersection of two paths defined by point and bearing.
         * @param   {LonLat} p1 - First point.
         * @param   {number} brng1 - Initial bearing from first point.
         * @param   {LonLat} p2 - Second point.
         * @param   {number} brng2 - Initial bearing from second point.
         * @return {LonLat|null} Destination point (null if no unique intersection defined).
         */
        static intersection(p1, brng1, p2, brng2) {
            var f1 = p1.lat * RADIANS,
                l1 = p1.lon * RADIANS;
            var f2 = p2.lat * RADIANS,
                l2 = p2.lon * RADIANS;
            var D13 = brng1 * RADIANS,
                D23 = brng2 * RADIANS;
            var df = f2 - f1,
                dl = l2 - l1;

            var d12 =
                2 *
                Math.asin(
                    Math.sqrt(
                        Math.sin(df / 2) * Math.sin(df / 2) +
                        Math.cos(f1) * Math.cos(f2) * Math.sin(dl / 2) * Math.sin(dl / 2)
                    )
                );
            if (d12 == 0) return null;

            // initial/final bearings between points
            var Da = Math.acos(
                (Math.sin(f2) - Math.sin(f1) * Math.cos(d12)) / (Math.sin(d12) * Math.cos(f1))
            );
            if (isNaN(Da)) Da = 0; // protect against rounding
            var Db = Math.acos(
                (Math.sin(f1) - Math.sin(f2) * Math.cos(d12)) / (Math.sin(d12) * Math.cos(f2))
            );

            var D12 = Math.sin(l2 - l1) > 0 ? Da : 2 * Math.PI - Da;
            var D21 = Math.sin(l2 - l1) > 0 ? 2 * Math.PI - Db : Db;

            var a1 = ((D13 - D12 + Math.PI) % (2 * Math.PI)) - Math.PI;
            var a2 = ((D21 - D23 + Math.PI) % (2 * Math.PI)) - Math.PI;

            if (Math.sin(a1) == 0 && Math.sin(a2) == 0) return null; // infinite intersections
            if (Math.sin(a1) * Math.sin(a2) < 0) return null; // ambiguous intersection

            // a1 = Math.abs(a1);
            // a2 = Math.abs(a2);
            // ... Ed Williams takes abs of a1/a2, but seems to break calculation?

            var a3 = Math.acos(
                -Math.cos(a1) * Math.cos(a2) + Math.sin(a1) * Math.sin(a2) * Math.cos(d12)
            );
            var d13 = Math.atan2(
                Math.sin(d12) * Math.sin(a1) * Math.sin(a2),
                Math.cos(a2) + Math.cos(a1) * Math.cos(a3)
            );
            var f3 = Math.asin(
                Math.sin(f1) * Math.cos(d13) + Math.cos(f1) * Math.sin(d13) * Math.cos(D13)
            );
            var dl13 = Math.atan2(
                Math.sin(D13) * Math.sin(d13) * Math.cos(f1),
                Math.cos(d13) - Math.sin(f1) * Math.sin(f3)
            );
            var l3 = l1 + dl13;

            return new LonLat(((l3 * DEGREES + 540) % 360) - 180, f3 * DEGREES);
        }

        /**
         * Returns final bearing arriving at destination destination point from lonLat1 point; the final bearing
         * will differ from the initial bearing by varying degrees according to distance and latitude.
         * @param {LonLat} lonLat1 - Longitude/latitude of source point.
         * @param {LonLat} lonLat2 - Longitude/latitude of destination point.
         * @return {number} Final bearing in degrees from north.
         */
        static getFinalBearing(lonLat1, lonLat2) {
            // get initial bearing from destination lonLat2 to lonLat1 & reverse it by adding 180°
            return (Ellipsoid.getInitialBearing(lonLat2, lonLat1) + 180) % 360;
        }

        /**
         * Gets ellipsoid equatorial size.
         * @public
         * @returns {number} -
         */
        getEquatorialSize() {
            return this._a;
        }

        /**
         * Gets ellipsoid polar size.
         * @public
         * @returns {number} -
         */
        getPolarSize() {
            return this._b;
        }

        /**
         * Gets cartesian ECEF from Wgs84 geodetic coordiantes.
         * @public
         * @param {LonLat} lonlat - Degrees geodetic coordiantes.
         * @returns {Vec3} -
         */
        lonLatToCartesian(lonlat) {
            var latrad = RADIANS * lonlat.lat,
                lonrad = RADIANS * lonlat.lon;

            var slt = Math.sin(latrad);

            var N = this._a / Math.sqrt(1.0 - this._e2 * slt * slt);
            var nc = (N + lonlat.height) * Math.cos(latrad);

            return new Vec3(
                nc * Math.sin(lonrad),
                (N * (1.0 - this._e2) + lonlat.height) * slt,
                nc * Math.cos(lonrad)
            );
        }

        /**
         * Gets cartesian ECEF from Wgs84 geodetic coordiantes.
         * @public
         * @param {LonLat} lonlat - Degrees geodetic coordiantes.
         * @param {Vec3} res - Output result.
         * @returns {Vec3} -
         */
        lonLatToCartesianRes(lonlat, res) {
            var latrad = RADIANS * lonlat.lat,
                lonrad = RADIANS * lonlat.lon;

            var slt = Math.sin(latrad);

            var N = this._a / Math.sqrt(1.0 - this._e2 * slt * slt);
            var nc = (N + lonlat.height) * Math.cos(latrad);

            res.x = nc * Math.sin(lonrad);
            res.y = (N * (1.0 - this._e2) + lonlat.height) * slt;
            res.z = nc * Math.cos(lonrad);

            return res;
        }

        /**
         * Gets cartesian ECEF from Wgs84 geodetic coordiantes.
         * @public
         * @param {Number} lon - Longitude.
         * @param {Number} lat - Latitude.
         * @param {Number} height - Height.
         * @returns {Vec3} -
         */
        geodeticToCartesian(lon, lat, height = 0) {
            var latrad = RADIANS * lat,
                lonrad = RADIANS * lon;

            var slt = Math.sin(latrad);

            var N = this._a / Math.sqrt(1 - this._e2 * slt * slt);
            var nc = (N + height) * Math.cos(latrad);

            return new Vec3(
                nc * Math.sin(lonrad),
                (N * (1 - this._e2) + height) * slt,
                nc * Math.cos(lonrad)
            );
        }

        /**
         * Gets Wgs84 geodetic coordiantes from cartesian ECEF.
         * @public
         * @param {Vec3} cartesian - Cartesian coordinates.
         * @returns {LonLat} -
         */
        cartesianToLonLat(cartesian) {
            var x = cartesian.z,
                y = cartesian.x,
                z = cartesian.y;
            var ecc2 = this._e2;
            var ecc22 = this._e22;
            var r2 = x * x + y * y;
            var r = Math.sqrt(r2);
            var z2 = z * z;
            var f = 54.0 * this._b2 * z2;
            var g = r2 + (1.0 - ecc2) * z2 + ecc2 * (this._a2 - this._b2);
            var g2 = g * g;
            var c = (ecc22 * f * r2) / (g2 * g);
            var s = Math.pow(1.0 + c + Math.sqrt(c * (c + 2.0)), 0.33333333333333333);
            var p = f / (3.0 * Math.pow(1.0 + s + 1.0 / s, 2.0) * g2);
            var q = Math.sqrt(1.0 + 2.0 * ecc22 * p);
            var recc2r0 =
                r -
                ecc2 *
                (-(p * ecc2 * r) / 1 +
                    q +
                    Math.sqrt(
                        0.5 * this._a2 * (1.0 + 1.0 / q) -
                        (p * (1.0 - ecc2) * z2) / (q * (1.0 + q)) -
                        0.5 * p * r2
                    ));
            var recc2r02 = recc2r0 * recc2r0;
            var v = Math.sqrt(recc2r02 + (1.0 - ecc2) * z2);
            var z0 = (this._b2 * z) / (this._a * v);
            var lat = Math.atan((z + this._k2 * z0) / r) * DEGREES;
            var lon = Math.atan2(y, x) * DEGREES;
            return new LonLat(
                lon,
                lat,
                cartesian.length() - this.geodeticToCartesian(lon, lat).length()
            );
        }

        /**
         * Gets ellipsoid surface normal.
         * @public
         * @param {Vec3} coord - Spatial coordiantes.
         * @return {Vec3} -
         */
        getSurfaceNormal3v(coord) {
            var r2 = this._invRadii2;
            var nx = coord.x * r2.x,
                ny = coord.y * r2.y,
                nz = coord.z * r2.z;
            var l = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);
            return new Vec3(nx * l, ny * l, nz * l);
        }

        /**
         *
         * @param {LonLat} lonLat1
         * @param {number} [bearing]
         * @param {number} [distance]
         * @return {LonLat} -
         */
        getBearingDestination(lonLat1, bearing = 0.0, distance = 0) {
            bearing = bearing * RADIANS;
            var nlon = ((lonLat1.lon + 540) % 360) - 180;
            var f1 = lonLat1.lat * RADIANS,
                l1 = nlon * RADIANS;
            var dR = distance / this._a;
            var f2 = Math.asin(
                Math.sin(f1) * Math.cos(dR) + Math.cos(f1) * Math.sin(dR) * Math.cos(bearing)
            );
            return new LonLat(
                (l1 +
                    Math.atan2(
                        Math.sin(bearing) * Math.sin(dR) * Math.cos(f1),
                        Math.cos(dR) - Math.sin(f1) * Math.sin(f2)
                    )) *
                DEGREES,
                f2 * DEGREES
            );
        }

        /**
         * Returns the distance from one point to another(using haversine formula) on the great circle.
         * @param   {LonLat} lonLat1 - Longitude/latitude of source point.
         * @param   {LonLat} lonLat2 - Longitude/latitude of destination point.
         * @return {number} Distance between points.
         */
        getGreatCircleDistance(lonLat1, lonLat2) {
            var dLat = (lonLat2.lat - lonLat1.lat) * RADIANS;
            var dLon = (lonLat2.lon - lonLat1.lon) * RADIANS;
            var a =
                Math.sin(dLat / 2.0) * Math.sin(dLat / 2.0) +
                Math.sin(dLon / 2.0) *
                Math.sin(dLon / 2) *
                Math.cos(lonLat1.lat * RADIANS) *
                Math.cos(lonLat2.lat * RADIANS);
            return this._a * 2.0 * Math.atan2(Math.sqrt(a), Math.sqrt(1.0 - a));
        }

        /**
         * Calculates the destination point given start point lat / lon, bearing(deg) and distance (m).
         *
         * Taken from http://movable-type.co.uk/scripts/latlong-vincenty-direct.html and optimized / cleaned up by Mathias Bynens <http://mathiasbynens.be/>
         * Based on the Vincenty direct formula by T. Vincenty, “Direct and Inverse Solutions of Geodesics on the Ellipsoid with application of nested equations”, Survey Review, vol XXII no 176, 1975 <http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf>
         */
        getGreatCircleDestination(lonLat, brng, dist) {
            var lon1 = lonLat.lon,
                lat1 = lonLat.lat;
            var a = this._a,
                b = this._b,
                f = 1.0 / this._f,
                s = dist,
                alpha1 = brng * RADIANS,
                sinAlpha1 = Math.sin(alpha1),
                cosAlpha1 = Math.cos(alpha1),
                tanU1 = (1 - f) * Math.tan(lat1 * RADIANS),
                cosU1 = 1 / Math.sqrt(1 + tanU1 * tanU1),
                sinU1 = tanU1 * cosU1,
                sigma1 = Math.atan2(tanU1, cosAlpha1),
                sinAlpha = cosU1 * sinAlpha1,
                cosSqAlpha = 1 - sinAlpha * sinAlpha,
                uSq = (cosSqAlpha * (a * a - b * b)) / (b * b),
                A = 1 + (uSq / 16384) * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq))),
                B = (uSq / 1024) * (256 + uSq * (-128 + uSq * (74 - 47 * uSq))),
                sigma = s / (b * A),
                sigmaP = 2 * Math.PI;
            while (Math.abs(sigma - sigmaP) > 1e-12) {
                var cos2SigmaM = Math.cos(2 * sigma1 + sigma),
                    sinSigma = Math.sin(sigma),
                    cosSigma = Math.cos(sigma),
                    deltaSigma =
                        B *
                        sinSigma *
                        (cos2SigmaM +
                            (B / 4) *
                            (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) -
                                (B / 6) *
                                cos2SigmaM *
                                (-3 + 4 * sinSigma * sinSigma) *
                                (-3 + 4 * cos2SigmaM * cos2SigmaM)));
                sigmaP = sigma;
                sigma = s / (b * A) + deltaSigma;
            }
            var tmp = sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1,
                lat2 = Math.atan2(
                    sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1,
                    (1 - f) * Math.sqrt(sinAlpha * sinAlpha + tmp * tmp)
                ),
                lambda = Math.atan2(
                    sinSigma * sinAlpha1,
                    cosU1 * cosSigma - sinU1 * sinSigma * cosAlpha1
                ),
                C = (f / 16) * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha)),
                L =
                    lambda -
                    (1 - C) *
                    f *
                    sinAlpha *
                    (sigma +
                        C *
                        sinSigma *
                        (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
     // final bearing
            return new LonLat(lon1 + L * DEGREES, lat2 * DEGREES);
        }

        /**
         * Returns ray vector hit ellipsoid coordinates.
         * If the ray doesn't hit ellipsoid returns null.
         * @public
         * @param {Vec3} origin - Ray origin point.
         * @param {Vec3} direction - Ray direction.
         * @returns {Vec3} -
         */
        hitRay(origin, direction) {
            var q = this._invRadii.mul(origin);
            var w = this._invRadii.mul(direction);

            var q2 = q.dot(q);
            var qw = q.dot(w);

            var difference, w2, product, discriminant, temp;

            if (q2 > 1.0) {
                // Outside ellipsoid.
                if (qw >= 0.0) {
                    // Looking outward or tangent (0 intersections).
                    return null;
                }

                // qw < 0.0.
                var qw2 = qw * qw;
                difference = q2 - 1.0; // Positively valued.
                w2 = w.dot(w);
                product = w2 * difference;

                let eps = Math.abs(qw2 - product);

                if (eps > EPSILON15 && qw2 < product) {
                    // Imaginary roots (0 intersections).
                    return null;
                } else if (qw2 > product) {
                    // Distinct roots (2 intersections).
                    discriminant = qw * qw - product;
                    temp = -qw + Math.sqrt(discriminant); // Avoid cancellation.
                    var root0 = temp / w2;
                    var root1 = difference / temp;
                    if (root0 < root1) {
                        return origin.add(direction.scaleTo(root0));
                    }
                    return origin.add(direction.scaleTo(root1));
                } else {
                    // qw2 == product.  Repeated roots (2 intersections).
                    var root = Math.sqrt(difference / w2);
                    return origin.add(direction.scaleTo(root));
                }
            } else if (q2 < 1.0) {
                // Inside ellipsoid (2 intersections).
                difference = q2 - 1.0; // Negatively valued.
                w2 = w.dot(w);
                product = w2 * difference; // Negatively valued.
                discriminant = qw * qw - product;
                temp = -qw + Math.sqrt(discriminant); // Positively valued.
                return origin.add(direction.scaleTo(temp / w2));
            } else {
                // q2 == 1.0. On ellipsoid.
                if (qw < 0.0) {
                    // Looking inward.
                    w2 = w.dot(w);
                    return origin.add(direction.scaleTo(-qw / w2));
                }
                // qw >= 0.0.  Looking outward or tangent.
                return null;
            }
        }
    }

    /**
     * @module og/ellipsoid/wgs84
     */

    /**
     * WGS84 ellipsoid object.
     * @type {Ellipsoid}
     */
    const wgs84 = new Ellipsoid(6378137.0, 6356752.3142);

    const NIGHT_B64 = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/wgALCAgACAABAREA/8QAHAABAAIDAQEBAAAAAAAAAAAAAAEDAgQFBgcI/9oACAEBAAAAAPysAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmAAAAAAAAAAAAAAAAAAAAAAAiQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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';

    const SPECULAR_B64 = 'data:image/jpeg;base64,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AAAAAAAAAAAAAAAAAAAAAAAA5ycMMcZErHeTOGeAAAAAAAABrJhzfgAAAAAAAAAAAACkVQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACiTk4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABhTkJYnRzfwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUCkXgAAAAAAAAAAAABITgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFImJwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgVwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC1LoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFIFUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEDFGRKoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABii8LkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGkG6kwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIYsxpsZWIEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWBdExq5rRTOqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxZYnJDXztBuJUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOSmQOUmgnp0y5tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABKcxOHGunSj0yAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWxxw7KVyBE1o2QiAAAAAAAAACwL8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFE1Y4ac9B6EOvgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFMx5kiYAAAAAAAAkMaZUAAFkXpgDx2dXOgHEzoRxc7Sd1ABrJizegADVjaQACiVgcxNiNsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMYcDOXEhmT2IVgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADGHAzl5TN3PR5nQAAAAAAAY88wHoYonIjTD1wVy1InNjzcAADInok3svjnh5hJz0MbSbeCU4GdXOHG2HYi6PORYFsYoyp143suyIAAIEQAAAY0yQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABzEtzgZjgbgerCuAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADSi2PLhKAdwO2lYgRAAAAAABwc4uTFIHVzAmrkS1LcAAAF4dlOPmOAKx6TJDFnGzYzRy2OkHcjgxz4AAnN3NzN9MqaibwZoAAAAFIlK4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABjTgBrRqQAPYpngAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYo5oSnDy0KIAM4dkNnNkMabSRAAAABSPLBpAAAAAAAAAAAAAAAAAAAAABVN3PSpkgAAAAAYkywAAABblwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgYY89mgAA9Wm7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwxzI44YkiUgAAACoSGQNxMwbidYAABqRyU5GAAAAAAAAAAAAAAAAAAAAAATnWzdzpwAAAAAAAAABbFyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACUHnU5QADInssrgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAolAvQAcjOEGPAAAAAAAABtZ60KgANAPLxIAAAAAAAAAAAAAAAAAAAAAAADeTcDKl0THWQAAAAAAAC2LkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGHODHdQeVTBAA389REwAAAAAAAAAAAAAAAAAAAOUnTS5AAAAAAAAABYmINNOXnpIyoPPByMAAAAAAAAAAzB6BOlAgedDlAAAAAAAAAAAAAAAAAAAAAAAAAABE7Yb0b0TAAAAAAAtS6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABrJsxyc88ncjQzRAAD2qXwAAAAAAAAAAAAAAAAAAAB59OwmwgAAAwhwU9HlYAAAFieUi/NzOKm/naTczyaasAAAAAAAAAACsenzlRYnPyUAAAAAAAAAAAAAAAAAAAAAAAAAAAqmyncDpIAAAAABal0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUjzsc8LEpmyFAwQAL09rAAAAAAAAAAAAAAAAAAAAHOzzadWNvOmFoQNRLk1IzJxg00zZMdQLo6mZIqGsnOzlRrwABE6Qc2AAAAAAAAAAABeFmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC6PXxmwAAAAAW5cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsjyAYgAAAGznrwAAAAAAAAAAAAAAAAAGjmbNINUMIc+LcAmKhljBkxKAAAC4L02c0ooAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGaOjnYiYyReAAAAkJwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAc8OanKQAAAZI9nE4AAAAAAAAAAAAAAABTOeHmUrFuAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXBIbQeoDLAAAFoXYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOPnJTVgAAAD2UZkAAAAAAAAAAAAAAAA4scFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM0elDZTIAAFkXoAAAAAAAAAAAAAAAAAAAAAAAAAABjzHFwWJemaAAAAAABwk4kAAAAD1mbgAAAAAAAAAAAAAAASGCPL5rgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKp3g7MAAWJfAAAAAAAAAAAAAAAAAAAAAAAAAAA1U80muAG7nqwAAAAAAA004uc2AAAB6hOhAAAAAAAAAAAAAAA1o8zmDLUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2E9aF8AAY8yAAAAAAAAAAAAAAAAAAAAAAAAAJCcA54eXwAbibkTlkcvLc74dmBZl4CQ42amd/MocbOAAAAA9NnSAAAAAAAAAAAAAAc8OdGiGvgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGXPYxWAALIvQAAAAAAAAAAAAAAAAAASluXQAAAAABjjjZxEAAAAG0m8k5yI2EzxtxoRo5cnbDHnGgAAAd/OyAAAAAAAAAAAAAFI8pmmgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHos6wAADHmQAAAAAAAAAAAAAAAAAABzY8+Hpc2wuQAAAc1OlAx5McxOBloAAAAAACc2o1IExKAAAC7PYJlwAAAAAAAAAAAADSTykAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADPnWzczdgAAY8yAAAAAAAAAAAAAAAAAAKBzE4CY8FY3o6UbKRJDNmbB41PR5vYB5mOagAAAAAAAAAAAAA3o9UgAAAAAAAAAAAAA83HLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC/PWRsQAAAMcZEAAAAAAAAAAAAAAAAsSgaAcDMYAAAATmZNzOmnOSBs5v5tBy883kgAAAAAAAAAAAAB0o9MgAAAAAAAAAAAA1g81GskAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD02dDKoAAAMcZEAAAAAAAAAAAAAAxxdnNDQjSTDlAAAAAAAGVO7HCzEHqg3s5oeZwAAAAAAAAAAAACJ6eOiAAAAAAAAAAAAFmePDFgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2M7+dBAAAAMcZEAAAAAAAAAAAAAGiHlo3E0sAAAAAAAAAArG2mVOpnmQAAAAAAAAAAAAArHp438AAAAAAAAAAAA108gEoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPRR1kAAAAGOMiAAAAAAAAAAAAAWhxU4iAAAAAAAAAAAC4LcAAAAAAAAAAAAAAFU9CnWCIAAAAAAAAAAObHDDWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXhv56LL0AAAAx5kAAAAAAAAAAAAaSacchMSW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAOyHeyoAAAAAAAAACU8dGDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANwPVJOVwAAADGmSAAAAAAAAAABYFc87nLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdtO7AAAAAAAAAA0s8okAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADph6XAJCcAAAxxkQAAAAAAAACyOEGQOXFoXZgQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATndzs5MAAAAAAACU4ecZLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHRz04AAAAAY4yIAAAAAAAAAOTnnQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHSz0gXAAAAAAABwc4oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADfT1MAAAAAY0yJEAAAAAAHLzSToJeGznjwsQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADcTrR1IrAAAAAFgctPPxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHQT0+TlIqgAAAxheFcAAAAAAHmE50AbQauAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADpp6EMkAAAAYk8rGuEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeqTejhpu5ljkR0s3ArgGNLouAAAAAAQMCeXzWwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADPnrAygMOaudAAB5LNQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB2Q7+eaTmREgDOnTDoBvRjC7LgAAAAAxJ5lNRJSQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVPSZenEDSDrRnScrHnUpAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAujZDEGIAABUPTJuJoJvxdFcqAAAHJzi5rgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMiWxbgAE5IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZU6GcnLoiZAvzKl+UiqDLnOzXgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATnQjpZsRUB5JAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABE2U6SdAPKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMSgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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';

    const ARIAL_FONT_B64 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAMAAADDpiTIAAADAFBMVEUAAAAD/wMEBP//BQUd/x1A/0Au/y5Q/1Bg/mAREQ4gIP/+JiahoaEoJigxMzCEhIYDLQNdXVwyMv98fHxub28DGQmoq6gEcQQdHBxmZWdERP5NTU08PDyYl5cGrQYETwSNi4wNAxlDSEONjctr7mtVVFNRUf6trq4jAiN/4H//PDyPzI8ElQR5cXVFA0X/Tk4FyQV9/32H0ocFBVCL/4tu/25vb+eewp4HB2uesp6a/5pfX/xYBFgGBoc0AzQGhwaDg9mhobyOlI9y4nKHBIelpbIGYAa/n594eN79Xl5nCAhoA2gwBgYGPgaXl8OkAqQBATNSBQUE7wSLBweWA5ZpafEmqybKj4+VvpXcf394A3hDj0MuZy7va2tKSmnAlJROp07Qh4df7l9vp2+AgMxYj1gfjh+xpqfgcHBPak9Aa0B70HsvTi+HT09KSoOPqY8ebh5rT0+nvKcfTh9pk2l9k36o/6hshGyIwYgvli+wBwdMf0x3CAgxMYgufy5vb4uPc3MxMWxDCQnMBweArIBKSppfdF+fCgozKD0HB7DpBwdgrGAhBgZfX44+rD4fMR9vb6aMYGCwm5tJLi6njo5wY12ILy+amrFKHh4RETWNjboJCZ4j0CNyLy8fH28TXV0HB8xjJWOhT09m0WYuLlRH7EdfLi7neXmGOIZEP0+xKCg+zj5LJUsEKCiNQEDRKSluQEAGBumMaoyLHh42NgcG3QZKSs5JSROBgaZR0lEHPj4k7SQfH05HR7BbW+wfH41jhoZsHh7tXl49Xl5fX6yfb28iIgOfLS2ngYEwMKGOjqN2UnaIUYh3KneeZZ5oaMkmJq5dP10jR0cpvynLcnIrK8nAhoZSQD9oaD1dXXSrYGBLvkvqQkKcSZxsQWxknp6igqJiYhmqPz/PXFyfKJ/PQkKxcHC4TU1McHARgIBCgoJwwHAy4TIrK+YqcXGAoaF8fEZUVDEQnp6NjUqQ6JCBgWBgwGCm6KZ+fieOjnCgoH+dnV5HkZFAoqL6nJycnAcoEMfYAAF68ElEQVR42mSWe1BMURzHj1ha7G5R2W2prVYx61Eb2bCtV5gktojRSuS1tW30sJv08i4iWinKpNQg4xWpUcIUilEzySuD8R4xzJhpPP7x+91Hd+PT4+4953fO93t+57fnXoLwg7VBYVt35PSnydm6Z5t2+34CODJ/iN3CuRoX76v9+vWDEfu3wwgM40OPjY1NafZxle9iN8LR+9lxoaurnWPfZn6Rr0p9ic/fkRO0PZhPWHDanB0wbxAXVKpSHy+9ZMNyqTRbrfIt4nPTUC0qm8GIjRWgzDp25Oxw45h5tgdt27OV8cHZ0IKNMLDRdwynjNAC40CA4arLuBFzFzpS7SPGuWA7S6i3i2aEqx0fjCyGBdHJotIeFqQNJvuDtdvC9oSBCbhiE9fF5hAnDEUR73EaSqQfywCk9464gdHjuB1FbgRsQAJcIZyGb+c69yplhbDYIYL8koKzF4YwXDh7t6RSeNCOhVDsFyfq0sM7voAWIYsF+ZUFd+kwQiD5ne0tWacE4j4FsJ9CfDBRp0sUiN0QG1g2Sh7ceyorrVMgOHuBVSKLAYEwvwTUC0ryuaD2rLSWzq/DWL52tqeBUnCwVUSL+sQpptuqBkiwwEA5HigUBAQEjBkzxs2NXbQQxuE8QjsCkgV30Uc+5YO2UUnZqEQbLKiFI8TBvRCBUJeeAgIMXzpS0g3CosVELDRQ7RzXi8NTdAZBEbET159obGk8US8QOwoKb1Wfrb5VKCBi9uN/V0fCJBEmLB4AFHeEp+sOit0Iu/swO48H/5gaIGi0Bbdj70Fi0OEwHZiCZYFjNAxO0nVCwuKKGKSb4z6+fzGR5v3HsrjR7omuDATAdBa661Ojuip4Awe4Ed96GFFGhREyeNgw55qGXZHS/ELCgpVO+m8H8t1jUmOk7nt9ARuqAFDQPdK4q0EqLfsYt1lqQCkC3fWnYFYQ3zzavTcI5jU21Nzw9HSmf27UNBhBSau1ijBmnXH29Jw2zROiuBIg2sInlOPRZ85NoIAiIBSw4EicWWpwJfVnQJTzwdnAFhBhgCGgZYx8UqjthdACdYMY6rqiUkefqfeFdmlqBLRzVNRFReilp3zJwkT0vMt4ZmTiQsOTi+ffnL/4xECK9tIf3bkr07WQYBILIYkHIPdARVdEasxIEKH3fyAPZreFPx6PLgGSaJBSSYH1kCdSfURUF5qCdWm1hflSfSqYBCeEZQSi0ztkfni0kmHjh+bxu2M2jaAhAJXOyosSU3S33HYQb6Cb6kSkJLOZCiN3hjl7Lm3Ly3DYXHmrTwGo+vcPCrp10X53kklin3UCjmkbOPhQclOM3iEDhoxv/pAJc+hQRqWCSZ+Nz6TEdVZBkoy8Nj8OSqkkKMgqwmH006V+8wE/v2lYAkwBgDY6ni15eXIBMn06lABBcMEZME6vA90sVlWv24Q2TmRFSsY3N2c66GFxI1g24RBGmoXcungEBeQMs7uTTM9godC+2SGpu1xuRXm0ySEyS0Xmboqxf9aU+8xet2muTi859PzQEb0OTRyBj5IY5qqHK901l6BS5WaJaV/PGqS8J2m3fSSIUPvPG2Q7ebKPj8/kybgvWAEEs4JO0X4JGEzqBmV0BZuBt9FJDmCSsGiQlAiTzLKsl8eW5HUR6zUUBKDSua3k/CFRvEI5Vj6IN4bfaMyQWWQYdueK5zS/GR7HZmXGFVT/WwD9q8/HZYqSk0UZxrRGG6YA+mnWRyQlt7bKTDCHRWaitIha3ZiWiw2ipHUp662CkmStHta0ykApLMwqYt3T+Ws9QkKOhoR4zIASYCqAhFWjY7Powek5FCtWLJhOV4AmZZ1JdgwGpmgIyBpzRcxiYLlquGXWBr0aBtBal9x6TJZ56Hx1GAuhBRSAGX/N5lkZuWmNamzPnGXGZuYXiJdBDtQEJtotqq0dvi59vSY91SS6JzKlpoMo5BM/CpmrwJhBd2kIKhXEjU/eqaQxJw/PNYIIs/8+kyZNBSb5QAlgBRDGaTJmsbogLlMWD65wQBhzJ8pFIywuSHhUdLyX02snCrj679x3IJzqwe2nIFvPvnl+D3qXK+WDAsa0N+TV0mF3nKfN95jp5GRpLnuzp28BqHNyXpQ9v3f49bfW2qYbXy9dot8Tr179AnpO8Tv32ee1esEkUeGok93e0FR71Ck+GrWtgvbtREtWWD6Und26lYuw//4zJNDJ33+5v3/gTI/5WAGc4w0bXj98924RsmQJVgAYIPSC46NRODu7vaUprzbQf2d01IFwQsAF3qEr6HVhwRFDZYfvPX8D2gwEBQ57feOsHa1tamnPJnuwnW757cX2t+Y1tGeD9IF9O4eOQi1qzg3oghxv2ZXXOhQ0hXDFJgFeaYN7gLtlzRZ/lqEocpzg+Y/7v2XqVKiBLVACtngGEBTw98I0ulAp+GAJBOmWdkLbhRvKI4s3UlxXrvCadfmBEjh9WfRtSmxPVTG0M19/7vtU6xESOGUsVMCdmjaPwCmxdVXiK55+8Elh/u8EKFKp+Rfev320yv/yzcPH1rbVdJbSL9HeHV095inLY8vr3NvWhngpYsurimFAZ03bWg+8Q2mroHJlwiz4FisZFPH0CcBGnJZ8/zETyjIWUCoSAqEC6KcA2QHqq799Y0+AJYsWQQVMwCMAFtytSFB01xV7k9LSUkoZ1lVeF+AGB9rStTP9leV1tA2G4qq62OV/RA+XPXp7YQcLQYF5r0U3P6+meSwb3nsCyI7BafXjl+g102+hTgBwXYWuu3uqvGEB3eYEc3dXB0ELIU7mni4h5NULmgTMtcObgBCmcd6oWa9WUYwS5e4CkdDQ6zxbH9h5fAD4QAlMmmzLgwJAq7C4WFgAwaGPVh8OmdFWc4fvCLMs2xBC7UQpYQlFrlfIFV6/HF6+lMtPvpTcfDVl7JqK66GhzP5zT9SMprb5sEezBwUInJfOCISwgIPXls6AfM3el7S7zzsAvoymCd48b7Y4xd//ZHGCumvAl2h4d16fgt8m+MLtFd7wmzEzQYkPFXiVgErC6qr4AtJcUIVcmfBnPDzHuYepBB/EbMT9Iz9mJijGytfY2q6Rz1ZOCfTwm+ZMFUDOkBe3/3Jm5rEthnEcf12zsk6qzGptUi3balfU0TRrZFRtrjnHXFksYnMkBAkJcYeFiCuL4w/VIIbO0ZQyiWtJRdaViaMJG3UfM50SZpH4/p73fXtsGYmfPzrp877P9Xl+v+/z7c3nz28KGmAOEBjDp4BpjScHfvvxDV1N4y4iPve/ngcSzbGZUqerIC8/Ic1MC4BhTBMiplvxUmNrRv3+2eMG99wpBIcOZud6HYr3TSHxJGoAiJN7BX6fwuH1Ziiqm+Y/fLtPQRrg0rWTxbof38zFjdcuNZ40YxTmk43cxc/XR+Qn6AdmYkW0KXrzSSl9puGrSxw6Oo9+9jsy3jeVIh4KnbBzq//xDVPvDiWAQjAERaATd62xGK9lPeBZDLF0VoJ2RLLTXZk1bnauJaeAcvFFToxOFDHdAUAwkAS1bD9d/THXoIvFllCEL1VQoqTHR9B2F2dKXQwAU5kzmY30KrRp9C2A1G4SBMAVtXyNTD56G2QAuyhM5Tas2y5Hfds+d4Pbmc02Pbb7SIkTSOUzGEjKhButi9WvDAZIyUPpdocIJjl9YMsWsYUsgK3DGyCQURFBy6icAlYEuC49B1d//P37YzWeRZgmjEEKYCoAEx4+DCcG68Vm2KN3cgEj0VTm8udpEwp1xYKiYsvDkq05LSHYx1OyYH5Wzy5CcD0HY0kNnjrNgyrx+pTEbgEHSIhfdrk0DZ76+hp8/+zNS9wqTkC7d8WxxV5hmuFRcJ1BPw+AC8uJTyl9pg2kAaKjnlnzF5R4agZVW63WV+iEVD0rJp8KkUGunm1sPHvVTERDBXAQBiwv4G/h2dm5WBOXtCqrFAkgTzge7QHQ/myOT02VPmj6QAAwtYSGEbfqMtydH/H7bSoTAXBlMyKu4gq8ak+EDwAxun3jXshR6NHycgWFKN/nLYbCLZctmTcWu54tHj1XNksuqGM0onCjJQAgH0OTprLAhXoRLtRIJHwLCIAUDBezRcR0izWnpQhzBACYy++vTVb27MhMADB5jCmzPQAgoD+ffmynm/1aS+FSWslOYQBo13SFowKKCmPRKaSAaABqbWXSysqQgZIIH6DsxNG79z+7pXZbxevX+H5P5fkzcDekh/8bgFkJ+gZ7PAUZFEqYDUyXxsXxco3KIaX9RgAQEw3AYH7f/coHIIGdjo4AGOFySrjKKivmpDONTJRIon21AUNhYT3qj6Ni0E2wu/wMACUGakFNODszvV/YcEIIYhQKviUoxBGheCvpjnvhSfyeSZxbPHp29iKcPGHlw41OAwAM34nxCHHrEFlqfAul72c4bdBBHa4zjMqBCiAAEh9YP3z9+sFaBRcqMTHTNKcDABC9GYmFtTIfeBbfFwYAC6Q35gdktYW5SAFtANAxYYHF3ipYqBDAZMYd41IzhawzgNvKfD3J/wGAPSwyVtQlNbsQTrdk/BYYQf1wxOS4T+Dykp6OcrgN+pk2nRYBAAynvxF9Kwffnl1kWejXVJfOSmG1gOOjPQDJDAAGdZ3S6RSttWgAsqlEDrRrfD8taKbx57ENiIELGjZ8EbwYbSff70A7k8l1/hCcMDTv0Z8vArYkX05+5MqLjaR2PgMoq1g8O/8SJyl+EqxDaiEFh+ARaSN0Us2YCShnOUvDlwBl2ciRSqXd1mEJYEWAKpCnz3cSAKH3ceJrUQEsWt+g2rSUWaVZSAFRAMRGAjAxBAAXCQDHG7v/BQB1U2SskfnI6ihIBgKCmyXbDUcB9sWKDUvWrVG/ULMJdRVfSwBIpgyVVFlRQPJ/DqpewEqBWwJGOwCgNwCgOdXXyJpdySz6Q1JHACBhR9awFBsWtNTXDGrOw7klxdAWAIjR40sNv3o5KvRiLB/NZ4CpZL6zQZCLyBeBBllAG7XyYqPUbgCgNYDyl0Vx+9U7GIXL4MxRC4kTlSjFgMe6CjsVmkkPsq6eyEgEyupMJpNM1lBT8bqCRGB7ADhRBtTLW0QBEA1ALCUWv8amN+ZCBkYDIAqmNgBwHQKgM6rkMmUiJz2tUJesNf8DAAg50oDejO9HjjCnA/nNLfrZzM5ctUwzCGoTIhDLFzU5uPwnNt94YG0qsgTL3xeB4eZ4ONxSnJ+/AuCVlwd4Z21EAV2rQwBwnNvp/0lVsqFPS4I3ozxw5KCxwpZJM2wDAKldQ+v3CPm+azWvAcZP37F1pwChsPAGjyKIlwoFACE24gH4xQTwKfwrffh2U591G8g6HA++cWejdQo9RpOnipFNAKyH8SX/8kVeU1s7Ry7PcDjqPQ02eyrXFgCOQuJ2+QPBFHWc12OzYzosCAABKz2UdLPSZC4kGdgOgK7/BoD7XwC2sutsibolzohIgNPBKhz9OnX0xv0bR0/siVfWNVTQNRBpJRoA5mDDc3//cX/w+82SYMCngcVNNv/fAVC1tOaz0Gpz8gqSSVKFfsdzNvsCLa1xHof6l6oleDDO4WmoK+OvDFEA8Kcm4AvJ96tPBfm+nn55FFqR/srGXL3yVqM+YiNDjWIIANWX50Vi7B8NpzA9PZ0Npnc7ALqFAdhx59w+dZzqhbf+9QyVSvVC7ciQJcUntgFADMkejez7rxJVL0USpiNGqLAUWnL8rni7Tb+SycC2ALD3RAHARQOAaAvAAGlSJADaSADwif8TADCCzrx7+7gkbvla5nQYR2GjsCPohFLyH8atBCauKoo+11gdoOOMtFhGR3AKFadqjOLEimUIo4mFtMZWtEYbQVFBwRYDFUU0LhhTV0YirsQNFKPBatVqY1xQy6LUbUgs0IhbqwI2aKE18dx7//vvM18TD006M//PvHf/P+/98+4975yz5uVigUNpAJ4A5hJgQYwz2Im4/33PzKhn2v/zVx8j4YzcuzJIIgCyRR7PGNjGfMspzBbdaOd3UrpCGeG0YHEgimsbiAR9flxVrStcBNi3KzMlV4AqVG015QFobB+iNDCNJ6ZnPcH0nr6OpTw8CXwSvWECeGY9hRbaipEf0wQ42EmAWCyZAMifIRYmQD4SaLMz05MJCF0XAXRg3nCwcnYmPuUIx2IVS8BE5o7Moc58koFuAvAPOQig3ARQhgAeJkDLIr+DAAhEE+CCbvxPMwJN6ZQIbg601dxZfh9KAUW8zsUUINPM42ikYBklAXD/cRmSCHAupZuD7e17p9MmohNRpKS+aU2r59S7A3MJgHwfTZudVQDybvm8qkJ7ghNyl3YM9O/0tE9Op6XP4rTI/r2TuyBL/oMAGDZGvt+yip8SbD1QGnioTMVnPDnB8JBMvQKcRF0TAkz4pieXL6/A3/KKtzhDzhEcbBGgiCI/NxZbwJGAAKIBbnn9tbjEMnDpkqqqhrII0oS7tvS6CKADG+lPD3r2E0l6nXkyTgLk7I17P3z6Q29fT87FL0IGughwkJMASrkJABgCpGV0tRR0D4XHNAGOXY0Ha9Gy7qkECDDSNUWra5laqIQTvu0tX33j2rXIdBRZGocIcM7jHAupSqQBZR7kMYPgWA/w8qDGQ5jwYBgR7qxbtwbjx+CY+XMI8G2GCKcO0M1Kra2m9ihCptuJ9FFFIqM/ff+0d6SqjBiCccUj0j0DJDJTWb6fZLsMFMY2Lp7BwkxvOOChqdfcf5zE918IgP4kdp1N2PY5695YLCbPD6xKWYRaBDCRUO7yBTuWZcsQjInFEMCx0qeV3n5fjyE8KR9JAyMJMOt7f/fvv/y++/20MchANwGEAUIAgbAXqfrT+D4yNAEqe/qgTDtGeogAz2+FFCItHMkr6gjF9+b0j4R2kbhmcYsM3LehGzYh6utqa2uZ4JzooGILtaFFPxcCAG4BH/B3z5WC0+7d6PcsDaNJPYDmEOB4JwHspdNSSa3lWe0dZBbaORhIi0Y615dOTg11mOQrkEQAiEAMG9HvyGBBvpP8uDmZAC0YCcUz8awUZXCz3H8hwAH0Z8vmYwE2HnSllpSUKAKuG0YKZPuhxxEBTsZtxNOapkilcOVMLBxMkVw7NwFE5y3JL0auz4QDqIO4DoQ1NmTI33/88cffoxMBkoEnuQggDLAJQO+dBAAcBJjt6e+89NKBzsG00YZn334CBKBnQGEkr7MP4rrHP1mBmotoInUC7Dqpqbd3sUPDmleZAKe/QcBqa8lff6GO8esT/F7JJ0tQUnlDxWKULvMSpj2jfn6xCRqAxo8AfhP4l5ocBLCSJzsW5uZyam0Jnjk2AXSqbddUd4csz5c5kq9uAsz6/LZ+p9J/E1wGIABdPIMTWob68oqnE1NJzxHdInQXsnkLewkwBJGb5hjkEOTxQeKJngFrmACcsqeb3MseJlcscu3cBOCDZTnZk94REw6AoydTRiv6cHT0wAEQ4MCB0ahkA90EAJQSAuhpxRBAoAmw3zc4ftFF4zt7fKNU8tNauC09srMnOhacaWvjqitri9OfI8fK9fEQzXuGAFLItXKAKC59+aW8V/xJBIWlL49Tt9zy5I0oJPcBPg8ehkC5b/gGeDOUxh0rUjbEmtYZArxjZc+OoThMe9p/cAZfIOhhvAARUruPWJIns+a/EcATdcj3AJWo8fTBBDCXAAXdI3nFyxNbel23XxPgRemPQIx3evG2uqIN68fDmAAbD7uyqKFYUppYlrljcRPAQez0Uqz0h4jgy3VJmY5Swm1wkJj8yy+//P6z3zd73iWQgS4CCBQRAP+7ZgCBJkC4v3P8ovHOcHB7sG7tRs5DgAEV2e1tgUDlWKCsrAHpaE6KKDHf0OiBdpMgeBo7WbAGpgiUl7EyEihmLK41EoSKC8mBCBAYg2anFzVB1BIhHgmyNnkk6zIQ4P/MAJgn0TxOPHtLylIhwOaWZZR8zZa1opsAIt8FAcj3NUSAQ5IJQHk2ylG57r+ZAXQt4PAnpOqwUolVLnVqX7unoerK+5tqNzStff7Zhkg7hF4Kch2oBVAsqAXsSMH3DudY3AQwAkCIzRHahKagQ339gztRidmBUsyOD0PIFlwsU4CbAIBS/4MApZMZA3gEjHjFlwQCEAMWbztz32Q4ODsT7htAiU8e6nCswLDSSncUOX9LA5CQWcA4t5ZqYs14rvNbSKwHiLGf+sjTJSuIYDswExwLpL3/zTdYBZA7xDaEYJJ4IQTf2B5OoIIAuoKW2a01gBRXxICCt7iG0HxMABzYvHApfSZjxk2AiTSW7/yHtHUjkVix+9jpaj1cCAAKaeijRgN0oT8MrjuSJ46scpmLGrMSk2DAs/c1XlfdeNWehpq2ycSi61/L2lBiqoH8XRHQbg1gBACIvTmlAFcY84QmNAd92vh4JyoxrwDvpE4l9hVCBp7iJoDG/yJAiESg2AwXVUtJEhTYMhXCMmM6HkKPrdyGepyNMuQbePlLnqmKWeQq26vofcj7UNw2ccITGBqOe+PDEFxwgT15ox+WuvMT8fDgINJpKCY3Z1zufATc8/qjN/qvuq8qT6QTlbiTVgHySCT/AaroGO1cT8h9npm47eiFBdassO1YlJmTCSDynUHy3cvyne//hQaHooDNzeMHNOzjW6mhUb9JKLInTixuYjgcyZie8TSU13tDd9c11MxMZ/xM5rramPEDyHedsWy1/ABbueJPSUvhRu+8XFxiEJqq5kdSN+TUvy5FEekYQi/qxaWQgR98p/0AYp5wwnSemznNcVwTAOqppaAlFY5nMkkooX1v7+bUrpHOnL2JrFR4mC3KsGElOwcZalg/sZSJYLSBndqu2NRIJVce8AxV23RtGBNLuLGpVq1a9QgygShMZw1RXTqUtYPMrmQRVRowDT3kg99MJkftovFpB04eBgYNGloQUXYf16mC3CXkRViPl1/35r5MLwuz4TP5+plkApy3+8MsI9/ZCltCBGAnktNtA1qzUUVDmYP49QlxBAkaomy7wfRGJiVftKG/Jy3oqUkbjvuikSDlOj7lXIfDESShlK23Y0H3YZp5lhxB0j7f88XIsZ+AQ2CD9s2cavw1ViaU78YVl3z/w6uWIyifPUxOzOl8PnxT5rho9AiGzuaFuQvnUSoPNikmAP96QTev81Gx0Y8SBb8KWSXSy6qKioqqGiKFUurQGmDj2rpoGz/ytQbYCAnQFqB8qVqxgg3wX6e0dFTl51WhLv0qud1TVq40CZfXKfWXv54mQMQvPjrPWESQbpvs2H8AC15xO/xlvWrNOlj14IB77wsu+9Xk8Ot7XQS4BGKil3Aky3cuAdL9P84Jqhvid/F9G/YJ9OvpnjlFRcsTdw9AJrf14zsHx9YXv7XJ2/xwTs5oZWWl1MitWMx3i0tNLMYTiBbWlXP7FIxSzrfohhQ1Ld+idi4WV7b++NNLlidQGygN5nbeHDcavfTBj76miyUEWKkLEnR0T1lO++f2pQQBdKmyOFLWUFaW3matUpXDrCht6Bbut4KDJ9DaAjOPo+CT5mH7ibMaCLPv9UiYF5ay7pnHzj/U8FF3ysY/QNts4cCC3Gxtjd7GhjQYcoOtAfLAzjnwLwR45xWlgbV6yXyocwh5J64GZaOwzOF3bdhncEMXO0GeODMDNEfL8jr7+8tq0kCA7e3ZQPv2m+owHnQsACIBKs7XsWCQ1EVbuagg3Q9I97ldiGg0Sf3h4OiNHmDK8i5Ha6JkD2ZX8HZpzQln5/WXjUZn1f7gps+gxG0CCGg8r6uLPrz9wbtwVAt18ausPh8rBKC9AvdfghBsTGpDyeWMsrdaKSoYSKM4iT+aSwDUTKES3rKujeIKmtOHv1ob7cnhw/b5DPKYL6jFToKPxZxGxgQ/jjTDfe4iAJYTWr5vpS0tG1JWqgVJwPdpgwDZ5m0ocxANfXWNgTbeQb5SZ+G/LxoYKNpTXj8cD0PtyM4BlsD/HYtshGjmfQGXWXENIy5p9zITKUctZ9Zamxdg4ffXl5fXx197UnED0poTyhGZtXvCHBLV7hu+9SniuYMAJOnxRK9v/rTZD/soQQEiEGmFcH5FBe7TajsIhoTiaEPV2sHVWgSQS6w7kkSAFaldl2/66PNt/LNqFXbTQJnSThzbDmCtiKtDsoGGd5lAe+KdmNNogw7esLr4Nw2g5TvcfI3XZUG+H5+EDfhp/BZZ5jTMSdzQT9i0pGF74lZRZ0O8M6ebfvvaEPnwFi/e9iaUNTSx0rHYoSBEiYV/FbHQzqAsiQutvyvtoj96g1KX4ublTAJ17d0ubAdad9W1oUcUNyCtOWE6nyVXqdo+rmIbrvPSlg8vmgMMAWKM6lCcjl5uXQohgCwSERmw2AQh0HfCuQrg4NCqEIBC4o7cKB0RApg9j9hJ9t6bR9N9Bh3I+efci2dvuFTYDChb6FKwz2y+3huITWfYNkf766Aunnwh2Q9gJDjw5331tAJR85PwALbifYJvQ5vY0CdJQ69+d9RRJ8kfjHfSLPq6Qu/B4115l9GWuN9o9yCUdQv2LP53LPOpw2TSw95AvLLi0u1yPGiG4uETZQMjgU55jBtFe9UqBc7nz6Q1J5QdmdlBqQ+VPJD5LW/6+oe9Kw2ObIrCz15NL1ovunU3PU0Loq1VVMo2msyMfR1ibW1CInYzKcFQdsEwxKgwlrEbJUHF2GKLiT0ZJIihmIy9DZJM2QnlO+e8++7r1zxLKeWHUzNVee/dd+99737v3HPPPd9phPWRmADYyxS/SQlrxVUWBoAsEsHAs4doWS/oprI2DOr9C/xwsxkAFR0pA4CQVV/7kqslPCCcX7NxtUA58A49x7WZ7OBLhB0ciRCbduYFZ8K8cEYEjdojglouZB+EEXGIZ08K/zmgjCdsFeKGFHFZc5elpEexcInxOgmf06W3EH8YL/X6CfD+/e6zeISEO5MeRpODrXaZpCzPI9xhemruDb0wYtjuxAxbaUBas0t557m7+lIMoWyXgPZ5ndBlBQDWq1CkULooYkXmOvjPhnp5wtPeXbVhfzgCgOrITOqIPAYA8C+IEFSc5vuTMN//l/+Y2NjyzkNCjgDterCab8BCLjaLCOgm7hXaTL0QkX86KnhOocx8nyOUFnvTiveuifQg2TORXjPaieO+P1Ps9RW9566b/Q0Gv72vJOaXwEqQafREVpJLVg2X0keJbAjCrZ+EFnGWkxCgrEvSgd9VOHxNWivvnTRhhdJF8Kj0jJP4wPqHW29Q92nxQMr1pamO6Am4PE45zt8g5+mCFp5GTLa8b03HobwwmZzuYa9V0renMVvNfL49r1fzjc82A0LMVUOZ+a68kIZNZBK/sYJIjzleBEbqCYefcdCNj1dcUb4Mdwa/7iuO9pW0BuQKgYngv4MsBLkE4RpU3oBWAzM9uPUHvQ7Cvw/1IgkBV+2WdABt/Y7JoWp+k3unOzf9lGPRApZGEyZgZ8OHBAyvH3TsKdPLrSQ0z5QqiDX6MR8IAj5fTGFAHv88elR6KiQH4Nn+d87jghZFfQfrHpau41AAMAmyHhzMiEEOvnXXfgYz3IUqz1R6ZtJrE1gMV5TKlpvv75peSEMLKDROIr2EDsJEFjHOv4Yo7o/dqSn2SgwOxXZn8Etf1Umy4NFdCYuUS5xs4HwqSjXwKfHOU5YAIv+DS39CFu8DZ4nW5JJ0QO5++GEzlQFELaCsqp8s651xXbKp6bArD2vKtD6xNW1sZPioKamfiW+EMxdt031q+P3JTAKSSaqUHLbOc2ePFHu/4vxJfB4XtKwN0Wx5x6EA4ALL5RzC4nemQet+rH6vfeCZ3bEoVgtqUyw6+WxZNmjz/V3TC2nY5JmbfoNIP0N7BODxpxLTUKLiCgQ2oTuD39ZXHHEGArUetnj0dA1ie3Jc5jwBb2PBP+P0axOgOFG9Dzwzc6Zb0gG0ZXM7TNVuB3EJVPTOENq/0P1x8ED84hm0UDrPWEGeyLqPbqNOyvj7kolgPBwOx+PZjF8QICWpn7mLVXIAnKo4r9wFhhaVHgA0e/DhnYcCADid2HfWnn7uvhcuEc7PywFyhQmln8uKaDq53Go33y9gL6R93iT+eiWRPk/JBJRH8ADmtOO0RbEX4eGHuDP4bX3FwQ6ysyrZDww854yAXKOSZg305OQw2wGFL8LDwecXbM6/rKp1SzogHVhfSf3EbWRPUbpIHjtVDUTVhX0YTp5AryIXuLCZnasrQOSh2E/JGRG4dRn/bDwUSOfzHI8rCDDdjnjU5mPQTF4iLzb9nfO4oGVdiPaMOw7VKJpO6oYh8oCLfd9ATHnjUlDr26UsiZ1O/qfkEtDXK4n0ILBbewJnvnDbJ3OkQFsVU+xJ+PNncWXw2/uKg0vFkS+Oc+XmB12JyqMeOWFeRWFJWNC2LNzvnfOJWatb0gEHF6pWBVSjalV5We+MSyRuOfXosxe95nmBw7EfJS+wtZ28rmzAUB8/4DsgMRr/lNebwv90KJjxe6htW+9p+4GSA0Cc5+nZZKC0bKoc0PkZiLZ2HqrPGNtUj+1S3VBsxB6YrPAnF7EfZshOJW+rQcrYxGJ00wr/MqUBeHFqODWAEOm/cRDpbRpAUe3TVWrHkMdfxJXBb+8rDiQTwM6yfYcb76U9wcIbclEdV/PmHXlQuPjc9uHQK21DXAazl2vSAbvno7q6DgHVhIAVDb3nWWXvnSHE/wJthC6IffzpG6Bxy56qDpVY5ejbW7zWXaQA/Aka/3woFAqkvOkcEUxkFJW/H7scKacGSOnzTg2gHNASVOI8VBN5Z6e/Y1G1kGLYx4dtnoXvrkG8diYyOLIJKEdV7Lq7nqHbRe7ntFcx21pBiPTPOon0ThsAM+tUcBu6KOrADDpYSYk7g9/WVxwYlAiAuIRHSyCAeXE3XESVOGRivTxMxPcEeDdI3PEovrUXn7vN78Ne5qxZbkkHxPf5oi38AB2mPXYd2VBTsPVOmP+NxTYKq/Z1g/7VPnGbh+kBbaEyCHFKLy00IvwAIgogl4+mc/FgMBziWGq/h0ZR+/vD56roy7XLzl9McWWVNsAkyOHZaxEtSlGHzkP4kMWUHxxM9JnkeLXPhychag4DAKHtPKJa2Lk5nRi8n368CQso8pz2ikVK24j0AxaR/tP7Ti1bBUhEw/LEkn4JWpLxV+LO4Nd97ZQgUooiNqk8wvnER0kxviYHZUsVv2PsdQKnQzjp7Vxzcyh3YgYG/D2gNbklHeC2fh6iK6uRbKCCLKSHIB70lRHLhLy9W2OBohiT8ziPg+xWqociUJ8MrVYAIVVuMXyZeMCbgupPJrPhgDefyyZjahEimwLK66/WB1iO0flEQs4zLcwJgOPiWOLFEW7vOFSLeWS/QDRkF3qPj8V6qd2dROsRKtOOMqJauCZkxMLexocLRT6UtFckZmGTSP+mJtL7IHArxGS1zxRfsBtRgjQQAGCGe2pxZ/Db+wohZqMGgEkj4fLkq9GsWgBA3sKrQZHFr+KFnHoX7HCXpANmWzoEEWFmNAdQSxz6eE9fV1SRixnGQv0nFbA8M68IBSBhcVjXqwng+BbvN13vaQBgBgino+lw1h/zJYNQAaE4RdMzNJIPnPjOc7lS+Nx3rj71LX9M+1qsVUMwkfQ5HEqwUIU8IHwBx6G484YOJhnvSTfwXKpeKtHuAYDvmcq0IxxT5e4v0zAPvTikpPhiGpXa1wrlRPp9AAD/ggVEgV+w4Hnltt+XXFu3eEBIAQDAQYInayWb/AGD3z4okNgj739vAwBf5Y8yQjQe5m0LQdmQt1APGQOboh58ihxRm92SDqgNcAabIioTAEjk4w15RXOKrKRVwOLsiCgADQCZALxzw/01CgAyA0DxY9Q9Hn82jMkgnsCYUkX+xMLG4tBQoTBUPKQxmOmOqPHPYLIIpCGBXDzrRADsxE3Zfq7VqwB96CT5sw1rvlSh3fuXAwDzl9yDgVPeLxHLAPVqaSBan2QeEykj0iPyciCz/KmnptIKekOLlc4AwOfDWWzAbu7uxnSyBkSG2J3BrzelwQ2BtCYXj2kAyCAx1StiTMDXrCM4DVlUaKlN5069Zs9ZLkkHNABoJ2dlnpPsAIiw9m4oljKzIyYAtAoYiy9DKqenJC6W0vKic2zVtI/FFQB4OOWzJ9NPlEE+DCOArIl3kQqm0CYM4skIW6aPgI3GTDAXMFcN+UAYCDDsQhaqzla1heOwnOTfcjKvma1wz4GO7bcfoChpZK8x0wlYW+5i+iIjFm6HxdzSQpF7o3VcqZ4rNI8aUwBsAEqBUA+ZMmUqh70oAJB+ZgBcK3kCIAABD7I7g1/1NQ52GMmtA8FvftIAoGlfyncCANsfeqBEClsaQLTXsh7wqmrI3JpluCUdEAAUe5NwEmMGkB5BqSsAdPeWhkdHh0u93QoAWgV8FR7nYF8LAJPYAKjz1i8OzhcAGAoAXuYWizkQhRHg98h64pBCtM5kEDewYSMTAyivWDAGsGoAnZeeImbYBWQina3qIcdhOckfUTdxeM3MgO9QeAmFtvflflgKKtP3KpuA+nS5pse/ULdL9jEkF5K5wgmA2TACQb745iuEPdXW1rbvPVECnwQAQujmRGaSKAtGyW6by2fuzuBXwenNLRtvSbJxy4WhH20AwGUp3+mBEjr0wAMtGpek8fywsRGE0Pg3P9VcePpxULuGW9IBMQJfDN7TsT1MQEShK1YdiyTfWTo6vIzmCC0RnC+2/RQa3vv79xUplQBAOg0TwJTswFYMgAiKyqALANTfBABFIUdWvaOFQTyZDBuxGVDIGwhj1RAPpaNkPvqc/CsnTUIflpH8Oeomc935ctKb7npP2E2ptvwPX6lsAvrTpZpst3dkSssaqhd18FwBLaEBwBZsUzy0dOkP3mgNODEtdZQGAQgwAaAJzOBnFVgOLh4CCBAC3Bn80ldmiO9DQvGjXhMAGjgo3x3bUQx6NgFlFYDQjI/fHcwkFo/tXdMy7ZimE7B2dUs6INomEF+yaBeSjau3lQBe82PfBJmeGrp6fh4fmdcZMbR0QjP0/Jj3ghu3wGMB4JRzVqMJoB46jQEArbGXBQA2/e1/c3RkilPvtbZ2gMMuWtAk3pLRmEnCFAzhT5oy/ioAhOTPMX3Iz2V7qfxGU1Erm0C0Vj5dDQC53e+j7GPFBjVXWNskE8zhNavsggaTd6cIegCAFGAApKyGGiYXZZpzZ/ArsNJwkaC7aTsAlOW+sNuHGQBLevh0+Lyxpo+zFPn8yEKEFI67XH7Y4dMBAJekA1JXKt01vxpSV7ctUCxR6OiISvQDAMCALFcBvgxGpiovPh0FgMPPwgTQXo/1IQNgXrdn0l6e3wJACH8LhfwqJIxKDg4OZrJ9rwgAbKtGXyxGyiDK9/5VAExkUj2ibiSqV2ifgdx8TAHz+0L50UCuf5FkE6jTWfoMPTNDtQHnyFTUlRvjREcc2cYAMAxdEOkGltx6NGlPnexN9xEAGE3n+uarhjDK/IzuDH6zYnCtDoWAjNUXGrUDgO/EHDDo38xa0Qu7h6J5aJmLFJJRIh+ec8p6eHaXpAOmyftjrSk77z1RotC1sddQ19czTgCwqwAP5Uf4MT/a0ztonY5MbzprGiaAxcthZsIGGOn1UyL63wOAJHEE84YyCY6MlEIpCwC2QSegeWFA/g0AbEeT0/4aAEz8ZsNqIBgeFhuLeEQb4NMV3opYsrbbO+n5MVfMJamfwijRw6u45MiasCpkNb5NAUBnf+oJB9EQhBoSfpY7g1/1lQ1WSMcALDgNAAEWf2HJDgAACoDd+gIAGhtKhCzJi45dmwDgknSAFr3kz/7mq3qSiWTJmhkrVbq+aHVfadykq1r0yOcfWT72UyrgHS9pzRA74bjTL6z5aiyYGEwE+2vGS9ljzsre8YQedMcUMAvekmRvb4kJrOPDo14TAB4fVgpVvFIQA1KWkH8ZAEK31gCQmZ2WVsne0vjP46WMycBXvg/TkrXd3nnbc5g6U8xU9bbPFQRIB7SxsDxJKyg5ErKgKiA2wHgpkbQaElvPncGv01Rg0QZpTSIPqgKAdiC1FedlboUJSAQweSvybRJjV+WNpBOuSQfg9oqDgNccX/z+VMh2ai0rAGAaYc3GA73iROjEKRXvSwz3ntxPbXri4o/15B+IkUwOODD7+8wc77FMsMwIjLIRKCbmSHEO3gHewLj6BGSpWJX+BwCwuiZ26HkB5Cb/vBE80Aj7WbBwZd+HBsCxNgA8EA6MNkMVH096MyoKXhPphfVsmsEWW3QtMSX0ih0NEWtZr99Xcmfw2/o6gSQGS9wCgK44evBI4ladzAWnOQHLS5w/lLMXAhc7INW5W9IB/BTEANayFw5kHnlkHRJl7Bp6BthloHeEbuaRVklKn6rHliOypBUald6add1b18LN20Mm73hPfinyeHMieh5EpcY9UO/kB2AAREjDtkVHe8Y/+2xZKfeKBoC7BhCLQ4+4PnQCYMUKAGyHiS/CDPxK59fqJgCu1ABIQHOOl0CKhQI/XhbINLwiivauASD16BIy5EewAc0YrRaStjuD395XsbgtOq/d345JNrhETMAJdF4AcPNLG25T345E2KvR6RsIAG5JB9aMtd666KOPNoY/G0w4WwSv6fO/uxBFRlSGzxHCLtcK4OASUh5rvXUJ7w3XilBqn9G2FPbIb7APogyusuql/nSoVJo3rzfb954CgAaJHTxOAGDCOfm0rwUA+tABAEIAA0CfJABoDbByuQbY04eItyu/tQBAmnMcxsyOO66ih9cJABQUIOkSTg0gDWkN4M7g130VAGxSAQDOKtOwLN7/Ec8A+qeXnjj7oqkTOW9Phy/2JTEbr49FXJIOoKbt4c/eEpVoX5cGwEJumADwyy93awAgOxQUwCG9iffrawum6WLM5NT89Sxj2ChPh5a9GHqbNIDy/2LUtVfYMETBpELxxGA3FkKLtnWuApJwHcvflQCIYMRnaADIYSUAGAECAI36yCabiw0g9B8x3gQA++F3bs4BAGRcYQQKAJKuAEA7FQBw2gCrOGwANwa/Q4VhHJwAEDMwOh7u/4i2dVfWALjjpKuwAJy/ZOAepM0VbvNs16QDkgR2V04ca0eAcgJEKc8+8rb+8ssvu7GfThTAFCiAxsGksM7FtwFLM0h0LQhvlHf1BcElgg3An3TAS0tGvz+hx1MAQPaAD1s/8ZbTBABaYyRQPgnsVLE2cABgrxPOmtHyneh8fegEgCAAAGD3IOvwL43L3l14t6wCjhbjXOfqJvL+MUcBAJS173lQ6Y+onAI0kZ6rnAJfOHPyvzhaAPBlWZ4AWQVI2gI0JM/ozuC39RUVI+mqJvSrmnnPrWY41P/eoj1sPP5Y65FvP7r3K/19wezy9zEQlN2gabpr0gG0teV33+3KldsRYLZbgDGxykZYDt8NFUABCoapAHYuwA/hf2SqpQJgaXJ86ZfrrLPgETYslgwwl4hcuzKiCAbLBikwgMZTa4AgQkURMHQyzGBqQTQG+f/i2UQiiO1jwoLPCQA4HaZpAOhDBwAgNs7PzkSgR3zMh2/AD0C/NSIU/CrlB4Bz6sRrQ9M+l4QmHoN+ucJmBIqLpIxIL1VyagAKnpHwH1WCo3VG8yHd0GT5XNwZ/LqvqJg85prQr9tG1S3DgVfeK+Pxz4Yd/nK0C5nVvq9neTSEIAvXpAPc1rbzUXl5dJS0CxMQDWzUST/bISFKxPx/+CmAFbtX3bEF2/FfuHAZLE2KRnnzy9Wfx0Y53gwerpViaSQiCOOYCuTC4VBaXDwepdpgA4TjYWz9DP8gG7cozl6maJ7K5ziEKFtpApQDQA4rASBicX5qOTfAmXBBt1UtfcXuCZTCCObDwu9k+Ek49xAVnNOQkoLguE+Bia857hK3JikGwMkXhjsnDNAl6JRuqKFQFEvKncFv6yvFF55pI/RTzbpxOAu5BiXG9KaLm701P/7UrkTCqdySDkjwXT8qL4+PRLsf4OmjtME6IUIvogqd+4BiFN988tW5tYWhdz7t9NCfO0/Gn+g1UsAJx0RedpTJ/pR/TO/u5NP5FH3Z4oYGAKACJntT2PTNe+eEfpDHxxXy/4XyUt6L8WfAaBE+yuGHTatWANCHDgAoMTk/zPKRqN65EDOdADw8Kr2SsPPnzuXvA6F9fCSCYqIm7ER6rpKigQ2dMOBsHIgIo7/AArpRsXi3jP9K7gx+W18pvvAAIfRzWatmWUVaNYjwjamCTei6e9IBaSunqrEQIJ56ySMgUcXSOfqpqCseTXnxc1uItX76pSuuStXQ3w9aADDMN2NG8wIAsr8bDuRTkHQobu7uyqZisdAGmTNUiqelBRVEmjPLB6wwYi170o9SHjZtKxlx52ElABTnB4R6RLM/wxF7UxwUfP0bQ0TY58QTM296IExHJFRMR8yzqCqJoo8jYbhTaKBVgk9ZRKMjFtJWEAPAncGv+4rzv7J35dFxTWH8Vm3DzKQjyZhIhslopBEpaqnYJYJjreVI7FQrpQhpK6GWqmqDUiqVttZYE42D2FqKUqo0Ka2qWhpqLbWe2tpyjt/3ffe+++a9NEP5y/E5yOx33vvNfd/97vf7/SAoYAn9/M72vV+VdzChRLQgRZUgjeiAm4QvYR33LjZ8g61F0+DsOnT6q7uuuDBr1LhRwraAc9x7maNw44I7HQDIkbFjMx0eBTlZmdiKzJIOHwEAEHDasCUUw+a+pz/B0ghK+PkOkcAGkvU8qMStGiALf+9NPwAM50dYPlNvLTidSPkeCj7CJDJc9lcKYkXsAOoRHbD0F0duAHoDzHBnwYBUnYAvP90ZYdsBKNIw+O1YxTrTEvpd9Bt6ktCFnJAX8gdaVYLzexYdkC/hfh/T+fgujpJwrbYj2SaMDoN7V93fGhk/9Iah4wsenMqsJbkVedcAQJkjw2R/h9ATwyktQJ9aQW4yrOfz3owA2ClQLM7jTxiNTzBEInm+pRLZwA+VqE6rfpIz7rlpkugXUgS8mM8vLB+tQbSVCVv9sOx83KW4tc8S58yzPER6kS/CLYfhPs15hhD1NcmIordEGga/HSub52pCP2x1LYlf6xvIO5iQF+IDU1QJehQdsF9C3sf2PstL+FP7HMnkQhkcc8FmgAs2dexYjLqB1s3EFNMAUC5m/608OBc1MA8R5tMpABAIcDwSg0Mwb92a54ec5weUN9B3n1V3w/CfRF7ae9OdRJtQASILCMsnwKRXZCu+sIkMQlOOfU/0EOmFtSuCAcdrwQCXhgCrjHsjDYPfNVaFcBH6+Z0tx54/zd5FL7SUBmMHFOhJdCDbUo9d70Mh312YucKIlsGhUnbO23dcBNnLiROpTg2y6B1MDpVjZ4/M8ZrZ7+IGxxD2bJphbonAs5hmDJNx7/MDyh9I1sckxhX/Ks1w3pvuJNqE+j/+S4Gk9NV47a97Szu096Y7iTZhfPPFxj71dyVgdC0wrJMY50M+QQAv7d+8+bb05jxtiBO+S0Uk9ePsYKzGAYsCXGd+pJAMkQfsC/1iAWTXf40j9Y0ZQWhM8uZQA5Cw5v0I+5DvUe3lQYcm3yt+K2omKqWJWm3kjvT382/8AD5uVlqAjhl2rHUbrQiPQIEAh0a+9aB8O7B8jIInIaWoxY065vbgdmjvTXcSbQLHh33zyYWeLtmWgU5Me5mNJnKERow4FfNbPgePPJ0gAEKZNz8/JEoFRGqPTQs/aIQI3Jx/hDMYPFVbk3qI+lAY5wfkfivpY6/ZbEH2mvj198nPJzd/oTEpXE5ZhUhCtIjClE/IQZCHPI8KqwibB7FQP5EQcANg4zvoWaGQpELmRFshoO7v3yL1/om00UJXi0k4siKaLLdD+c6nzw7pu68kitNdsxtizkOhECSXzwFYMSzkpENv+KWvNh/33nQn0SaU5sijQ1CS9u3cJHx9ORqLIML7aCa/I2TkfkEAP+3fvrkoFTA5noQI7hUhAjfnH+EMBon2tUz218x/TdSHutbT8gDfb0W93Fm7mBAKcQn5ePLdx77EjeQIZXTIJKQvkg+GIxSAez2Pop+wlRUW8tpEQYARYDqQvpkBseP7855JaaE2p38bjPYv3A++VFIrC0zbbTccant7N/l0ITLhDIw+5abR8q3zpspDdADaHph106UXcY9b6HzKRB/YZFNuhvTedGfnJhR3oNFCmycGzUA3JHyTj0DIl9jvIL8T0c/MXekEARBK3pwExYSvz+R4Iuu/qpX93B+HMIPRTzWiAFiqm3hTHuAXWlk/97pdXX06W/lHoDGMOoLcwNqbBwMlQjNW0iOU6VAfBPuQfVQZbtUiLSEACDAApNefvm/BMgxLOuPkRDty4Xse9hfuZ2WBkVAW4OOGY4DbWltgL/l0JjLhFETobtx85b3IYy+5Bla+itS1J9HuznaYJO54bmPZBvPedF8mbUg1q0brjmtm/huZQsLvrQNFQiG/41n24mUFAfgfKwhgUwz75gHh1IMcH9BCBCMhRODm/COcwdQljDWpJurb4AfkfqkDOoICRiwAwgGZ87Vh/4ts5i9/sxYpj7Kex1yvv/V++iDIVzH/yKNKc6tu6eoUCQEgIJ8BwN629TWJW5b9tj13xr2gi0gbWcMAun9P7/0Heu4/XsQE5Lihwkm3cazptny6EJmeuI1OQSZuzqSzYx7KaWkprh+VFWml3SUjtCbhvdl9SEndVNgN9f1rIeFfLwHeK5zDFyaI8f6tU0XoXhCA7O3tIsO+eYA3ACaDmx9gIYKopitZzj/CDCaCpwrX3/CZvJ6lcr+V1XXdVLfj/d8Q5pJ669pXQAnm+2UwepxW6YyFC+ShtfYhfCMetmYVzSnpkF70g6XTTM7/rgMGBuej+6MiGKfOOOECKW1eC8sQ1HKDTeJXIPdzW9rR0WCcni+IEUO0xqhIyiqwAvi2FhcQZhfVlFlLOR78OYJeVRyu15yBLf+sNvrGVRdevZvasJBNNbt5JyT8r4Vnfw2FMN+XRmGJ0kRPM2WEdIIACGXfXLGodyUI/AFQ9YccLfrebs4/wgwmMrLs+0bm0eMJv1g+k/UslRdacW/XTcXKARVk69+PdxOjzIzaRbFzP49Twvgt7Ge2BdEDuj1CfyMZNnOrPspoX95y8MkHo0eE+ePcuACX919LyzKnrK6IZ4Dfb8hAUC74loj2FZOXnrVkydLJssGI+7Wt9UEgdbEegEYMPvzLJUureb+UTwjdPkME1+XTC5cu+RKHguQHcGjGBeOkcKAHltm+fEA9qVK8uJdXJU7MWCSyjVDacVhroEEKiykWNUQOINvqukDo8Oy/EhL+BAr0NFH7fM24nPnBN/CrAFA50gkCIJR9c8VmAZXYPM8OkMF+LQsRuDn/CD2Y3yJ1YzIbl9B9qXwm61nK98Nfycj3u26qx3ECYNuFD+gHT3v8NRx3w4GJGh4OXdies/K70yhoSyCHcwDbGCA9oPSNShbKsIlbVR/NgBHiEftCQUB3m4u/16/F40aOn/IbGjXB1Ik3DWE+MPYFWbpi8lnDUModBjxTQyQDgI1Vg6wHgF09jRjFugLV7I3DC83sD18eVlnB6gL86cWFZw378NHrafQAQF3GnMTSTz+8nh8iZLbcdza0aF5/az9e81pZuCPdAEBhCrJllBBAxgzLB7FrguD7RL37bDrFehlWpGzPHk9BCUBGAhTjApSVEkgD9C98/YIAdhXgvPk81Y/o28zdhBABA8DZoLAEQDyfATAl0gEA4D6vaanxLFXcsmMNPFw3tW1XIfXsTKLWjCrxI+Zeu0NrOzDOZ11KZximbQ2SHlD5Ro4jTd/66MftXbQKOELzTXTH0K/gGCXhDdiek0utGvqE3n7768/fPL2Q1Ep2pP5x43wnwyLSCDF7CDF80HUDCDkBs1ZdfuCRnR+qlD5qzaLjdikaPc0At2TFv/gUeh54qLy+GgP74MyhORdeQbRckno0snC3pswAWA01YBlHxepkXrL1dKylaGmBsnUKAPDMVAAcjoDiVYRU5Tgx79I6WBTrEwQIiSAA54l+AIAXFXgyHQCWta6qme8GwG+wDurHIZWGI3sCgFgQHgQLQnFtradPcgDQgrbARyiwJaCXRLo58A+0B6MHlDo30BI60A2ARAksdeGzmAqAn1bd0PDjCkCtq414GtI/BWMo2sKOU17z8MN0btkWaCPtJxhkSmcMLV2YAjA1GACAK0t0B1poTrq7BwAsWzQOANjRAAADu+nS0QWn38VFPZJ61IutECoUTkVG7UVCaaePr7vhl7qci3n1QCsLWnn1DABZldJSNBkR1a4kVMLJ5QfhEQQ42SUIQMnQhgMA3I9V9C0ZAJbPZCxLD6eaWRoAoDuP3Frb8lbwFQD3OgAoOqK/9j9VZkmEg2A7oing4FuUCoAsOGHmWwCg/xjd1sUn79sgxtBt1NwlBxGqhKdDfG4UpeoTPACApEnctoHzlGEAsCaLCE+80AwvXj8AZuLQ8NyoAYCBoWZ0ft5sKuqxK11uHS22ctvIjsmUfKizAlvUN16F1UZmpC5zJi0saOGVr3oGAFUA8TN/8fWQUe1aHELpCxVBwGq9ggBc5fgHAACtbFx8Ps5/ChuEukStZWmPABAbWkz9bckVdAVgkqidAfIAVIp54uXCpnReAGzuA0Ao4AYAUgDOB8J+AAxqSKKqRFvBt33y5ctyCSC+oVijuqhgUbbF1QAoa2fKIxaaR7TN/W59AFiXsaCmET8NC4CcXJjsjQhNY7FNlnrMake/Zdd9q5h+4ugwDsKV6VqsjoKNKxfUoG8FC4kJuw1KBwAlttYwmXVUu57Nho21lK39ggBDRBCAfRA2GABI1Bvnf/Hp5xYASALBq7pbtvJFTT8NAMSFdPii3N+mi2+3A4DlHZFcK4BgIOAFwCbpACBOwkd0B4B8yrduuvS80yOgpGMZ0CR0TJkBKoQKFmCeHxtj8zIwURoXzusxJxx8cnPuegGwNlE2n8+/BUDrpXStz2e13f2o6jEnAZpzTU0N008kXZPVAa+Omn6f0x6k/CQU2G+3aWkBkK+Nk12qXQ4Z1goC5IkgwHQRBDhICwJsMABoQfHphx+mMEKNmIDx00gHALFw74r8xk6UG1sAfJxJAggIVwOQDwAb9wiATTY2VtL2ErAYOYAcRL2ZE0OH0Jj5SxuD60gKxQAAiwDN7kXWWCgAQI8REa2E83owINBZsD4A4LeRhfO/owcA9HvMz2cAXHtVWXuiNDGnsbHRDYA+fbjZ49vnIZRW9nEjZvLwO7ThEzsyDQAkPKpdbgAoRTSqnHYSBAjCCUkEAbj4scEAWE6J+pYpnHASE5DQ7X5pAICSC6X/C6asjpKjtwsAwbJ1qQIIXgCs15iUl357X4LP6A4AObjWi9N9Nm2SqgBU6d6YPLk6IzMLNFkqHwOVSAJd/P5CJk9ApyR3pXTZIwmkbKolstIPAP3bGBfRh8Y1MCZ4IOQSMDJrTmF71sqVK9k5hy4C3K11Pgu0Xch6qRm3YBJ8XnZg/gIAulHtcgDgPFzLggBaTEG7oW0oAAa2NDcQb4dCaZ52sEJHUIp/6QAgDt4dWatLBwzGXiiFmsD6nY4AQmHF0ewpuYEAkNmgjVcBza1z5VpPAJiI3W4F3VX8GGvqUSDp6Gzm8rHOTOLo5ixAY19izUIBQO9w8jvi2STBeeV3bcnxAKASANB8pOGL5NC4AWDLvEgCzx268neyLI9MQUQKWmWK09LJb2ZJTFm2ApsqrKycBgA9qna5BQFq12aiVrOZCAKIpt5WGwyAIk3sxR1U84feCJmWckyfmcnl/54AoJS5BrT/3CRFAAT3R0AQBloIw0WXQKt/8lJ8x78JAFwOuCrUnLuMhLVyvztrMgo+giZqeFKBKy4swU7Zgo7ln7UYovI8QmUhGoBJ4wee05gyJAlMDwC0sn24ZP6hAwEmfisPAAQCrIu/+LvKwo6cH4Zgv8HaxEHeeGidVG052I+NtY7dAFAULgCoNKpdbkGAWisIgFuaVbrBABBGFoIahSPgabfrGt2eb4LUg12+Q3oGgKTcQ5ra1/AVQG+GvARJKEt96tuXTVIZ+HyBZZqfDwDWmJRITn1/0gBQ/aQq1Nk1ZTWO98qzzpDCngAAnV9PXI220A9mLerq/MxIFZBEBRzjKqJx2gv4uWS5AOB6JlrN4UvAEUcgCTCXAFQCWS6lFmwj9Ih+ujReVtqCoqaicA9Mgh05Ao8sPq2ysL1kNS7Ici1mUGpLQhsfRSsmj7nlsanuHGCe5HsCAD4UaVS7+AkGABAECKNd5ACmfoJCBOvKfwAAULh1jMhbtGD58hbhaVvLUgHAJd0CIFvLSB42feEaKQJwQNJfl/sahJO4B1FB0wCAjUkH8MYFk5zMDKBQFaKT9VlHyZrC9syvnZI/cgCyfkI/QpJaTBqM/Cix0fNjT0Lb8MCjj26aPp0U48Q4+hoQrUwSeLBJAvVegFY/rDwJFh1LG9tHlTJXCaHcjqkSej2zMwFgTU09JjmI82h2LwtGJhrP0gGttATIZ1PenWpLwczmZmQLAGgyTKPahYctAEQQgDYc2CJaV8Xsm/9NAOA8SghPG+U75ml/K+0wffr4AGClYanHisValv28thprgE0NABw1gJBVAxDhAguALb0AsHrrTHKSj5QDRQiAsFZibVm8uml7Zzv4KG5upxYENJlt2t8BAFuc5CV/XEbKOisKulqoDoAPF6IVLwMhV82XlS/09qySgz+wejIc+4M1JXOEq0ThHpiE4tiSAJCoqSeJMZE2w6iwckcOcMsXS05DQCg2J2vNutKyOq5IGACscABwhJHIzE6j2tUrBQAQSY6NoP1nHwCkjtevPwMAXHzMhG4AlAs32IrvaAtvvQKxi29M7I9fp6n9AgB7CaQLogHAxEloshMube2A+/gJsgpIFUAw8q+pAOjtAQC7eYoxKXhLe1gA5BMCTm4hYa21a1br7X0EOjXOywH/g+zVd3pqYwsAkAUKCBiRH1fs8MyPrV3FUgnULgrQjWhBHYgLQWizqEmwJROrH/YFa7EUK6wFY8resFwlNhrmrgpDgOLgIwgH9gcwx1kyNXMxoPQMpehnITy1bPW62uKzx58XdqiIVGxHhRxK4lQGZz1WbBulUe3yAWA2NpwAerkESA5g3zxE8KmELm8sBklSBwA2y6Eg5jVWVbp0p/SJ7hYAJgfaZGPEpgIA6X4di279c7ZlUTV7BeBloHcGkOPTIwCsMSlITjYJZATsD7VKaCsir1y24hmn+nmA1nTn3+rbFgBkW5I5Zj6S2PCT4Ybm8ipO9IRrhHYklIJ1z1GYfFXYllH6DmAzPhzRXJB1lW2Bcg9MQiHkJ1RYTF+bxRL0FxRLQpaKD4V/XIHDX1w+dPSpR2UbAGC7TfbIgA86y0vnkjFoGtUuDwBWhB87d/RNb3+D37SjLOF688WQCK/9feXc1v79WyH7oAHAKwzWiNqRYmc8XR7h0ACwR90CwPzm0fFIsZmdD9ThU989D9fftq72j2tWzdrUAsBs+YkaAH2wHwD8vSwAxJhUGhhH2FWAQUD/toIpPxfOgdTBk/N0a7DaiZtTSJ51xh0zZsw62WjQ7/ciyjSs/3diaH9Mh6V6liR60VA4KeViM4i6Dve/tQC30ZAILhVfgenbDR68WVvydFcTpHtgEppUJD8hWbQ4IFOai8GJ6AosRYqLNj/zyhEAgO4HwIb73LtPo7h7bk57EEL5hMA0ql0uQQAGQN4FWSPPnDVYloGSfdo3pytPe/SjLCwWITSatU73A8ixLqyEViTFaSdV6iuAQQAT9c2+vxsAgoy90fNMsceujjYwUf4i49H92dXx8agbZjxncEqDca8CyvG5ZkseDxmm//X4XpZE5TYmdS8DDQSgYLG68HeInXBRWevqkgn/rz8VDR78wGboGkF1l+cvuJaANEyNKuhLhXCg6Qew3mViXRYgbzWWcRxkkrBNAdj9w5PQry2UJIR7YBI9AkAxAPj8o1mpcGBR380uvQglZNMRtNb2ydBJhkoANcukUe1yCwLUon8m794xo84eXj68eKCzJHK/+dcoUpcxF7+lI6OsdgDlrybLAUP8JIqzzqgeOECuABK682eASX4tAPgaAATsvisF/WXU4SfQgh8tni3L2+vOdAGAJHi/t/6nXAeQcoUcBGNGgm9kVROIaSRuitlPfTMLurtFGIoyIRL7lcM+dwrkpKsL/NB8tOsee+yBgfEE0E+JxwmqU1wvG14Vna6XaAHmBcBNsQ8aQiwvAPW9fCfNRgQCwgOYlu+YitLALAkqPQAw3i1YK42O8SbnCO/hMt0pV23j+8K1H3O7XBrVLq8gQN69X8SrqlJKwSlv/tH3hYaL/3FQ8leT5QysrT6UojpaNaAv0RhMKKMYYJJfDQB5ISHgkr0pLqHzLy8kCv+95ER/yfKOujPftk2RPJio1SUwPkAb6YOgTYDwvSyJio6cBsC27LVUW//LB28rCS0KUMj2S5dZ0ghhc1dC5O6MS6oD5StISFB1akhTtKqKJCmhric9gf9WpAGAro5QU1LtgHI6VNIwIjR7V9stW/qUVRD806h2eQUB8iBx24TQqpoEAPPmQsGX/8ufb3D+qrsr+xYh0R04cGBV8YCivkxjMCHc/kZr668EAPJCzPw4xhS74/emX6iuuRx5dTwKStSCc085ET8tCcXMfpcAwoG0bUnDNK3R0pyM72VJVBYArGtwdjw4CuNWHLcjqOJfKk2bCGVqo5ST6IHhGiVlIC5QAwHTmxDURayPkQWOCcNBss5MbnrShgFA10dx/ikB3ByHSgBgOfI2lk0paa+gC2Aa1S6fIAA0BEhVU0sGIJR+c3+8KWaGkuXgcPXFHkJRUXm5obFIOHymMS7bfgGAeSFmWQRmW+eF8KJ/8GI0Vg8owpRwJTnDStBgSiBr4DYDlGHyQRAVAtgJXm6/EdIgAwD6nleOLrkK6jKjr1SI/Sj2ElWAkgvuvFzCFEedkfG4aMCyRUG0gMNoz1wvG/0AwPokRBGLPaKdmbL99KS/CwBs28ge6T6SAMpFlthEliNvAmtUaNPxC9OodvkEASBx+/QLL1iHCGLTiwGnN154WtuZ6q+MnHwzpHL4L86iPf+Wz+Qm/BMAenihOhLeROBQ3DeY7rPkRWIGXegRQJBhWnoUE5TkGwmJygDgEApxXIW+FLZdJPa6P1erAhyrg0cm4JSBbYJByA/QYYYgXE0zEuZ1nPTn5rYmk3mLjTOTwwKy9KS/D4D96LN1Aii5EmIQcQMt+Y7jySdh6SMvTKPa5RMEuIveiH3xTUuY980txY/te/uYYrMkujhWchZtMLffQ9QnAPTwQtRciRN15owHmBJF6RWHbzCWnmcJkkRRdEscGAAchZhkPJcnqUE6pjVoGld4rAnPyDQtC+GiDOpj5AOArPoxG+bAEygy1zgzrYee5A/uq2YA0KLJCwCbAEqhlTmnPo58IABbQXrhm09/m0a1y9DmHUEA6hBM8cX3EfB9JF/rqifRyxMuUYBsJzCWHl4oEv1wcn5O36mvAZZo7A0PRTrbpQ6gAWBc14WpGVP5JiYZYudEE96ROYNyPk4rj/oBIGyj4eipqM8AdwAGJ+LMtB56kj+YWbGkUswf7/AA4EUkIJQA9tXXpOsMAAa5z5HSxqIV099ECtyzatf/8a+GPv8Dqpg5pIP5TR560glCT/IH1j+8saB3CCwARCzXSQD5CnJPtwBQyiS7M5ECp1Ht8kXAKFfQ5BCbNvsercmK8Njlmyf6/frtFKGN9rM1w80Gad2TCoHYmV5/2YQ7wf3dGr9gNUjLdxj6vPOX+bayxMaL+Zn6cRu9ug252x/rZfz37j64VQQKKL1787KSb8GElfVKJjIAqIhaGpR+gWACRKWZPAMYFpDQk04w9CRfCLFwTEJWWCOudAOAxHI5AdRb0493CwCldLI7BnK2F96VRrXLEwH44BvtGlwxw3lX04W+NWzMJd1++SRy41a5sTIAHh2AI7UKwTc+FYLQNA2Ah1+7AC0C0KHYVoVYk5H2CyfG6G/nLybChNREZ8a2vHsJbyKOcLIK/90SPsb/Fh4AbKnDACAW0uarYrtKPiZbkmLREw9OjfXRNbFS7QkE/cD2khyxfNQsoFR60sbKH1iGkIiZrLAOufJMCwCI5d6IBLCqs7kN+tfYWBVuUKhPCgCgH6zdRsGojrTOTqPaZUMrnkG/qgANb6EA3mcEUmaSZE2O4Pd0oSQPz8MTSecq7EDA+vXLP9ABEKN95O7rUyFgALx055f3Thl/yjnbYr2njLE/3JBG5LUibzZ/Pc9/uqj4eCbuJN49hz8RR1D+bgHgulevU1MZ/zqvtwCAzJNHBG22MV+l5H7xYrq1446ff/kJlGNHHKVk29XtCdTRlYshYhVgWEBCT2J3Q9SjfYEFMCu48Qor71QBgHQqN7S+d/P2FcvxjkYAn9ZhSby3BQDLB1OERWAhryGNapcJ62lYwvp1hACYFo/PnJlJpsUc5lnily9Kd27zS+3X79MBOJwYiH4VgjpiINL73fouHDYzh9504i4gPlL70HuaTo89WfdfgOKDLymh3o8E9V7fiYcpvIk49hYQWMPxqbb5eTmi72BTcEhh/KP68YI1lRClt5dPG4ZgGUQGwF1Xa/NVJPdzsbeGW+TB+j5LGehtEbcnUFVnWwP/SgUAbnrS5t0CAEuYsOYGPlhw7ik3OLuBxER646CF7VlTNPsRvVUyu6QCQJJdmpomYJKK9aza5Zn/ydPQKF7GFFeQy6xgp4MS9suPU8D80oodGhkAG0YgAEU6vwoBc5CRi0/Dnu+rjdh5veOp4/KVi04f8P8FSrGl3oecOxHeRBwVnN0RXMTBqda1vcGSn6OUP1gQYJUAhjDjn3U0rasIdrbY+xMkUUGAQgIl5qvzsTvy9Vdfz8lM8C1uc9Qbo25PIGmOHJRvWUAhoSfJjpQ/LDv4idvws7lhuFZtZ7VkuKKtEQscCW0o++8EQyyBvAUYIAfcwNsf/FJfSmXzbSXsLAFiNKW5+C+ZX2rPfCsD4NEBuIx7ef0qBKw9nD1oNrbYscP6y4zncJyM1xPR8mIkUVzh/MWU+gmWii9UJ13CdSeBZocBRVzaZ0LJDFuWXN0fXIT8LIhhl9ZrBLiVABAVRw/R9ni9jdprNeXzk884SZTjSbhgptiuYm/tD9pa41vS6CwNoCmOIKXSG+cAIEcDwG5J+kPMWSc8/An9bKoKpS+D1ZJLC9euq3CFVmjoNkT/i5fF3tDps0mi3V66RHwG6ZX8L2P9Z5UXF5dDsvspCWeWSASj3BZL80AUCY8WPLa2plYHwM4A0s+6xqNCoMB5vuLGmU0DhzdjpiSqM9mbrqqqBn8+NOOX+oWJyfQXQZGoMNjnI+p9JUuX073RM4h3r2yICTnOP28xFqHlsogFBxgWRVXReAbGnYiXFmu6MXefGyUAnO6DDtzTOIux3rPk8/GoKMfLDFAG21VQd2QGyCiDJoFudBYAWE+gAupnkvOcCoDNdk0LgMvJpWJ+EOrXYvig1ZIrU6IxQRss7m8vlxEKzrxlS5pCN+hmI0xV2iTRrH+ojbDJ8QKkV/a06I/tMPr99NJhZwkclawIAhK5ZWSDyTOeRwZAdABsDnDVm14VAlbQmZp33mjyD25ZRK2isMFkp9TiKDvHNXcszFi3dNjiUH8weyqZYU9UfO7ff2FeP6gV4N6XU2wf5UyD9v1T+X2z7rtveBW6OuhHotsi4zxwTGGlsmNNUhBPo7ZyKCsBgAVYrVs8jKuMVgKQHXTJAcaP/KULzA0SKUAOkLUuCE2Cm7nR2cwAXgD0SgUAhpIWAGNpNyQrYyYLedOcZNWSbSwh1WIoKtnQp+lYBOt/iYYWQlEQD4AzxFZJn1kwl9d4YxkA+sxrHDRgnuJ2LQsA43yagDsn0lysBbDUibIBbkB5ZQA2MToAY10qBF2OCsEnoj1MjR/wDw6WRDjHO5xPoDjHoZzdsjBzHf21bzmcxF7mn6BUyuFbHqIGtShca8L9ENhhM63W2PJH5XPVLx/chCvHuCCXQJQwYwisGDY5/Vdxz4pIQWxfXSlKADjlFeKMoptbcTzwRelLyw46VgG0oMll5kYuTCGxs1aNBiWsUHgVQCgrdHkCxU1zpIeckA4AE4+k3RBkw28S+Y3TUqOWbOPDT7VOmw3zQyWxrjtNW5pQS5UQQQbRGvHc9yh9xn8lizzkcA2AkjgDIIcBQMZ9egJQEtr5lPURwkhzUQ1gelSZJD1uW1OjA3DR+agDaBWCb60KwSQw+0lkcBozPUZlrAVtZGbmBbeB5GCc4066O6+5c3lHyTr+a3gp5mALAPiW4+gDTlG41rTx5oreXUHpG5cQkho689JziJECPSZsQzIABpTyzCZO/0I3Ure/iIt6E/KLL6EEINgSwrcm/OJayM83zn+k3n5piJgbxSRSgNZI7KugRfEukPSQ6nM3LdPHtSeQ6Y36WwDg1TEO2tX41ZiVqVctmWgmj/JeRx9fGYzrSaz/ZZTDjHwtrRcO0Hl2Hf6rs0gHAGUWANq4L2XLQr6T6CMIIGRGEKckawkXMHH5sUR6tCoEtr3yGq6kBRT7cXHEX733E2RznK1R7/p3yeaDPwMxrPqsuUn6qbNluwHAmhxY+KHzLQrXGtpdYVkGIECSyFHys2ede4AcPXhCzxC/LpnrZLsNbZ4Xvqf9AiZM4HOeAoC4BwBc1AzAZ4Z2a/rvj24i2lhDA760OMgy0HoCJUjjZNO/DQClpLpHvxpTm8KOyrGslmzj+mt4gyXgr4NySRn6X7o13aoXc7k2cCll18gf5b+XBrBjonOAsqBcAvC/1uaDTxA6jA2xvaNVDhmozKNKVJ51QLYyAM9SWCEAq0JgAaAYACyNi1rDx/C0H2VmAJ5H2ToQAMhZTX911kvbuQHAWpOBkYVfC/ZWoMsguyvkE1GX8XF7Cc1somxJajvu9Ez8O6MCAFKFrzt7JLcRPLGjnQG0oxl5gNAlQy4B2VzVhimg3q8FAHYgADAZhQEgHFzrCVRqumPdLKDniJ7EPZKqh8Axc1fW1V8KV0NKgBWp0BQ0D4t/gxku1/L6CRJs+r8h2agVvjvAWxDhK8GiTp4AUgr+7IyGo8gsVSH5nE4/JjHNNzIA8Ms1mv6iq29VCPwAQA7wHohj0E4bOV5yAEwBYh1Y0HXCZwsiPzThr05cEpAC2BnArMGiQTEiRzu+7traGvUhbn85n3Z/8x4Mh0Ko2VoAhAJa24N/m2oQbQajjaAAbQRb7gw/aW2QqciCD+ayZZk5SBoz45PPgsk4AwD/bukBgJBR8pVZa+BV4gmED9FJlIsFJPuz3COp/uWwrn6b7h8K3w05kgOpnd+WsrU6KyRIaJOyjuQXTauGNsCC/VFmArlSbhcmgOa2cJgL/gYA/HvPyDmXlMVQiqJSH/2Y+KKXIgPwEP4Z9sWYEhg7oYTYHQCUAGAqiryLFlDuiOourQKEx4Sk7+vIgs9O6Cr4rQl/gdPMVwADAGcNtlZmAN5dkeuVnQEuQrZDdXDUbMPrAUAvJZvB1EYwNox1v7MKIPPPxXO/RgNlBq12Qf2GlzTdS9OpHwCacC8cLHSLiicQyg2mOTKVnmQEEXsoBGEbbSJN+qRMr5RR+8eyPT9gnqO1uEWNmzeG3BXvtta53wEAaOfnWrZAwKizivQqbRfkGHVWSfEzpcBXQhPAwZ2LqORPRhixgAMAuuILSxUxHTDKybAAYBmAM0xMjou3jqgQeAGgGACxhtlEYyFKAgv1a7NcyLqRd+TBYO5OJxfJ6FJcASwAsAajOmzOzyYHwO4KM08kB9CpP2U7IF7cgkTXvUCTK5nkAI7O9yGBSTj/LAhnXJRR8sY6FylOMEoKAY67S+9uAUAIMPVGMjEHD4gKjqY72tCTsMcnHkxiWeQPlOvZ0ALbaMRDu814U0xCTvi63l3rI2IReE5DDLf4BbRr12Aq3ptTxbsrsvKMg36IzGVLH1PKNuqsSWwU0HZB0qqz0jfmIi9921xkAJ2LcBkrESucWAoAcg1LFZWoXA8A1gYPciKODONEAYDyA0ARAPKJomlsaqlo1ctcA9g7shkKQVFIacoVwAKgo6sVq4BlqyvEv7q/4Z7JKqB+oAiOnshuV5ToagBwkZY9PstEdkbvLtPvnc8/muG1LSvG1daFXkox/lrY0dXcRsPGELoHAIUMnhuChiPKZcuBw80Cwq9QE4SUP4zYN/aCaB/P7OKpESwPIbtreApuGYFuVo6gvbLcd/X8CQ91KngvyPr9oJ+zvl56xtKlupDZ21FnTYawUXDnE6E8q85q/IzQyVSQbKYJABNCQrYGkPV7ZoBGXYmqG5oKgO9ZBmAI/4MVGMh1EALAgfMDgPuc+UBbm1oXAKp+x955Z3PeiiFNH2UupyuABYCswULPrDiwopLdb0HxYwDsrxSlWGj9B2VhxtsoZsvXO4eT8AG1QdS4w2Ga6fT6jDr4xcN2Z5x/4QeL4Ej+/v0xiKC2/uPSIfCVBgC2l3AwQvYiJdwsIOyyapV05Q8j9g1LK4IMIcbQyNCwK4oQ+il6rw2LHSPiLR0pmIFKqYDdkflRMHMO/QXOhiDApc6qLgfNoJ9VZzV+RsncZBLm/TQBREqopSERL6PdrdQcYAyzVJcQolNzADj5L1uxD8ebtH+HXPwQd43OoX86YW1qpZBDgWsAeUd2dLaF0cD4UUZ06bCdRYdUmY65/v3mPQPFLiPLYmYAYZvQp/Qd/MCs+8rh8giR2bdlBqiNooRRAC9PTACyPtOTOm37OeffqGwQnQ7PF/PPuOTzCkOwTXv7QzCVAGBEUrvtJZRws4AmYf4WnwTljwO02HfGyFPwvwTVenEXWspcmtzqAJbt5r22J8wjiVsuuM10pETjLGXb/n0wg4v2ZUHSJyAAWDlWAoBbrNVp9UC0YUalCSAjmAD+8V+pbcoqAIs+cgz7HJWoz9FnQKuAuF0FHEpSnU9ug7BCACY9dQMAoWHhAGA2t/Y4RKUgAHDfrDAJBScmO0rEynbMzcNDFS5hJqMBjTckkpmQeoje9cA3T5kkkH7RWVTABuec0jO+pPP5B6FNRKGFYW1X9FhGYEVvVg00BjuEAEkmV9vBeXsJbbjoSQHK4LRTij+O3VaxUWfNuLNvOHucltI+fCznNrjysv62PKN6LdNgdNOf/K2lYOKZUsAuW4t8nltToiIL4hLlUBQeUQ7BQD7rJpy8SCrDSawK+dKZUgcglip1wtzmqQMwKTk2j2IL6VdBN5ldnbgBIBiwRtVX3LVbvpqoLFGpkL59iBoYoVButMiV7Zjjh+KizUecfC5aSCIOBBhSz65czRYArFvTHoyzx2eVJq/R6Webz5POqG6inUBkIshNCADd1vQUjcEOIUCi6VYoXf3zgFmOCtwxCxNzMZhvmL5mzYgprASYrrgKJGzob4v89vJ2MaRVivQvorxXJhOXVLwZtYV0BlnUVgpZnjPeyw8ArZyCGlBrQSafeb1DEPNUAnkx4q8EAgDg7ptgehyff98MIGEB8MoVQAvKxkJUYmNS6kWIXXFjRlkN9xVwKNsxF7r2xhROvlQtewkCNN1IyEb4HJkBfs7q0Pk591Xjfuf8R7ETvAJiz4otwbSwS7zEOv0LAGgMdggBbq9MGKuENJ2JsuTgfkalSIlMXIVSgs1yYg1tzUU/IYo6ketw85m090PbgaS6Vb8HjmgBACrws/4wOx+7Z0TP/xDy03w0S7kjhc8V/zZjVPmkStpfA4CeAJrzIgwAUx90skC9FxCLUWdgUm7jYQMA5u5zbPocmeWNCA36iwBAcxdIGcY8VBt0kjXJSOH7cBjbT3ro9JwUTj6ff70QSiH1bGwAAIZ8V6eTn/fSANDn/8AVP6JmAiLPnWQL7Z8BqhgAPAgZgn90ykZKA6L+uq5+xvyJ9Ld2FXKHMcvJXdTVdfLJzYuSxizHaICTzCMSVAAA8lm0QZJNikBa9oVwO1h3pJiELRmSukdlegCYs4T7IJ7mB4DdDaSVYV6Y2t5wdQm6dwMPFe4+Bzx7SKJgt78CgAORMcKK5nJlzUM5ZWbVtKFcqONQtmPu/lY2CSrQnHw+/15Sj5x+BwDbL8tto/TcWZ7Jrh/O/+ofluUmF5NWOhN5PFV9mwPQGOwQ/mTuSsCjqq7ww66pMwnpJOOkmWgSSAMNoYgtmBaiBIOUrWCrxIKgFAirrCkoCkgRgwpIJAaigAFLQYPYSGURMRpFJAkaRAgqEFyQArKUggRsv/7nnHvffTPDZCxdvh770QwJyWTeP/ede+6/bHkmbdowUSNRBRHEnbxEKme0ECc4qVQhZ5mwnJEjO3UqN2E5YvTFF3otU4r2V5/tQ7vjtQQAZfxEv6Y+8uDTaF6cxdSWNlJOAMiLbx7qqyR0imthcpEmN385IgIATFY2++VjRIQ+gx44+QAmyR917hExybhFSo3Dr6WeU5X+vXJbYM9I3seWIzyURtR9SXnP5uJSFjPmWJOkNPljorON2C5IbvRtacQNAA7B0N2pQbLIw/+O/vmgMRypogwCJeTRU/0cTPUDdgF4Coa0Fw12pUpUkyfnKFE9UgGHstw4o4U4wUmlCgWUCcuZnl1ownLwe9l+c2t9mHtgTF7cwktwgHOTPisTAMi8izt2AwAcZkQAgMMqAmcWnbIVPyQNC4HM+h2MIErMyMxkqgzA4GQEGe0+aupsPo0McCHArhMkI/039Bx4g5bbhShfAIAJD5WbcRSO36iTwE8IytNAgobR5EsFy43MSkPGAABAh5cWpLRytOcOb4WjKoMEow283iFTfaEQBT2F8LSrlGzWPaPATGJeItDO0ULMZ4xCertHpwo5yxmWk7LNhOUwALC8k7J/s5vmKasP1A/Nxdt6czaQKncAxwoQAgBvRADoa4ReM2M0olqIIYYRAB8NJNAIXR8AE3PURZRAZgYGcQLTNSfQJPo8GeBC4JWdjRT/XqKlySNlN24B/50SrVQ6aaXmOls05e+Fw6V8XXjt518dMNVPxlQ/ozWTCK2vW7CfYscLqr+1bvmH40/9uZ2Dz7j2YwoVcnHKkOWssGE5zUwTsLmQB5919d1L8GhXIZjoalLq7F25B3A5eoARgEhT3ozqGt2Jq0g7nBRif4EfiqR7zfkyrFAPAvCpsBAEsoIXBZDWBkvIqcOFwIiUpHTTzhFvIIDr26gsARJOLEffIvPDsUe4sFGhPz/MYaaqonCcwgL9HhjF3zk5p0jFOhkI8KYiJyDRjNzEhqupfkua6qPy2qupvmVK9E5gsrczkaGBnTRmECjazI1maq2Dz7gWGUNFE7volCFT4cJy5IWSJmAXAQD79NPd+/CjITZdxuwCpAl0cRMo/AesEU0DQEe3TUlO5sMBrPZpcXI0wGu8QUCwLkCBg0lru4M4a9QDOF0IZupEfynD198EpUrq473UeYhtiaVKokEWBKaU9u3rNmGjLIAAY2YpHmgBhBskGvmXJHKYMnP7zDgOyzEIUJuKdwK0DNxzaR65TPVheSK8DlNMDkLqKkRO3NdLCfVSfIgzRq88h5o9jsi7cIIzfEb35td3wzc+twWnCjkrbFhOM9UE4J28q5wn6uWnO7TgR7oF0ADI47ac+/V0NGjRvFcDVH7UNADU9gvHg6Ijo6OBNFxptHv6+htlEAmDYtEHokfWn1OkNdjYSZlEH9uFYIxo9pkkIKWbdgR4zr8HKRb8vegTMjonUzzzrVInBaaUksbJhI1uWaM1UPztSQH1DI0seTNhKa1UsaQh2QjApoLJDdpbgdVMeH5BU32zmzBFfFbQA5/7w3M6MhQlp4X61AM3E/ASMbQleSBeUcVn7LAhevmIPa7GitwWLPpyVriwHH1GQmzJqjX45rRPw9fRI9UCCAAYJDkeTLwxyU9PZ25KbFyy4jQ25c4quy96ySZwngNf6VQ6GjDX2BmYH5KAz4p8J2lNcdb6BrkQCE1IyvjUPUULqTRTAkU5cFCFxYQWDgkh1SmlCNEZtM8+zobkcR9UkHjE8OWEHaCZ4Ix/qLVSews5g8cmUEpHbxSNomdcEG6qb5kCl4UIwiuHrJS+nkomy2oFgAR4Cnaw0+ZgZoBDEWBUA+D0rtfvKjqTeSkAhA3LUZdrNG73VTir/+VvOpVH4w5Bj7oaugx3iq3zeOKNZj2nISeHPopxFQlEmnJn5XWXr6EcQdsnA46LHBiAb9hC5oaMu3YwZy2FOnsTvi/B/6osE/V9tY7IkpsRH5+bdmIPH1oHpJRC6Iw9U4w+zobqGY8QZyoPLQ7YkYeIN433YcRGMzWVna0QoDp6xbwyiuZwU/2goHcEe6MkMhRlUy8tVn8BAZmQWeDNSIciuEtpRnNq1e7BLmQ3XAIAYcNympkmoEqxtdbjXpF/15G60VgV5EDS9K6YeKMDPIj/JaGJxfWXr2jCnVUuIVsRstJZV5T1P6+rUUKgsXVGDbJ5CEgpteaK1YFsK+gRdlD0ECsvuDb4HD+CMQI++18oyS5AZdm9pUI+NYG4B5Bt8P7Vq2try8rK6UxEA6A+8cQeV+mp6tWXAEDYsBx1vUggceTAalaXb6NEDTyaKh0+KqB3HVeTedBVUbkHiqfBd2mEON1ZUU531v9OGdOA0EIyMiwBsJW/pndUyhIdhbmEN6RMoUvHpJ+mCqsrYk7KGbYzpRSiDo531GGj8hAGKq1XbspO2bb+h7cO7ZLVfiVPHRwp/sLeS6H/0MfTYD7IYMOY2Sq6EL6ECVlP4l/jPaL2HbwC7CilgNI+0swb6qU4kdeCA48yfEUNgKrdRSVDYw9khAFAaFiOAECzJY9UEwBwHg6glOARGLOaLiNfJMa0tQlHvsqCDf7u3btH3KEoC025s0aoK0yloEh9SocUUU1f5RDTgABnFTcZamKYh0EfbsXvv0sDvkK3paeG7dMb4UrasyVsSSsPduQzbGdKKW2ZfrD1xi4dVdgoCo/hoEDcDTf5+vfB+EbGjo4Uf6apc1E2Aw0ZwUtb9iqe5Pek4GcurgQwKgrxIvAthj8AuwEwn/Wxd0jsxJGh8fHGRgJf9YR/TR0YRTU1WAeYr2gD4EzxESwA9WlhABAmLEcDAE3Aker9nxKkoqhZKKqstlsAw0hB69qpLu3E4KzVdYnLX0dUgaashHdnjQwAY6VQiEJPRWzL3tQ76Ksceo2DTQNAEzDeSohHWUOz9A8x6hdS06C0vY/306sdAHDmVBp8iUFvPCoG9JY5ELFUfgcBwKTM4PbJHjqdCmGF1cKb11qpgE2Kv5LTi08CHH2hXeInKTxnQ2QAQTXIi+BB+tstclgDNwDsAuhfkTqFIkM3rzU+Esjg2jthxYqFJJ6LE64C3rA2ABKOFpUOPb2mNhwAQsNyBACaLlsJABCionilqMwUxqwBAB9DZGdHVwEA7cvA0md7A67w7qyRAWBbKcBLYdCgQRDGLyxOw9Qcmwd9lfVFNu5dwaYB8B9kqROXxY36FBynxU1glhz4TnQeZADQ5/zpaHcr966qvwQBAEfOKlLCCQCxcaSbQNma04fQSI3WlrXapMvI6a+XH44fvZQ9Cd54ZytcB/l/WynTBPsMx+x+vDYoEH+AhVACit6J9WmIDK1a7vCRsLrRHuZNWCuA1TNMsZUMAOK+AvXgdHnXSwEgbFhOM9MEVMJnhskPFKniqqwAXyrE/T2llW/zJyMAgJVtfY61qSl31qbLWOT9/FbUjBkzYuSUwiaxvWPMGyXLjco2DShV/w3V3p4oqzO7b8fk5MQkTC7YAXkOSUN+5QQAra0UB3V7IAD0kbMP6R1OAIjWuw9sVGLr0UeJmxqVsh2QZyz3fPxoHOYT0wBPEk4YQ0FlVP+Vcrw/cw8WxnCP7x6Af03iNR/5A7AbANt2WRSh4G1kKrzxkeCfBnNe6kbnz/8wCACNlUgd3+APA4BwYTnqpIaaAAHAyxYAsHVoSWUFyyaFk2Z2KzzkHszyfsu0J025s0Youf5kknljC9SOHeK42kaT2Iw1hGS5CQJCTAMoklAjwELuP/XqpbmL4qrBaTr8OTNrAgDwQwbALwIBwJExVIX++lNOANhOqjVxZ6kBsC2LVYq/yOkFAO/LT4ZZmsSa5Zrq4ppZjCwepxcBvoLFaz5ICcUNQLjOrUhxJol4xkfCasMT9byp5zahVrbWABAyYSMi/LduiO4kAAiaBIYLyzFHNaPHFYAti9aWzw26lx6sKNodxEnjPQo9+SSXGPTaCGjKnTVC6Re3RZ/c3HSqiTiwmP9eO9q0mass19g4DQcfEU7VOV8MgKdV516Kdcy1R/8agQD4PgDwo0AAsF18J6qyOiiLHQCwdBuw39NoGgCUmHRN5IMVBsCrb78EW5A+oFiBVCXSeyky0yYiCLJ4eHa/J58G9q20Q4Hv/XeG9uk49dxz71kptKFgyWFSknhXFynqJX4aiX9wFtC1ZUvqs0RkyXzGu0BMHApcZ+MLckPPAsKF5eBlNrtjpS8hxz9gOJ0d/7gsff2ZtjI2k5Sx09gcTEGgKXfWCCUDiqF9vFl5GSgw1rDbOo5TCsalsYbApzpOFK9xIEDadmXwbxz+fy7o+BN37g/O25iU1ACrj+dlHYsEAOCpYGprBnDrqbM9F2wAyNwCTqgwQ04GlZ+Z/FzN2KQLXISuRBC1fFseuPvBd2ALkk9Mqisdpxgn4KUNY+0CzuLh2T2pRbeub/UHDGGJjuWjoxrsO46/zGR30ZyCmQqiETbfXvFgZpODIdRsMzERrvPCVxQyYXrpY2+8so1XpFIl3TQVNiynjdQ97OotKTOYfT04L4YpaYow5/QHeG2VdsXthlIIaMKdNTIAcMfpXurNG921FqONni1bKvcd4RBAFbhRUUEQO9lRCyyCaUIm40PrHVPc0XfHeQoKPMU4VeTrFREArgYWBKI+3b+zQTP8dUXBTAfvHnItQNqnVIA832q+wD9o32NDS3MPJnOgo5HeL9+VGIuAs5rJ00YtoCgWLRdejxwuOYr30QmdPBdUMwEAc9OB7tEd2YNZAksMLxE2NbwA6GghHJHeH8Wsx+QZdFjqrLBhOQ5Xb32ehj42mDDXTL4Hqtcs/xomn/sXGJO/bzTpzhoZAB2wO60tq4MP8po15eUg4eHfaQo1ACDWEBI7qSVWTqLgN03Olw0AimypS4ibMiWhrq4c31C+YwQAJHM8FwoASHYCQBC1BpyV/AuNxZL3GwqA3rDb8ewo8X5V2cgA0KcYa9dG++swvVldO2zUpN6RAaDTmLyiTvmWTcywjNm4vs8yFDlaiO3RltFZB7Ee6bDUWWHDcq6RgqgEciER3WIny4S5kYYwJ4sIl892xVVT93+z6A7QoZQGlAhNqz99+rTWjJqkbrGGyP42Jw6JyDKQKiyyBcr5EvkNj0xpYlZTgZFfbU9FnEE1CYALHhYDoGoPVHtOGgCoJLAybM2TXRdP1W8gkncoALqNHzWswFXU/2jcGQGAT04x4n3ZEhHYc8D0bpEB0Cw8AAwv0SYmWiiJFpqWhhNSLRQSr0RTYcNymkuRvoQFg3ziHUyY+7dkxSFcKrFWJvrFFl8UnVNv7V6Sh4R5CZi/Fa9ulAi8VFb/eYmtIw8k9TY3K0AVrQAqk7SjuQXwqdlN9Ebev/9TmziDah4WACJBryvvRFVeF0szwiBOI5QRFz0VBEHgTNoXJwDQosFDYtGeE1XFAgB1jEXYkT17p3vGRwaAGViG3gKCjxLVNqsXTz5xvZb05QupDkudFTYsx3mgpny3LRlmC2EubEU2CDMAkCet2ZQLjIbJ3YsBMLSkJu5UaQnOP0pK2U+Nfi6mwkiGVN4gFI+Ah99RoWOmB5C7g9weeHEQAR6/5aBCqnYQZyRzJywAxISiMJuq0C8zQgGAjshEliCO2nQfggoEALaEsI5585Mqygw2AOD5vXi4th1+VWQA2EcWjiYwXzWBYczGJVoIh94pEgGmDkudFTYs598sACicQZg5lRVluQlJmEResQ++IRHl1ANiOHG2FCS5GOhlMcwS96olmAojjRABTYgl5HiE6GiQEsTejq+YoQqDX9PejqO6QhFnsOQGEGdwDwOwp4cFgEAthcpnj4j0rJSpnOktTsUe0H1ICAAgphs1Z+GKzxG+ZwBASCYWh2hM23wdANgUOm/STrUN7C9RPNblV9iwnDZX23b3dF/3yVmM3N/ZKl/IqXy8zUfaKYSxhySSShvIhhqEqaJXzwS/EAeq65DvfmfUdLScTL9Yep8AwFXRmBSDI24iG/DLS/PcZ8C1ia1xXdwIbxBhVSOdkd/nCgA8B8ggqdPUvDwdR4Wy5cJBxJlZvdyTYJPcBAB+voFv7npEZADA/QeJPFLrqA+5kcYRIQC4anzqhOffeta94VYbAJZl0sSpYw8EwIZLAsDQHAdz7TGDoKZqS/SY8do63fimW6rChuXg1LQ3igIvyL47Wp/FUFk6LGOMu7mbCC7kLuBbQq5S7MVFzJtuXKEGYVJ219KyK6KfqDLad235HdKnJu1g5ZMCAJmHwCKOBSGqzesM8npMpcdFuYR79gijfZpKnlUAyFczoon5Fy+eGYohkTRn4YgzPfot9g9kALQIB4AfKAA4copNAwBoIiOXsgwZayEAuGaSf9WLD0Vt+6ECgFMSJzHhgQA4tGGBr7yMALAcADikASDbMmrmd4P+GDAKbqqWPZM46p73wgEgbFgOnZvTBYR33Lx9aQPHpOEsJjaR9vhtbrB0XM6aLewVIDYCxIhboWMphWUTahDGxT2AjjrIUiawxIR9hCZ8J/d8gEGTAgCLDaPd0UQZVybGnLrlgmPqSTse4bY7NQB4yNbQANt8ChtzQU1QXH9aN+dhiDMYY5FN8p3HMhQArgwFgIzQA4KqTQOAe/96dzZlGXbRY+egOcBiuucbABgir1oAAgBwBmd90bjJwbaoyl/oP31KAcBQFz8R6qI5DGqi2GpywPzjav4aDICwYTmUS/jnq4jb6pkB2wVsZLfLlA//3JLALFLhXGV7BbxGQ4I3dTCthWqDMgZhfKW0B7RNz89ymMB2bD95GFaAnO0cLiM8FSUEZo8NbvNkBSioiTkJawhtX2xWAB6y7dxZkVB/qAPS1lzI2K+yvVbCEWce+hVskoc9MloaySjJLnXwAbpwMP+foOoxn7lFD6RkA4qga7oZTMTYeesX38PXOky6LI6TsazvGwAwejRZKjtFAwDfHwDgs74q3OQOHomt4+GzPJfmNolu3UdEhHQcBzdVT94/L3PyuU28OQgFQNiwHFDQgQbO90sqwIXB/zG//mqk5FgSmUcqnCh2DqAjrigKBknmoaG8yVHoWWyDMK+aJ0vp1dNhApsMj7O4OZlxjds/+QiNLR9SdxGliejExVCNyJhzJicg0HV7bP1WMTA3PQCGbHU1GK3VweL+h1uh57/56AnMBGQqEY44cy/ZJOM2KG91Jd4RRpDJA336aWj1zWfaWe1UOhIfNWyzUtCfExrU13K7LiZdlmr6DABsTaQtXGQAyOw+v9Fz5MRu2II3nPSg2a+t9lyQ58JNGe3KnETIyACY+/YbM3Jmr/wutdn4bUMAIB1dO3OPUIMgXgK6vTcfTsp5U48dgwcMOV/wv+Y8TfEEjKIrzHL6qLmkXZfLbF9n+K6zQVjsFJGcRZltIK+eDhNYUoB1rIlNK95xKQC4DQAodSuVIp33wBriJeZcjGEdHu8CFsACCpl1Zci4+D5GyUDAXXfIVCgscQYZkMS26ziRDTu2SSZovoMTKO6Hc617JS2UP0OhPOQMizjPxzgt1HI+nOs06SIA0HQgEACaLKddnQAAJRtKOliEgi14UkMWamdDkjyXy6xl9897LCmvPVFyKD3uZQWASEUTn9uewgwBuMZSxi7YqQOnS+wDvxEkJ5fd6Mj5Nuppcq9gzGO7arIeEmxNR4Kt6TCOKB4xgRXhd076/urijYsOf/IjDYA+oSsAG63tolB3soZgUwhfoR0+Lm2enIZGSeadzErCE2doYvr8wuSkLn1w/XEHUMGoO5gVbPJAwcH9leMzbRCORKvjopwZ/EnJDkWHTvP2+1/VJl1Q/bQBAOj6GwDo/tGmxxnZEJ7IjtKQkucSrphY+zAlCqmurodSJ0lRAn1O1pdEySGD0+PQlRgABAWTObh1GCJCC40+r7DTd8HkwTl+2ZpEdEqwY14jN0lJymYXgf7kIgD/mg4U8S+cuPBZDwIAHtGFmMDu9JxNPkwLwDdYsWIAwGIjucTxzbEbIwCgR14rN3bTqTENWTu4yVk9p5Y2SZzBRihhxkYKb8AaooNRxVXL5IGChX+f+Qw2jwM5HIk+9wA+ST26/htIcJ0mXfIyhwLASGaCZEPdg+qdx1ijEK5oh/7sutdWIS+0OZEnF78GdRL27JbUkjWQE8xuj6NC3PPga7Bp/j3jJzUPZV5JaQxQnxc3mc8RCtt+F4UxKDq/yZNJYCxtsmyOoBUGACAEjQdjjAHAkI6Q9aCjLkQGbkwhG3Iqj8BGmwFwBfGUxHFChIe2p6YCgObpBJ8FGE8ayT1GcHHTxJlemFbAJ1viW6x+Eowqrlo6hJQ90J2fucZKTVPCoGfocxYfnChlUNoap0kXvcZBADDeBUIhkhIvAiUbMkWUwbRAh69QiwfYDFCK0HWSMfQxPTLiymnDzq289ie46cHapHblI8NGjXHbRHx1+RFhxOGkGgLCTqKTxLvdcEVDFUbT0WLyjHlY3y4BgM3xUesDAWCyHmK4zTfKbhQrirTPOUpZB6dX4Cs2r/2GAACSpVzZBrKBepfuZjemeoDytjxJVBswunwUw/7ll9eKDZUibOFcnW21whFnMO564G1wNOmXp/QDNk7k2H0TQkopCL0kMlUC+S1bGuhm6Y9yGWBt4NJVTpMu609SXwAAwge4BWV2CXZZvTBVMWxXk4YmzyVcCW0QHpxQKKFDTigWw4eBdo8HSeGHm77b8zcwOEV7VDN78hyY6juJNzqeuDvR5wQB3AkdJnrSG2/7WlG5qf8p4Xbo6wHAZD0kcJtvvB1QfErnTTYycOWnurO6rlDWBMVVJXcQcUxQE13JOn2ddgE2H6C94QMYXzo0IorIn99fyD9hiDNMtnsSPtn0myvWuZYEmxDSlMDPxFtB4mDp0fn+i693mnRZT0uR+FoYQe1QvINozx2TriDZkJENyHMJUyxJ8qDV9gybNt0NdVIMPpxDXEQjKh7+XjbMLctqa1fv37lzXHKmkUWrDBtsmUsloFxPsmTLU1SCONhtUWxl/Mnu/sxWAqcoMgBCsx4C3F1kwMJaYkuVuAp0rC1r28pwVUFV1EZrMgikZyZP7aTN+8rIm6gM9zQnUFkCWIoCmJ4v9L8wxJn/es3lYj4V06l4qk8mbJKvapd1ecWB9Bt5JFYYTUMyF4UXYPdhAADo+tyFa6Cyhv1C+qI3xz6hjRFUhg1e5yzMY7NKWuiDs4fJywTu1fS228ZD0NdvH6wnIpEBIFkPOeGyHhTRIgQAKvTKMtH5eGZJyWS01kfWeKxNajdmW0Ok50r/zs9b2nahJjILmElMOTOJxRSOOGPKWCRDriflOO0IetMbSwB50wcmlt7yZ1af0ld2lgIhOZn9x2hEZvx729hlhS8RDRk5Y7zx/6J1jhaXXDAHy0+DQZiFDftz5PHAJdmjzyLGfdfyqiNHsXJm4Tks7eHkXeBVzpo6mk7OsujMTceYXUnXvGQoOq8oK54SjeBsLdfg6wCgiayH8ADwYuhpACDYLC1BlbboLtcf3YnajZXSsFexgk2sv4PCBA4TSEwSWzqZLE/DEWdMiW/y+yTY9fVCNUexnJd9kh23fZOJaG77nJtkEkufwpaZTuL7cnqqDlBlXYCiWqn9hF1W+FKiIbH5SgH9hvy/5JFF7cVLWznjs67+vFInIXTLAOC1tz7+jBIJ79pThJH77IK4NNMDYKElVQg5UpDnbxbP0zQAfgw781IajmABIGt7AsMVXwsAsnP3hrT5Mto1t4BEBoDpAWz2m52weCt1J9iibdWX+D7ZjUEXYIQBRheg23b06Tq2FGIg2IdBkROOOGNKSU7EEADFIhTkD6EPx2mHFegIYNG3f0Y3/qnYPgQkliLBaBrvEPjrFJ3qTlYGCdVK7yfsssKXEg0pZ4BZ9GiaPLpORRFiw+tdDXVXrlEn6Rd21QsrPn99xO13DS7ywrFw9CNwxog2uwAeuecRo522U3kl2N0LAMwSAK78Wl4A9P0hMgAkEYjto0ybb1xeLdIcqUANswswiScCAB2ySWUucT+1G5PdkgSwGmXQAtvDw8SWYn51Gw2wwhFnTOGNmQBowd+eXJF7yOYefyOnHRYcARCkRevLQM5FZsOAONr6owNHcJJKLO3adSX9d2xy3D4eETiUgZRgHK3UbQ+o/YRdVvhSoiGohmLxLXtInCnnmV6vFRSQpu7PPFui4slQeg7gTyt+8/Dt/Qfni6E8QnTZGcMAAJutjK4jp7dpR0IwvMsNAK5Ul329b7MsAMKvjwwA/X4PbfNlTbDd1IMWiHStTiYAmAkFNmjmEmNldgdpA80Iy7j4CIeJWEzQBP+Z55/hiDOmIDmZHLNDEkihGcKZJu7VU2yb5FfpJBqzvikcDsAthvkL3JsksdSuHOyZaUgoFWVu23hqynwInUW8XVb4UqIhskGDNYBYBcwW0y9+pUjacf6MN7kxq6aWGhvHb4agzMzkwbT2t+cM2+f0JNAAoAUBABZ43x6CFWCoWgEYAbLww2Jkl2MBiAwAfT0v0eazB2S4SSATbr8dnLP+vYAhZQR18L9X4ivWJb1IOQJoF2E+7bjX4k3FDnEEoC6b/QLo/IM2HbjZLl5VPDMJDmAHi7iSWMb/pPWfKBENNXjF5+utFTi8mKge8C+NOKn6s40NDRXVdeWtxI7CnAXMSPLymx9ND3oTgDAUAAdGTpv/ISyDs3DLp66fASBhlkV9uh/yLx9hFoCIADBW/6FtvgKAuIzrTYKYwGLTIOZ4BgD//iUO+D5RWOTbtFE2e/HyP+eu32Jnwf074Yq8WwYH9BdTXTHpNEnQBgHQg9OcAV/+/kvoviEJ5d08tVtka1nS4AFVBSL5PTM9++5fhhVAMqxI7Z9ihfu97IYNOwpav9SOop1ysVGiocadJUPfeX9bPB7A8yndCH1k7GK6bkc9DdAmTWW3WlbltLs0AGLnPHLu2OxxJUPZwFgDAFcaVx4WE1XAgV4ADADWXxIArQwAwq4AQsPm00BjAosFQO5fqP+UMUTArWSb24feGX7CPqu5XQsc0z064cesJOYiCaAftqRXyTuIxxgmPsz99lbSg2e0pA3ENlaFkcPacczzeBlbs29GacnOmupYJMzQPI6bQJ9R+ztl7wHSdn5C8W7M8dmr2af6/PeUH5gSDcF9HCv0NuzJdxc1VqSL6Re/VimUN7LzQgOT0/muq98q7749z1NwbOV3lPFQOAAs9MyePS7pzNl6pW4wWRWYBp1CGkyubBANAIgqCR5EWwbAcgLABgYAhVcH3wJCewDhA0zEmMeYwE5sz5lX4QBgDq6JoGwFVJBlgHlhAwP7/X600uQnrHUP3Oab+T6eVc+b9iM+lC0QCACsjm0EACipy6EHR3yHbxuNKr161WIUPnP3vEO0qT5Qt8YfTQN5bAPhFUCcSI71N82tPCGJaUQxiXKSf6/yau5tzVqcSqZgSLbiowYhCzVmZpWCMrr2xzD9IgDw4UgzVApOQWvzvI0VmJfRZTGLChqXfXOGffictLzhAYB7SkMM5fXUFfIthLcJagnwwmLAXgAMAM5TQhj06gDAieVw80aqJQAAls0W96Mq8S20zedkRJsRhHBtyppgE1hXlqhrwwKgF6iIss12k1svyqBAWwaE+EKYwH7K669PQ/M8JXbQMurvjfhJn/ABAGAMfbo/8wwLLnB7oCgRV+VZBQCjB89oTaYghIU8als0APrC6g4yyzPIhyjrVA57D/KIsjQzkr0CrjBPqEP3Dh309sYSBqX2au42twfcfenJJrAhmGaLZe4v6b51Pbn+lWQ6ACCn694zZ6v3q4k5yj4qSJsGe0G+/E2vAFMrKvbXrC6T6ZgcLtPPhcPYRU+l/X0NAE4hIWzzrsQDNRORcQZjjTXItZ2IhFvYsM9ScwBcbmebbyBhOIGAAJWLmlR6KcMDALs/tuv+Djj/KBPfiqLLeMnRgNolb+0gef3FIMB6wGSybtClAlCU1VcrAcDZXLoHAADikIGHNgCMKYh/Az4I3HWlIPmp7kCmp9E1DpMVZSjv9Aowsvfu/IRa3NhBhQbJM/For+a5TA6IgYaRs1g1AOJqXJB6k+sbPjQA4KTqLOgXDqzOssnpehfgHzN9uGEFN9UDHDgAspRK7+w3q9ejzVWc4R5vzEEADwuAlPABYHhdtfyOE0eQp3owDucycNaJu+itSJgHB9YeESaBhhUMgQZHKmS0by3umOEB0IOoiNCw4Gf15OrEnv1cQZYB8IXoIPRME9jPh9JnMhe5zr7x4LuWmcA7Tg80AKrPlrAxutWKTZLiDACcpiCJsE7VSY0oYZyRYxYOXLzpWRnk9spP72pmRrIfsy177w69C35vio3glZWe0D1CncQOg1uGh9jfdyNvJQwAskph+4c7wCkNAE1OhAP6+dN1tRm4CYCogXZFzwEWTEI3GQEAsgsoL1NClVYUskdseUwnEWd45GASnwnYABDHa8nlP1qZ3JATQ2mKq2tichqSz8ZQ2oY6Cwhp8/XOP1QX0FKcA8IDQJg646biDOgmLtAbbARoywDjC9FC3ghy2AFqmAT5uxorc08Rk6mdXY7zQyUcIGN09smPyqY7wNGEMwYA5iYAUxB1A5BnHOCZByWLd+poGckJAPIdAKBvgI0ZiXvwhu2wlc5X2uGoEvS7jmSxAS7+KyDjc+MPkiHO3zQAiqvzSrqfJtcvuL4JADQ5ke7+SN8CELA5YF5i5DIAaElzgGxHHB4oRf0eHzN++NXx/M4lVJlpixzGnMznOngyHfrpT6GdhnR654WLEN6/9ZA+DQxq8+3TwGZSyjlgiHEOaAIAcgaUj5+FH0ZFDBeFgHYBxhAZGXnaF8ISm4FcchlPi6VAqtzzW7/4wrrFLkeQlQHAKTZG92V/ZzQiRRNOGQCYm0BNwikzdkM5HN/jwIPTju9EsRdmJC3t2pGH/YTgX4DrxjTSuXJSCeN8WAEMTOOWIW3VR3IAh1ZfSwaKq6e6htZXwfWruDpDAKDJiSUbH3tlfbb+6O0gHwDIdnqINOySAJBJ4J+zO2mlAqjSYMsnjpp+Wzv3moQYvQBICSs4L8MuCdKB5ramIrmo/+7Pwep28AFCsh4YAOGcA8IDwJwC30TlTG6yxDLApghAb8K+EOD4KifUZA7yj0Vf0uU8sGyegpObpQFQG3uKwjHgk882ebHnDQDMTWCnp9HcAFDaNzcpMPNBDKOKpbnrpr15S7JGt8TyxcsWL/KWYYlOl5Yhc+zSpTiMESakBkB93VRXKWzf2PZPACDkxJxFxNXZ1moA2QCwI8Creu8kg2i3Foc25woBwHcEAD01AO7FCefSCXOmzX+ubV11hcwHdVnqZmzX5LjqAz17HqiuPRDXeKH/iI/WPexkBEmbb7IeFABCnQMiAMDwQLgH+A3uV3LDsi0DQBISUajxhVCHHRxr5KNIAleX8/hrDpEMB4Bf16bV0z1gV3Rb3AH2VNVrABhTkNOnGqEIr6guY165AoBJfVHJb3mMD2wDlW+wbANpAQB0ygvdC+DaACY9D3Q1S/S7d95DTvMltJC+ZR/B2gBIq80qOXukqPR8mgKAHICCfkjkxOuZlygPltmb5+v0qZUcklH1tYLPAtJw2pliAADaxb33vjU2bsojm4Z0BejMAoASZRBOvXQhYwcGDqANJhafkbAgJyeQwh74z5jMWN0SNotUVkgZJpjsAjqRso4tTOkSOO28lCo8l+4B6hfk7YgMJzQAiBMTDgB1HI6x3N8Jd4DdVfU3KgBIsaVOMaUeZx4QUxhDdBWeozuK0G+nhfrI5VLmO5ZakeCnt8a/YcNpIqkuLB70wHV2nhJaALIXSt8D5sizvNvC/tsAAMn2rrOw/cIHGgBjHOREJy/RBsA1chhNBhEJcvx8XRAAunTMjC3Hztr0ACCE/P73z66YGTObGhWzAHBZekOuiw6+s1HRp+tbaAAYVrDJeuBA5MsqAcAuBxc0mzoWE9+ofAGYKCyLsRDFLaIWthD2IR9R5qAHEAD04Ny9SwPgNPliL08tG521Z0RiCADk9ka3FWUKY4iuKtpem+7wd32UpNkgajNxW/QOefgR0C4dqsfhNc+LLG2kven4U5w203/EZ+vW/egXf7xZFjIsfywbTCybika2hH0f08X0S+xG4IkOciI5pOvMAgOAq3BuRXFAi2I4F9TSQn1zC2jAYtYJb6qeZhfQ475fPYFtCIhCwhJxAMCM5L4p/xH1BfPKqG0vYXGjZ/6w1gUEZT1Euv5XhDsCYo5KABs8hWVemgFuAEA6bnQW2jFA9Bh2jHdanBMAD/HWzQBABkG/pHAM8sU+Qa/2nhOphwwAzFCruiK9sdicdRoA8E9irGkAWAAAPg8A6PP3XBhfnB9K29XzGL26MS+yAYCmUoc1XXklADA4lwAgoiFQ8k4Dk40nS7ufXrMyQ50F4ErZPCXwEo0uwAEANvja4ZXNbudQAMRU1FAaHsQSek2d1a9fj6UTMpN3lJRgq8oLQCgAdJG9scU/5J1SL61d90bIeojsD2uPdMMBQJSe6vlqANxV5ceUkPpK7RliAyDtUgC4TxTDDgB8iwGAEHHcA06k1eIOsDwYADJ5JwDUn17/dQCQYhtHpyhTxlwyvqCc+Nw+N3Zg7WokAIhoqPSxV8ohOIJU6TQJj/AQzX6EiuegKckDak8Ss7mXAAAC0z/lzvqXrJfjcynQThLBhQBXmEcVEQCgyYk7sngbGCbrIVKZQTnm5DAAlVm5lBWoBzHyWgOAv2+PXVPeSYxBMkQtanqAS9wCECXAALjplwIAuQoEAMpOKDoauxp3gF3+SwKAejA+d9GlE7Rk1i23AOkB2GVhLg6DlkTpF7zCUwK6fEyycB3xXRQA6LfByMwJAL4FiGhoHFRHqZMLSI3kV6ZfaB8DKyWKvBweYjMHi4pPld5r5YY9hZcG9ZKw+2ggAL6Kq8Y+DoXrjxZQeT+54e7wBhFvcBUiAICpj7jPxBXMLsD+5b4wWQ+RAWCIYFQdaKQrq0AoAHDpggBwMCbhQG1XFDnHdRGxoOwCpDVzNoG8L8bBKwMAdxIBgL4K/g24BxxNqHHteX3XhksBoBP3GE4ASPgnx6gGNYEL7Ny/BTYAGnlaYNjO/K/hXkLvP/ea6uT0wbsBANMEiuHX5LhB1OXPhF5HhEcmBlBds6jmS8hX+62le/0LsODgOlNiJJJmyhPrz3hXHxA5JYb1QQA4Eis2WD3l+ksBuHLChivQNAAsSwhyg2KHPTJsThpY55dVelD+8w4wCKVqMVSkChEA0EoBICkZziCovLyO3i5CcFakR4nkFH2JBsB9DIB4n8hJ6/w2ABBjWUj5SV9l7i/aDQDcqgHQTJdpMs2LIhyHPGoNneGf+K7g/8lkZ8wk/YInY1qQiHwc1jvg2zAA9BSmsK4a85TdOI8028B+rNUDo5C6fCiVnrmk6desXni/k4PKiuLYMZM4G9l6bRUnzZTFxjW6SDYPQbUM650A6H8ikW2wcPkd+5q+IlPAyx8BAPS1VIXK7Tx61qXvRopkjaSGzlgYooLXBTMob9HFm5WFMwK+RxLjPwIAZBTscl3IlTLusWrfnUvjGZ7OpPdhAET1wkLJ3MEFfhaUw4+7mcyTKGu0EM4sJQc9O+GLHS0AAB8gYHwoAMAQV5eljmRkEIQNsD0IGj99WiZMFDLhR2Np34OYODsnXlaqZvYdDQqOmp0xrj3wf8EkMFcGQb04txSMQjIIQMe/RIRHgaZf4nXywN1xM2d65kx/gLORrRefGOuB9r09hnQwzjhFlgqZGNYHA2BXdDaVOWI1ALgiEgBoTeSys4qx8oSW5kLej6QGag2iqTMIbA2eBuOCBJ25CDMf3Xr06PZ53hIa6EUCAB8GxbAzyFAULMI1U1yfBUgkpyensUFWgOZkesODkUmjEmApAS0NTgMlazQDWaPr0TMdxFX45DM3BStKWHo7KRm+qybcLuVKmIHJlzP8k+x2MO9JKkkSpbAAwEU3CpWOLm9xy5JdOAk4a/fXZJ4p2gMTmP6KiEeMwm7MKIxChAjpjXhnya2/KfE6SUUnBjOH1EFpqygYk86U2FvY1eC6wBbVAV0aKOV4f2DrtjYKFz/lv6qT4SC3QUyy5s0B7w1S/dEGAnOJcwWGOwUngrk9pGXrDDotwQsUoQfoNp4vYwGWuFtR3D/KuiGc6e6luRzkf9GzkwEA8SbFus0EC2A8QQcmGLRBMlmjCygdiKmAPvqIOYHOI0S7CbdLDoNwKuclKQvTG/Rh0Hz6akkINQDwU6uYGgsAEBPfjlEnASdyenHQULRnz+B8tQX/usxBvN3jJqfVl46rTpsXVwyvJc6a4qjKM405ruSKmrw8Cce3pGTrljvYbN0il4N5a4g6wrSTSrHdAYlrZ7YcRL6AowxlJZrxANZLtGdG5YSn06Ujrr9EzAwBZ6TPjbgJhNkF/FoBoDecQVbv3z+bnEHABjEZEvZdhQUmpWcz9wsAruIDmhj4mQyX4+Bz5OvNjiicNeqTpH68VG5oi1ha9KLVxq577CbcLkvH57QPCP8EAIbzV0tCqAyCNACwAhgAANBAALfitQfS6uUJa3M8rtAY0WZXtcFP0GGioI6S10l13NmcuFMbk+WN/hprzrvXF8dVXGiMO1B7jMQppk2XrVsSfa2sCpHLmZ/ZHCxt7RkW7W7aHdBqRqxrkC+Sp9hhsDlsG2AjADxrWHmnj0OS7VOtUNltsaaK90fTc4Dm0sq1JmeQbWaGZBhBW1lfUh9bnScAwCVk2xoavJ5rT8fB4PVZjqxR0fFAT7RsUALab9YFGBbRQLsJt0vmynTALeGfQ2xjfP3VYProUbAcixJLLsbLBoeMaEIAt+IIaTy9lQUx2nSKKzRG9Jvjh+McRYWJ+qz7QB7f7hpXEVPRWOJaNJMkgJjbp1E+zenE6prcM7GJ5ZtYnGK36WbrRubPX6uc+ZnXQKdhPMO0O6Bf+QLeTX+C4CZFJ55sFjQ7NtNpG+CJs6NCr4PQwrMd0r47b4uCDg9muuU9xf4pFADBk0DazF0rQ4wQUqjSvx8CYUIB4Gr2889Axtdx0mnrMMtJnDVK3sjPrBk5jW2Rt6yh9nsaPnIQCWn+/jk34XYFh3+aGP9J6qtlFyBNKRMlosn7SnV5ilDUVvXi7vU/MHoYDYDQGNFvjRqAhVKHiVqgkWXGbDyDm11FzdQCD1IoLI6qfPvd9dHlyAyCt6b7KRan2Da/jq0byvo6RXIYo7+DHkY8w3D+FOgOmBDLf47S7oBQZyMGoWNeTQIxA5JitDsYh0ULApYUJk5Y+AG+9YDhZDq4bjPZaSuz54CzAFTIWQDmeTcpZaETAGa0uH69v6y1AIBNnNDvg4b0XZ1kBgA4skYpqn86XinVfk+n18wwibX6H9o/XWHCPwEA89U0B+AmAEsAyd6JoNBHrE0UAlqpXjxqmwxDNWeUKzRGFH8AbDpM1FqcOmjfvOI4T0My8s9YAsYbL5DSo7I3dQUAoPVOYUZQlL3XN1s3KutrlDM/8wboYYxnWJA7IIJxhAknZQ1nztNsXH+hCaBoFMIIkFMCn3vV0uc/xntloHLUX16VVr1fNtxOXwg5DexpTgNvEWOIm5jW4USAwwNn2zZf9iYCwNaXvsA/UHFmKE4y4w2bI2uUhDzshdocLQ7LciGR1UWuqFr9rytc+CcmgfZhUJQhhCTFcMaqbXugCn14K9WKB9zJqEJjRFvXVBRMNWGilnvLA/7ER6rHgT5+pj7NDwmYJaoEibNXgREBlDCzdYt6lMqKXM78zKtBHDCeYapLMu6ASa7ZWM21+nn6tDkecB5ZvxCnbAPSEggBHgodV+0l3EZf2Msi38PYByFRo6KBX6MgPoCcXGg+gCJ2rcasWyyqQgGAv2TPsy6n8EyFf0EIQHGSGW/Y/gdFUGSOouwVtCD/smJEJ3KABcrrEpFQ30kDR84pGFdytnpcycYZgx7Y0lcAYLWROPuNMLSCUskAwBlWaX3dcuZntgNxwHiG6X3SfOHABVkgWEyMKWbNoG0bgOEcPVZLgHoDvrbYpOogUief26QmGUGK2llDoESZRcByXH8W5Se5zuJV4E07ECBOAdcGJ5n1oqlVvKyeYg1gpP9BnqtRFh+2tMOHtnKfm3KLvZZlJ2T7isTLrsTI3oeqOZclJe9XdXDULLDi49mqgM0LeAXImQoSVk5DDCxztwurJCoaEfwzF218LHZ20nZmX8h3vIosP+Nmbvfsu5vcrvhqX3458zNvAXHAeIaZWwD7AgrJGTcKKXEzomksveNlzY+Sk3UeoAsaabs4aQGuZ4GrC5frgvTJhhO4P5QT2EaMITLJwI3KRoDGgcWi/OlzPPIqsDABHbs4BWg+qgFAv+ZUPMRnI2RLS/9NvczdlHuJZUt4fFq5/x4tqegYbP97W3vU3KlTkC5fzzmlfI7EUQdtTuz07TOFXtQDTJl8ruxAXCWI2EfIMxs9AN5Aq14Y+8HMGfPSJnveHPvCqsW9GADdUDz3WBi7htvWAAAYcBtQy0thMPknTG+BPIKl7GQJADLmEgmp0BZME1i88EjcjOIZcbAuMk0g8WLoPM72CRHiGEuIREZM467boN3yD58uyXo3nj91NuakAECajbzkCj63CmQFO7NtpBQCFAwsfmqTxkgKI/YrTq/60LR+nBRJs4+wfzZCtrT039QfoLMeiW2ANOSByv0B00b5nS4A/KeE5Es/whAwtlwGAL39RkUkl1+eJvnpj6Gnw8bM/fBD6fmUJx75yltzIHUX9ESJhdfR837xreeLE+4eMKd47MdPvNZvFl2/3igdZ+8v7EtlAACxtU/xe7KzNajpRzfX5UZg5Rd0hkjaNjwOAAC+gxMAvbkmgQOXSjT9ZIxPXjDbQNAiQlXjPr/DSMA3CU9l/rSRe1eNoi3E1p8fOh0LV1gBwH22LqA2RBeA/ZvZmhq7BQEAv7BUC3QOK35DqjBp/XJUqLb7M8QaQEn/WzpqJbvoXW+JWB9tOCn3zQOnD4itPboqVPYe2OWNNyoiWzyB7DPUkCEjR2ljZryQC+iiRe860Z/PeJ99EccCS6x+NKF74oXEBwYm7l364kPoO0kfT6UPiU2cvZTYLaQxw69tWxvUYl7KxSG4ZFUHUPKlbAoAwIdoHN3U7ydDZT0W/oXa/6BHiGZUyDXGN2IJcD3skclxY+HoStOL9Rv8VUe+UsTYfpqKuIYOrgKVQc0DjCEM8ZUAYPIrfIv1q2A1ndYPANjmADlsDSDSf5w0TlX/ocbJjVek+yLhke6cVfzUEXMrAycg1h7x7Smc7N1CBauItHxq9FQY9U6Fun8YJoqlOTTIlWU7au1y2DixHFP2GD0oFeS1xf4tk6Iff43tzaxI1UP28ZOPde3Zs+yABnUzqW6o8fxefAyezKPGd6NqCgC6WiGmMO9izE6oqlchENGU0gvFpqo7gLYBVhqy6zB/K5idM3PFx8/SrfCLbT5s/QfnMsPfaAOj3dmoAG1gvNMYQpd1mSUAuNeSbpaPAbjrLvJyXUhPPykf7WBGDuavH2gJTxQr98lc711LuwugEXY4l0Uop4rIls95XaKdo7ZaYhvF+yseKlECAJTKQjiT3eYs35Levln9uJ+2iODfY3H0JOCFuGBbohf3oK8ychvta9H+ptXoKQXUpv9Ue3pActgA7fYfGQAiqbqI43TkbocCQAbhBgDcBTIAroflHQzPtn/w+br4zk9a+A0336G+9xVOdTAvYpdVUaaTdgSfiBga0nwhbgoAkOr0HHBcRAeBvAIkk/TsTCNOHUUUpQjdvxftPkL9odz/7PPd/XVAZy+Ltx0YbOJPMVtPkTNWbAl4zx/ChHSqiPTxIlmqezA6d+UVTJ6cc3LR7k+gu8BzxwtypQIAWTIAAJesh7AmrEociNQQ68nOy57Zu4pRYj6N+njF9qSOX2JPubMhP3nGINwCHAff7GcnHhhSkQEgDkBeCNkk1ezrA+BJGjH0ye8/AtaeeAuvXQtOVH+V/PkvXl3zQqc42eamk25ugk/oUB2GOCDTLl21mKiVzONet9ZXWE4AABWAegAcY71z6yHK79+ZmVB14o7dhxeyR8/D0O6/zq/AS9vWfoTXAj5LEPPwd+HWdOYc3aCCe68PSnxudfqOmZ/RsztVRJpg4Iohq02Mz7x5nriZnkW7YXsKAPBLrwHAGWHCnX7491j5F0cv4D/QCv3qobeemBA77Z7b2sE5/v5BsS88YRijEvr64gvFuG2trs70xOAAAfmXS8zBt5reUryWtrSMBACh2rfGwCUBoRe2UTNVuB4gWfcAc+dixqDcfal+/Is7MGKQsKBALwgKKdIPr1O7bHN13c0dLzTvoXSbd43upOHhaw4xrrNAv/rRZ+DTg0nVXCk5Pvtos7/uAAHgR9+wFj+eSE3Jhg2pB0Afqa5L3fXRZx8LI0f5qYHZA+W+cdOT75LGKSrsXJaGfJJJFvdU6Kj85aJw9q1f7zAKCFARGYpRKqR11D3XVBefBQDwnpJFywCAroQGwL0vPvFC6pgXl+5NHYP7BPYFKxZmDrvzvaei3n/lwXmZCz9+C4QCZxP42t7YOcPqYovPnknac3jhhL2wnnNIZ6mbgyfOcTjPcTVrCgDNpBi4fU7F1ubdzEuAlGWsg5y7AGUnBgAQIeQLcfe9nfJwcPn/eNfNtgus8YLgzTmy5VAOhw+3JQE2d9PVlRf6FXqhsYUyBzM64mTkQGfwCWzwfvzj10fA7isWna66Cp+8/npVbFwFrwAS3o+mBH4IkFDXlhUuWLuOGTlL2FFPXff1m388QrvpmWv5xCre1MzbB9YR/W0C2nyEG/NGpty/YWsHlOav9PYbFZHw3ETUxOJqL3TLEqegDDx+ZAMApX09Hl738fPwCv54bPHIUbC1X7x07AdvJv/23KZs3xcvvbEx+fBCng/owvwf+9hRsDUYCgbC7g+eX0qf1NL56QPQAdBIZ9oA/RJGBoC4FeSSjIn0DXDqNgCIkjkASwSlAuYAf1Jx7Ok397/99hGwtuuP66/sawO9IO6m3Tk5+clDdvZzXl3zQq9cCemxPpu1bqDGvhS2Xvfc4Ag+QTf1C/y0PckFc9DqSiu+fQ+q0pMsPYBM6J52klB+rw4DtJsWVioo92/XVhrqu6Chj+5Byn8ka6ML0G3+wmqaZ8rB/1DyCRAjTIeKKF5bqkt/zCzTnZ4d2yVOQV5SswJwKVOPzz7/YOaUxM/hi4/0FsufWOxZ5IJUuTx6QwdcZExh9zr0GRT6muJbz58CC42GBwBAN6rxA0eNJN4GCgTWkRoBTgBYVCEA0GF7qUi+QlxDIAD0JFAtAUC2mQSazPgu+UUYAxfle7sYF9gAL4gZZP2JLQzvteOwy8ZDubo7OLVGv9AJ1byHGt1SEBCQ5GEOMbjXuDk/1yXKCUm6cVGd9C5Civ9DCgABLCSLAeB4K7aAcv+O/lpIq74L/ShhLPI3l791VWbW0Djz009JY+wC+VHh3KEi0l56MiKRtdOVU6niFB5GKTdfjmjgUgD46JPtOQVzjmzP8cDQ0Hpm0L4ZG7tkZdTWQeIEVXrBlJFjOC/A1DZ4ncj1/9Gz8jthu48pViqHq+ynqll9oE6EsE4AtDJZagYA0rrQq+Hv1DVP2kAuecP77bMAH9sG8FmAXhJEewv+DljBJag+5KBhHE8cXhCUU/Q8rPz0wxgwdpxX136hx7mIdZCn7IfoGPhYxsSMY/D1MsEnvs0/vqN/fpcWpfwmBTWQ1XnJOFNHyRxAztTCAkDuAVDuyx2AAcvfZSIl7ZD0nzwIzj33nvztQU/F/tU3/eamTz+t8OwYB6OADBVvyQDAj3EAINkBgAZwiXexm/7vudbBwZvVHu24lILyk8NJG2fE0h/70vzIWHrwDZzdZK0GzQzXf/Qjdw5AUG1A7wy+zNBSuv54r8rvhDEKOuAyiVeSWk0npt8MAEBbBYDNAQCQ1iUXFlLR5B8kbSCVvuXLaaDYBqQmmtNAhy7g56QLuJGEAQ4XWJTxgiArvxXYD6uHbOzHh/wZklqjXuiYiiQ4H0GZrpT81i3HlU//8Vvs4JMNbvoNsNa8w7fpbhz+n5HeGAetOZ20T1j12iUBYCkAGEfFenFT42fM3wU/qusfjv/55ePiQXD8Zf5bPC/S4nUqW71zZ/K4YysRA6xoLwGHQaErwMSaOr+b8uWse6lYLsR6L2M3zgvAjuK0BPwxIe2BLdb1ryILoQMQUOG5SGH8m+bfdsNV3YJPJ0u9cv0FAMK3gfqWD1xQN930Mz4zf/kWeBBrAHSyAbDcAIAPWbgFRLArJbyaNtC+52fmeF1ggsUSLRR8AMBBLQDGH/YHJAwSaqdzWGq8INAlUAiAeoifggfOrDZ5ofPBv8fPIZl6nvQszjw/fe/aEL0cCwA8MDDvRKN+jXrlz9Qnlrclx190G3KoGgwASwAgSwAt/sVH+A4Qkh1pBKj0t3heDRUHytuC/49EqNkr//AtO/PGqSIyUiMNAFdHpGG1kvkNF1Jfc3Yk25bjNgAa4zITFuEPIqF1fnLu+xtO15+52JDjBezKjz+F5DdtTG1s+Qff/jqukwFAK7n+dOCC6vnTn/wMWN6EtcaeA9Qy/w40CzemdQoAt6BEmHmmOJbC76CgozwZRoC97WOviBy8M0ELFUYQyXZsAJhJOSp4WCrcj5qdDRcIWaTWwUMShmNyEHB18TFyo1kQ4mfMiYdpKACwVO3C/5MTx7tvL4MpeHMFgBaHTrtbkec3se0AgGAmMpUBwI+o/Tt7ZDCbLUcEQHIm3Nio/ckfd+wP32Y3QnkF5QCST/yC9eYJMUCxNri/jwpyIW569QmYstFAC5BUkLAoJ6cANFSZtZCLJO68HrwazMFWaRImmAO3anWZBABCuGOlYFsk1f9hSFcQJ6cew821jQbAasXAxda46qgAgOYHf37qOQwBKNf1xF9OHK2MabDbQHvfl0icQBpvmighuf4Bg/JgebBDgUVLZ+NFjgOLJ3UvAIAfEgQAWT/RQrt5CyUynUsCwK+McF96F+a9WHo1ADqQ8otd/+PJlzAUADJ9cVhqnq3ML6UhQGQAxCW6U0iq6p2Kp8UAYBGoURFBXSXzFMaw0AfJS1sjjwpyISZfJk4y51+4LXyw52TW7IQ9J4WIDq5CK3KRrGhIutBINpJPUwKJJaXTzOCGwFdJAGAyVnH9Ma166qmn4F+ECTWzwBQfYGem4uDTcKzyoPABmgllHvnWJw/+/a9//evfD55MYmwJAAwChBVswsSi1LMJXwYAuAarycyR48DWNgkA5U5vhHqhAIC3Wupy3L+JdjY3CACk2lSEayk760m2wKa0kWOlDAEsVNMASAAAxoycMm4ibeIMAKAiGskqIpz4Gc8ZJTVCIwOlgQIel1ouCo3vC04moCKFMOTN5JKkAkhREAJ823OboDXxNsbszD0DPtz774KhYklplrL06gYAAnQxC8HbGleVwrY3eniXLIwgVuFIncGRvTCCIBOkphzJXAe/+goA+Ap8HpkGGgCIcQSxAW3bACMbj1zGy68L3QQ2r23VNjwAxKpUGqgwALh4KrZqhDhhbwsBAKIyLBsAzVAGAIEEAnZTu73owsmS7vUqaTwyAAZOmzxu4t9+agAgdPUCqIhmEqXfuE6J1ChLLImCRt8kvVhin35BRcrRdplxBKOREKNdBSrmOXiX9TkLj7lcdLqv3L/seqMolPVclmlVvQKCjTEV5HNNHGy/MQ8ztt6KE5h+IdfUhXThBOI1wbbcA6VV3JETf/nLX8Do81ygwa4CgLENSNW2AaIMCl8pXKEAoGwEugms9YUFALxtIgMAdodH9hR1OS8eyU4AaLq2AMBYShkAODEQH10VF+PNbyzWngGRAfDtYb/N+PInAQAQFdFJFuoY3zkXiZpcWVOVk6rVVPVbtTd23hsP7rPlqJNGTZs8G9f/fH3agfaUbDrvbnAFgzyCBkujpstKkTsAMW6h+bmBqBFp+x58habsPrCCoZVhkzDoDbNyKr/q37//YE7X5KecVl2zc391WtWu5cuX76qCe6hObgyQjLu/nm0AaNLBmkVt5QYnL/rOm93/HgBgd/iV6+LZU6fVGzcIAIQAAICuf8gKIBV8zoUfGAEA6m/loyAAcJZQspz4Md7IeRJSIwl7MKakYauX20+hdw/gDxGk+8G7JRuCQ6f9ZV0prVm4grrEQod9fYIBwJoLXHwMBUGOgnkhjlbwBmFdAJuE1TIjDe91xNlzuqYllksYGhwoj15LBdeg811UeKtlKrJtgC2U0EoJQYABAJy8sHJRMHBhp7C3ABkxMwBCewAaBW+HojgpNzkmDo3WWksqEAAEga8DAEEZe2GHAOCbXxsAoiLyyIFPMyU2C5IaNQ2BR33YRz755DJ7M/n4C2Nnbk/a+M5L691tNx0DWXThBHMWIJHGoQBopQEwsBuay969QQzbcn1nS9xloAxiZk4nxUhL3LX8o885XdNSeYhfEllbiEgbDnGHgfOUh61/rWQW0VNppTjnm8sYOZ1vQTeBXf6wAJAxmo8VWK68kF0ADoM8J096zp4qOfgVh4xfEgAo62sC4OyFkx5zymF/LThn36GPCAqRALAFKqLijRoAoVKjiACQY3A0Bp1VQkGPpc+vmOmZ98r726Ke+vCRyZ4PVjzxWo9ZgStALgGAKggACamTunUTAPgWU2YaTz76KmZONjPSMsrwZhdbKrelEtVJXy2Xi61pcLhHwY3Wv1gilbtJGKCEAAMA5ePTnW4Cy/1l4QDQPj3JoxVY3oyQOcDivbHQGVTG1g+l88dfqJR5/PqAMQPAyP95wmECPzmZVJU9UI+uR19aWbUr3uxXlegI1NNr9Q81wyrzEQaFAABl8uHoZt+8jXLiF1ZqZAAQuYgl9OzzYxPufvtdZNrfRmTRt94yfADTA/yCD+AJAgYA48hUDPMFAsEkP3HuXgTlymbmRK39bAQA0HVTqyiQEFgsLHNZEQM4RCT5QmMKrmaOCjaLlK0oaz9QGEhSPxIAAHbrxk3gRFVdOAD8DXkEWoFFYVrfDAKAn5RGR6sSD93YJ18aFS4eKQfK/y2HszBJSWkkpoqTYSW6DU+HoP4wl/b+hOoEOXVqKWjmHFfjIwkPpbdNXi7vowaih85BC4DnEkZqFAEA8T6VgPLq3Cf5FoCjpaUvpD3w6pPItB8+fVQayKIPORhBeg70xztefx1H8ICA7gEyJsrgB00ghWdB3/jxxyDM+DQA2Lhqj5cOO662FACGs/WlsJ8wmeRYJcisRV0dDgBCfGeMG5CrWZQeRUvSu/wrDYDC9Yc60E2gqq42/C1gZ7JHtlDtcQcIAoCPxaZ/We4/zUiSURjKCpX/a4aEMRCwEz9NMOgbQ7vcvIfChrhkF8fSEyRV4vqL/NAcWOEjrZwB7SqL91GYAyC26s0PPqOe6bJK6BJoAPEHzxOJ//O4fwtQYUHgNsa/mLiChhOolGo39wfH7fYRd6Bbu5IB8J2f/o1nv+2uRmEbCJeTmR8snJDoX6AAYD3EOUYlOZPvvAfXWgBANGglhKbJpB2XSDrrpWEAoInv3zXEDQGAVn+jVEeqV1a1RXVvIPJIf5h5hQUARHKQoJstVOAuQAFg1wYgKf1mrIICAAn/D5D/i+iN98MG4VLWk1LYG21MStoOpD/ExVsiSE9+otRHoj5T3zsHR9ZkMiCTfG79eR+FfOvpI0HpX/cwASDYpUXUGbSFC2+vqvgR+wbdjb0gJM1s+z3LTRMD66pu1yxwC1s0aBTcoktufn5R0eC7ZB2UlwmgHQIiEFY5Av6wguTtdGW7KQDQJHpspjCYcbEFAGPsZEX0jjq4kXhXEFo/bgWX8YxHmKfO8tSsA9OIZtNSYACgrdw6gU1Ftt0w86oOCwDwEmkPRVso/s7B28A//gMA2By94efOm4B1VYj837YGMAYC+m90Muyyu/d5kO8AXsJ9XJrV/VOjPtKUJHmP2PSV8Wj9M2fKPgprberepW/B+ZEBIMS29xFsTfWFsnh7NFg0ZHQNQpfQg6BiKBoilFKq3Ug5rH1y5UiAAKD2LXjVbsEJIFEDZ3tdiLqdfpUAoB9qlYytE1n6wwBgHfQ6UlebbFXWVBH1MhQA+iW6FgulFukp1oH498ksKjtoBeDnRp/Y9gNeveByGBYAxQdqnVuoUAD8A6MEQpIwERkBdvi/kf9btjGACFAwYZHHEiAqSAezbticWGSOcqlfL0h8ZL73GKYnMoGNDARWyD6q2zVE6f8VZRSznoU8dZBsr0pZvM0KEQ2Z+UAbNuFImonFJYlvvBFKKdVwAI8T+BZqJGgaWEIACiducF7MO4ZbXxsGwCyqaBVsEN2bigAwi+OViSilR5PibsSSs1AAqEUSd0iodEWma7MOzLELPlAGelaAuW82RPTMIKz07AwHALgrlzu2UM4mnPkAAAD8v9Zuk5sJPryS2rfmIfJ/2xrAGAjY+hP1JUv8o6bPv2f6KP/iWShzkQLbG8f3bq4P/twLouGGIPuooBJi2ztbuTpsVRZvPSzn2kkLp37RbH7E4YSpE4uQmR7R+Ec5c8K4Om3QPLhjCgCkgcVbklcu/AZ4BELDyk3v4TgYAHiUy6d0jL54LgDgX6tmqk3iC89CfcM6cACANgPiAxAIADu47WCMAMB5dc2RbnS22UKZJtxmBDGTYBt2q6ChgWLAcYHO8H9V8aqMgYAtP0mRYkdOdmqRV8e65AbH+b0NiZ0CvkPSHIxQaChVKf4nFm/gQTnWTpRaOM0KcDDpKBQESYeJzRihJFARh/r+QXcbAPBET7YwWL4IZxy3/11KpbZCK4IrYGf2ikoxBlPyu4pEGz+Fl34qJ+vAAID/Xy8A2gviZ7QVtyzJbjjZIHwAs7FqZ/2ZPbeRrLcgpZV5/UM5gfnMJaJI0FJiGX1OgaH/PyXENlO5yZkTHod2hd87fFXMwinWGNylZDYexjwRAAChPRIA1FLDGcn6WFg1sNfytTHvTVmdw1xuvtjEzg91BeRdCbO4+5LB1FKl4dPrzO94nUE5WQcGACbGRGClQ34IJzxoGtoiPZ3fx4GcQOb1lb7zCuJYTNdstbEdu9poVjBulAjXw/mG2q7KFkm7FaAbU/WwpgFf4ShFWjBlLxZRpF9A307gB3dcfUsyHLmmd1SKRf/hOzkNGkKbe81PpjpaWRlzIYvMpcx752d8fVpj1WvNmUeoJc+kTog9lXR4QiwUBAKAyIUxBwlSduQW8bEwAKAQEHR3loDES5aIMvg6h7oCPqjz2KlVsuPdnZ3Gyy+/HMg6CAIAExPIfaG35Yz5wqCJ43sl7Fdd3WTaYlliibGDM7fMS2uacKMLoL79+mUP7OPtKkuBnW5o69ZdqUuEAM0DeEuhpuZWL+0jxOhXRzJ0ykrlRob4wDGqt+C0a9uiJcVydPVS3ANAoTBiBNhVCWcvZs2eMpLJM3LzpPVy5aaVK0fnyczGQiGlY9+MHYuO7Htsx3YeKEcumW9AAYZtIFj8DADdnwECIf15UKkNaxR6Wr7O6vbudAUEazuBSdzX44VmgylKrtB7DSzmxzFXC2QdhKwA5JzVvDeabuPlB9WDTJqS5X3svLpsBDgTG1eo9zjA2yiD2LHLqQzauxjIZFewD/Eo8fEAN7TPP/qxqo8+k+bd+E6JpznpegwESFioEknTGP2DyBeAaUOkxCbL35FpYtPAX06GAuIugJRCtHVUds9CuwDWKO1KTaw/1Sdr6m+HjRrTnO+DuMMRu/nch/MpMsrFr4eFgknMlJhFh2OnJC9iBrkVqez0RKw0I9Q+yOzQeRdrTDQuCQCUBRlfNK422PmFKkTHuAIWCGsbHG65XjGLJLlCprVfZhBb+uoQ1kEzBwB4IFhW7h8DjWugFwRPmvbFTeb3sXOLhfdOGuty0vi1tlBBTbhTG9hL4v2nv8d2YMYNLWHmm7tH3KFrt2ALADB7J9vT3HBXoSzV3gJAfhw/T+GN3QfTRiixp8Ttg5WAfDm5CySIoYAvW6wAjIwFT1dUiu7oDRhXgz72CLL/CQDtaLWkZfDOe4Yr1Ql+DvcA9HDmB6n0x2frIs8Tu0nJSvM6X38BgLHQQKmtZjgAQFi5eVdV7OSc5IS68rbZ/IXGFRALdr6KY5+rAtdl/QaKR2NzCSVsmxDWgQGA0JM/Xb36QNqo6ZhAai8INtyg/fczeFPx+zjg6mpLjL2FvNxaqEDHriB1cAoJrv9MhNlrAtzQ+jtqUTJrbTR3vUN3zE5KSmBq3p2dfgwALMWM2gFeJrxIMS6UNuIJEmIn58RgxqjxAmZvZgybfGWLFQBKj62aSR9C2fBbKWkQQYTTx6NZkM1egbztGWqYx8CQkXcBV08fmTB2RTT++PhZGidFKBWgrNSQ+jDI2KLrk6iwJ5GaFn8HGKDJoLvXaoNUrStdeU6xtn9v569PZC2DBRQDGzmYLoWyDnA/tLeBbSFQgHS5Im7YAMAmYCveF0W3VTYq5XA8baEc76P3TpAlRsiTj+yG5r3oNSX9pfa0b9En14tIHfI0b8EIMAAA+jchwY/eonRqkCJKHuw7Dy9yVRws2fjGS1988TQfM/JA3YteJbotScG95PmVNZUQoABAGVUcfZk3Gi/tcOkWga8pMQ0VmSMxhGNFJL9tlB8vLuYTk1LJIiQyANSAw/c4+zLq4+AmU92soFKU2LsGF7m8DciAbS0IwMGQ0pVq1jYmLCCUfgEsT5SYRpovQ2sP/VIo68Ax8vcVrqmrrqloaCj47Z3w8xUvCNmK81uXGmu2Kr4cz7bQwsRdtMZ9twzal+zNaTx75kwLqY0i29ZptF0m5rUfjWqfN7ELI8AAQBzpOk6FE6mvHeGZZRwf4/SsaH9mZVHp0DewO6Gy2FyATh4LO7EVQAxR5YEA41sXhR8mSZPEJ5BCPFwCE6/GsPMNAqPckBNaKOwxFsAdpHf0YliEqHli5OoVuOGx/pUSdfRdRVmwLIupLPICATQu0K6Ac6bNkdNaoVvw7E5FqeCWD4fvmkuyDgwACu8flDhqJA5JvVnHNj33svUvl5hZX2UjxAEY527u+7q+eJ92rQusFERmesYdrIxLqBf+M/rZBLzl5PykA65/RuuWQ8TTnBAgrr5iLuCOvnNygQu7zUL328u2FPrYhwHv9e1JroKENxfBQ2QeticoC+YCI+5Kh5CuvKe2AhD+L8aZHDfU+W2edZC0CaMvxVo0K8B43L+p88HNjpsXehUBQf6DJsrWv10megg3zHa3gCRPKhnZ4OLJsEodNh5Z7avjcirijg72kgFvu3baFXDUqFgGwGYFgPWHNADkFuANwzqgPSIxv+pegWPS9AEDHpndsSMd6Vsp+oAM71Q9Xwr1hzDvb93r8d6rF8q+ZfTFV5g0/x/o6PmtLz1IDsfE8Rk5ZXZePrLRE09v2CCTeNkFSHhsRleZX3BCkXIxuELHRM7xUGpDKrbAbAtAZ2cgILGBarGH3JlhVtdZx4LTxLIcWmq2Aki1w0YYAMveJuUmHWcTKYp5y9IDqNafTFyw91kIbFqXUWZp157TUY+qnCGHKyLGne5JbIf3FL7CvWXLMpxL0cGU71FLSWMzatOOLJode2RPPm/R24grIGDpr9OJjlTgiJ3XAAARZnRY1oGwC7HIzXvMM3nAbfPPjf7bl0yqa64OyPTZmC10xWdsHz0qSxZ02e1B4AUfiOv0TkzZQuj93A+pobeL3unUUjcHofa3o/Py+59Yvit6wTb8PPae4BQanB9ntJaTEtovt1ae5sYWgNGfaNsCWBbYujg7Ax0+DlrrWBwbpa3ZogUFJEOrqyYNiOSbxui4oZQlW+5/EHp5MMLhBeb7gn7jJT6ehqHBkmHIbXKYjLuTdTnloGQ8N/+eUWOiZ/WCWdcYuLUdNwMJnHiRqTA2rB+OGpXqh/UC24bRuYf1Dc62QhRm4u5Fs+s+2J60Qw4Nef+CsMxCIu0erUotbEtV6K8/pQGAVy4860DSW/ZnxsXsyJn9yIeburYWViU7P8CrA29IeafaQlfjD/H4rH4odUOXec9k3npdL55YcZPZ2/p6BQDKqLoRKX6l+r8dtE0FAHqPH3AnaNlkWbN5bZQlp/FRiko/sT0zPFD0e0hSrdMWINH/wl5jC6CTVGGPjTIe+QoAjXFHEHghlFKRgWoAPHP3Y9gAQpy9xr9+/UusXlzQm+YAQ6A8bY/FlvzuZTA23LqcMpaJQzYp13BryzM42Ty3ybBQretphDMogS3wJoxMAJQB7BdW4fVUBhEdWwsAxpKuhWkD/agHmfVoq2yK86qEI0YnqrK62LMX5bdrknWg01s8wwrGgWPYtaW29NYHZLfeinfqvASeGdmdkfbR64Gy5Po/LRPfHEQrv9qZra3HzsTgSEzdrjCGBLleXQ1e3qYSALoNnw9mISHgFx+tu1e1pxbfAXKVUyYjwE6qddoCRC/2GVsAi2xc2Saf5OqkhwMCDACSK0lFpwNuTeSgr3DQvo19dtZUx6adPoQDQXrZR00i9xj12rUc8odNK7vihTqG5APrMgvfjCkZo3FnmoDcAAvjOk/Bsa58GCwA6Ix6FemjMQUFMQuHeSjceuHzT/wKJSvAzVkCgJUTgI272eeS28pHRbl1MgbO1tdStZ46O+aCAKBJ1oGe+P72kWOjM778G5GqfkJfqMLY2UV06EY2ojUzrXsGYJ7NgSh4XpZQaObKmU8JObfNJWvrFRR9n3uWfbOvkIYeliQdMzLac62uiTnJ21QGwA0YhgkCPvkYvUm/XhoAuANQUx4cIhbOFkCcEdgmPYYdv5JoqO9jAKy4Y5H3ggv8dK9JNwQA2PppAURtO7wVYC6fH8qFgc/08Tco/j0hgAmHlDoPFbp1edUqW818M3RyyKtvz3ssKS8DQ3qFcaE9vfv2G4/tcC06kjDbtQjqfHwlyqJNwB91D1CWOkiOuKMsDjS1BAAu2+CX/a0FAE2zDmTii0HKsJba0vm7hlSXyyWGHs6jM/bRW8Enen3l+neWU98+Q4nhaeEBPBVuRnQYO7nJAoD7ecf2mL9RldVB6MjbVAEAqMmQ8e8vuuvwiueX9kNzCgDQP+nDAGgmZWjk3wtjC6C9UZTjl8eYopDEO+Zk8tlTZ9UK4AwdhaxnToEr68LFEl3o+zBYcp7WacIhfflllJAvf0Mv8d8ycBrGp800X0/K+5Jc1JX90NMomeKUekHAgZvQ5xjsUFnKHqPjauwCakDCvv9d4aPTAkDLCwMgGQD4NRUBQN3gmmYdyMR3ZuZIbAGFVEXXX5/nFQ2mggMfHQjoEjJv/91EQQdNQ65/Z/GBgPofzm0WwArfsQsNCA1A7jIDgPel2GNxQ9+2nKTO/PwAACGnU4xfQ9H2mcV7HxfKvwAALYAGgFDQ2dA2jCiYZQOZSU7HL9Gt8ii4EnvN2IQKRw+gAaBc003JGYg5rTOEQ9o1XlYJ4wrHii1Ho1XSt4DMgmPtASweR6g+m6jPG97YuOMgLGDf3LV5nZkDkMNOPuYAyECoP7Thwbd5lIcFwA72v+DJrJZkytoD1Z6TAoCmWQcmvWVMatp3DKkKpzx04rP7j3+EHGkmDdoth3MAZ66Sx6C7cAu6dnI4FgUYWbdFkbMiyQEbJTqMjYRF664aeuxSYHYgADBSVnIxmZgzZU5q9IJ4BwBkBejWTQOgRZMA4N7e6filzJ++8Xjqka/+/tUR7AI6srAMYn4TOqpzE3QdljMQc1rnsDu/bADIyBWv8CbmbnITmDZt2LnRKlIZs0et1IC9/wwcm8fMTFtTyGItThn+Bl7WP941OB8E3MYz52/FSGwZAMDEU9UgXTwbW1feiasOYgwBQJOsA+fE1x1dyKQeOWOQvJ5PkKr4uRwrm3ZWpy6vjZqEncpLr/BWxQGAeDGevOgJAYA0dGJ38kcBgIxhrfjNu04cPejNmD152sBJvVknLHcNuQXc0K3bDc0cSqLwADAXneXqYpfJTeCJv/z1LydSy2tZzS75pt48EQJPUskpqj75XOiIBIBQwuHlA0AYV99WcUK9LCZyftiVn/vwbgIAUeqVHYCfZEFm9YEyluvhh5Kt0Wtv/ZjPApIadNSnkvPrDhkifH9hNlWhXy+xzZpkHZj0ll7xJCOUq2/O89Z99KOP1gmxJAQAm9cOHIWdyjtomcGg0wCA2H8t3wC6cHZc6AqAatUKdicnNADoGVxJa0Z/b17rlTh3g1VEc0BbmkAe1QgA2BQFDgPhASCGqIGOXyJcRdzCHf/4xz9O7CrXqaMs5pT1BYYhPKOHjSX9J16m0cSlCSEc/vsAKNfZU32tqAXdxisAzGcAGKXWaphzoKNbTd4xfF7BvlYwqV9edSSuMaZiP4aiOgQnwDNug0+Yc/Y7rFkE1oENgMCJlYS+or8kT1TMDH3xIQDY5Ya9Ie1UPAth8GUA4FtLI8vcM8XVeQEA6I6ODrxhqrbla6AWMgB4UW5vea1bbnruNpwUdr6e5nBQU6lVow0BoI04o4pXahgAiCFqcigAYOmy+y4YHu3CWQBZAcRRvikAJ0tSFNNsZUbPbsZyBmKFKKr+LQB0Aum2tqyujuYAxIRmK2oBwDkDgFYSbIkujjv6X3PjKQesnMILQ8IdlQnVPBTFEmAE9WKAtGGbthRzAiAy6yByhQKgEBSJca5Fb2Kn8tZDBgALNtMNAA6mAQBQY93ROIdHlR1AS2YA8MTHOObK70hzeGJcPckAwDwboPkncdcCX2VZxj80q1PnbKyzHTd3pttwDcQBYYErQpkOSGVBaczCJgiNwAS5xAxDK8TlhZvgYKW4MNp0qE0CJcPpkpBt2CbhSLlpCoECiyAG1K//8zzv+73fOWfvxhDqqWhbRdu+//denud/Yd8xAYA4o+L/YWMHALCsAOz0RRbgcX3GwQqA801DPPg55yFGJgqdDBcaGnLQB2ACjQFALwMAXBYk2LSyvr6y8Vp3t8Z+8Qh6vmBhtL6xeVNCUyNvhrEAuEgB4DIDgK6wDqQySPn6hO72m/4/5/poAGA7RfuOKL57n8VVRQNgT9z6FbitDLkaDqYGAHqwEyokS/7+vXtzH0ADYNUzv8KegUcNSqrPwfBBAOAjY818Gs/fRQC46wI8urLxEiZv3wJS0skPUQCgzwByDUzniNLBnxrnWgFcKgthRLITBjESVvQ78S3yrovqP8Dt6QyqJ3b2BvhuDczNFQqdBsCNX/cCQLkGXV/RBJvbS3vRVXfch7/8HZIHUymFN3E2AaCuCtaAbJYcAwDaFXDkMQDoCutAN/tJ9/YX6vYns1Ewiv2hyTo42QVAaoW0b9955wGUAUAzbQA9jkt6pPqG6GmSMObIyZMnp2VLJ9CvAbDsuR+8huffu7GiGoZoGD6IJXEyjqWtx8v9JSvHzZ8zfeqc+eNWlvjLh7fGBR5J7m6xBdC3AOP4pawEyOlLkkl7AgFwAmAdSxT9ToiDv/y9jOZ/+abkhFIZGiE//8udrhfAifC2nLa2YUVKDicAQDCvAYDsFBzT16e09OmnX1xZAv7uMdKFkvovflP6jAkEgPcyAQAJw/2GFLu40a4AqbUkTAEAzAfoCuvAaxO8ViimKGbepTLzDl5+CgCn9u3E8982UdObNABawytoAxgOB9trDAB4QAkbvaVHg8hwpDwANGR2yywgOXznok1FoQZ4g4fXrdPDB+QHIRYos+VwWW7Jygmzx0yafevKktzywy2ZP3gLkwmLLYAs+67jV2Ke9scehdnUBE5z9fVUVgCfitkIhTj4NAwFqZ5+G2e18Ev8Wsr6iaUTIVZ4/lc5XS/8AlpbDh/xL9m2VcnhAAClzb125a1zVBq8Eeq8+a1voU2rci3AywSjerMfzC8DAF4B+nEJiXvIeJZaS8bczcMUI6ibpawAQHMI5HUa1nG7nwR7TGdfyLk+GgCJ9YWHavfB74GfvwFA3UFsADB0jhtkAMCF+VvdvtpdfmS4DdjTsjQH5CPMGIQPsGRLTY7wAWj4wORWSezamXK0zV9y27yshHm3lfjb4DT02lKyGbXYAlB/LzHd4/jlV/7YN9BwWqW56lO9EftJKeLgynFSK4/NmJfwk8flYI4DFNU4TIXolHpGz1+core+956Sw3kuBwduBdge+akHAH3uAg2Rw3REF8ohDxT4XZFKW0Cqewbw6KlZ+gyptU6ZVJzuLhfRTOM39yinHRMcU53qs1m+oACARmVxOlkPYpP0AOB4Vh02ALJ+K40GAO7+B/cPyy+HAgumh031sEZuypyuGEHpcEM7Pl6q/AUit/J0aW4J+l7pA/OC25cGkY7E2X1sNGyxBdDxaHnx4vjlT1fJaZxQqtNco30SHClFHCxxa2YQoy2VN87aoH/2OgB+6NShlzhdLB1ly07B7ys5nHs5gNkP7PQhRvNuAbNnT5o0BhO5e8iFagy5xv1lLV2kGhOW4hCI5VdF/V4uxc1Mlj5jb5F8ms2bpYVr5xiZEtsSKRXvPyR7seKYKnhlZ0uujwAgvmb3oS0NO6sD0qfSADiccJA2gK+sWzD4UxoAQmlPwuGQsDF8w0Wf2xjgFPJKbPraDe1kvik/yw+eclM7p5W9kLAIs6XsXcXFxTKZsNgC6I6iXxy/8PzZHfM0S4iDkhFKlYbR1i/U+Z3EQf/610DIKahT5XS1ZBgSwpEJbQbFp+TKgLskqJgg3COEXB8CiZ5dTya/qdiMkbsBXaiDBrFcpOoT22oTKwtDEobqaD21pKYglQEj5bsp+i1HRajZAWAe/mVUGgMyIt6xpa147FbmmPIGAysw9P+hgtPmoFtqakM7Giu0qZAGwL79tAGgG2AAoG1++XZIdu0+4FxLkZUbWm9PFYr8QPILb0TEUmFefMKi+M3lPVDlkgtmsQWQgLyUHPHHhCuVseoyNYoHaJg5PqSJelAjQd/PxMHRh9LbjqhDCo+26KWULn6v/iW5afHswH4mAGCHEHIKFumTgzLfb2gJDQj1zIjSWm+srGxsrKioqC4NsAUJMyoGXD0ktKMmPb0mN79guARmXCJFzUyRPoPCzRl1LBQyLVwrAPD0+/aFb0nfvgoCTBIBKONPFkHAQpMmdlfahc+h631AASCtJrH2FDPo5KIhADhytHYYO7JvzDAAcBnNowkbOLjo3ykd3FkXQG5opg6I/EDlFzY20he2L8WpZAC01W8s5Da9xRZAHHtTEf0j9phZ7T0sdLhAonkFSXtJ3cHBQsgdWn8gNjNxkCZGLS0DOLRIRlsZSjaJQ8FtM+9VSaFdLWMUGQWApNXNdDKakk5zf9UI4rxmFFybTGwnrtLiMFB2Iu1EWnkPib44TwuqjfR5JFHyAhLwAtJl904AgMHdq/Cf27oVviVyoBeiKLnELr4ZCxYBgNLJattOshmpawyWtQ+9m15qXK/9IIOn+CXf6Mu4IAIANB/kw4H08eQERwDQbmi//pSuF98W+YHOL6ymL2TRvWTt5z9PZB3WANm79L5k9PnZHhPB2YHY5y8sur2gd4anj7jiJfps77v0GQ0MZGLUSoeUBjlm8w6A1arixfm3TphFSaHwAjlDACg3VwMA3hknFvlL5s6iEzduokAAAMeuXTq4FwjIcB0G9rQcDuLAdHiPDvjQGklXDpwRGfGUZAeAfjFv3la0mHxL+ErHABCX2CNsbQthNptB1h6NAEDb0tQ6LOm9yRPGAKAtflcBveQ+xwuAB/heqjeA89wYeuYDjAxAK/QtT17wh2+K/EDnF8oXAOi/fCRc4icJ1h116ckf026PiSksRdsibhdkX9yuU5hbmDBpDADQfPDv//77weYAhRb19wDgWngyvohr4ffv5KTQ6z7OCoDysMLhfz52MfIlSCw3SmQWyJCorqhobKwUEFwrkm3hVeIunVVf05CStW7NGhFInGkJAHhwXxQqK0fIdnERm80+YGyC82kPEAAULq7FpwYA4Fe2Nq+gq6bqpgkf4MQhFcnhsCeb8AFwLRWCyBByBMOuqqXHzAjKACEE7TfDjf1dP2GT6/xC+QL1Jn8L8gkZDROsO+7S+3wd2GN+FbGJQYTGBSfMnhO44+F74vHhPFIinI+LCkaGuNr6YI2sAMAtvEpcWVaysgzmT0DAmZ4B8EaRT5xgwHETEEouvZWlc053iA9IaJXKHr8p3+a9QEwb+GHDYSAOPA2c7gMb8cOdNgB8Pl/s74NXZlmYx0N6Nx72PdjjwfLQNsFHy2gPWC35lEWJCgDa3q+FAiBoE4BRBNz8hBGUnV1AvQifWBkCAMwI4swNnOLLFso19WKP9Nj5nxd4V6/ftxDBmWiwlMbdB/aVn8R/uFkYACSBYWUAUNoEX94tvUugLAPj8bofwf2ra2VcwsZOvIVt4mipxYBPB1KN406gj3pwCRJnN2bMpEmzZw/CgVC5NqhHzQH1wOtU5/SLMoPiaEWMXhKFY5KNm9nnkbMOAycwkGA0qG2Cl/YgxK72DaYdYH/KEQGAsfcLrH+PNoHJHKbDtzY8Y9WKUI2Jw8wJ/CaL9abk4ZaKXyC8wCSGnplGjimvolA+uo4/wqCO9jYQTdzCFqc1E0g2tNgCiHxI/hpJAZalBZwrsirJR4+1uhUSulwwC59+k7KA2gcAbpZ0rwiFKKsWP1uX20AmMIJ94m5Wxy2a8BIAisifngAgvhPBTdzqQN11Vx9tJ6/tOyWgflECqXyczkufiXhBwa0yyjPcJJF97i9/+MPCcr6LPG8AcJj2gPW40CHYc3/KYQUAY++3ei+eOZR8JMxTPhDpoAXzM5Y41yA1JigPlF0BhDN+JW6tRnrseGq5MQ3CR3+SwED3dEv7vslahykASYueJBN/my2Ak2HS4ViEgcj86cmO2E0O75Fd2NjUcrwA6hAWWf2OqcOxAPBtXIcW7snFo7el0woAHJ3BLEDmocN7lMEnjm3i+goA7r7MCwChaPql1UH1pnHu4lIB9Y8+F16AD53TqWS+FSXmmNQAcy7mJDLy8F+zEasibuN5wR/g/qV9omEUjj0APuG0A+xLOK4AYOz9kon7Tf0mSHNdXQB3ItxHzLoA1oi8PWG2Eux7bq3oBJrCwEu7CkCLrBToL1XB2ku06DyVUyrbLJW1ngnijtUWwFle6uZDLgtTn3/2pMyX1Hn6JtIBkBt+YS8tEgYAiDVySyQAMJQ83iNUtHUiHRV/MmbqVWcyC9BKVwgjymETN5osYhgAf1IA+AQDAAsnxI4gO8OYherDDyMAoAPqSYzbaW63SY1IgUzCmxuSbACwngGwBxP25Du2z5oxg+zXXJ/orBbaA5rj+mAH2FbXogFg7P18kGGxQAFvstzaZiMW/yV+xsaT7Qrndhznv/XmHP1uem+tCxxTPPAS5wnzEYiT3OGCY4Cay8oCQn2unHlklWm3BaC/UCfEvrIqAXILzi/VMoXxQ3DQLVNBZ14A9I0AAK/dcDh9HzfH5xIm3XVGs4DzvD5xdB141QuAyeOEFIrtFY4UZEUDIQJmUkTgNc5NXS4tk4mnzCCTHKSTYxBZJ0FUSHEIPPV8VRb5eEwKB4xReMt47AErwoMo2rmu5WoBgNfeD68c3kSy57hdbm14xoGRqIjGhMNT9t+RbjRD4diYWEUdz+/B2oK8UR8ZkrBPQLJ8RMpGdzJPVrm88hB3G2WzBeC/kFNF5/ief/QH0ApSfik/DFJPHj8SSm/LbWikvA4vAL4WCwC6wL3/1DOUDsycta4DgBGAgVBm6ncfHtCDL9hYnfE72usCoJtDPvDcIfmy8vMCjetGuQVY1EZWH2iUjKBJJhFKI50ErQMhT3d8BCidd4CZNeRIS2YzrZN4TTEBT/Y4xZOf2YrMism52yamagB47f2o4fQTMeiRW9vQEd198oz58MbGpl2yCli4md2nfNBGlPFHya+T1cUU1xcbezUCs/gO4Watt2cLwK4AdNzfXMx/IcLbX0vzv/DH+/4s52ks7C1H23bvrqlvqpZudjdNHCS+MxoVAAB3AvUKALIopQPPmD1p+ogzAYAcyDJhE7ewQABATahfuQBAOSKAY0c/19KvgwWgm90HGiV95kSSyQRJJ0H5QfSJTg8cOpWylhN3QTGXUCfrJI/LXNOIplaCKogf2AEOZu7RAPDa+/nUaRzpOKdZpkdlDO00UJ5g13vKG/XJRyv5I9fqggvGZCwKKjRe4jZbAPUXknzI9zN0Iop4Xm568DIuNtMCIQ6S4iGJxiHTZBYgFzj0yZCyXOTPC5Le0DnDEps4xAdSR4g7Uq99cPNioSai2JcOyz7WACHw/pAIvGTdZgeA8TI1bC8pLZPh9BLoJHAXwHIQ4h/Zx1PfORBVIokqL1i7TbL0r7pcAHCBjgrAHnAwqxE7wAoDgNMpry9MVMHULsrQ7lFlaAdfiw1EBEfeqI8/QlzvYHzEihKitqi6iyafaTh6DlY5AsYWIC3CFkD/hZAPZTyAVmQRQtfWInRNT+Hqt5zYfZIi3iRN0RAHn/LxLbaMrn1gJ/MFjlOWQwUIiv3uk8udMylM1VhwV5a/mG3CSBkUTN9WpETqKEf1tzHg9hB4eRZgB4DwPeF61GtyLwivDM9FZDLgxND8CjoJdANIK4PPZQlQWcuH+J9+op1gNQULzvWJrgjvwR4Al3DsAM1hAwDv2ywNOl2yGGB0JSeCb1F7a6RbDhfoRpGGdndqQzujBhzsQ84yAMAfsaQIgR/d3CgskJHRC0k1d1qLLYBHXpiRROJqE7xK5OvGwlBbTQhn4HUbfeehPMRBHyvmWOrqyAWOU5bLkQb2x/t+/PgVZ2JG6bWJE59IEgGWhXL5GiKPzHjTCn9XjL172hXHaiZ2aa/+vQupevc3mTdCkPMucsmyIghPVlaAdNgiHgIZo5xXANRQBYAfclYE9oD9KQ3+ba82rzMA8L7N0qI3rh/KN0DuBGIPoMpRZWLI2dAOyUjajOy0AECTHq3+N0l4o7QtQEp9fcqsB7UtgPkLowAg2fuhI0frd0jvmgFgiIN361ssGEHqAjccVJXhAzaspdzLK7tOsom0ieOZEK8AeSX93ZQqK4HXsZRm/F/TvzA3fwgQCjcl+KkotbFwpEPCitT7npHL0RkAQ5GExLZsDEBBO8EZAKVtgnEQHVS67qbx+aegUdwKANwUCwC8zWpIp30/1oK9AN7gKO4KwB6A+AlSjirW4RlDO/EIW8IeHJ0BwK7+x46zABYZOxsrUQ3ByQ9OmDMGIWRWAEj0ei6ENDsrc2VETQAwxMFRWjH3pG4boFe6YQNZFX5EDUinq3UhV6RNHM4AuJoeW8m0by6zqUcSeDv2HCDXq3wkwFM/vwcU2Ho8I/pXRZLXicLEkxR5NG4BNAlNbTmSjQEo0U7ICQmjHzGNoMSeUvzyy3YFt2yb2DeOACB8ACrzNtOY3tQbyjeA+4IQt5E9AJfjFlbBaEO7fCGvtQuAjQIAmjna1f+4WAaQwn7tjX9D7djyz8m3TSCjNwsAFIe2UKjLvUMFICnRrcFLHHQVc8sdk7LMZqW8zzldK2MTl+qxicMtIHX2d95+2nNss/F3OwDABeycA3rABsSAw4IDLW7V2dDvO7MiuYQ2r9eE7nQNBfGaTvrNAXaiGToiOWOkNo3AKXsNDtG74v3b3ns/AMVyfhEzgqTM2wyijqly8Q2QyYBwFKkcU/jLow3thgzkeYIRgw1OVgDoM3jjOoxRheBuVf8bPQ0IFI2VDf/qXfLgd+YMHWEBQD8J3aLdP1x9PYCAuQaRab3EQS2YMp7FJmQZCHAs1SWbOPIIwsD7l2euOVJLGURCA2CiSRZMdFrJZgmeCwC145vYxRBrJVhvinbIBr7rw1vqyisuvmrq9LjlVzgmsWcBvZ5MBUymj4QTKGXeZvL6MAXfgD/h1ebZoLCUUY6n8PIZQzuVkDxQCOznaTFYn55r1gkAAmuw9ChVqV3972B8y88f/BkM0FTzrJsFAPj5oGnKLXth4R/WDNYfka/FOa1YX2wZUF3sNYmKKeU/NlJ0OcqdS47TD/xMRMFAsPgnonBaoQVTXDWUMiYGACKW4b/05dfXDhjvLzpYFxdAeDUMXDOrXrrSYxNMbbg8PhYHMCqICaWSt/lEfE1lf13a+4BuXcO0TsGUkIGiDO3cB2xcBPpgZQIAkJWHjAl+hAwAm/ofhunVjZV/q2wEg660WvFNP2kA0AcAWO8C4HsYZsDvieZWG3t+h4yvZU5ptTakJzfq7h9R55Ld037x8yfMvQfBkU/G/dQ5RwXyYhIqIJkR6s8AfQk8RkcU82hYuQ6qnzG+OhoA1hUgY/njP77vj+PLF9cmwHn2ggs+nH/r7ITvPv5Vx5PYQ1lUzNBj4t4M0gXEvM2IBd5ZcakUSBNyBmBpkhJytg8AY2hnACA9F1AMBlVTGC7SMlv3kFOguETY1f8YLgnNPLUZlbqzYceOerwDGgDXVwd8kMsqAOjMrZztUGdA8aA/eTwKAMapfONGmSqCRhgLgD/DYBGE7k5KE7eSX3qC3BRwtIwqk+PvLYfoqzQCrGJ2MHy78Cdnx+D530/ceGOawiXvEP/CoraA2DNAMv7WhxeW7yJXiclk3XLswVmJd4AHbUwjprO59/eRisXEvQmz8VHMwxxyuKWqug8uLJ+64NegTeEMDVMzBgCLVS0A8BrauQCQngvOsb0a6xNPZtektByHsRScArlTZlf/A7LgcG7JoXjdiQf30ce9XvzwlwoAlTur4tasCdcdVADAmEoytzC3wrmMJpBoRGRVOZ4yxobkUr4mTk8VowAAHdsf7thOIfSd1AipBeEqGmJXxSkAGJjxIRMVCQKHY43YZJpTqnHVlesaNgDQUlzfLLZPlamzcVUQHyylleaSiyHfApIpKQkM+s1+aM1JKNl/cq/Jc/PQ+nrZaxpBFgZz6FRMxD1sEfgoFgDH94TlYfI2MpW8DwQAIlfnigZAhKGdAQCvYAX50wYiMTtvNwjaBUOy4RQqFyWb+l+kLOm70+Jrt3HBCYwFdThhEAAa6uH9tac1Yd8udAIRG0o/HWduBXhqhYOZRLK2N70TX8M9mQk0VUyZNMYAQJ7bRWv/eA/iZe4/LbdwGpFuxxMEnUMBwMBsA9fnLwIKPBAQCyjxxEOXS/4k9ppDRHYFAO2cJ9+3sdaSxy0vjOkDABKmDwBzuGI/9ziL2Y/Z/8LDdzzueBJ7+FyMfq6PiXtkBOuLAQA/Zp+uu0fRBVwAYAwrTC45/jexhnYKALyCcddtSD7Eo8UncKgciN6Wuihb1f8SW1GcdqLMLf/MB8E2kllATc5hNHEOHw0eklnAdfxbFW0GVmWjC2hnfo/xfXn5+DdaZoE4SDwdA4DPyHT3jRfSX4Nd1mn1AaaSr+8LxD+c6o3DwNMfgCs8Cp74wIAHAvheaQnwcaRN2m23KqUgMmTpRBIBABY3K3M93KRwaOqsE3jhVfCZzoNWkaYcY0cXDYNsNT7xu086p1+uL0nceqrLtLVGdwGAsazBq669bj4RY2gXPGEAAATgtzr86uNH2vIWp9c09Ed7WzdKrOp/eUN2pwfxoKkOH4bPG2hzPF4sz05rY0yATS+xobo6z/kDgyfkR8eh/HDKlGJulmsA4LXl5za+vGzJa6Tp6aQup6IhRl7eDBK2aADw4x8OmAluATbw/S9yEeBg8MqrFUcC3KatEXnJemyVAEC8M5XPsOPwKZABEDULADOQuijUB5Jb4OX9vjV/RvC1v8IaB8IQgODmrR8g+SHsmefIHB8su+XLNQUvwipYOxPVrVihzXXu5Kw/AcCJYOLORoklx/VMaYg+0Y6hnQGAok2QeLQGY0p45Jjhhk39L0M20DbrE8jmEYs9ipweSVGLnJPCwoaatLzaU0VFrJ2zMOdQkQBg83BMUslX/EjOlh20qfRjALz8548u4sfPTvYImFo16jQmATLFzJ1LYm80vfShfQOByA9a/rYisPP9ZYDABpOLUaUyQgFwzOug0KSpnTq0ZEYC4CEawOFUbQDgnQaCEoqbE3VRZBrI39P3KD8VjSkWB33ta1/D83sGB11VywOGyeOO/Us9VsHd5WHiMdPh6zf4x0Qcp+fNAUlHAOBPrxHbOlG4CAJiDe3SDQDUogjeRFb9DrL2RTCGEfFa1f84XDWBuV3ZFMZpLw7rrOIbSqLuAVim7arBN7lVYkNjyoeXIwDKrOHMaqdqtBwAJlBq4uHXQ8xBshV+/PU/rN1wE17bsvzcwv5zZ8zDsdexl4fGsLIXNjScTsE/dJ8/Hj8ePoQ5qK1bIdEoKwdJV+di/IRGJWRalsLMJvozZXvivfgKOFLeLQAE2MB00NV8a8wZwMMHgNCQeOYRfAAYR8MB/dE/oTEh+kD4QT31/N0umCUkBL1x3AJSxbYYlwBjFQySnjzMvF1FuhaLw+Llzp9I2SnvudSNOpq+PUM7DQAp0DCTS8nV+3hLa6BnBjxJpOzq/6RkFpteS0K6QCk2tsUS7gOSIZr7L1Zl7VvcUJ/avFdiQ2OdG4g2izKcWXGqLuDVU3zFwRyR5krpk3fc90de+0OUlbvyQeQLBTplvXRTAWSiYsbPYp6/v2jbxImQ5qFWrFiBRIhQ+XisAfKrYN/YJcSSysQthO8iqfIF/HzeW4APjMhM8NWS0UJzAWAYQfGghKJ7GsEIuurCofCNf4UOGVokiqOFAQAmdfQCzaCMr3nsDoxo6rtdq2CQ9BQATviHuIWDCkhznBUXPHQoPqeyEeIGFAlehdgQZWhXTYZ2XgBoQ51ryBUWg1oz97ar/0W9wyAb1OfYsZLCaRI6spyb+4G4uq2LCw9Uxz0bHRtqny+Kkkf7imOzmdZ/Z/XgDBiK4SB/zwtY+3MLKXPm0y/Ov2vq9O6nm94JNbscaJR9Lj1/HMIwHeqLagZno65uPxCAXYCXANZOL9ycD/pTdenzj1FEwjpmSDEbytsH2AhBcMK8W98uXbdH9wG8nECanvCf8TmuXhZ7+4IA8ea9mX04W7oMPZUVhuZeAih41AaEXYC2CgZx7yp1oINSDY7C/A+Yds+eA29955W38Fz1WR9HACCAbS8cpz1DOw8AFHMCzXrSHrA6V0PArv7XatMbsdNceg18dSBWANNfmvu++2kuwbywaIqafb4oAJAdRmyla3ZW47snV9ng5rLQjga0HcnED+b/mB2cXtfeLADqxrNhOJ4/Hj/pM1ErUum2n5BY5NetHZ3+Q+oL7KCjqG/2BsWaUGpnP28ncKMP5gbB2441pbaoxloEKzgvjSovPphy+uJmldZPcoHEhlyO+8QAzxsbqa90CS17vsJFnoEJNFV2loXBNvy3e9sfZPQNsYZ2NxsAuAem+Vp74E6SutnV/15V9bWg0sAHFabO2LDJ9cnh1WizxNBE0VDt80W8nThLpQUBMJmh6qn61DkTZkIkTsrjqnBpIBlr2ukBQJyMWMaOUi2b8Xj/X+2Lxz92G2prwiz2B9+6uGy8LAGsYdjAtgDojyPEl/O3QWTGjwc2lJkFwJABlKi0KZU7QeaX6YdNFyDPP9YVjDV3jqeMb/GuYM3ibRL4+zMVFZk3A741pqmzbo2K3ebgDkgWyAv2H9BYNCf3RNH7qQEQa2jnAsDcmDjqn7UHUcPkgE39D00tS2qJRqV9MBkAFF1AgRIp1ECLAoB9vijX6bScWADAVzotdLLt6OGW1lYoNDfKdKZzABhXMw0AbABli/n537xtsR+1pDYnzQ9/8Ne2+cvZD1VZLKr+OIakHAUUUp3RbhHTwHXPLYpPG7ijJqctf6CybTBHHBIGJZA0CIJZn8UVjFS3yTeYAvhQn/novodfwMsBzdAzn30ApaMiybfGtHWTN1J9RsJFoFlwPksiKxbZmAVaABBjaBcJAOV34WoPvHQSu/pfEIBB4LeZR8XPXwCAgPFlYD/fR3wHBGJGAsA6X7QDYPrtCTn34qwOBsZ4SjJc+zri1zoHAB8BxcpMAwALAG0A9PyL+JQWn0YB7dveA311cTkx0hkAuj+Ofihmo8AClCya8uPlA7Rkpcyqr6nZneeHcUtTaTIf5ow2MNyBXPoSD03PlFocAnF3JAZnzsxZqiVFJE4DmpZm3T5UA0AesxQRQbtTJ5ABoDv+HolbrKGdFwCXSMGpWGsPDKPMov43CMBWM8jYBQgAEDCOg/vjeEyIoUFFAMA6X5TJdL7nDJB/NCFMkF0QfuvORR9QeluIruwD3vjDHWzb30mpHcAAADvAhuG0ACAKbjSsSxmAuG0WwXcPWhHsAQIAY7IJG8XwOtkAPBxSSdIBIwjtr8NHj7ahIUor47uPyn3eXHSVXNruCrYwkWh6pvTWimN64qzElKamPqyfUFEitKJqAPBj5vrk798k+V1gJACgzgDV0WeAWEM7AED4AE53XQu0NjBuuaGUdqb+z+jZc/AFXvsvp7Oyzhe9twA5eea3tbQSAHzLVj32zN5XadcuKi7DMrDw4e2paIl0UnwHEC87DQDsALwAQGKNew06NXTDyR49sS/0otv8OAQoAJhNoCK1lTcAXt9QXk5gKB/RmgUnQ1vST+yq3f/BojvfCnfRFWwzR3qbkuePR9dYWVNTg0MvXIs/IUnbeiRhzgAYJ3P9GmYekN9dQW4B6hZwPdW3zS0gxtAOzBHFCEpyS6uD0a83z/c01P8ZFlNfiUDjgAUUdfM4mcg+X5SxKi0N4TgSEISUS7l4Nj/1PhZu9M+xE5RtjseNuFOpkOcIwEWnTNoBXiWeip/OnnLbHAaPhigAmE2gMaFFbQCGQSYIACu4kN1PezfkHD3iX4yefhfSzYQBJJ5gpviVojxZNOvQz/nbjRKer6JE+BYgbzMeM/gAqjBSJiKoQ0aF6APUwO5W2gB4/tIH6MDQ7tyVRKBRtOBDD4GZVYo8Njqu2OeLvO72yHd9xeNhGIRF+bcAAMnVn6Xm6au3TBw7enEobwaOQ2cAgM8PL8cOQAuA9Db5/56YMlEAMJtAQ8phI2X0kog5DbkXmZ827sxqOTy+jPpgMQ4CMfQDNPf5nejHMphhfMw3pUIuaOmurK804fmesB55mw95GUElc5kIKpzAYtMJvBHPnxcAR6wBvIZ2WH3E+Su2knjy8NsncEmR8MLzmVklsZTs+aedALSfiNCuyGPAgeuwPqJPp3Mg2pdV4CqMGEFnHrqvZFrni1rPz77iOcE0ZB/IoqUA8DO0zQCBr2EnWJJHSatdBgCeKR8BYBCi+pkRACgzADCbwJZgm9oAYkjETCMf9+lPDaoOt+55Y2E8ySZtAND8AwoEJAAIC3jaMKL8eooAoIh2FZ7wfG9YjyP+gRGcQD+9279wyKgwrzAdWwdNAjAKkOeP0ox7Y2h3j83Qjg4DpZg8QG0gWiK7E8BDRLD8FgiWjmsJkOH7rdxKHnrI0YyKO1e9ch3TK4RYYZ8vamqC+IqXHU2cks9dCQ0AaZ1iFXjvg3shYb24ywDgM2ARjgC/KQpxP1N2IDLluezVrZ5DoIMij4LWw22hdH9NvdzwNAAMBIRGPrhnMlLv/ngPRs6xL5R6/MxyQddmw1pEIb80Uk6oAAA7WJnSnoXwKPKG53t/FHmbi0Z7qkjebe3xhmng9SgaBup5cIyh3XethnZ0G8DLChqU+q8YJ4C3opwAcNebBIr1h5/sWZop5J1w8saP1qqXXg4uaFPSMcfhIHg+xVjni4aawEPa8S0z0kUnZAAgEHjn/b2LUnAcOhMAjCcA4AggmPPxGRRnQLaN0tdAXb41rUuDaH7kUEPa0RUjDibmjQ/vy3ez2nuhvHn8VG8gea404GsfAOb2HhWe7wUAv82YY5naKmaVDowKyePt+6nVmg6gBW7tGtqJ81d0kREABg8kNljIMaN2JwB0eyCyQAjj4MB3U8QSYM1FG9CZJAfW64QIPMXPboxgV0ASx910+3xRrbsbRBC0p1WvWgYAUg88+9Qzd2ZhLHJmK4ABAF8280g1fNmrdAQYwDuAqY18ScChtNQjFGvX+xl2+y9jVouZvIXlgEEmAvlxaSh/IQd+EDe0CwCnu1aJR4fnewEgWTvv9HXrnb3ybrseb7cHNCFI4zbG0O5Kq6FdN7qfQEaUPpO0RGQRYHUCoLNEcCbGM58qxfiMpa7rMGlHY5VJyv345BIiYUNSBj7sLYcY+3zRsDVQn18Xpy0RogEAas7zj72FwegZAEDOAAoAQtahIwBOAIvLceLcGN2xqq8hc76ArxMAiD4zuXt7Gnb8RGA5EYshF5eGUNq9S59b9tN2AIAJuwZATHi+FwBMHpSsHfmHBAyhD+DTHm9JhhFoLfsQ/UNmwswl9QFfFLxOAPFeJ4D7ef6ci3SJajiAkdQVytbyMnnn78ff5MoRVvfER//8F4ev2+eL+rQkVM2NpOggttMjsQDAZXVZYMRp9AG0p330LWB0Nl02wzTkyIb4jiLiy7AAQLIMaYuUqJkJAC2t+PoZl0/y+HNVHv8UJjNdFwMAavcpAMSG53sBwOJ+ETqYcaK829bqdBAB9tEViKIlAR5eW2Q3Y/R1TJkKWp0AZAXYXF5WOLk6k8ZlB95uxaSlcG68yBS6SeIUu54N7qOTJjqYL0bcl/Arx2PnH82xVNc7gdIJfpV8+tLiuQ+Yl54Noz55/uvWJFNcRQQAdrI5nxcAvuW43v6ckq7NFy2GIbgncQgPR+Rfw3n8x26Lfw25lA9EA4BaQwKAdsPzvQA4zbLryKMGEd1RZDryEdOPoOCgjXvubbdKMiiahVYnAAqr3r7wDeSLwNUAlCiyNynPRUQjZx7IOB5y0KKJX1tfOujb+P7R1LDPF+111gAgsyB0AtEJLlaTgLaTw8aO3Ybn39Iann/XnEnh0ojIIc7NNQDg85RmZxmoRBmGaBDQRdnHMqtpYNnSmezDtx+cteiZp6A9igSA7udbwvOjAWD3g/Cx8EmwZNWRRw4i+NifqgzAUh0i0W6C5H/2PGUs3M3qBCC3iTfGlxVek9pCAEhtGe8vuQY5DBRyroP1ChePfbW5GnNjPInTdxdHGcNBaiPyijUyo2sAML82Mwsox/eDWdDoYj/N2xKPnsyGHT7uHFkJE5AsBmkyP87o4GRdNJkSpQB4mN6Dgco3wVDEGIbwRTluz/GCbI7mYb+I8OyE556//0eRACA6Bj81S3h++wBIjvSDuIHK8zW7jjxiEIFPxuDYT30BpJU854z5Ptj4cPGdlFCvAYAroHYC2LcPFB5yAiDb9xuSCWJ/pLe+qeVI/g40xPAhDDjJgRXnXLUH4JoFACCig3aAzt3FDcA9hoOlIAW+Tk1FpwvlJQSZaSANA4AAjJaKtm3bl3D4eI8CDJhasgDtmUEg+0rnG259+GsBAM48uhzwzMmlLYd45m5liMHEl2Quyj7qKFyUMydlQoOxAzqZ5ub1l73zPl2WV939zfsjAOAYAFjC89sDgNz6jB/EKCrP1+w68ohBBH0yYRY+S0d8AlSIbOuNbYcYnwIA3AJw48+sO7h/2zb80vbvP1iXGbcMCGDrodcRyuIvQcpMaEv9UloMBs3/ns4IwRNgx9ub65oaeTL9ydN2F3dIROMaDnJTkWkPXQJA1B7gKEIQRYggDnQiWIF1ma17SITSmlp3b5qfgsVe/oXTzy3DkXKLA57TytLQ9rvcMxLD8yd3KRRlxSoESB5OYhtUEgl1r1K9B34pe0J4AcBnbwGAJTyfrYLRCTSmPahoP4jrqDxfs+vIvYMIJ0NkuyEKTcdcwqG37tllAWF8CgBwB3in74qbixb7c1GhYaN/s6IZrT4e8FAs0+EjaVNy4k+kB49ubmD/L6HraFOQwuKxdU2VMpeyu4vHFpqHynBQrLVAfJo0tWsA8MScCQCIdDS+jBFAtX593Lp1ra2tQPfWIn+5tlV2y3Ck3HLki2TVerE3pJpMpkxIrJCQOA9nZhByK8TuSG2KF1cYDwCSPACwhOeLVfA0MvAyDXDp/Bo/COebKM/X7Dpy7yAC2AW9ZWDx6LHviXsAX7h++pDkbgsAJA+rKFRYQveY3rnFo9E5Od8EUIPelw6WatoWP+hvRhLlho+HRu+rr/y64qd27i4upZQn8guTnhiphLoEgKglQEmPJEZqIsd1rF/fjKo7OHEbnj8GDx/xO66LXnbDkZLCKZm1zabxr4In6cFHxURzHk7aCX/ohN+tmeKzZwCwngDQTQHAFp7v5QTqivaDkNua+ZpdR+4ZRCTz80cU4c23vPMOsY8cFtM/pILXr2UA3H//U7gDFuNqOA51TX+zc/FNqaK+wb8ZYS9tOQ1pJ0HaggWqAQDnXiyurd/xN+W8d9rXGPmh2XBQWWt11ehc7eK9/tULdD587OgRD2jBi7eN3YotAAVqaKQyQAhSsRwpKUd/ERc1B2WCJ9loEr8gEzxJ7yhkabuJwiulCbz9XACsiACALTxfrILzZN/RRXkAXj8Iniear9l15J7/80Af/fx1FKEoIyMAwOtKGl0NS+EE0FQ5UFJYOLSmJ9hRJSTjaph2cmlKSS5SRhFlfR5KAYCCL4pra3ZUYgdgtUEnrh6SHgqto3cE+ubT1JWYfOzpN50ulET7HTvQuzf+lyD0AgBm3MC6IKmiSG2Qc4kuSXMXjpQuZ7r6oroFmODJXji4obzBk7DRejihfkuoNiVBF+uMzRngIBN7PqlZPbbw/Atd1JkGeKwfBG3W5msROvIL8A9XR24AEFfqff5UDi0AjguA6wkA13EcFlbgMJZLyIe2CACM8VPBeBg/TSs4nLWzJFTAuVoofgH5GNg/lwBwfR9walHWtkVGT1TgE78H6ZvSQ70jUByNuSvx4e+7bhKHIcSUuWyubiZzIjAs80uVMc/MVQd6OFLGn9X47pkvSh/A5A4ee/PNmODJO3LiaQXIqa/kmov4A+wnYPDKMwB/C4/HsHos4fnGKtjTAG/PD+J887Xz7DpyA4DwIHn+YqElABCDFHMGoMsMLpR084Uc8eDBfcE0A4BPSrbwnlQKe4H9E5L1XHp9PyoJsThUs6NRe4w6sSUB/oP7oKozkfTOgY6WpOIulJjE0UmCRMaYHnrFoQOAAVT5eHGio9dfawOTdHkSFNoNWIgCwKDvxARPwpQw7ZAfqmtVGNyjiYZS27AQewyrxxaeb6yCzfiuXT+IJAMAu47cXX7qmiro+R/k5y/l3K/PtTphCu0MKBPDdXX79h38+9//fmrXIb8CABt/4Z7fY3gr5yoPaK2i5eBq8f9y4zVptCDnFy7b8+/DYpaKphSKicE48eMDYCjXGBjz0V1iUqQ8nEdOA1B4+FHy8K6WPXgSfnzBmTV5h9xbwKYgRTv8/OdXqoP4ofiGSi+rxxae77UK1hXjBxEFALuOXANgf8LO/hRFW9csDGMCgLlBGwBIAOnYJWmHdv3jH/8+Fb9bAaAfXU7655Yhs7Z6JWll1oYHAQ/K/8vEa85QQSXyefvPHzxI1rNVVtbEo9WItNSPDwDZx0fcnvnWXl49FQDMyElXpEeIzWsmGUMAGgEko0F1P6cHcHUUPEkmPw+m1BZvQR9gIorTDx6vQhtVXcX9uyNZPU4Xql0/iKT1BgBWHbnef2pTKtOIHGs6sQwAIC4KAEmrwaJbHDpUe+rvf9+/L0edAeRnYNZOHP0wcPmNw4abqxJsTLwmzi/3si0plxNVxnDuRqVcl3HixwdAd6nkwCMQ4NJUsT2HIGMTZAeAazXzE0xLwgvQK3v3mbeQH8LVUfBkKQIzMiHDg4Y6s3n9eu4Dfuf78IT6uXIFi2b1OO2W1x3AlOsHkerxg0g2ALDryBUAdgURrJ8XMt7t6uWPBoD8PxWF0oP79q1YUQcNuQIAdjsh7dwX+I58EKe+wgSlS6T4/MLHFyknpuQejVdIrQCHirbuhTeiBQBdLkyTf0ZTxVEMgM7LtpdAnIFuVEIq9pRFv0KzfLp8taPgSYrMiVtxcLQ7Cwi8OX92yh0v//wJ5Qq2NYrVY0GydgcIiHxIql0/iMD6FQYARkeuSunINQCgv6+J3zWwktMb7ADA0VLz6JvXN4ebGvU1cAwzDemaPHVS4r34YPtP2AyMv/S4egHFEOgxciaXcqLKLKH0M1TsTAG1naiSFgD8P0qWLm5M4XBH47J7g/QqcXUUPInRXNLq9beAgw+FiUwDb521/b4/Y4MUVzAh9hhWj9NeGXeAR0Q9JNWuH0R1nAFAjI68THTkGgCHdm+prE88VTxQ+UHx07cDgGyuSPGWUjJNAUApiWARPT1VPnrS9f+qetLxnKWvozOz+tSJKaNiwy0AKyZyRNFp/PgAIFr6E9izk1QpRxeMUPt94xIkqYxUKWgiXeBtnv4nWLxVRpDa5tVphgWaeIcmTLgtL+82tGSk7MGTBAA6PyElrngg+AC41hEf4OE//OWJ3ypXsGffiWT1WABI7gAyyEGZ3O1YPwiYjRsA2HXkAoDi3Q2NTVDGkwLOtc7VozATM/oNdwVISE0lvv6UtOKx5Dkqzl/4tuOWSwABLini/0VeOnFdPEVjAaB1M9B8EPK2g80RAPjEmQEgDNLDH34SjhuhysFJOUCrMpjM6DQERKnAykpMNmSbx/8EhnILws89Q0QMtclfzMVUmcKSuQcOlEifR6qj4MkRhDkkeGP4nNu7/2TEC5RMIUbVb3HXNA6mHlaP026JO4Aa5JiK9YNA2G5VnQGAVUcuAPDH1zdVNR+8eRhk0Eb40k/KxIz2U1rCEGWgEINnV1sxuw5LIvjdo0BGcnUB7P8FywsLj4esA7jPJ75PePnw7pmu0yB3BcDUWjG6WN2P1phwu7oEAB7cb6e4PykHjbzlOJchyextdF3CVWLBUhVeBjUrb/TTMXTC/2LSGMoJXIqLHCoJkxopCpfq9Teq/tegq6G+2kHwpO7NUIb7sGJQAqEkCpEpnD3sxd4UR6hGpDNau34QeKX/rgFg15ELAE4EE6pwZsDLrc3OUe7tfb7hBErY7TB/Gvwc8vxLgm3FFPDxozM4jdHrx32+jGRtxJpsvEYaG3deKmeARGgJFKGHloBPoTneVUKUqCGC9wQTZ7u79ZUoOLCkIMoMWW00YaR34rlV16GwO9CNRSzlSIxNWmz8j0YkGcbXJzOzdtY3NDTU76zoY9zGOwmePJ8RQJo2ToteEo/0E5u0mXZLc91PUrRiFRtKsTo+D9ezfT+InXUHFQDsOnINgKOY3PEOla2OAShze0dEjNzeHY67Jm0uasm2fSnpxsDYFJZXC5vHvOs/fQTXIurzlS7HhF90B8v0HgDP+YaGkhK6BdDM6nl3NP5FGozKUtAlAPAEZSZibkCxl92ax3nsADRzZvyiLJJbBhf9ABYsKCJYSfImRi4T8L+jZEZKPTUAEOpMSso9iVkkFNAAsAdPmrToy4h/cDNq62tIIC21MZuWB1TDL9CdS2jlKjh49C0YG9BtX9/Zkpu9anB1kDIAsOvIBQDo3WNwl7SaGJIcSM4IMLd3PuGzeIj1OPgBtlJNrNueyBZGj0VphOVb01+IZPO8/Dq968KP4DjoK6eO4fcvBZmZcg/ETBFmsyE/hekU/QaHQCH0MMlCDUYJo11aOd+kRMjCA3q/dn7B9WdOMV6yKQXcO5AgQGCmYobdxZg/YZvHLk//s/lvegFwFUooFumAf7Ix0bEHT5q8eO0J9+p7IHk+kmx5/pLiKS1/KkWUVdHhow+K7FurfaL9IAYLALIMAKw6cgGAhFeu5uXdBJJfImViRi9x5CeANpeqOZyqHIwj+rhcRolyRWk0mwfyBuZHxPM8xIfoHFIK6YWkZ2kVWAVtaenb9iNPRwCgxmJmMErfYBcZ7i+6JnEojwPLG+WhWqSyILdZazNFVXHXJLBw/vVPFmVW3T6GM/VH0nM2bW1/ujBpVHUSPHk+l7aEAyfsT4++Yk/1M9mdqmV2ngEAIkayRPYtTYZoP4jB0o82K4BdR64GEQVki+UkcZg17oLKAqe7lIkZ7W5ATLWaaIeEpNvN86f9h0tr0XR8aIpm89DJairzI5aEiHjlIx4SWbO8+yeOFNwY19py+KR/yQcr6lKOnhQAyFjMOxjtYrxDhEuc+d/CAQiuX5t3pfs3vbbinWfBgaCSxKXvzE5tavzCF8DsuL4aQFfkum79PIOtk/FbRm99j7gzquzBkxoABgTWw75J8ZTsTtzV1PM3AEipr7wWpZsM7ftBNBkA2HXkMogoENpAErkF4C4IEyyPX4DREiUZFKOS+Cjf72IsjqaNR20wKuNMaeJDMY4ThRvYPD97du/W0cyx8/XDnL6QrFmeZZ7OGuRjFRTjF9sMDmW+AKD9waipLtvEmQUrnPpwPGUyZGWWquW0m5vDXAXHE0C5+rmltNVBmWZYosxwPImVg/ogGjj24Env87fc9qwpnhfrx28AUJvT8De57ctfHuMHYW4Bwgew68hlECE9e4c1H5uKs6d02S/AzHHYiwD/0np0HR9q2DwNxOZ54Nl3JgIAAzas8WUMHndNIYmGnmVTrosoWLyIUrOBBJWT1P5g1F6dG0VqwPap2FmfE5yZg9M8L6fdUJLETmJU3s9K4yjNbkqQf1+GJU6pZ4kNpHUxgi578GSX6wmT3enznRcFgHiQKq71NBna84OgPoBmBNl15DqeJB6jSWUXQIHk6eSobGYPGD2wCEkG37QyKEmhSlJZjtZeRHDQt11nym7qJ9FsngMDB1aCzcMdJQBgT2tgNZFOC7mjSLZ89N8eMmzs1vfXJ0tOEpbYGLlN1wEQxQr1+FpVVmLoBCdarFl95AIsDDuKrUymRIXAr/BZdv5Rfke6obTKYcjhlMrcIo+kr6vBk0l2WRaHbkrYxpo1FEcTAYB0yNSvp8VW8Wtj/CDot18d/usHihNo15HLIEIS+tguQALJ2YmUzgA8e3gdGhJq8OFOQiNk8Q3Al/F1/InBBH3VFhykfxJh85AssBE9RQWAIy00U6C4EQGApJiVFS9BOtLqP0tO0l7kJH3s6hbFCtUbFpBKU0eyYMFyqi7AkrgkwbWOb/X697aOHpZdcJxeJQ0AYT8dTgByPUtA14InO5ZlnSfJExVVresg52CKkgHA7pyd2Ox57ngtOQd5/SBQ4gdRyqxgfsx2HbmOJ/kBuvikJ4DjrVEGXYJiSQmMiT1zPHxd64myeNzNg2V7cJDJ0JBHQOxCBYC2xH11mComqLGy89WX76OUJHZFTXpZcpJwOT9LAMAS8GW1B7jPn96Vyvp6LJ1fZwLv77+BKwI7Z0l0Nfr3dDU6sXvIcSK3CAAk9zK/R0tWI65kEw2HqmvBkx3KsuTXVgmFzYDhA27aQCw1A4C0HMjUvVxNrx+EPoMHPLoAu468u0noE0WRgJDea+4DsKQkcd4kYiKqO4mjv7wwZ56yLabBsj04yA4A0GP2g1dQC2KJinPeDntxbi28cqXJSTo7APBKxFXH6Vqa1YB6hLMTzgcgHdLh92KH+90UXu+T9v2wk21bhhzn47QGgDCsMiv658o4jKuLwZMdyrLk1wZbovHl5YqnaADApjoZhqqn/SA+5fWD8CiD7DpyGURwfLhPb0N6MOa4/Q50wvBv6eloBpKQQXF7NmMcRibGarBsDw6yA+DQrn//G8wiTS1z4C6On4NTkkZdwTlJ+BizgLMEgAuMLlmIBzKr61NaegEIbf0HDmQXnss9AEhaTTfj7JNBAwDNfw31GNAK2lOh5xjYxeDJDmVZ8murOVpOukXYEAIBn4kFgJrStucH4c2PPkMd+cUotvaYchtqLssUmcmn5gP4Am4QJIzBV23BQae1AgRPCADchIQAks1NTtLZAYCO5JUIPFlAZe6YjKYdzqcg8LIU1wXAGp/0xoYczdlhACD2oIX5YODFVYMAKcdAAYClLAjoSJYlv7b4tjQx0ZWA3SgAYEsTAHj9IKii1MEZnUvHcQ716U+vUJYhNA0Urh+Cg/r3hjRN2Lzo7utoQxLGMLXEybAFB0UD4J8DGyZMmq4AUJMiZ4CjJwUAl3BGivIfS5KcJASmnC0AmFOgou+KRgk/KHX2sJqxC89QA4Bk7o7nH1laXygA0EsJHwFbws1hSCPMMdDpWnUoy5JfW3oae5jCTlk49jIYFwBgHXIB0GnJdc7rEPBzdfuQAz2ySJhjhPO9Ng0K6GzCQRWNlTjR4XT3a6Lzc3df5gM4A1Dm3/fnoLtvDQ4yAJCtMzdnnguAhp18C0BIoQDAUmcfADJ1lEsUFjTe1OblLIQLT+rtIwwAFvB8DKd9BQBROHATIPvI0oQ6YLe+BrYSWkpjLRG/cSyOqY5kWeKWnA/HlCwx0c1nabqXGtMeAJIirui/UFf0JFzc2MogwiFAbh/qJHoHi8XpKGoOps75yu68qWlnfX39zqYqxRhdTt19uTsI+4e6+9bgIAMAFocN9AfnZS4QAIAfV40+AGJKCwwAtAuM7FQ8RjwXAJAdgNoolyO7hbRfWdvvYxeeZA2APXE8IR9yNU77GgDSBkYT4ESwdv/Bvx9UB9iOAcCROKR+jZS/dijLkvy5vJwsKKY5fo5FFp0BgFv36m5Jf8oVvbtDdEykXkYYBMjtw5ED/T3KqZjP9+QJhk8d+j5WQzNZt4+rTnHGTXf/sVWr4nR33xocZAAANs/Kktzd8QnhTzgwKSYAXPrrwRk+ClDmNGOHi7jWfGL97POffVbGiOcGADKnw8MH1wO/oSq8ImQ9nmEA0IwNQELO3S1A5kBzQyDG4/xKB9g09hazAwCPP0wMIaaJe/3iO5Jlya9NvLPFSw17QOcAuKTdK/olzoVEJYt2CJDbh5zziWREVsX6U57N8fha0hRgBjD25olf68sCZtPdH2W6+7bgIJMgjZvRr1fO9e+e2YRDIFTGW0dzpzMDrcLxBZxnrvh75Euw931Mm54RFwUsymcdAJp5NGnMUBIMjEAT5qUrEYxArEANgNbwCtoAhuO2d405AzA/AokNu06dAgBOndqV53YD23/+ePxZHBkhiRGZbjCSTZZlACC5s+KgKMIv4w4Ates4fChUPV0XxlzRmYKPCx2JlCINAtTtQw702TiKMstIPuWDqZgB3OI1A/ganXYs3X1bcJA4v8OQHDzIlXPT0rfMpU7gj6AyXsKzDh/FopQVu3NVNAMoJ/Q9zJsXLX1PTAHOGQBSiCQmAEheRimRDnYcFwB1B7EBQOsSN8gDgG7E+tmyJZjI6qiD+xJxhcGbawNAMmVsQDSfpzJjEk0wkk2WZQDgNwBIEwAYdwAJ4ReqXkQ+onj7ea/olztKlWVqVyh/8b2LnoNLoVD+soeNprOooz7l99FiBnC+pbtvCQ7SmeS9wYOcXDKlrWZLJb5l4gNg6EAiZ9/LnJHOaw4XPg9u2kYVXztWxohnBQDGKk4DIDSFOht4QwgE08PUEXsel2MFgONZddgAsPWuKTUAoCZAVj27t9U1I2WsuY5itkdrfx9UbCQOHj8ZIMXHEwrSg24wkl2WZV8BjDuAeFYIVS/y5m6u6Lmw47yY7+h0RE9fMlbV/tradFB7l7617CE+iUIVcgKXGeBP5QnwjmwzA7B0923BQcprO0Q8SP/mnJpcXi/ufuxOHX5G7b8ZnJHuUImM0o8qxjYrC83Z7wRiuZrcW+yX+RCITRIn2nfffWzVMn0IPJxwkDYAxAEN/pQBAK8juBTtrI5bjVoP9sLxITgG0hLQ3vpPqWH85qegGApBHYxkl2UZABgbYz4DaHcAcNQk12czU/ViVoA0c0XnFeDCoTgDLPpg6y1U6NIltp3MzZsFHiB/ExWVW7a0neQfIolU/r1E7mEzA7C0dmzBQRICenUPTmY9jO8qh04Gox5x4w9fqsqaPQEty7eWmRUgr6ShJp36RJvSz9YKoI3CZBaQgU/+yb3ffhej8GuD4dO9f110Z2p4gQbAvv20AaAb4AHAN2QT/hcNupKoNlJOHI6BZPXtxFSAwg44ODKVKgurQZ4bjNSRLEv3ARLxXxUb4wKyL/a6A0zlc53x+TZnALmiY8in9F8XOizKwsEK0wC6drccOTmt923zJsWRfxM6IhiIBk/yOrbaAwCLGYAFANbgIB0DDgk2DLgS75W7wQ1xbgAq0gVBwKL2nz4DkO0wKMHUJxIq0dmfBnZTBkzjsEjhZkcLJ5rdm+g3qxpBR47WDsvnSMAMDwBk58WG9uLTqt+G/ZD4C8yO95ZJiyb3u6aKRtTOJogpkH8kbogdyrLk7Ez/1TiOHM7nxAyvOwDsKb4b7fPtofClpuJPUYBiUtedOKa4Wq1eHYhr3XMcW/I1E2aPGZGkFO1/25FzdAhtAutX9+yjAWAxA7AAwBocdJ5O+ob2urWKv/vM6V6Ro9uyTNK3gFQYj6fuO0V9ItwCMs/KLUAoQS4fgD+T2eAnvoEJIEk9oNDFggotPwPgZPBUtiQCZlxgAOCS5PXGxAPsfAs7nn1QKTq4ovFaHtM2NqUi/kKnx9plWTRFpy0AQbMJYqJbwNwurzsA2VSSjb/X51sofOHqpoqdqIqmKuhW8SVtZQCI+sC4kgysW+dM9wCgfumRfNoEVicbAFjMACwAsAUH6ZB+1Jq4ANK4iV3odFAUPXBXoJl0lJBRUh+g+8cHQFRypFEaEAJQbG8wrfAAzidqGNQWv6uAGvA+xwsAUcHyBZf17ZLumRfLjkdJHALJqCq+jaffq9c/e/c+cIzWhKAEyNtlWYpHsyv+ZHqQTXSV2YbXHYDeoWifb2LwaV6eTowWtg4DgJ8/7IqzKQXvrqn8zklT/G/1CDykTWB9wADAYgZg6e7bgoO8pr8+fBcmPtSiyKXYdNAwuE/UZ7DvLHUC5Yl/UbuECR5wVqGtima3+Az6t5UvvolxMPMBThySX7rjkGFjofABmFmhfKGUvkQSsukQa9jxJhONXneQS5HYsnLlsQNzc6fcNgE5adLf6UiWJdH7u2qP+hGZkeYv6yF2O2fKyxMA4PlLKDvLf753lRcAjVktV9MmsAJevgoANjMAS3e/66WRQcsD/vQAANBDp5gTOB3nrABALwDKK1ZO86I1wX4F9gZROQEPeJj/ThhB2dlMlfXJtg8AMCOIt+C9Ll3/ChSPrXlu3W4mGkRXFXgbj709/1bMm9KD85CRITFZHcqyJHo/PfFwOUdmDPjKRZ4EC5mT6V3TB5kr9lDI7Ky8PABAJfJKBN41hLQLDQCIQtp6vAdtAs1hDQCbGYClu4+yTkLNPNrLhzUWLUJ6+owGANFcFQA+yd/7xy6xsPknLNvQN0N5Tfi+EGnppzmB2drdQrb9/MNMrovjs5TYq6BGovgQ+yadYmPugFju8ax5AYAmCWLynIUPJ2QmECoEAHZZFi8sWFdaODLjJs0IkreZJ+WiVBhJpsC3q8G/lZeHMjk800T7EwmAb1dk0tkAzp/hCgUAmxmApbvvtcpGubuAw9Ycy1Y9L/19FAxqyFbF8Zg0wZ5HW3OxDu58BQCbBLDrg1cS+sBdDs0rKmPCZ0w95eLqsoKnpIMWTMlaohJbEmRyHYCMQRVtwa4pDCKyh17Vj97A9o4ASMBo+jZexNlzcG9Df/6On9C+QA2eDmVZEr2Py3FmqxgXyevhcI2CcIHIPsLjA40Pp2b8V1MfsfLyIMoTa0zOv9MwQyCCAQDHYmITQF9SAcBmBmDp7quVlvfTCJ/sEajpmW898+7edy7j4g5/5nQAQBI0eoD0hCBYbc5Iz98DgLOCALGwmcIWcVTGhO8Lhr+rnr/RBbDzrnuxZl1AF0oDIFUAMPXCobenPheOe8wLALssS6L38ZLH8flZs4K5cD8nttwsZvLCFBhNNZHo2Xh57LHOv205ALrMaIqs0gAoXbNnAG0CdfpVt5kBWLr7XEyJ/RKV8ckeioImiNr7UhPR4UcCEely6DsqC9GkAcecmxgBoqAwAEB9fAwQ3SpdHOK4jAmfyI2MESNKlEF4o54k721crGF/oXK2Os0C9HweuQLcehd0MXA8/sGdBgAdyLIkeh+XY59vo/prDQC+KcKFeF6h8Bna6tC2gD5r5eUJAMwBEM1wGXwxChUzIoALAjaB/Qmq5WczA7B094VpfQG9U1RfkAUVP4pQC+fFU3/f+CSjG0gigOFI0KBRQ0lhPh10zxUA4Ne26LWlKRS+wWXj73IJmw6peGy+b7Rx4FB2lgXoNRmLPAO8Pf9bd8HmeNO9KeYM0JEsq6NiG+DiMjf9810IAELkGWDj5TEAXoYzLmcgA+nUxJJQR7kQMwCSORy/eH9KvQDAZgZg6e4rbTefpqj+CSxDidnPHVD4TbGAmnso4xHGvJImDa6vpOQSabqAshT9uJXJzvepaItJGamJl7+rSvI3wKXjkY2YRN4vt1cLAHQWIJ1mzXKtbwGpFdfiPvbi029jeIMOgrkFnKYsy8UYAsk4v1MCfwvc/N/3SbkwFp4BVl4eAPD46+4BkDvOOtVT9XKIG7WR8zGHQSvLALCZAVi6+9rdAdpYFHEIJ7MYm0k0mBqW5J6IbyhBNcTn5ZZgfsg3nc0UIMcHlv65ivb2M5ShC8iZ7ePWI6+AFf2I1tqTP6KNwIvq6k3WmwU4QM7rVFF9gEvHrQS7suS2W00foANZVmzgoKFxOQ+4wgVJAIcp8H/+AzLZZ228PADgpR/fdxMfAJkFaWJdTZrO4J6+jRySXBuUC7/NDMDS3dfzYKxhx1Bzp4TYJPdySLMlNCyX3KovvXRnSuKuXKIx4KazPefeTcijy3yX1UH5EDICAD9CGbqAnNk+bl0nzved00ttMTxeZZopNwtSsgBRPa4e8BVax1DeTuC11Af+AqZPk5toW5BOYEeyrGgAfI5AtvaP992RGl6m9mb1vvBnt/znP//BLM/Ky8tY/uQdD+MAWEjXgwB5hHwkJiHdPXFKPZ2NvLTvihcA2MwALN1990KBo/b8+cSxpUEeJlVaSZF75HBWVXV1Vd2+U7m9qHmMMSBRy+al4HxYl5BYI5E8HHYgdIF0mnpSOeeghCbrkmNHymxC/TnS8dLqRzp6szA5UAYAn6Pl0M0CHKIPs+dFzwJQkbOADmVZpriBIy8c2YOtGhUFAMcAwMrLyyit2r6wR/4OTFcy1627iIpiXWnMIiZgGIvRQV5Ckg/tZj6AzQzA3t0Xi69rZ02YMHs2EQ1hRDX9EgMAWEgj+w5uiUUCgABsxHAhxKKF8yGxK2XgdTeVoQtQnY1WsNQ3xIA8Qzku/kWvqknaqEj+DCTxVUALaxx9XOQgKGDAAEDO1mUhygLsNRk7Xz5NELA0P+FOAwkBTTtjp4EdyrK8JW9mj4KyMjrq3x0NgCSxBzkIANh4eckYS28esqUmcWnLnpu4BsAojAetygRsMh09ebY5vkd2NjOCbGYA9u5+T2WUm5OTkoIIIDKiokmVBgBdeH1J8K8UALB5Jt4zSpKlOpEtABhFZegCVGcJAHiMvycD8ttLlyvHxbWKHOuMiKsSW9/vcsp53AhvDI8EQY3DpQcXn0vHqfuinnXT2Tq3N0xBcJkAbaYwu8dwOp39PJoP0NQUxQfoSJYVBQDcuwuycwv9m8g5t30A7N+XusrKy1tAS9Hu9LajR8a79YKQraTRKaofnMtZnZstnMAul/i8Qpy8Q4xyq+FDRcgZoQHwFbS80PNUACgNT+JNBQ5NOK8cjT8kALiBytAFqM4SAPAa//pFDoS7wtE0WSHHUioRG4XhT3kzuB2oInfo+ePR9i6kQj7uOLdjzxvA1QW5velrVKQwG1L+xh9gBO9hBKV5GEF5zAnris8xBQ5S67X/gdskflsAIOYf9H+Ckd2pf59CRKOVlzd90ryZudknTuZ7KiTYkJOozDdluIkZhDD0bHV++6UmEehEUt0o7hUZ/BMM1QD43MYkmi/oM0DCrBkzZi1FmPwbLQmJtbICRHsic8f145aW9OG6OXdm4h0/gfCRuFWby8uFHCvHZ7wT+FO9GSZyh1U7k+Hr5wev0x+it10hgG/ETI8jFwAUK8yy016gc32HnMDTV+48FJg+lZQT0/pXHJswL+G5V+42AKAO8caNC+JwrNpVm4hGkI2Xx05vRaMjakk6s8lUo1MsvHm4aRh6ljI7gyoFADT8Hw1XNbF/njJJHawA8L32APD4j7cHiQ2aiaU4Ez+DOgSe9TKk0HG9ehfmkjHRLxyhyaZtySV3ovvpAi3hHrB+4tsLjwTFYKPnYGLth/DsUPHpaaFC1Uztpnti/a+vHpyc9KP770Y0Ol6nTUG0ja9ohxWcbljBkWVX7oihHpinubAZz/xuJvQ7EgZC/io0Q7sIYWcJibsOpb+GRpCNl8cP+YOJkQYBGGpPvdCcRDPRJKHhJil0haFnK2N3xnXZZQIBB+bpaJkuSgAJPpFnkfDc6KkAMD8WAEIvp+YSZg3wudNr2rkoV9QfWrw4D9FfvxB+dagtp35mcOlzz7uxVPhTlkYTw5Mszz8Pzy4BBH+s6ELdkAhi7oo3NiGJgUMYSGH2GlELS5d3rgswZVfuwFAPjX+oJ/01KSqNHw8AHTpirA+46Su4ig1oOYr8Zfwen7Xy8sQf4L2+pt55T4hlnpPoApluBuKUJ1qHAODrISPpFspcIwTQPoqmQHDWbIjJJ1yvDfIQmorD3vxjsQD4OR0580Gn67t+xauI8KX//FwCgJMrx0r0Fyss+oeOLM3CsvrWKw7TpsFAxchAmOgmhYUoMvT8U6DrCeNh4h4P6oa8WTIXI474CoQw0GvE5OJnHlsVSI5SBqG0Mii27ModItAvip8bPLE7/qhO4z9fLQFDelw9HM2YHohpL2aVupWXx91srz/AZcogoDufRNHohM+vT0038cIK18BWsYohRgD/EiGZoZHb/PlvuwBA1ihMQdsBwBMffYTwzlDRWMAIHsqsgD7vXAFANL2h0Vv/ytFfrLMGAFpavzNpEnorQ2lasC/xnqX3JAoP1QuAS/tPY9Y2Jf7KuX6gLAEOHwF21yTy8OUD3kjfeu7Rp/7k9o2NNjDOaANjy67cUcn8qN1+lcbPAMD0GMY1Q9CNzQ8tPhV/ggFg5eX5fkp6ywdiTcrORHltVQxdTrFcuYUlx15EreylATBq1VsIYz7WP1csF7CyFkknkMM7hyO4rwhVPKQHeSCcSwBAWR8ae8tejv5SAOixZ12Ac8lGYFSbSc8gfVZqJvFQTQxPKYXfqN6NDrzP7k+nAAFAQTFkYkVUfJRe9ooy1bOrg2PLrtyRFQCJg4h9nOuuAGI7PXZ0EdU2sLVOMgCsvLyul/gE/JxOpSZzXmwDrIohdPxBmcYs4JpLLyVLXxFfO5w3Phdc6oIBAABNLopyJ2N+qBgqlNqGKkcPVVxQzkUlGQC8++gry27waQAMQB48rXbdoUgNKNFNgHioOoZnzzrwKgayRstnpvw492MPUAAI6SAGzgJdMJ36VsTP6kLZlTt8BngYLkr+oykPzlBnAEEAuvQwHcbSQ+okAYCl7JEzSfxPH20D7EudpL9kEuejzqWBG6yKIfixoquIYaBknSqHPDYF3eTPDbHIwsezS247OCa4D0MFYT2dMwB0v0QDoO+jTDPVAMC35AAAIE1m/PLFA2D8H4Be9ac36Bymwy2ZVQhCTJP5rWH6YQ9wAUBBDMevRhQDBi9zvhcGW+tbVw3tGgDsyh3cAkDOx6SEvhUO0fupPoWL53Dfvs1h3BINAPRD5IcdnS7U3TRYnO5uLSDVgBwDdUnivPdYetHatXIutSqG+KAtUadyBcECoOgL6ZsLCugV38iGZiJocicpSG3TcW3nEAAXWgAA3jcVvMw/VMLbDzM8OUwpdXUpNdlEi/Jpri8JtaZ5AACHTgxfvrKBDOcnrUIHeT4O0dNt8fb68Yg1iyyqHSl3HkKTGjyvQuxGtF0hqtvcw6VJvyBuzwADAM9jRWOZHnXyDW45ctsg3zd2ezN20HfKpcAth3wC9KnUZM7TubTD+FCh2OgrSE9NYKID7k1Y4n3UYVWCJsfDpLhIWE/nFAB3AQD8a4oEgO48eKX3JocpHi5Gtem78xI9AAgbAAg98tS+uvC6NRLC8OgPEmc8OGF2ani5pa+nynixQNjRoXJnJJo7UKdKLOR/mbsS8KiqK/yiuEw7kyGdJCbNBCeBFGgaRFRouiAGo5QCrbZqFNoAgkHAIlsJgkAtIlUERWggrpFqQwnVRpS1NEpFJIslIMZaAihWBAqkiArYr/3POfe++2YmLyNWEo5+SgYFMu+fu5zzL7ywODyHz/0q+AqrHAAwj5Wb3fKZtUtHznDw7EV24QQMHRlz3XWZxHnnudRP51JXxZBx9LWvIBaK//N7X2JmI/EZs7RjeHhoG35wpgHQN1tZeoUBAL+nKwC8R3DBOuLtHAmA9Al8DVBGLoUfUhLDv2iK9Id3n56VN3sybpqXtZRgaIwcRNrlrtyhEm1aH1pALQGAKdrXIdYlAIjDhsm7NvFCdlly28B1d+qV1pW6OOF00SJ2yNKlEuePJJs6In5Wd7kqhoyjr7mCECUcfph0nEDbEittii1oslqxUjB4mjqUPN1ekZ6FEwCCgEgfQdnnQieOHTuR574CoBPY5yr4A6xbmQRd8/eTnvuA7mzIgrn72y3FjhkjBxF3uit3UJhFEQBMMnD483+KHTaKmBGkU3IdiQZ8mdQVFj7fQRc/65CXX9XF/tJ79mAFtA+mfkjIiRPoqhgKp9iYCwg74nKbG18YQVP46RRlnbGSfuoDYwoW3kwAsKzYAKC9KrD7SCDx6NHEyj1RZ4BeGgBfwzBYdLUrMbQAVYc6WuLD7J5ibB7QVv7YuSt3RETMADB9Uufzh73ub6CnL2G6nrIIiEo0uEuX1d0+6XZnqpZ2giuv8+8u4JGwKvIJyKmrgz73sD6ZkpcbsYJdFUNftDzSKEGa4pnCAO5SWXMm3VrsLRx1CYf0RwMg3D8gjkIDEg7s/s+BhDSQq11vAefQHsCSKjTDUOjP0JQGAwSwNaPL+XycY9gWlTtxTgAwApzP//sywFOsYFT35hINdFnX2yfd623rexjB3QJ5cFVuj+Hnna9fRMaEEMyRc3oJH02R4iAP2k0x5MwDE6GS8cQ3LzZnohCPVikKfdIzBYHpCCiZPM772YFN9SstFwC0CweAT+UwBYNl5VF9gGTpAwg9koiUw34PCFzyg1dG3VxImmLICJ9ykajo0kQMsXhxV+7EhQMAZZnHr8KvHNE9bokGUs6DjgnAEn14VVFx3wsM16XdXKUr8a1cSWfT4F4YYfCDdlMMReWBAQDPvcYuX86QMCmnhj6YRuMjDMxlUHYGSgJK8kioH5/SLADCHURQVoqK4akngxjqBMarTiCdAUUXxYwgUlsAATehJY62DPmKi6nnn1xEarpYFKDzGN2VO+4A4DweFOZ35LAxkpRBKPdEA1RzAGAOyb7y1AMLC8YMP88AoJvJO0JtXrW3jwKAq2JIyuSBrfyq0gANdIaEXUbleP48MPeHUP4cGZWfgSKOYd6euprqbXO7uAGgXTgAsMxJDpNzFuCJmAXop9bxquQi6mgvLMKARnMC3dvS0a517sodQIXlyZL9QSUA4J/mWmq0gSiXRAM3ACgKyb7yhP2FydTg1gDoEgmA72oAuCqGuHQeWOrPf7XukldYA4TJCl6cIy9+myrcRAmiEy9ZInvz/GyfcwaqP6mnZtfsKi9DczLGCmAAALI1BPNqGghiH8Y5NA2kBaCvmgYqBPQkxh4KrGBqabp2tGSzjwJAS8odvZ1L9gcVA8DRtIfDhlEHuyQauACA75iiDs7aNKyogL4tFwB83QDATTEkJXlg/pm/iK9/ZcdOma2aF+/GoSXcRCcBRrjekFgiK7rcl19LHoHU8oHafTyeiAaA1dwKwGx72LgyH6AXE/vg9piQiOdfoPkARhdAsoA+pAtgHXdLALgu2rKmJeVOBxTLk0UIhLJaKvdEg2gAWIbIiYAZeKLljsExsHkAfMUAoOX4UJMHhudfuFBCFM2LzJUz5WHaLFx0yBI5EEpmwqz15dcAIjkMHUMBG92iAWBZ0SsAx/BcSxdfuOZcAKZfMoh9OWB1hDOCNEOahUEbv6vCPVoGQH9+q8IB4K7cASue/cAk4oXKaqncEg3cVgAjDq4fdVMyH22aA8A5DgDEiA/VeWBN9aN2ektBsKN7rgkJeyrSQyMnnU5YmWKJrLxRv/TyUCdw6DL5hrBWRraCo1cA4QSyf2UGjLPA9gUlMJoTiIpoaOPxxwTAffzRMwBoSblzUZg8mcpqqVwSDVwAoF2zwSKOr8e+TktbTADEiA9VeWB7MzftWFgKKUMqOl3qRR6+ZmREemjwxz6FOfTJopqT+rJbwe8s+wjf0PzbIgBAA5foFUCmVuNC1EcjVnCnrj2Q9wzxR3YPJysYFd3Qjg2A6cLfNQBwV+5cHCZPprJaKtdEA5dDoP2cfet+cHNhrn0MRB/ADQAx4kNVHlhD2uGd3hFvSK/bzohqitd5FlI+89DFDhFayjMKgI+WDdUAMONgdCqiVgAxCWB27HTRBYBmPYaEAWG6AJeKCYDrGABX/0gDwF250z5MnkxltVRuiQYuAMDXShyeIq48uhVg0Q7FXtRRAIgRH6qfNRaAkhEbqesPGMuLYOBRpo2JvPX4iFyRx8u+DFmUO651ZgBw+S8NAAwhhHQZ0SuAjtyhAbilh1zDtY78izNtAACW0ggAJPSpJeVOkpYnS8RLzHJPNIgGgKQp8ue8N9JR0MWk+20EANpFAcA9PtQA4Pji/TgB9Fz9OuuZ5cWTJxKraxFoBtUKIGDYNaHWAsAVNgBsRhDWJCJC8NtmjLhRKkCY42u4T9guUkeOslztIcLJYM45xwClpVIqLsj4AIAWlDunWW6JBi4AYLtECTddyf1d5rrFAECLpQPhqrakHzvahAm2AQDyDnftk1Q7ibwFAFpzBbhAADAVrArmBDIrOI0Z8fy2rbCNuFGWJ0od3C5aHexqD2HooJoNql8ZgDB1VlNCx1mDZjuyFuJaUu5El/gU3d//ngEKV8zpuo7SNab3d080iAKA2fZYwJHE7Z0C3EIiABAXAwAeVETXNZRPIogcvtSbF3PT6wgAEAyIaEh8tELJmLUKAM7sGQChYQwA6kdeZlGceI9kBBeKfFaPz2xJupGHm/aKKQMALZUWfwjb68xoAtIkKULTwdvHw6uC9dQTR6di3Ab5Pm5JLSh3ooqdysDxfhwg0k5lPpwSoEsArmIkGkQCQOwyL+Snwe0d7nHGBoD7IA8cUPR8joDELqOXJPXieHoxh7YAaEaUaMjcAtAB9siPzxQAVGjYR2Nu5X6k1YFsw5Lzqj5jHgTbbE8lg21ysP/8inR5/rY/BLwBVBtAP/8sUYTYeiBwskgTPwugu3PwSP+e9MmT0CdpSbkTVZDU2WaFEPOImgevfMCkrhiJBuEAwFfkoK9OeiI2kFaAEwAE9EgAuA/ywALP2l8FmlxDqbcQ0/eVSfh99Yv7+RD4Q52pb5b9NKySOAflGerNlwwAjfZPsseFqB8pZioL03dfK/ppIUY5E/sjy6OY3VEAQAf/hn7GHsJQWwHpLNYFakUgE0JYgeKH88FtMg4m57qWlDvRRfK9nFmkQiAOl0XjwJ+nolEwi/JBYiQahAPAXHyw0asWvzoGWmwbILOq6y0O9QYAmA8QY5B3bnwmaVX3Z31amqybkPrFw5lze/d2Nhg88VmJ6P/h7RFLZMLCmRgHabt4+NqiHwntLj+IWVt2BHZuoag4um2zEbdtAhod/BMfnfsk/gDfIH+IooXXXluUz8xXBQA+2vvTyUopN9lucmOdYfXZO9thT92DxsEwBWtJuRNdIAD84kF/aFFIkUm+jy9nypdTr4yRaGBOusQHcDxkyyLnGewB6EXzM+dptQSSdAfriFRcVwkjKMYgj3D0IewK0vaOKFmoLqD0YjQAbJlFcp4/hy2RvaEz0gcCAPSVp2uP2bwCQAqURsE00HMtJg+V9ihjxI2KePzxztwnA4E/KcOsosJhN9988zDIW9QsULe503OL2UwNIGdGgWw9dNRcwdQM7gOcpnIHEdvgAK3JzwUvm9y5IOnnr+Bgjt2kxUQDZ+SMxcfeHmR9zw/51+I21Vm+thx8lQ4q1Ttf6EUxBnnAERmWHM5swmircBStGffzi7wFlGEHMFuAeGgE8vD/Qz7rxfNn74wvv+K4SOa/TGaScIQg47D333/33effCi7Qt20YcU8XF9CI3J80kXeKvjNon+mfYnnbIMr7AkX/ZzD6GyRmd7IA5OQlk3MAVOnZilHAT6ArxDOdQJzFHquSbE+rnpLPIwaHMLfunbEZ7m5stsbPMUaiQRgnUHif6thriTPTliJ56JI4v4gDScg3gKO8xzErOMYgjwy+hsG0rD7IwGNCEr+oD4FXm0OgvE2pOX4RTyvCxhkoO9T5mRXz5RaQlILr2B+ee+4P97FtrVsJSDEDJl04FS92UPjqDyPe3T752BuJEUY503C6IoGTPuAWdMV8Db4EY3LleIs1GAs0+RKj+PwVwwyVTESsDEOkbG9hQ6YtGbhjXwLfqtUYIgBoYoMcI9HAcdLFjzleSlvf/0R8ytimDFmwDtsA+AYgyvtt3RiNMcgTgy8Sff/5Icr/50VDXpRr4I/MNRDl4U+XfLjknT0DZUgY6+ERxH2AmBW+02GlU/4QtNghxsMj2zEFHJV2psQtoOmbl5BqXySuhjrWG8MkMHpUh0OOIuKlSF7lGCvEBMBdJPGQOFc0MRUJQciDnb43Fyt8x2QATRqUMRINHCddi3njJlpuOnzKxJqJnrqcS/m+ihMRe6LrxmiMQR4bfBFF0ae5ivh91YuVNeWmEeTYX9MwZ0/A9kpr6xkpYxLVnZkT0dsMBnI6cfU3j2IMl+HMfcJKl4zPvvKHcOxU334C32Q6PCY++MMLdwEAP3MCADsAGmvY6sC50InPIp+CclL7E8ulu5nKkEohGyHP2DQV5zoxJQMAUGdP2gTKljft7ZhfMEbPcWMkGjhOuiL+MkZM2pqJBGC4TtoDiAXca9CN0XjfgBiDPDL4msLjQVxO+PfFoFBePIhW8A+ppBWsy0PBqig+YLdJJaFSwm3CUug1fZannS5ASx1OAgF8YWuFL9tA3+NsbI2P//bd9y955eZC3gJs/UhuDyZV+jCTS84jajlBkR2KjT+xCwB+LOUj+4YFOs6VTOsYAMJFHITxYUIDPKpM0ECMRAPHSdeCQgN6DZYmUWmbsjdZOohzaX81gKA3QvpiYhsQY5AHFN0uFEX4AOJHPCiUF9c+k1aBOQAPgyKJ4agzqAzAsdr0hAZebL4Lfi/F0DzIQh1lFhaklzLMTocPvfhDpGE5SMZyLrSFH8/NxHv7wJTFsIWAGTY0AeL9rfUjvcqJVg1O9bbyCfJeGYdip4FDdGnG5+/IiPG9TRLnmnU7rA0UABSDuCbxOB0A7KiRGIkGjpOuRQeL3zwlPkwoLR5ml7KYe6T7IG8A+5yT1/JSyjWQ31defGz9WDMObtU6l2oelw8EZTgCZHDJe4nlnw3NySYsIZX/OQSO0tgGZKdDfwqLvvhDxNN2h69lCchYMHHIjPnzp91OnRm6Bp462tC0ymMDoC4HAzkUBKZ1cgrkp2TUU+5TRc35/jlcV3YchvrCG6iekkimdfxH1seAXYET5gCAipVocPo2AaLqiSz3QZ7HSAA8A3lQeNE16sXu18e197T6wzdSintQS4KZo6fhHsDcinOkaP+HQH+On2KQp9A/p8FWHucAvdN55YpjkuD4e9UiCAzDX793Zjo6Qcknji/W/ZAUcgXfg4nchygayWkACARiGzjIIRPXL8j2FuWRwVheaOa9f3nU0o1mXPDR4wt562rKKvSRKu60dz/RbYXJyJeqgxBdOsJtAky0j+sg7+ysc6UQrgDO8pRJcxKInmzQTDD3kaE5LB6gp0qHTZhH3hE5y/OzM4dffeKVIZNlid1Vbu6EPZWV1Y0VON9oAHhpIicjuS825vD85RcPwrZvXE1lOnR6oZlwLTQ/hyHy8ZNFdAEH2V0XhoKYNi+JX2C6mWLUhQ/gi3FxpEsPUyuLctOWkRP/hD0EED0PB1WRsL6kbQJQSsbtOsgTxoPE/s+ziQxixfuUPl1n4EvmvFmtVOfqgt9KYDLoyVBvOpYzgjkDABxWsQmbS+/IgAF8lk/XOEdJ9zpPDAPke8X7/fLdv8iZPHuMv7Ju165aJvXpFcAfuQI4yjnVTQob6+I9s4Sz3WUunTIPNlYn7vbmpM5i31JdGb7lOJAUnTyxuCl+s/lW8f+/8PhbSMVW8wyTMrT90PnxPtqDzSasn7AtI2fZMu4c0LqnPbKEXQQd5lU33KDHXe6DvCQfOiwS+5+CH74m+UBsxfvmExvmpsybhwihuRueYM6b1Up1vxSoiX9/dVFdyLvmob/Cal3KsuRClAnP4i2BkfgnokXS4KEASz79eTcTCkG+rAl8S38Bd6Xnf5c1Z+QDy1Kry/dJk9OcAVIjzgCOsqe6Psdx7REa68KtQ8YXvbtVbCMAbMuCw3bNNvG3MgFxZY01ySEvzh2rV202WP/1H969Y/HtM/Qo2aQMvfMM3Lq7cQEEFheeMLk3gLvJMnKLhmL0CuvK4Z4WYRMwok9P0T24D/IGjkWPVWL/NwTlhyBcTAwu5zvnclic4MSNN5zsFDKtVitJIUCze2dRZc7uElJZKJkFSmCeSrVY/ql09QoAjs1NkJ+slruUR57FdB9vNwmfVjyzrQwkLxpzuN8CHBU+1eVDvx7rZmVatrVpcXFBcXk1AFBbNpdogUb7Q9qPU4FKFiMyuVl0Y199/wOY9Q3WbCKTMnSwb2pj2Q9RhpPFGSP+rR1LSVsKGbml3AK2ygu6r7gnWVW+Vj65DvIwZUEyjsT+IwWYfgheML3Kx+vxz77c/xr9BWzxW7FgbfQu3IqwzKdu8W6FzOL1v2mRgsD8mKP4+8f7IZtbFAD0fjeRpvvousAX/zZcctScC21u3QfoGtkHcBRNdV9lb7kh3LLhfmsizXlBBrTU888mh1pvbk0AIQtYWmg8pMV/YCr3yof6r1d+R55BcpFq470dW/Km4Fe1uEzKULG/pvxqrltUoqROLbmqs5KRW0q13Lkz9XDvUl7iR/yV5T1Q2dkFvUT7eI7rIE9cd1kQ5KEc8C2SDyRevGvE7Bjvd2ANU96s1qwX6AAQwu+bMMs/OxTAMcBSpWFuiiJ4XsP7IQBwXQEA5Sl+9F0pcRaXHHFLZwDI6SG6E+goTHVn+hctCk1hZw7u2ZoXLOF2Z4tDbcjrBwBA3HEw/yH9gDP50YTGHhNkBqkB8I/3tqSvmfl2WjAyZahoT92+fT+iQoKJ/Cklt2hX3Qk2mMDUhlXLxV4/t7d/LblWvXZvwdLRiQoKmc4MN9dBnjFdvdFDjfJ01gYR0PCyOB16yE8QfhT0emsWhnpvP2gP9SbNMY1nhvlJgbnUuDy1ApgtIPoMIAvobG9u8UFM4jroFUBOgc5ZQG89CzAAUFOah7aqqW4HNbUpwRGUp3FK3pfuh0MtrbBHyF3TAOB8RscgaH+2gQCMaGkgQANgx6I1i8en/cqcsCRl6MgRvQJIqizBiZ8w0uP9pwrB3SCuB0uRd+NrqOLut0Ri9J+dm3B4uIAKQlnWKbsP8rrzwLv44DvbPexdIvlA3fnl5ELAKikDP8zm/6K71RoVe6jHMD91nGAuhaGxPgPQLcB8eNWD5VtAigVvzPn0vWSDU3He+SueAcdenQHMNPBCiiY200BTimWBmR55BAAyb76EuS3a+kxLtVjeVyDDlswEYImpOhbKHADwyYf0A0+oc0c6BhgABGTco4tThqp2765SZwCw8mSnUqlxu+oCp9g8hQBAf9iqE6eYRigAgP7/yXpfly5gRNNX+bTeuA/yYBbYF5yTvs8csv5Es3JxBZXYoF7EKVrZBT/6iHkoL1qtUbGHeqKkO9rAMD/vAqQKvDP49jScV+VxS8fb9AEMJLrLeB+eiNTYHX4FFgBDdQgmRPMBnEVT3Y000wMNTwf2oK2vggMlY0GGLdqURCaH5gCAxXiVj7WrgIKIknnyvihPBr666GAgdhdyCxBWHk4BBACxhxCnyST2Iyr2Vh0PBwBU8mSswb9vNs+73Ad5hnWWAf8yAICBy39mcela2bubJqLFWa1W7kM9DQC4ggYBc67Hbpx651j0AWJ1AoFrzPY4d5jqch3XbOblihGUqxhBznLM9JCSncKRXQCMomWzumcCrzT6QKl+RplLZPPpf7OnC20GE3A02/ivr+BSS5P3QqF8OAFQf/jD//z78JPx9B2yIFzrZLsIAI7n0x4gAChYWIUvIwBAzfN29BAFAG6DPAMA7H0pCDpQANBypcJRP0A++S34D4QJ0SoVc6intbSrUzy6pl93cfukyFkAMQOBI+oDyXoumzEjgAf8eP5yvDacwNwCFDiB8ntFM0rFE4SIHYQF3jIEAHQEkLu1HCih3RYAdFekHz6Ob7YysAgBDTpGEAz8WXklkStASj35nchzTEnBWSUCANXHS2gPWGl1YU/1xAgADNsURAcJO4C8UUh3cx/kCQC+cwVumnODWUdPCQC0Z8XCYa/UV8BKnrlwrQWAWEM9vQI0wPWf6pvoxcg4Lex/BM5BfaB1RP+ParbHCcRij4rDtVBddF6MnJGAu0jzkwhih2Q354owRwMgW3qQ0n3UAJADNQwDSh+CYwB+HeeXv2EGPkgduJmGdQIzleMRSJnBYEWZ2gK0PHxf9eKOvDp7etMOcCD1WBgA/rMlYXnF9y5A0WLDrDfLpYzuHc2G721LzTmpASB7AIjCAAD0yNgBWg0AMYZ6AgAcAmlydwkVqKLjs6g9Y5YO8YdA8kPY0hGRQHwFwR7P37AmoQuQM1L0848gdqQ1YQMQ55EYALiNqFzpi/JmsmGABf+AwUQCWhRCEsZfiIHP6UdZhlIuju10CEzYhqeSkNCIlmU5HwINAI7SHrAObhgw0zuQejQMALv9qY21fam6Zve6ihNe3ZODmPECq/CrIQEpxwxDAQDFh+FCSqfmuxJTYVqnYmzlAoCTAbb9/z3+GvXPWTlzZoBR4zw8+PEgcXowhwdzJWflqGTK6edv0kKy1BnJE60qcWwCIHaoDSDOAIC6R9FbwBDm/JBfAAVOSvNWXgHd1eK8LUqeQ/KZXdPJ9fDIkUB1be0t+DYqK6FDLqvoYtkAqE04Ogh7APxw6BntT/g0DADpocrybFRBQa/kqyTj2T05SASHP6Vmw759dXsMAAgZ5FawaVu5rD+tBoBYQz0BgDdvd6EuitubCk6d8/pA9Gf+pz/H5q5GJRC3y4jgk7uRnQQAZhOoST1aojYALn7re+TKsCX8EJiZJS1kSTcXAwHdQl4OTgfGLr/BnGWpx6nXg2G3N30PkTLxXewJVdrfQxdlEdRAe0B9fDfsADs3NWgAqNTnk/mqrhrUpx+3HNyTg3itp5smqhwdTAMAwfRN+6vLdbOk9QDgPtQzABDbfymaCN8IAJgGAjZzqjw/9gK7gRCZQKwwHU12ctGVmU2gLnDCbAAoS85MMmwJpplrYJxjiMRuAWw8bQ+RTAaq8RHQlv1eBkCv3FzvyRPHaYLkMQDY1jACe8CTwe9hB9ixqaGPAICHQX44xirZch/Y+kvLyT05iIdYuGkit6i2MUHHxMbZqT0Lq6p37eO7cusBIMZQTwBAtv8w/ee/mBOC/qyLLkA/fwOALxI9bYgdTUdPYKpXWV3GB0gNAPq8yLCFncmwBQjxO0IcnISixAcZI7sYZb7w/GI/bQHltbd0pbD+XKT174V22wCgqR/2gCczy8bk7hyVZgMARCmSsE5OFd8CJYAFbF2SgwQAKrboe8gJPlDoBAA1GYqqKneVsyygFbcA96GeAQCOSA17v8v1hmaFOTSQabSZkzSIc5++zPKsalocwOKS08jEHineSiWtCtq7QF7lEY5ZgXD9i1nlvpUqh0AoczjlA10kmh8AZ2ISta2pJ/aAw2ll2AEOZ+7VAMDglsKIZ2/TxiVaAu+eHBSnY4tQkhMM4LIBAx8De+QSAH7YDVhGWa1TsYZ6ctk9sClz9Sr+LsX6f+LAgeGb+eelLhMFD0w4Z/DWuVaSqpSlTzxBVAgH7XIzXTSoVSjEHilp941BC4GGLeMCu5VMq8PnjYQxfwC27NfXwG7dcFiB7Znc5minYQCUZe7FHnA4qxY7wJMGAO3FxqJrGTkXOU0wXJODnLx2j8kHchgYH6ncVattqa3WqVhDPbvhnbKZ6itvamZ41GYem7pMvFP2xRXqqWZpWANVxQf5kB5cEHZEhY/LicVhulg5NQ+n5To3t7h6Vp4t4WmhBrT3qUgY3wAnAObpRlB9Spcu6OdJPwcAkFs7AYCEXAsPJJRjB4Coq4+5BZCRzaWyZTtJoa7JQY5y5AM5LMyTpU/JZbVOxRrqaQCg4a1LrCG+SN1j++IGcUrXhDTrGlVjcU3HBjN2ojNzuYIAQHziqKxLMEJQjQkqZqXlKHWQvseq1O1HwlaAc1euU53AJG7VRACA8r2Cq7EHHEit8e58pX61AYB0da5Wk2gHAFyTg+yC1MzkA31LCtNTrTjkslqnYg31dMMbIy+u89eT7dVEsG++SPUn4ukDYJ7imm4TEi0TExFYo/t0BgCN6LDLsdwAQAew4PNVkflzCRdpOUqdGGUqJsQHPv5YxNJz0SyAAHDYMdSb4AAARhmQmN0wIv8zuIvvAABu0ABQCvKrWUGOMgBwTQ7SBamZyQcy3z6kabNYcchltU7FGOqZM0AFNkiqZ94ZCu74hstcL29SHnDqrtRrhdn7OOtzcuDBu1OS7H6J/ghwFw+fANOp58x3nrFFAMAEsPSO92HfUBoey72IUpYGPldoVlrFO4OnpcFYkMsxDeTvkDq6neUMIKblH106fO6q7/Yr2R2o2znqkngCgPABlKl9uX3+NABwSw5SdR3KkQ90sRRL0xzxVFaMaqVOoNBeqpgPIPXxA1OYgRtdTl+oVb4U2e19GfbDxOl3buari7zpD/01uA5W+xoAHai6sz0AbEHmbwflQ5cZsjo+YM4OA04eSh3ccpQ6qQBnJVZ2rkpsXHZwUuLbWIK4DB/AEHuERSSMoF4kJl8FNsJuv3fne+/7ONKXGUEq1qKGzp8o8wZYrslBUgNQznyg9lKUVPw4uxtJWa1SMYd6hvimq3i2/0Hi4EeV8YUiY6hgkHZ7s1Zk8AW4bFtqVfIpEgXZ/TGkKnI9dmht3+zsvmsPvfiiiQ5AjIcAAERlXdbpF3uFzAxVhdDog5QgbyaF2HMZRpB8h9kFE/Klo6s4gXRQW0AqcqYCptCPhBP4LbEJyOHzJ8rI6VyTg0w584GSVHnApGcLBimrdSrWUE94kGGcQK9b7o/2B9/YE9WAJBrHWpEhyd21NZX+I3mQBNw8Cr4BggCnR7zKJepuF013xUnZrpZvGtY88YjH7sMiNxsA987MqwzlhqpITGQAoDiBXkPuHdRRdXT5WMZq8hQ7ecYHMwgtJ3fYBEipt8ByTQ46S6vFoR7DPMylrVDMuZsFACc79ERod2npiKM5frNWZMD8k5rg+3bV7Un2HkGExE3SHzMAwPHrcj0K72AX8SU7lz6Eaa5dMexGB0BtKT6W1A9WV03eAiYlVnVGmvX+/Twtok0AT0vCOzuiBgm9v19P6ejyE54lT5hU5GwB8QSJUSaxLgAqkfHGJoBLNTFjJAdFBQixPCnu+hfJVNRq7Yo11GOY74gwaXM9A0hKTAnRtb3HcqqwVtwra0UXOG8T4XJfTWXoSF5lDcyhFg6T/pgAQGy5NADkVKgN6nia+327LJcySg/kxMCwgc55WvyEQyBE2Ps/61zTmJWwGJWQtZz7tjwNdKbTG4GPPGGefv8OKnJoyN9aAjm52D8vsWjP/q2yCdDF74IVIzkoKkCIZbnrH9t+420z7rRau2IN9cSl7R8OkzYarS13uQV8hVOChK6dfmJyPlNxdPYGkcJqGxNx4kqsbgQVrEgbtIXvAAQAkyCobDsgWLTLilEvP744By7tsJC3zFVzKUTY9Ydv6ozR4gisTx376M858CLhnVJoduqOrjxh5r+QihxLSrzoyOgWOcBKmsc2AdPFJsC5ccdIDooKEGJZ7op35g/G9cpq7Yo11OM3wenSJiZtzfUBJCkOz1/RtdND+SN6vvSvP1kqfIf41mVp+w+QUd62sr6IayCb1q+GAUCG/s6Q1yxMc1n3ZVcM0XYXH3VhxmGf8q1Msq+anvaelfVwKanMOeZFh15m9wSAASIBjRb58hP+CZ7wdfd4WMKN5pEHSlJpZbfU9YyRHBQVIPTs8+NT53yM9giRFtqm3Id6DPNf3+80aXM158YJAAwOr5/p2tTDZ4rcOZZELzApcG794QNgYG4KdiMGVaEjVtPsAACASRHWth3SuInhCS9XzYrlWft35x9PSIPyzOZioNj0vfLEuGLqz0+4Su6WLcj8P1clSfGggZMsMGuIkRwUGSDk+yPLcidDjwPaUmvXlznUE9NUJmqksDhK8tzoBKCFYT7VeOe8qV4S2GGZI4DsAHHqbTUGdRzg/zlKrpqN1TlHvERieoXumjYAxJV7XDE16IW/R2f9z1PGxEEXDmzS5BKcim78zb8x3WhBjOSgyAChIAgJ6d6tD/31XijyrNau0xvqxZmKdgi3cATEDiBs3RTimeTzCiA7gMhCdOMdDDvq8PCUzIq4BH7xUbhcNa8mup0XXsfD5K5pAIB12Vu87JnzhMEr6HTShJTfT/cXI32zBvjExuV8XYc4B4LkqGqnYlcpdPZIzhojOSgiQCizHv9lfkelybVau05vqGeevlC9zkcZMw8+AkgPmTvMefkjFAA0294AwEOiDfj0CgDMJdABgCRVZn3F8roUp2xTSbjyG38mPH88fqHbefd4k4uuhUulIIDOggSAztlEH2QGngLAQJsoCKmDRCHALEBqPUQQeMxL2chpMIycLtCFhjhfM+jPLn18dPa1r1yM5KDwAKGGrMPDFqL3tPElVuVbZ3fFSYmX0wXC9QRZ3wCgZwsAuMUVAM5LoAFAnH0QmMvr692yvtL2bBqqY5VDm7pq3IKrJtHtjlDzsiC3qFAhwDqXASCO35I3KssT3OGEKpz2CLn8iVnAWv2Y1w4dzOZT/dnKbVmnK3T1PXirNLniqLhltHVrHnpG5KceIzlIyo6K2T9sYQmev/ZSb90yi55e7MzJD/68+tjHd52IOVwnqHqg7Ok0nAy9Pt8K8MMIAGQbAOAzqS+BKBttekriXF/PQZmRStq0ofxZtK8a4FxjQszN/doeBZ0L2QraHQCwxlZDwsenSzD6lEkH+3ZStQyfXNxAlZlj9keX6/qoeJw0uV7kOkSz/HFsQYqKkRwUDoDEA+b5twkAUmTRe+xGiYAxDny4+0lJ3AJP2+T58yg+u4BLksLOjzwDiBmkOQNobbDzDNAXANCHQHMEcAKg2fXVPqPDtYOGqnLl56uGwKwMdLvPeLzXqWuBNBvcASAOsSVo875GTr9kFpBXnK1LHPSpX/z0PxclT/jkl7o+mZDMaZUWz7Hgbj67oKCYLYlRMZKDIvJjPks/3tBEPiZtBAD0zWjRW4vPEVZBlbm8XLo/pvUj/U69W3fqmp2LRGBUkSMrMPwWEDS3AHo2ShuqbwHxvbsx0UQDwOwADgBIKd/e0CTF+jlHytAq+LMIlNm/Ceh2KtsaEkLpwbgDgIaQ4zqrU7pEInY+kmzXVupCqxWgRzMrAFM5KGABg+yhzEzt8PmoHDoraLc3ZKS4rQ4As+hhsSPVN8w4xI6DUjp+xoWzjJ54KDPPTlhaKRMcNQyZ4JwWuh4zPABA9QGgMKMgaQMAtQd8ryLzMIbv6ANU0Nxd4los+whwQRgAXtRTQnbxZtofyozdlbnDwhL6LDr2Gd+6yKtmzBUgb9EOuafTaPBa8q8aJrVIVgCcAVInyRngQv67kz4D4F0hG73ArFlT5kybsf6x5vr59h2yGQDsPnLSW7V/0zr0rNqo+ENUXFw8jp1fLPTa2UPZv2jnTbp2LuL8BVDBVfBmr6KbcMN6BTbwr4y6uRAIIFIEJuIeOgXmpwdUJ9C+BprtuWzb/irpBHbNnsCdQOzPzh3AAMDQBD4u7lUw215fHaQTD1MrOTvacdJMibpqfjXGGWBWYNEO6dTdj1jka+sqU/cfZuzv+OfD7KB/j30LOE/+4lsARt1EZxsyGhO01GpEg6xdsf3Gb115kRXV9GeXnHYLumgTMgOAPPgN4H0A5U4NLVq97sOHyFtyMp2cX7AK/gYlfhzaFwb/1qxbIWTzxvoziB1QlxD7mRwtbsTKlwGDfp4F+GUWUGkDwBzQq3OqjuyGNz7yZvF9YwGwFVMUwuMEAK2ukg4s6yusAaictJNVC+Kf/H3hVX02fv1fmsV/2gDYgGbz4q0EgHPVGO/aCTXkX4XNDxn/3IXmPsBtzj7AetUHAKEVEWeNteVUXQ8+gOC1ayK4PECP+GRlkgEBOdE5AeBPXHws/1p1V2kTAEAXEVhzNBASJxx4c6jQhZPKF6YcA/xemncvCwBauDTJRT0n5mLjJKHlx0uXxpNDe4lXpoF1GgD2Ff1H+3ZVQodVuSs3GUkio3RelzkCOAFwEUrW1y2BKdOmzZjBPxtGO1kd3HS4kDcalxUA+wxvAaDqg/rDAKCN+tBwAQAGFcG0t2euSd/ynhMA5exfRd8fdaF9S6UTaHeIMLnFPEA6gcg4rChD7wH1SS+8D9OGTBxoNdf0XzZnWxl5kLFG1gCgsjrhU6SHMALaBgAvv5Xw9oPI0MReSavgn1TmwvFT4gtT1gjZRK+uorxRpNkiHuIYi6WtWylc6BoLh8e05zMbGoQPsLh6V746A5gmneIDIAdumPmemQz00UdEBpKyuK5BTVTrazWsC9LGEgIiaScHBACyzbifAdgJD503ioQRDr6MKklPGsjbsuO9bzoA0BUXVjGWlC40mg7qsqQbRJpXat9wru7aozgXY1Q1Rotu+k9GIIBtQmYAgERckM6T+bb61TYBwBKyKVzeWC5vlBZmw73g1FHyTiQJk52aatFarQ7WlkU6C/IXg+YefRRk+SKj6+3Ff394fEJDz354NNW62WYQ8MPaamTkwSb48Kif/cBe9brzNs/OSFIW10Asr/HLZX1FNV4oCRKiGlW0k6OL938mADC3gIrmbgGS+rKIefdCM8nnexxM2gZPCbz6wfv4sxgAXBgGAOKzo+PAHSI5A6wlXilR27G5yc4zfNnHt06e9eodzz+7ZIDVXNOfxIdhJmRqRUKqAazNi26SBKH7rVavFPTCfRW12WEACO799L///XQvXFN89Zs+dAJAt2+SlMPp5sfHvw1nS8gtUqxH2fwOzObMpqamTPAgrlJyaUMKrCBOYF11wqb6dUIIQ0lOnZf5wFK6FeyBi2At1lcumA3hsnF9OO2k5HhgNwPAXDVuQR9gP/cByrgPwAsNrox8ldsawu9C54rJeUJsAvFr9O2L73j3D/c7AKBNxzQA0HKQy9KyK7g62bxS7j5gAShbO3/oyCn4dX47vf91VjNN/yMhWQGMU5JekSriyf+CEoTYjK7VC+bEzL12AmDzKgEAuhPo3JjcZBil6WNV0sCx5Gn60tdX41/icypmbunE7K5AwQByUD+RSxsIzM38+yI6UwYXrFxp+ybcSTl1swJkO+CkxMuHGs+UFs6ucNfiy0YE7cR7QgFAFmNGQGNqdCcQVHwJfYFHGNFMcmYpYtNF14zNfOvxF6ApDQNAOycApOMQyCvucblUj2JFK5T2E4LosCaMvn384y/cRxm10U1/xIIlsg2ZaojhZXtF8q1Ctg5ix/75AUUItXYBAPgmLggDgBUGgB84AYApivyXyuD0jRtuaEigNO/xz/YXc7dStERvHT4c9OpcNk0L6214oAsIbeVUP2NUjXhg2KY+vDgLmlMpGwDEI8IT/eHaZcvGFOCygeVbaCcj8o1LoACAlwAgwGUWoEJfJAZmIk7+TwuxCdyTBfFLXv4JqYqdABCXLg2Au6TjgFagbgSWPPTX15mfCFtiSERrloHP8fNfLen/EyAguuOzn+Ii03ALgAWMtss0K9LmexFuOC7P/zBFCLVFZZwfBgBIMlcrAHgQnO0EADl08rFqpTI41Wne3EM4B95uSIqEJpIqN1+TbpzGvONTdRiToWstCLJvcjB+oCqjCrmFY9TemU9eP15JMqUTAI5NxiVQZBwaATIN9PI0sNA+aTJXVGkD49vboT90j2sP5g9IB1EAYAQ4V4BZzawAAMDcbQgjrcsunjzzF3ilP4ToUQDI1ADITGss36ccIMyK5IEzLjrakzhCqC0qzgEAlA2A1c0AQBvaWSJmzJdim1OJ6ug5orTEiyopHaEcGi2jiEFDhb2w2QTaJmxqE/WUcGadPmDjcn2bWOjSZUM3nI1LIK8AzfMB7JNmuDrYI2b90cQmJwAYARFngL6RZwDR0cATFE1jXhOsi5rVw9EWgGsg7jO7dpWX8RnAsSJtAGN12jtDR6Ibb7V64RbuAoC90QAQMzz2TaQWfWgR+oSfVeXBPfcD9BDE0+OGflgTOo4Y0c+EBRtFjE8HLhgl17kWs34giZhnmTIWLfSxZ3IohrZQUhEAIM9yuAQKAPQpQxhBu73gfz+Jxx+rv+IOAEGAAIClXGZOzLcAtqEhD4uGo8dOLbxpZ4hWAFIkfKuZa2BIDoF+f11dZfW2uRweYVakH/tAWQXHBINtq9UrrnkA/NcNAPoWIDF7O0Yd3g/B1bBR/3jufnNDvwE39I0bTVz46ZcBQGXO7TgbXMzSXtJ2y9DZ6RJYwgAwnMBu4AQuzK1JQDdvpeEEhhelWfzaxtyAe/pjt8eXTgAoBBAAovoAh1QfIAkWFqs/7Qif31FwgU/41ZA7r8QswP0amOwt8gcQnbM5fEWyPEkDL0Z3CSN5q9VLC/AMAPBNKQBsDgeAOB2K2n2lh0PY3quvRx636rYpZyf06EyASgQA5kl5qD0OSjwF0j0KOlbKPGsp3SpBzDL7AAOAor7HUkcg+Cyi+JG1oQFgTOJKRmxkAGgIpGjltZMVHFHYdF6T6I72GRmU3vEcfxUOAIEAAMDMo2siOoEXX0R+mTz/QlP7/Q/++PzzCaOnRs8C5LQnKwBGLt5Tx1jrfNZUHKpZAHxKRjlOAFiWsxO4cgA5Mj23Mn55NVaAHR9gnK679KqapdcO4LonOHb01Kmjx8YvF0sINE8WiDuEOQkSAKb499AKcCcmLgQ3ZG3ExwAAyiivHQfNiAra0R0DMf3OfOt5PD9kyUQBAMXNkgUT8fl/7PzHdCdQYlYXpDAAKID8/T/88emHc0biuHLRxS5nAFwDOy2DHkLi886ailgB8MHjW2AUALpYxhKZZwE+ThheGczCFrDzn0//droCQMv86ozrhMmTMGfkyDlZyhICmTxQoKAlTSaO5i7IPmzpPGfAnQMbzsOIi+AzQMd84xJozgBSRnntPGhGFJI7H6ZFGx1sxIfKFwBaNABQ3C5Nmzb4nRXn2cVBy2lzN9grACw0//5q6NZJ00ZHzQLOfSTNvgaCSqOnUGdLRawASe0tZxtA9QFMIANbqFAkOCCAD9G6+k37A3mdF8264/HrPt+V87LpKDJnnDw58RczyBIiB2ys6dQNypk509kNQsseHWKZRN4ovTsEaThpJ57IQyDKKK/NQTMaAEgc48AOhOBxOkVIfhwFACksKglzJn287MIr9F+d5N7/besrPAHHYGsUBuPevAD5nkb3AQ4DAIcz5/YGlfJsBEC7MABc7GwD6E4gdS9xZVJu/L3QYPk9UuERC/+zw1W7c3NDOePRCQwvTOub4Rgji8+6j45FofQ1D94bHDk5PURXyPs4sDsvnR1SpGDQcGg47PUp/H07pgUS2X+bpp0Yl0ANgGjltbvKmgI7tlJ2x9QO1t/u/esab7okw8MsAACQ2Zcpy/QBpS69vMfsyUwVETvT/IVkoZk8CGkkP/9deLSoNP2xBezPKhuOBhnz0c8yADhWAGYvxDcBAJ/ubYoHfwEcLswCEMqEfO55ygIcCLAZQYgETcYYdE5a/LwomUE8qQwiZAYUxshd0J0g8gQxBPLuBBuLEnn4GdNEqIOUpIlTjnyn4c+sXQbjhmz85HYAgD90xiWwpA+dAU6veOKdX3Dw4xVdPPhhx2QZRVnk7nXthB48/TZl3Wf6gFKffML3/kcttjPt13FQSUlJacd+b/z13rufCNeuSdPff8SfUz0Ghe40KVLOIgBYYSuAsBeycLM92kCuMN0qMmkaWL4NW+qSe3i5EE5gL7DuUUVFE+ChcevI28cukMdscs8zSWmURV7A8QYCbNb5aNK693YsLOn3UnxF3+KFpJqyLJ4JjxGDCClFFAIC4DQN03HMAoY/cwjEM1kCtEvgiUrOOXMxhLO/whfMdeZoYAuBHZzYgQiKLkRiGcRWk/g9ueMru46jhDZVkH254QRmj8tjA2o1mkTvA42PjS+99DcsPZazdNM/vS6XKjlfkqXOIgBYzhWAjqxzJqVqNkAn5gNQxt/M1Odf7u9gBXftAXvkXr3ACu7aadnQwUMmtm9BamgiiJJ4hghnth0LS/s1AQDkvRdPx2mnNIBLkMkIwDv+HcIBzYMtHQ6dzy6BJYFK5gSGR37aLRZIt/ir1/EFcZ1JZYijgVpGOlNu0QKygCqQMAp+0lu3ykZkii8W3AfUBcL4JCaMq9bHNzai74HGx78oX7q5a+DWUin0R8l/5qwCgLMVLH9afx7oQOyZIowgGOL6OdTMyEIuhC6ga9euEAZceMGK+bfdyTYHsSOIJBfxJSwr3mMNmcFt1fDfTps2OrihGV5YnEbA5Rw4QM//fOEDyLJbSsvucTXXtUxB62E3WTHrkQBQfOEwYeJlBEPYApxu41f3xA7QifmIFtt7yRXSURZbDqAPaGotZc6DLGabIqHvQbpyCJgi9X3S9H+jHxX7D+D5n0UAmBc2DJK21Z7kznvqknXt6dz5pJey8+6LVAaJNOj8x25UPhexI4jAoKQZYgOWleOpmzal5uRWpbJrXDQzVC03duDAhZIor8MkNvKy25CABPEc1gWYQpNSD37BK5OI10SEBZING73I4gIZKfXoVEE2kLbfvPMKacqCAkn6gLrWr5AU+LDeB/8ICLCcpZv+2oHg69QfPasAcI9zHCzshT2YpNxk6rPJeUU7ia4Qrg08T9nAtxNV0eeJINIzxKPHQyfBvabcYH8ldNHYTI1AWLdhNdYEafL4BQBm2W1ajv7QHVmkDDJ15dTBMIRDxuDUKxH3KRGv/kmD8a9QaJLQm88RLwMs/RUwgsW/lCzZh6hkfYU0ZYntEPcBTS9QlFSxS5r+2oGAcHJWAcBzT3+PIYSAFw3JYl0lBUToQkL/iSJkmoGvFK0OprfNACBmBFEHDkaEyz7Sw72oIxjbwkjm9b81ow4Jg5qtQrVsUjBqVbxPzXUtUzKo1OFQymdo3K2o2fp4h19E2gm5Y7alfVqKhUDWHZgFXPZ9fYU0ZZ1eKT3rn556Cr/SZeoUahwIzjIALMVsPN5QwtC1GHVTMqiK9YiI4aqvx6UAABAJR3RpAMSOIJI8XoSn7qzyn0RvvLimMg8ijC28AkTrw8KhZjTIKL3sUoTVT0S5aEooZgvzJg2F5SRUGZRfhzskLOBwkYS6gP6oso1g8+/RmPBpSQHvAKjTfM66MvCIafOni0eGx1J61n9Bz4q5p3WWF8vA0qpr9Arw3HsAQI+yinjiRYO3t3IlBZwV3Ywt4P7/P4IIZwC0XTelHveCstWYejwda82ri+UMYAAgD+ML10VEMdsyawpMZ0WVMX9kYs1HqPLqhPkz2LtSEmno+F+9+FhyMe8AqKhQkST5mz/Fcq80rxn5cvxcqJfffJ0etw8bhtKzviR6VqMMMrYSGsNnw6IAJm/Oq/sTQQsfhUcs2XrJxR8j3TQpCU10rGZv/vmNQUU7/x5ucRH16ZSKZTwqzluZDce8cJ9d3nDUi7Xm6TveCm6I1ojrjbedKrg10PxFHgy/pS/izTS7MCaqF/FaZMF1ejF2n8WYK2grptu31XJKxzR2ZeLDu7QTcmsSj+X2GK4FzgvC3ALao4xCndXp5iX8vMiXiWGmHncmE1343GnrWY0yqB3kJOKdatawtj8WsAwMpI4i7sjxLQB0GuXYey6apo++fi9ijrc8/Edwfkyp7VnvzxoEsSKI2uMy7otvaijF9R/O2yO8xdBgwB81RetOHQBYGn70PrRiPh28hXQNsy44dgxRns8DUGzgtZ3sAXUeeyqIBNqKaU5mBVI6yKl6Cmu9LEvvAZXHS6QJQIXMcxUs9ux1BDOUcQCJuByod0GuGXR3zJmDcRJdMcL1rLYySI2QIChTAFCeqjw5b0MAvP7gmvRcFNO6cGmFimFNAEJHJudCK/jE3W/nTJ4dgEtiGNvRXAadLhGxIohgo4w3I+toycL9m4JpDaW55dsyKYFiSTM+MRt+F3b5Ho6rNwuYqaDVA0GHTTpQMmCEfI/8HJarqwZPd4wVU3zvuX8kLyY/t/BRPFYcUVJ5gncAwS9GUrdTtGCOuAUYtzr7Ymn6A/bngMRrIeoecZjW9OuoqfkA6HISdd1BYZCjA5TPslPcgtYAU2faDAB4voHJB8eMmT055w581ypbLyFtIk9kL0P9LmvOyAfmJLxFHwpTGZQJKHd06GUvVB4BMSKI8GY8j09hwvH0qsSEbQmJJ2BJ/Abmwc+/bDtFfUc7RfHmJO23S7n5NoYFzIxCac2RewObPpNVwONE2ptEn2+5BeTzLcBYMb2esg4/8nrph49iB5exd7/SuhPSBODC+RHjqZL0Wfgs0JGVS98kS5nNbL9mS5gfW/EADar4cRODyFJ61oMQIWGkoDBYTKV9luX5Uwe57ZuDG5ZjNP/x2o8fwHgej/gezdFYMBBFfhFL4+lDO2N0ELMApx8bnv+lOhb00ksVAmJFEBG71j+70s+dxprAyVDgaOmaALqM0V5xtDnNTC/Ixq/Pv8tH2SJg1u3Vh2Hai7eTLESJtcsK/hBxdR0p7d2lr8Fmwys/2LFzIdzhWBCGgxknEjUcP1mEO4DtcsNXxiOFyi2ggypGlDeUyxYguvSdczv/bgVjcL/wWMQ0tbAk3Gr0rAqDXi7xTmUAkKduSTKWXvBnCQFt5Q+0NDh6xtT5h3h3ikcmOFOziKXF9xtUirY0BW8LZTQbV1z6nV+qYGBAQBo4MSKI8GaQGBnWzLj+E3X75Cn8C13G+xQAHG6RPLJNz/2Ef33UJ71kl7I1ifDsoIkc5F2at18iai+T0v6itmLqudG37pUdhSdD+R3JuxIHMxwjBa2Y/WEHkLJYMxRatOM9dgvoLiVawlP+unK6ReoX9QI3FasDq2F8zG1+doml9awUrYRfUzAYqjqwc+fOLbwC6APIVcjPpqAyMNsZlm1S/Hy3PyYUJ3nEsUt0WPzgqXhUcyFWbg2AlleANSdCmC50PHacF4LiPF4Bov1i/0Kb0+yul6rqyrsUiEcoiWWCu1IfeePwJr+346aijmy15khpjxMJJgCwOv7JUTu9UKx3ZDbGPaT37sDRGLIDSFlsTRvQYvHrVXGw66kcZPo5iAJiV7Z5Qfy0KYFZODTFa5aZhUtI6oMJfAhFKQxyb23H3x+WMwDuoJyH3BcHA2he8kvfIOSeTRXV83N8bWs2vnMpdn9mOdAHbvihx16MFUEEfn3qzMU5dZU5ixsaEivTMXP8eNIUnAGiHaNxBhAajqrhy7BLkQAJxcFsr6BhwWG9TOd+5eZCMiaF1VqzAGiqf2XYwmM5GgD9l7yFhW97RWPlnnEH19pWd+IWsEYDgF/T0c7HEmtI02H+Wz7JrVrdJObTTZmQN+H5jh7iPISijAy4ft37kCPhFmAPI2vLKubOZc3LQ7R3tVXBFwZnPTKHgrSJvHHnGQA4r3oGAEqL3RVkHaq1y4p79aLeQYcYEUQSprKtehfejsy06oISKJBZaItbQOQhAJsTX5/CaHiZIB4pmh8/8xL4kH3NYyWRM2eRSBHPaQ4AezM37Sj04hkqAEwnkhd4/o01eyY/sGJ9nCpyC3hwzVbtFiAvSlDpVUdTy/exsJNfi5Qpj3ijAS3OUADHROchFCV/BDxseA5on2XVgyhvzKzHojFy8pYtAehMrLYrWNwSBuZCJfnCy+BBm1ye6KueAEBE0R9v3779xhtB3uRvGK3XWBFE83wboPhFQDegjyTO0k+b4unuviAlMjXC/RpoAICmdVEp5EebmbpamE9gOKd5ADSkHd7pLT1aXa4AcB+RvG492Ld8V+WUoQYA4hawSLsF4BWd65s76GhC7T62usuQ12kjNzJl/OKp44Rj5jyEojQAOnXr7RGfZW2qW4fklPeIjZqIpQNCRasN61GcpSHvzxr/xz8CoknGEdBc9XgcGwGA7w2eCtkWTk5TQrzkXRSjE4jywAyixycQ+iKLxlva86XNKsTtRSqnVQRfA3FBxW9Pf4VfA891LAHfWOVZKQsAuHZuANgECtKIhMZsAQBOje8+TRyfX+6qmTJ0u4z5pA8weJL/1b8rtwDHDpAPDNXyt8zJziihJoGc5hV3fDii7KJVsLvzEIqyAXAB/k8DAKibQoEqHAtDU6aNx+GBBlptWb/BDOwvv3g7ByLdzAXGEfDCK8xVjyDQzrEFsO3XtGmjRw9B520m2meQ98aKIMInAh+PApDx5hMfUM4+DIDuVJIchZ/F+2iugZfjb30NhPyASlz41GNflbJOFgBQrSIAYPw4sQA0ZNkA+PV0XBvTkz/5zuXVtw++EX163Qe4cQa5BTx3vwGAjhLcm1lGAMASYNzxKd3cq93x/XW7yolY5vz9UQYA5wM6BgBADhdWDTid+nAEt9q0YA/1+r0z/SFSYqHPqckYlzuuenLQ14dAsf2qTmXeH0k+f748fmCsCCI2fcKt6daR7K23BlyeRx8lADiz48QrwlwDUZHXQPFhlIUfJ/x6vQC4ASD1wMLSEU3LaxUAIPZ7djz6mz26XnHheTM6KMUPJ1UMgVvAa8otwA4uI6uDpqC2PM8w7vg9BzHWxR1/T2U1vUHuAGCpmVkB8gLHoazGynn7yKE43rT53PCpN//80NZxkwbPuFI7AoKOFXnVW389FjVj+4Uc/PLa2rIybOk+GqHFiiCSeEie1E0LwBTi7bufwOZDALhI6rbR7LmHA7S6Bo5p9hp4Lhcd/RZCaBN8cpRaANwAkPhZyYieTRV9NQAGQKc8h/qztK9h4qSWAOuaiyfGP2K7BegFgLn8q+O1DVkXpzs+bW7iju+d0IMyrlsCACHAAGB3YkIDeyugqYkW5u+sti10RjeOYHo8/LdFAYBvg5d+FK0F2NaoEdJBNYLY9ottb66GhwO5X8WOIILt0+gEHHkS0pQphCSBAADXSE0ckkWvJwyZyNfAkS7XQAEAmbIX0u68CTigBcANACeqvKX9VgcNAHAaHTt68NAVz/Dlxk4CgFtA+xTjFoBXVKw3bTQ+2/A2IyIeIUUuPxMqGyvwHrQEAIKAfQj8D2VyY+V8WtxOn7DasDJIAhBsKE1Hr4uI+Zqki28DOz/qGcpV78UeHRgTzhPjN4IAY4A2AyAgI2YE0cCBql8SDErbZK4kgSSZBGn++beCC9yvgY5NgJaAkqMJ+2kn0OGSFPnZCYcwMoRTVkwndkNAuDr+ewwA9Ao4pwv9ze3r1cVG7QHNNENEEY9+w6oU7UKlkM7NHOgTsLjJxIuxEAMAKDtbBZn09UgV+uDvO6mHCWJrmxWeJhk4pTVsHXdQgvolOJef/3nr169/7DHItA6Oy1eGgEkp0AXCIK+irKy2tlxAQAjoEjOCKMnDksKXlyzRphAZUiZDXv+E7lG2U7Xe2azkf6olIBk7vFkAAACiAGVPYEM4VmUM6xzyAh+req8dAwCcRtPVHAHRYtrsMabn9HMWnwFxvI0FAKdBoZScH8keEBahl3BDC3+qtusESqgj+SqcqGlcLmu1tOW/cym0GNT9pnkIZp5rxBCwPcTa9PlNY/FH6i20F8jxKFYEkTWPzDnIDYIU+tJz0mX+A9Hqg+FhMzFNfIciWs7Tsjs0+E4FqvK5JSgAcHIClSoDyYN//fNm7s+U0rjA6eLL7E4IlsAF/PZlP4ZdjIoCUwBgZ0yC12ZcfcwxMO7zA8BhUKhKi1ugsAPnEjOqQX2QF9E2swCzn5dDAbAnsLgJrgCyj2IZzR7zMe8InG4O1gM8OmAISLyeBNHTDhkyevS0afjflf2ZawTRl1zX3TNgHmEhaR1a/Mn+3SVw3Nd6dEvMS/Iwn/+W8vnOg3Tgbo/KIDSpl/N8OrrPp0ZgvpQlz7782msvPLskBXdhXgD0DuARRzD5PhkAYlVizgAIqgpujgaA06BQyha3JIumsATrU9upxeT5k4srvJVOHG/Yy/309STUmlBA3T2cCa8kTkTW2/eyR0eKJUf5LdT3RE2d2s1eG08jgihi2BDnqOgkG0+EyLQ/EOCbiL7TSsiTd6fLTEADQMxLWALAqowpQhygl2EOl4hpTFR0H4tHiJmyIShnEJrkyVVI4oVIKm8MyXvjZ5y3AA9nZOWfaGiKBoBSBjEeVWkznT4dS6hK8fzZTattSm507OM8OQSpbU/K6UVoNKSaRXlyKcTpHKwoEAXwIbnsxxmSquv12hK67XQ8YgCcRgRRuMTAsMpQYRpTX3MaU7jxXffI2Dtv65DEbYdBZgGgyE82L2EREKf9IEY0C9QheZndn50uvqzzvpP0KmCmPIurB810yDjgGkunlw9CxxrmwSt9cytqYVkJqWw7BQCxK0O/A+74yZ0JhuGHUJTlMChUBQAIArSmkJ5/WwFAW6yCMVm1O1CZO4ijoWHOMHLynj1+6Gnw7C8eiOuRbwN0vdb3sU9SrvbHB+HbR+NxqkOHNABOf94oATQcPGMjwPH4jcY0bCeBG9/0Z9NGz7ixu295qt8sABL5aYcNtocqg/K+mDzIL+vUS0MrYZ23D2x1uJDd8VvkRKu1DXM8NQfKP9aASR5VfVpjDWy+trFGjZdxh0zZXwccfu0rf7KYhy6HUJTTDkyVEbd8dyPKmCm1fpm2flkaglb2V4/zrmEHVdry6+pqUjNBDRMApCyhICE2TerOLXvIdSHcphA2dAxkbzx9ALQjpSlYERQ+ZCPAPkmgw8aHSTlLZhqZ8V2w43t8/Jxp81d021ZdySYxhl3tgemTDhuUxL+LByZlWJxBGGYOZ/hiPjYjefXpd1Ne/+savbZZ1+OzjCPgKajYDj9JdRhiNvh8dXoGXJ8wmXJOIP1UoO4q9p92HkJRTjswVQSACE1h2wFAn2yQ5fHhZ/sx0uSgXtkCkseRkgprFoFgYpCSdF/A+0dvDF8SmQ+AwsRAn46T2tPRna7Z13AaNt56fdpmryWc5VXMm37+nUCJyc0tKO5rEGDfJbJIWJSnbpOJJDP2WIoQctddr92ROOWBtcP7YqRAC8Dp0+uZq7OTaSRdMJnILYRdb8qbb4wYhNH2CnILYCpQNsg8VQc+lDpQVRXaI+755iQnMuXjiePyOebceQhFOdXqSVJOcQuqDXUBxo4TDssf/vvDTak0mMz63QYL7hxjssWclQ+BaJIjxffddx/H+Vjp+LhNbPeJZQFQALjyf91dC1BUZRS+TfbYaZd1W7IldmuXZMgKK3rYNvRaSnvZ9JiptRcm1GZYlEZRlmKZw1RGbZLZyyF7SNFjGEu0MpIeKqJBDGkPwLIyLJRKS9OZvnPOvfe/sGxLr037mpzAyuXec/97Ht/5PqrhnyQWvAoAyzclAKTIGlcUxhUM2YNH5PX2C7BRP8ntp/1ip5OiwM/6KzadEHLPPS8+U+acDkZVUB0ADP2Ko6gzrrvIEvDmfmAPBebqXB0BX2zBYc+h3Zf/wtLPPaQbAHn876EWQK868D2zNnXs3PmjYOfODhgKTaeH25RFPFQSuTW46awfak1CAW0XhxEAGXMpAHCPX4FdtkejO/wz936PPhhAGQgNnzJER7q3QrcOYk7grTwooo6xtEhtwiBEej35M+TXrKQlqnAHX/uY9/rrX6JvjqzwBDSzzw6PXXLYDcqCHjDa6CinOvnJTwM4FNyprMDDjmF3Xvwozu9gOBzUiygT2mBju0N+RSZwgF7meRx7W5cYxOSZarzDhu9LAXD2Yg/JRbAqmnCESQzTWb/jRx3f7agvuXRWSDRrJQKWSCa3rgc++7yobE1CAS0W1PhS2LM/aEmCCoD07u9g6pwyLcVxFxihUsrgjKdHQRpByAr9yyisR3J9zBEgq/syK+ZZAF54EIB7cApkJq5Beu2aMsE7RztP/+YVWMwgj+wpV3jnXGAEQE4QlXQmkujIEfqC1kgOAAcl1jxSSs/IQCaI0yDkM2kGd194IYycsv0rZs8+v/AEOQCsVQBPJzOvuldXCRg9oZrzMG+NYrYMIABo4wNimGDzdX8n6IYu5nXfvE87ICqT40RuYYpRY1iTUKCfrvspZBwjviFqrqHjvwqA5obuH7/rzpDteO9jZidwX1ytizABZG+8ITSoBevDQhY5hiBsEbr/2CvAFsHYa1zYwShxT82cgdcJzV5Ri4HPc0N2SYlzauZkF8l0yzmCHIvYYhmu+kg4j/kGBx4y2uSROFPXzly9ZvXq1et6KNEOsUKwjfuFd2OeB+HpQogucBNYQekDGNWXuSvUPG8ee11yCCQOAH6Sv/3qKGzK6kAdcNTnX8HPPnNCn0zuA88jzz/14ofYcrImoXjhx3ZdBQgC61QD/ksEcVFIfgDMb6cUYO7kGXTJXM+/a50F7M2deEyD0BjaSMNCzSoTsS+gP1Uih4E5e4F7LXYw6twFJdlEdWOp/pKCktT3l9lX8O9Ok16MEQAub0vD1RFZ0tfbvdxZwRTRXccA564nHaWWzJVFc9SBp/o96C5IFaUggmPUeeFfQS0waJppjaWlkDIvGsoRkDgA+El+9fP99nO8bKAiBU5CfJ97Z3KIShQZTPn64677cHTdGco8iF1GMRIAriS36/8mADZ0IQVA9rqCti/uNKaBJ/E0kDo1+OoXMLkWfYxxcC/CqGKM6pVVmc9X5wIBo3KZzzd15vJ3RBaOtjY2zJq9pcwnNBC9BAXf2l7bntkwJp+X9A+W9VmhFuJ5R3Hmry0uLrbTOJ/OBLfiG2OD4a7l0F1Qt7/PLEBNBGSzoz672E6aJeEcnDUJAwB/Ajvo3gN2kE0ZWYuXLh7vRMvjc2S8oDJRICBy5oBM0DkC7pOh1pi2tvw2pW+fNIjTyvrGDTu6ujNgohlh2o30QJgPgEoPzzlzg8AJYi2tWJUIgQTAN3j402atqHPBjo6k1FC0S72dtsxeV7ksauf1DSP6muav/2Jl6ob8CC3pX3uwEASFXQ4iaXORHRqrGzeWFs8u7CF2qYVvfIHoLvDtjz0BqAzDr3wCCE2zw1kLjkI2CCqcbw764wAYQEsDn9MWmMPG5sbyuAIWipGDLleZqDz/qLmZR4O/2T5KdhxAcb86SltCyuEiWRB6H92Djq6G5qqc4CjItmEvyiLRdUyf5Q9QXuJBIxMpojeUhZxTsbslZZHY9eCbfnyzLBRykteC/ofXsN2Cs2NIuGho+hUUAFQ4CrUUL/yqInsXNFbHzSu1Fy7xYsGAh2+J9QGkDJNfkbQQTbM04vcRS4nYKmHcYUsALIwNAJS01mnhAYELRH3yWJW/89p4ChubL5flcc95JjAwMzJR/EqZqDRdcf/ZAofMg5hbsodGdlatV0d5SyhM/mFJDQDpBM3/YpVzU2pae04YMgEiBqNHQB9OoGztxQfa60xwuq0g1UXLmqnQfkAO/gl67vgmvsTv0gand5I8QxW4qdmdnXbQ6aqqJ0xBAUlXm5dJnHSvc3ECIACweIBiH6mikzeMTHkjrDHghAZMdx/ALMOqjWKMapq8nImsLuolkiq/bswAgC6+Z3gVBcBcBMA6CoCqcs8c1K8VxrQw4DHnhQ8YE2yWBsgQY3NeHofksQkamPXJRDWbaYGTSy8C6Z3ugW0pFics3bh13LhhYRLqSGYAyBHQtHJVZ6h2ZTgYvVTcHJVEF0IghhUsnRbrsWu+5h57BLLKYyenpSHnnjyWzdUoB698OC2t8vKx46EYszZt5lrMWvj+Q4i2u6t+k337NuKQjp/8IGpFXG1JAUJI+MYVoRJo3LhxevHjq5csoPeC8MsDBJGrhsm5A4mZiL9T1SVlmC4RwMWYCOGxTImDy4shXHLqAfDTmh6ImjbPD+bD07jc27P5fAhjep9FKaSmhXMmkbvevSyXaWR55to4brDuQH+OCR6YYQZYIpkomoL0UqhpwkoErwPBDm09bUcgDLGR/7CT/s0HH1xkWHJpSQSOAJzD7lDIF43m4/mn+NtT7QXIWoCSaQOk0/LRDxZIq5vLtwk33W6uRpGtgkdycFJjxldi/UJ9FOH00buv1tlhx12gxXG4pnjfusAIgPRyBAAlgT7fisJ1CytUABxLKM/A5Pbrzw9vafkEJq8i/o4SEmXYY+869I8Ai4HzbBIAukgF8zclzQNXhwKgMrNhboNrpb0Dnsa5za4tv9kbXSRhbpkWnnjTFS5amye5zHPMYQavjZMJFi+Pl5GUogHpIg4JFtxvZqI4Lpob4S/VnN4C8FiJWMRUOafNRPxAj3wRW+rPTbaTdMCBMtzuru9qhZ2jFKLxKj0Gd1rufeONt994z/xbGi56K1itRtEbXXLwCH09mq6KzFo04/4H5zem7oicftqazDJM5mDFgx6BeQJc48Ya6eM8CMhY4FEBICbnJPP+1dIGoJI2bHgZk/lC1u0sfCUBIBuLkl9yAAhfLLIte0N3a1equ3OTu7GpqanRvd3uriNBDN7sl2mh7dopFLlOvseaKQ0AY/Pp5IJXgGIlQlKKdxjQM1EfnQAyFqCXQlrtqlX401h6jf552KLvn9TO81ZfhcOFFiHzSoM7u7pbXtaSiwPAqmgrhpvjXLMRoab11kpPh95psUJec3oAWFajOAAsX3/80taiESOIZ6QJpXNUMKepuaHr0sj5myu/mRVcQfodJ1pygGxYea95aMWsroYWh0PlACcToPkOxTEMaiA4KCeModtwtHU7SygamBnFBABzdSK+jijQscnu6/xiPdFifPbtPnqcLdNC2yUQDvDRIjspmxPkD8FUfETpPFkep1nSPQaYNAP6SfYMMxM9lV4KnT5nfRsDGom8TwnrzqefXp7iRfIMq7VN8JJv8WhJxB3kqru0dVZxe7V38WLTY6dfQUCB9MjdJb3gpiCXAHjduhpFAWD5GjOmYWgnoMGs0QHwQj7kenO9LXNhQv/Tlvqdp4Oxt/yJJyxVQOMX2KBcXQh776WLU1QV8ASBdd4xqeERTUQfv8qj2Xs7K04A4Al/5WF/cdhACKIVMB30Q70uSi6OMi1kdQnb0SDFhke1Wd09jyQ5uum02SPL41GS0rtPBw58ykSfuTkTv1Lj8BBRr4v4ts82YS+5H+9CHlTZSJspaO/0Z6c1lx+mJQ/o0uA5+KrNVzqvxoFGx54qAOICB+xnBWjSWOByFsBBXgJgDysligLA8vUgo8FMGZhuRkJuz1eOGTVkW8mQ83/Fgj/ZMao+wIiceTU9qx+3t7V+pfoAyuTc7pQTwN+pL2MK06A3K8t4BbBwjcdr5gDCF9uYN4//yrsltbG9qb2xqTF1W5SMXGVaSOoSP9jIuyA8CnKZrxr+vnii4XdR5oQ0gCyPS/6uAykftKktmehoSYU6oYlSyNi8uZC0mG5ityS0Cm5wY1OpFutlVUTMTh7uvPjiD5/5dJmPpPPVaCIBl+N7BMCn3pdMeN9DAHy/BwdAn6ufOABOOYyLgY7tm7ZvWdNDLhWqE9jM4p4p8FaNLvuUXgvSCdRNzt84odBeC7IGv1Br5XGPHwC8oezht4s9nMfpF2tNLXpuH8E1YI7VVOfWpFf+FG1FMSxVAhO9bAHy+hhlrdGpuEEOUuka75LlcZSR9NsCos6fY2SiKZSJskYieh6Nrp51S5as63EBKIcmwS2J+IhreQumceX69bx/mjxcCH0ltGlCBWPx/FhMlgab3TYoYBIRUHpfjEEcAF973tTheUMFQMzVTxQAaLrZHKB2Ou1DQtnkAwPrTTULgKMIxFfunekM+cvULMAwOT/hcfvK5gxOqdevbOc/L24A5GTRKAkFXyb6ALKpx9Jyl5hKdFSzYFCXggMnSu9zFQAL+guACuaPvvZJdbssj+slvABdir6Z6OgK1JpEKPOmLFiQAhkZTI/Bsme3pIcecs+gLZhmrKAzsSJZEGd0V+pU921omerKRxIAh6DRJXP05U+/Ve4ZDOBpVicAdqg1/ZXww18NANiz5GAycwoK0TRn50RkQC1ffsjmuzIN9Gdng8Z7vWPaVUTtVdNACYD9EQDBoqpyhyE58IcB8PNEux+konSwDNAJJFkY4ouNFA3PQfQXtaEDARt0EVdESbcoQQA42HvusfIavAFoeRwV3HXSyAeQI/bJRHEmlFPxfwbtUTqgCxKKihcu3JLc/hUlULb9+KUqmswmNwAwVaMjiHozp56qO7dLAIxEVc1zdKJLT8IXI/sGwJ76orwlAPboc/WBOAEgu52REcOGosasQitqUyhrR1frM6889W4fPkB6LB9AE71vCoBxww+jcYbB1v6jV8AqUE+Ee8KDRyXiKkDPl+oL8pBi3aIEAcCGp2ijGcvjw4Ly+4yYTFSx78Cdyx2+dWtpeCIfDhA3p6kVduIXfbZoqOJWJg02mqrdNa16wqSR6G1JGSUBAMgcfS2zpPF89H4F0LWg+/9XA0DKgHBOUV5e0RHBSL37t6z8ZWWVNz9iYQT5LIyg3p5cFABnUQDsFTADQAPiB8C2Wjvoez57sDSPhchiAwD/MbnIzbgFXBb0AfoNAM0ANaJxU2V5fJ03Ny/MhooSALEfQnquslR/7tC8YbR2Mw/UQ0qpURsTxXZoHriVokGRRAToPY8mNxwbD8FNNzhsdDqeKnP0OmZJ44CMOQHwgzI17i8GAI6AMfmRICqw4JBRXRsqN5+f5XPOGD8hMScQHwSObUvOgtA3nuUBBgAyddBPMXTJG0dNrdgA0LjFWI7+L+sW9RsAqknDA2F9eXzdwpSaqpyJnAbGDQC1VH8G+uuYrY57Dnwr5lgP/fkkccbB/Wdu3X8Pfj1KGiMs6fgBMPATYJA1APQIuDo/ih70pWO6GzJX1/mmF1wz5aZ+WMH+XqxgsTc8aEnhbJJ5DQw0ACrbm4iBLoygfgMAi8oBmgDdPgVkRjMAFiIATpEAWNy7S6cvj29e421BhjeCHCTjBoDYm/NGNc1WjNmaRjJ05szlDBkS//cIOFjimpu4HAAfX8vXhDHoz54AEIG+lellGC/hn47nSYxEwNlXXjdmDHYkl85t8b73kPuWsQ9i/TjRXoDYGx6EKrA0D5P7AQYAMrUaiNqZTW0tAYwAwBTC5inPpQCY2+IxLgLrCPLyOCLLRdMEeOheSkdAnABQBveXGTQ6DkNj5iLkutzhu8T913AQUlkyGa8AWpSZPBlqblCLTXgCXERQq1EERS8jvbFj9EtiocItXboUPqSLX65YfuPaGZffzv7r1s0goPdmkJCPFyykFKBqOEr7Gg4AdLJYzTTmIxgBACtEmHdKU3vgAUDTwsWLvc1N4VFdDV4QWjWBaIhic2g7xijd33WTAQ7OiPgBIBEATlhuLw8cNXOh7+4i919DKoTh3NY0A/O2cl6UMAc4mqBWowimA+Rx7P8nR4EEgNDhCPthBPrEO9OuyrgCh3Kf3cCU2N3Au8EzxuB2drip2YuiurodZWB79TSv4zz5DBaJAADNaJqzQSW2InCYxXwkAWRamEXTwqX0gK+y17tmgNBqHP8sIoyRnw/taFDG0Y/2SRoYPwCEFGyYLcmnUDMX/u6u8P4HqBiCxPWw+TqGlZZwZcQYFP8EMLWV1T60OMLxO073/xM+loH9EAQsywehuvIU1CKnJtwOFvJx5Rb7yrRM9NV6MtFiW5k2U1c0j/kIGouPZUGTjFUYBhwAoi6BaWFra2vXBhoXllgEHZE0sLRwNNSxgxYHduzoCEU5DYwbAIJAbw+cXiMXfL1r4Alqh9hH/LJexy8TRdNZnQCqDLSeAEcS1GoUQTMExygElKx07CYEkUo8g0cfMlJLBCEfu7fXurds5r56di185jHCZRlB8yP4iRAI6C5CrBRPbNQBBYDy/OyIEvB82zt9dWC5quVGWpNftcqduoH2BrAy4N4uaWBsAOwyN3agOPmde6f6i4/4eb6On8MhmpAmbAQdSFCrUQT9JWf1//u710OMTXwQG58t+M2X5fvNr6vIxXwEw0UoVcTlNW1gAaA8PwU/bQtZXEo5rjPBaPyiMbOBFgdaGuCuJWng/yAAwLagQVmjgbyNt9xGHAnGoPit4EMIajWKoPXv//d3INZGvpL6fBP1oSFtusx/zEfAHCYTW/+GKJkGJPwIVs9PAdSt2af4B00gwrbrkXzAYYsAK5xfT0cayJy+2Ex098Kxz/KgbDwzP7AJNf4zqCx8oqqAeMOgwQS1GkXQ+vf/+1u4B+Zm+UKuEWxI3WZvg+0VDetjPoLG2mNKlEwDEnyEWM/PhT3wVgM19QcjAPQb/AuJh9poZcCzEIRSpIHMqo1JhrXdCxfIoIx4TbNpZnE7aTqnOBKPgwHrahSg9e//93fA/pb5wcbMjBbd3DDd9ZO97crP2drO8hHulu0spT0WYMhPMSDPT949AVBr1GwstTiVy/I4Sg14hcj/kI3os/LHsMlqbCa6eyGgOoFZQbMTKKl4fEJIssBcnXzYfpZXvLwf8HKKF9wQsbf952D1/EQZQtdCXE4Fsjwuu+IitvvR2+/VnRmZxW+imGRY283AASA/Ak8tj1StYKGEZff6SyhhyYKw9bhDCRITzA3p0gtj7589B40A0G2P/eJyKuh1cY6kOSLJW4eKJVtG7rl76QT0FwDyI2Abmu3UVQCI3lYviCZXsiD5uQypNID5odOZs/uvBADxf5gAJC6nAlkeL9O95JiozLyFgttQjvaTie5mQAAYPwLsudkx0QwA/va3vSAbOMkCM/Zn6mNqTWOGODwhibX/LwUAcSPSX3vlmdfI5VQgy+NmsXMs8FY1MmfswWd+0k8mupuBGUHyI2AZOqXCyggarO9Nq790Ta5kATs7zKUXogpdeSiSQHIdezv/TgAMBpgBxC6nArkIcm2AC4A5pEkm9qUxybC2m2GwyudJOZXzeSMAbEyG2dMCFne1aUnDAw6i0j79LFPVyO1oEmqWa6+Y5HhASxpkeVxur9xg4ZiRpO3uc+D/Dky0DcTwc1dFAAAAAElFTkSuQmCC';

    const NIGHT = base64StringToBlog(NIGHT_B64);
    const SPECULAR = base64StringToBlog(SPECULAR_B64);

    /* This file is mostly a straight translation of
     * GeographicLib/src/Geoid.cpp from C++ to JavaScript
     * by Kim Vandry <vandry@TZoNE.ORG>
     *
     * @license
     *  **
     * * \file Geoid.cpp
     * * \brief Implementation for GeographicLib::Geoid class
     * *
     * * Copyright (c) Charles Karney (2009) <charles@karney.com>
     * * and licensed under the LGPL.  For more information, see
     * * http://geographiclib.sourceforge.net/
     * **********************************************************************
     *
     * Geoid height grade not supported
     * The files can be downloaded from here:
     * http://geographiclib.sourceforge.net/1.18/geoid.html
     */

    class Geoid {
        constructor(options = {}) {

            this.model = options.model || null;
            this.src = options.src || null;

            this._cached_ix = null;
            this._cached_iy = null;
            this._v00 = null;
            this._v01 = null;
            this._v10 = null;
            this._v11 = null;
            this._t = null;
        }

        static loadModel(url) {
            if (!url) {
                return new Promise((resolve) => {
                    resolve(null);
                });
            } else

                return fetch(url, {})

                    .then((r) => {
                        if (!r.ok) {
                            throw Error("Geoid model file: HTTP error " + r.status);
                        }
                        return r.arrayBuffer();
                    })

                    .then((r) => {
                        if (r) {
                            return new Uint8Array(r);
                        } else {
                            throw Error("Geoid model file: no data from " + url);
                        }
                    })

                    .then(function (rawfile) {

                        if (!((rawfile[0] === 80) && (rawfile[1] === 53) && (
                            ((rawfile[2] === 13) && (rawfile[3] === 10)) ||
                            (rawfile[2] === 10)
                        ))) {
                            throw new Error("Geoid model file: no PGM header");
                        }

                        var i = (rawfile[2] === 13) ? 4 : 3;
                        var offset = null;
                        var scale = null;

                        function getline() {
                            var start = i;
                            for (var j = i; ; j++) {
                                if (j >= rawfile.length) {
                                    throw new Error("Geoid model file: missing newline in header");
                                }
                                if (rawfile[j] === 10) {
                                    i = j + 1;
                                    break;
                                }
                            }
                            if ((j > start) && (rawfile[j - 1] === 13)) j--;
                            return String.fromCharCode.apply(null, rawfile.slice(start, j));
                        }

                        var m, s;
                        for (; ;) {
                            s = getline();
                            if (s[0] !== '#') break;
                            m = s.match(/^# Offset (.*)$/);
                            if (m) {
                                offset = parseInt(m[1], 10);
                                if (!isFinite(offset)) {
                                    throw new Error("Geoid model file: bad offset " + m[1]);
                                }
                            } else {
                                m = s.match(/^# Scale (.*)$/);
                                if (m) {
                                    scale = parseFloat(m[1]);
                                    if (!isFinite(scale)) {
                                        throw new Error("Geoid model file: bad scale " + m[1]);
                                    }
                                }
                            }
                        }

                        m = s.match(/^\s*(\d+)\s+(\d+)\s*$/);

                        var width = null;
                        var height = null;

                        if (m) {
                            width = parseInt(m[1], 10);
                            height = parseInt(m[2], 10);
                        }

                        if (!(m && (width >= 0) && (height >= 0))) {
                            throw new Error("Geoid model file: bad PGM width&height line");
                        }

                        var levels = parseInt(getline());

                        if (levels != 65535) {
                            throw new Error("Geoid model file: PGM file must have 65535 gray levels");
                        }
                        if (offset === null) {
                            throw new Error("Geoid model file: PGM file does not contain offset");
                        }
                        if (scale === null) {
                            throw new Error("Geoid model file: PGM file does not contain scale");
                        }
                        if ((width < 2) || (height < 2)) {
                            throw new Error("Geoid model file: Raster size too small");
                        }

                        var payload_len = rawfile.length - i;

                        if (payload_len !== (width * height * 2)) {
                            throw new Error("Geoid model file: File has the wrong length");
                        }

                        return {
                            scale: scale,
                            offset: offset,
                            width: width,
                            height: height,
                            rlonres: width / 360,
                            rlatres: (height - 1) / 180,
                            i: i,
                            rawfile: rawfile
                        };
                    });
        }

        setModel(model) {
            this.model = model;
        }

        _rawval(ix, iy) {
            let model = this.model;

            if (iy < 0) {
                iy = -iy;
                ix += model.width / 2;
            } else if (iy >= model.height) {
                iy = 2 * (model.height - 1) - iy;
                ix += model.width / 2;
            }

            if (ix < 0) {
                ix += model.width;
            } else if (ix >= model.width) {
                ix -= model.width;
            }

            var k = (iy * model.width + ix) * 2 + model.i;

            return (model.rawfile[k] << 8) | model.rawfile[k + 1];
        }

        getHeightLonLat(lonlat) {
            return this.getHeight(lonlat.lon, lonlat.lat);
        }

        getHeight(lon, lat) {

            if (!this.model) return 0;

            let model = this.model;

            if (lon < 0) lon += 360.0;

            var fy = (90 - lat) * model.rlatres;
            var fx = lon * model.rlonres;
            var iy = Math.floor(fy);
            var ix = Math.floor(fx);

            fx -= ix;
            fy -= iy;

            if (iy === (model.height - 1)) {
                iy--;
            }

            if ((this._cached_ix !== ix) || (this._cached_iy !== iy)) {

                this._cached_ix = ix;
                this._cached_iy = iy;

                this._v00 = this._rawval(ix, iy);
                this._v01 = this._rawval(ix + 1, iy);
                this._v10 = this._rawval(ix, iy + 1);
                this._v11 = this._rawval(ix + 1, iy + 1);
            }

            let h = null;

            var a = (1 - fx) * this._v00 + fx * this._v01;
            var b = (1 - fx) * this._v10 + fx * this._v11;

            h = (1 - fy) * a + fy * b;

            return model.offset + model.scale * h;
        }
    }

    /**
     * @module og/scene/Planet
     */

    const CUR_LOD_SIZE = 250; //px
    const MIN_LOD_SIZE = 312; //px
    const MAX_LOD_SIZE = 190; //px

    let _tempPickingPix_ = new Uint8Array(4),
        _tempDepthColor_ = new Uint8Array(4);

    const DEPTH_DISTANCE = 11;//m

    /**
     * Maximum created nodes count. The more nodes count the more memory usage.
     * @const
     * @type {number}
     * @default
     */
    const MAX_NODES = 200;

    const HORIZON_TANGENT = 0.81;

    const EVENT_NAMES$3 = [
        /**
         * Triggered before globe frame begins to render.
         * @event og.scene.Planet#draw
         */
        "draw",

        /**
         * Triggered when layer has added to the planet.
         * @event og.scene.Planet#layeradd
         */
        "layeradd",

        /**
         * Triggered when base layer changed.
         * @event og.scene.Planet#baselayerchange
         */
        "baselayerchange",

        /**
         * Triggered when layer has removed from the planet.
         * @event og.scene.Planet#layerremove
         */
        "layerremove",

        /**
         * Triggered when some layer visibility changed.
         * @event og.scene.Planet#layervisibilitychange
         */
        "layervisibilitychange",

        /**
         * Triggered when all data is loaded
         * @event og.scene.Planet#rendercompleted
         */
        "rendercompleted",

        /**
         * Triggered when all data is loaded
         * @event og.scene.Planet#terraincompleted
         */
        "terraincompleted"
    ];

    /**
     * Main class for rendering planet
     * @class
     * @extends {RenderNode}
     * @param {string} [options.name="Earth"] - Planet name(Earth by default)
     * @param {Ellipsoid} [options.ellipsoid] - Planet ellipsoid(WGS84 by default)
     * @param {Number} [options.maxGridSize=128] - Segment maximal grid size
     * @param {Number} [options.maxEqualZoomAltitude=15000000.0] - Maximal altitude since segments on the screen bacame the same zoom level
     * @param {Number} [options.minEqualZoomAltitude=10000.0] - Minimal altitude since segments on the screen bacame the same zoom level
     * @param {Number} [options.minEqualZoomCameraSlope=0.8] - Minimal camera slope above te globe where segments on the screen bacame the same zoom level
     * @fires og.scene.Planet#draw
     * @fires og.scene.Planet#layeradd
     * @fires og.scene.Planet#baselayerchange
     * @fires og.scene.Planet#layerremove
     * @fires og.scene.Planet#layervisibilitychange
     * @fires og.scene.Planet#geoimageadd
     */
    class Planet extends RenderNode {
        constructor(options = {}) {
            super(options.name);

            this._cameraFrustums = options.frustums || [
                [1, 100 + 0.075],
                [100, 1000 + 0.075],
                [1000, 1e6 + 10000],
                [1e6, 1e9]
            ];

            /**
             * @public
             * @type {Ellipsoid}
             */
            this.ellipsoid = options.ellipsoid || wgs84;

            /**
             * @public
             * @type {Boolean}
             */
            this.lightEnabled = true;

            /**
             * Squared ellipsoid radius.
             * @protected
             * @type {number}
             */
            this._planetRadius2 = this.ellipsoid.getPolarSize() * this.ellipsoid.getPolarSize();

            /**
             * All layers array.
             * @public
             * @type {Array.<Layer>}
             */
            this.layers = [];

            /**
             * Current visible imagery tile layers array.
             * @public
             * @type {Array.<Layer>}
             */
            this.visibleTileLayers = [];

            /**
             * Current visible vector layers array.
             * @protected
             * @type {Array.<layer.Vector>}
             */
            this.visibleVectorLayers = [];

            this._visibleTileLayerSlices = [];

            /**
             * Vector layers visible nodes with collections.
             * @protected
             * @type {Array.<EntityCollection>}
             */
            this._frustumEntityCollections = [];

            /**
             * There is only one base layer on the globe when layer.isBaseLayer is true.
             * @public
             * @type {Layer}
             */
            this.baseLayer = null;

            /**
             * Terrain provider.
             * @public
             * @type {Terrain}
             */
            this.terrain = null;

            /**
             * Camera is this.renderer.activeCamera pointer.
             * @public
             * @type {PlanetCamera}
             */
            this.camera = null;

            this._minAltitude = options.minAltitude;
            this._maxAltitude = options.maxAltitude;

            this.maxEqualZoomAltitude = options.maxEqualZoomAltitude || 15000000.0;
            this.minEqualZoomAltitude = options.minEqualZoomAltitude || 10000.0;
            this.minEqualZoomCameraSlope = options.minEqualZoomCameraSlope || 0.8;

            /**
             * Screen mouse pointer projected to planet cartesian position.
             * @public
             * @type {Vec3}
             */
            this.mousePositionOnEarth = new Vec3();

            this.emptyTexture = null;
            this.transparentTexture = null;
            this.defaultTexture = null;

            /**
             * Current visible minimal zoom index planet segment.
             * @public
             * @type {number}
             */
            this.minCurrZoom = MAX;

            /**
             * Current visible maximal zoom index planet segment.
             * @public
             * @type {number}
             */
            this.maxCurrZoom = MIN;

            this._viewExtent = new Extent(new LonLat(180, 180), new LonLat(-180, -180));

            /**
             * @protected
             */
            this._createdNodesCount = 0;

            /**
             * Planet's segments collected for rendering frame.
             * @protected
             * @type {quadTree.Node}
             */
            this._renderedNodes = [];
            this._renderedNodesInFrustum = [];

            /**
             * Created nodes cache
             * @protected
             * @type {quadTree.Node}
             */
            this._quadTreeNodesCacheMerc = {};

            /**
             * Current visible mercator segments tree nodes array.
             * @protected
             * @type {quadTree.Node}
             */
            this._visibleNodes = {};

            /**
             * Current visible north pole nodes tree nodes array.
             * @protected
             * @type {quadTree.Node}
             */
            this._visibleNodesNorth = {};

            /**
             * Current visible south pole nodes tree nodes array.
             * @protected
             * @type {quadTree.Node}
             */
            this._visibleNodesSouth = {};

            /**
             * Layers activity lock.
             * @public
             * @type {idle.Lock}
             */
            this.layerLock = new Lock();

            /**
             * Terrain providers activity lock.
             * @public
             * @type {idle.Lock}
             */
            this.terrainLock = new Lock();

            /**
             * Layer's transparent colors.
             * @protected
             */
            this._tcolorArr = [];

            /**
             * Height scale factor. 1 - is normal elevation scale.
             * @protected
             * @type {number}
             */
            this._heightFactor = 1.0;

            /**
             * Precomputed indexes array for differrent grid size segments.
             * @protected
             * @type {Array.<Array.<number>>}
             */
            this._indexesCache = [];
            this._indexesCacheToRemove = [];
            this._indexesCacheToRemoveCounter = 0;

            /**
             * Precomputed texture coordinates buffers for differrent grid size segments.
             * @protected
             * @type {Array.<Array.<number>>}
             */
            this._textureCoordsBufferCache = [];

            /**
             * Framebuffer for relief. Is null when WEBGL_draw_buffers extension initialized.
             * @protected
             * @type {Object}
             */
            this._heightPickingFramebuffer = null;

            /**
             * Mercator grid tree.
             * @protected
             * @type {quadTree.Node}
             */
            this._quadTree = null;

            /**
             * North grid tree.
             * @protected
             * @type {quadTree.Node}
             */
            this._quadTreeNorth = null;

            /**
             * South grid tree.
             * @protected
             * @type {quadTree.Node}
             */
            this._quadTreeSouth = null;

            /**
             * Night glowing gl texture.
             * @protected
             */
            this._nightTexture = null;

            /**
             * Specular mask gl texture.
             * @protected
             */
            this._specularTexture = null;

            //TODO: replace to a function
            let a = createColorRGB(options.ambient, new Vec3(0.2, 0.2, 0.2));
            let d = createColorRGB(options.diffuse, new Vec3(0.8, 0.8, 0.8));
            let s = createColorRGB(options.specular, new Vec3(0.0003, 0.0003, 0.0003));
            let shininess = options.shininess || 20.0;

            this._ambient = new Float32Array([a.x, a.y, a.z]);
            this._diffuse = new Float32Array([d.x, d.y, d.z]);
            this._specular = new Float32Array([s.x, s.y, s.z, shininess]);

            /**
             * True for rendering night glowing texture.
             * @protected
             * @type {boolean}
             */
            this._useNightTexture = isUndef(options.useNightTexture) ? true : options.useNightTexture;

            /**
             * True for rendering specular mask texture.
             * @protected
             * @type {boolean}
             */
            this._useSpecularTexture = isUndef(options.useSpecularTexture)
                ? true
                : options.useSpecularTexture;

            this._maxGridSize = Math.log2(options.maxGridSize || 128);

            /**
             * Segment multiple textures size.(4 - convinient value for the most devices)
             * @const
             * @public
             */
            this.SLICE_SIZE = 4;
            this.SLICE_SIZE_4 = this.SLICE_SIZE * 4;
            this.SLICE_SIZE_3 = this.SLICE_SIZE * 3;

            /**
             * Level of the visible segment detalization.
             * @public
             * @type {number}
             */
            this._lodSize = CUR_LOD_SIZE;
            this._curLodSize = CUR_LOD_SIZE;
            this._minLodSize = MIN_LOD_SIZE;
            this._maxLodSize = MAX_LOD_SIZE;

            this._pickingColorArr = new Float32Array(this.SLICE_SIZE_4);
            this._samplerArr = new Int32Array(this.SLICE_SIZE);
            this._pickingMaskArr = new Int32Array(this.SLICE_SIZE);

            /**
             * GeoImage creator.
             * @protected
             * @type{utils.GeoImageCreator}
             */
            this._geoImageCreator = null;

            this._vectorTileCreator = null;

            this._normalMapCreator = null;

            this._terrainWorker = new TerrainWorker(3);

            this._plainSegmentWorker = new PlainSegmentWorker(3);

            this._tileLoader = new Loader(options.loadingBatchSize || 12);

            this._memKey = new Key();

            this.events.registerNames(EVENT_NAMES$3);

            this._distBeforeMemClear = 0.0;

            this._prevCamEye = new Vec3();

            this._initialized = false;

            this.always = [];

            this._renderCompleted = false;
            this._renderCompletedActivated = false;

            this._terrainCompleted = false;
            this._terrainCompletedActivated = false;
        }

        static getBearingNorthRotationQuat(cartesian) {
            let n = cartesian.normal();
            let t = Vec3.proj_b_to_plane(Vec3.UNIT_Y, n);
            return Quat.getLookRotation(t, n);
        }

        /**
         * Add the given control to the renderer of the planet scene.
         * @param {control.Control} control - Control.
         */
        addControl(control) {
            control.planet = this;
            control.addTo(this.renderer);
        }

        get lodSize() {
            return this._lodSize;
        }

        setLodSize(currentLodSize, minLodSize, maxLodSize) {
            this._maxLodSize = maxLodSize || this._maxLodSize;
            this._minLodSize = minLodSize || this._minLodSize;
            this._curLodSize = currentLodSize || this._curLodSize;
            this._renderCompletedActivated = false;
            this._terrainCompletedActivated = false;
        }

        /**
         * Add the given controls array to the renderer of the planet.
         * @param {Array.<control.Control>} cArr - Control array.
         */
        addControls(cArr) {
            for (var i = 0; i < cArr.length; i++) {
                this.addControl(cArr[i]);
            }
        }

        /**
         * Return layer by it name
         * @param {string} name - Name of the layer. og.Layer.prototype.name
         * @public
         * @returns {Layer} -
         */
        getLayerByName(name) {
            var i = this.layers.length;
            while (i--) {
                if (this.layers[i].name === name) {
                    return this.layers[i];
                }
            }
        }

        /**
         * Adds the given layer to the planet.
         * @param {Layer} layer - Layer object.
         * @public
         */
        addLayer(layer) {
            layer.addTo(this);
        }

        /**
         * Dispatch layer visibility changing event.
         * @param {Layer} layer - Changed layer.
         * @protected
         */
        _onLayerVisibilityChanged(layer) {
            this.events.dispatch(this.events.layervisibilitychange, layer);
        }

        /**
         * Adds the given layers array to the planet.
         * @param {Array.<Layer>} layers - Layers array.
         * @public
         */
        addLayers(layers) {
            for (var i = 0; i < layers.length; i++) {
                this.addLayer(layers[i]);
            }
        }

        /**
         * Removes the given layer from the planet.
         * @param {Layer} layer - Layer to remove.
         * @return {Layer|undefined} The removed layer or undefined if the layer was not found.
         * @public
         */
        removeLayer(layer) {
            return layer.remove();
        }

        /**
         *
         * @protected
         * @param {Layer} layer - Material layer.
         */
        _clearLayerMaterial(layer) {
            var lid = layer._id;
            this._quadTree.traverseTree(function (node) {
                var mats = node.segment.materials;
                if (mats[lid]) {
                    mats[lid].clear();
                    mats[lid] = null;
                }
            });
        }

        /**
         * Get the collection of layers associated with this planet.
         * @return {Array.<Layer>} Layers array.
         * @public
         */
        getLayers() {
            return this.layers;
        }

        /**
         * Sets base layer coverage to the planet.
         * @param {Layer} layer - Layer object.
         * @public
         */
        setBaseLayer(layer) {
            if (this.baseLayer) {
                if (!this.baseLayer.isEqual(layer)) {
                    this.baseLayer.setVisibility(false);
                    this.baseLayer = layer;
                    layer.setVisibility(true);
                    this.events.dispatch(this.events.baselayerchange, layer);
                }
            } else {
                this.baseLayer = layer;
                this.baseLayer.setVisibility(true);
                this.events.dispatch(this.events.baselayerchange, layer);
            }
        }

        /**
         * Sets elevation scale. 1.0 is default.
         * @param {number} factor - Elevation scale.
         */
        setHeightFactor(factor) {
            this._renderCompletedActivated = false;
            this._terrainCompletedActivated = false;

            if (this._heightFactor !== factor) {
                this._heightFactor = factor;
                this._quadTree.destroyBranches();
            }
        }

        /**
         * Gets elevation scale.
         * @returns {number} Terrain elevation scale
         */
        getHeightFactor() {
            return this._heightFactor;
        }

        /**
         * Sets terrain provider
         * @public
         * @param {Terrain} terrain - Terrain provider.
         */
        setTerrain(terrain) {
            this._renderCompletedActivated = false;
            this._terrainCompletedActivated = false;

            if (this._initialized) {
                this.memClear();
            }

            if (this.terrain) {
                this.terrain.abortLoading();
                this.terrain.clearCache();
                this.terrain._planet = null;
            }

            this.terrain = terrain;
            this.terrain._planet = this;

            //this._normalMapCreator && this._normalMapCreator.setBlur(terrain.blur != undefined ? terrain.blur : true);

            if (this._quadTree) {
                this._quadTree.destroyBranches();
            }

            //if (terrain._geoid) {

            if (terrain._geoid.model) {
                this._plainSegmentWorker.setGeoid(terrain.getGeoid());
                terrain._isReady = true;
            } else {
                Geoid.loadModel(terrain._geoid.src)
                    .then((m) => {
                        terrain.getGeoid().setModel(m);
                        this._plainSegmentWorker.setGeoid(terrain.getGeoid());
                        terrain._isReady = true;
                    })
                    .catch((err) => {
                        console.log(err);
                    });
            }

            // if (!terrain._geoid.model) {
            //     Geoid.loadModel(terrain._geoid.src)
            //         .then((m) => {
            //             terrain.getGeoid().setModel(m);
            //             this._plainSegmentWorker.setGeoid(terrain.getGeoid());
            //         })
            //         .catch((err) => {
            //             console.log(err);
            //         });
            // } else {
            //     this._plainSegmentWorker.setGeoid(terrain.getGeoid());
            // }
            //}
        }

        /**
         * @virtual
         * @protected
         */
        _initializeShaders() {
            var h = this.renderer.handler;

            h.addProgram(drawnode_screen_nl(), true);
            if (h.isWebGl2()) {
                h.addProgram(drawnode_screen_wl_webgl2(), true);
            } else {
                h.addProgram(drawnode_screen_wl(), true);
            }
            h.addProgram(drawnode_colorPicking(), true);
            h.addProgram(drawnode_depth(), true);
            h.addProgram(drawnode_heightPicking(), true);

            this.renderer.addPickingCallback(this, this._renderColorPickingFramebufferPASS);

            this.renderer.addDepthCallback(this, this._renderDepthFramebufferPASS);

            this._heightPickingFramebuffer = new Framebuffer(this.renderer.handler, {
                width: 320,
                height: 240
            });

            this._heightPickingFramebuffer.init();

            this.renderer.screenTexture.height = this._heightPickingFramebuffer.textures[0];
        }

        /**
         * @virtual
         * @public
         */
        init() {
            // Initialization indexes table
            getInstance().setMaxGridSize(this._maxGridSize);
            const TABLESIZE = this._maxGridSize;
            let kk = 0;
            // Initialization indexes buffers cache. It takes about 120mb RAM!
            for (var i = 0; i <= TABLESIZE; i++) {
                !this._indexesCache[i] && (this._indexesCache[i] = new Array(TABLESIZE));
                for (var j = 0; j <= TABLESIZE; j++) {
                    !this._indexesCache[i][j] && (this._indexesCache[i][j] = new Array(TABLESIZE));
                    for (var k = 0; k <= TABLESIZE; k++) {
                        !this._indexesCache[i][j][k] &&
                            (this._indexesCache[i][j][k] = new Array(TABLESIZE));
                        for (var m = 0; m <= TABLESIZE; m++) {
                            !this._indexesCache[i][j][k][m] &&
                                (this._indexesCache[i][j][k][m] = new Array(TABLESIZE));
                            for (var q = 0; q <= TABLESIZE; q++) {
                                let ptr = {
                                    buffer: null
                                };

                                if (i >= 1 && i === j && i === k && i === m && i === q) {
                                    let indexes = getInstance()
                                        .createSegmentIndexes(i, [j, k, m, q]);
                                    ptr.buffer = this.renderer.handler.createElementArrayBuffer(
                                        indexes,
                                        1
                                    );
                                    indexes = null;
                                } else {
                                    this._indexesCacheToRemove[kk++] = ptr;
                                }

                                this._indexesCache[i][j][k][m][q] = ptr;
                            }
                        }
                    }
                }
            }

            this.renderer.events.on("resize", () => {
                this._renderCompletedActivated = false;
                this._terrainCompletedActivated = false;
            });

            // Initialize texture coordinates buffer pool
            this._textureCoordsBufferCache = [];

            let texCoordCache = getInstance().initTextureCoordsTable(TABLESIZE + 1);

            for (let i = 0; i <= TABLESIZE; i++) {
                this._textureCoordsBufferCache[i] = this.renderer.handler.createArrayBuffer(
                    texCoordCache[i],
                    2,
                    ((1 << i) + 1) * ((1 << i) + 1)
                );
            }

            texCoordCache = null;

            // creating empty textures
            var that = this;
            this.renderer.handler.createDefaultTexture(null, function (t) {
                that.solidTextureOne = t;
                that.solidTextureTwo = t;
            });

            this.transparentTexture = this.renderer.handler.transparentTexture;

            this.camera = this.renderer.activeCamera = new PlanetCamera(this, {
                frustums: this._cameraFrustums,
                eye: new Vec3(0, 0, 28000000),
                look: new Vec3(0, 0, 0),
                up: new Vec3(0, 1, 0),
                minAltitude: this._minAltitude,
                maxAltitude: this._maxAltitude
            });

            this.camera.update();

            this._renderedNodesInFrustum = new Array(this.camera.frustums.length);
            for (let i = 0, len = this._renderedNodesInFrustum.length; i < len; i++) {
                this._renderedNodesInFrustum[i] = [];
            }

            // Creating quad trees nodes
            this._quadTree = new Node$1(Segment, this, NW, null, 0, 0,
                Extent.createFromArray([-20037508.34, -20037508.34, 20037508.34, 20037508.34])
            );
            this._quadTreeNorth = new Node$1(SegmentLonLat, this, NW, null, 0, 0,
                Extent.createFromArray([-180, MAX_LAT, 180, 90])
            );
            this._quadTreeSouth = new Node$1(SegmentLonLat, this, NW, null, 0, 0,
                Extent.createFromArray([-180, -90, 180, MIN_LAT])
            );

            this.drawMode = this.renderer.handler.gl.TRIANGLE_STRIP;

            // Applying shaders
            this._initializeShaders();

            this.updateVisibleLayers();

            this.renderer.addPickingCallback(this, this._frustumEntityCollectionPickingCallback);

            // loading Earth night glowing texture
            if (this._useNightTexture) {
                createImageBitmap(NIGHT).then(
                    (e) => (this._nightTexture = this.renderer.handler.createTextureDefault(e))
                );
            }

            // load water specular mask
            if (this._useSpecularTexture) {
                createImageBitmap(SPECULAR).then(
                    (e) => (this._specularTexture = this.renderer.handler.createTexture_l(e))
                );
            }

            this._geoImageCreator = new GeoImageCreator(this);

            this._vectorTileCreator = new VectorTileCreator(this);

            this._normalMapCreator = new NormalMapCreator(this, {
                minTableSize: 1,
                maxTableSize: TABLESIZE,
                blur: this.terrain && (this.terrain.blur != undefined ? this.terrain.blur : true)
            });

            this.renderer.events.on("draw", this._globalPreDraw, this, -100);

            // Loading first nodes for better viewing if you have started on a lower altitude.
            this._preRender();

            this._initialized = true;

            this.renderer.events.on("postdraw", () => {
                this._checkRendercompleted();
            });
        }

        clearIndexesCache() {
            this._indexesCacheToRemoveCounter = 0;
            let c = this._indexesCacheToRemove,
                gl = this.renderer.handler.gl;
            for (let i = 0, len = c.length; i < len; i++) {
                let ci = c[i];
                gl.deleteBuffer(ci.buffer);
                ci.buffer = null;
            }
        }

        _preRender() {
            // Zoom 0
            this._quadTree.createChildrenNodes();
            this._quadTree.segment.createPlainSegment();

            // Zoom 1
            for (let i = 0; i < this._quadTree.nodes.length; i++) {
                this._quadTree.nodes[i].segment.createPlainSegment();
            }

            // same for poles
            this._quadTreeNorth.createChildrenNodes();
            this._quadTreeNorth.segment.createPlainSegment();

            for (let i = 0; i < this._quadTreeNorth.nodes.length; i++) {
                this._quadTreeNorth.nodes[i].segment.createPlainSegment();
            }

            this._quadTreeSouth.createChildrenNodes();
            this._quadTreeSouth.segment.createPlainSegment();

            for (let i = 0; i < this._quadTreeSouth.nodes.length; i++) {
                this._quadTreeSouth.nodes[i].segment.createPlainSegment();
            }

            this._preLoad();
        }

        _preLoad() {
            this._clearRenderedNodeList();

            this._skipPreRender = false;

            // Same for poles
            this._quadTreeNorth.segment.passReady = true;
            this._quadTreeNorth.renderNode(true);
            this._normalMapCreator.drawSingle(this._quadTreeNorth.segment);

            for (let i = 0; i < this._quadTreeNorth.nodes.length; i++) {
                this._quadTreeNorth.nodes[i].segment.passReady = true;
                this._quadTreeNorth.nodes[i].renderNode(true);
                this._normalMapCreator.drawSingle(this._quadTreeNorth.nodes[i].segment);
            }

            this._quadTreeSouth.segment.passReady = true;
            this._quadTreeSouth.renderNode(true);
            this._normalMapCreator.drawSingle(this._quadTreeSouth.segment);

            for (let i = 0; i < this._quadTreeSouth.nodes.length; i++) {
                this._quadTreeSouth.nodes[i].segment.passReady = true;
                this._quadTreeSouth.nodes[i].renderNode(true);
                this._normalMapCreator.drawSingle(this._quadTreeSouth.nodes[i].segment);
            }

            // Zoom 1
            for (let i = 0; i < this._quadTree.nodes.length; i++) {
                this._quadTree.nodes[i].segment.passReady = true;
                this._quadTree.nodes[i].renderNode(true);
                this._normalMapCreator.drawSingle(this._quadTree.nodes[i].segment);
            }

            // Zoom 0
            this._quadTree.segment.passReady = true;
            this._quadTree.renderNode(true);
            this._normalMapCreator.drawSingle(this._quadTree.segment);
        }

        /**
         * Creates default textures first for nirth pole and whole globe and second for south pole.
         * @public
         * @param{Object} param0 -
         * @param{Object} param1 -
         */
        createDefaultTextures(param0, param1) {
            this.renderer.handler.gl.deleteTexture(this.solidTextureOne);
            this.renderer.handler.gl.deleteTexture(this.solidTextureTwo);
            var that = this;
            this.renderer.handler.createDefaultTexture(param0, function (t) {
                that.solidTextureOne = t;
            });
            this.renderer.handler.createDefaultTexture(param1, function (t) {
                that.solidTextureTwo = t;
            });
        }

        /**
         * Updates attribution lists
         * @public
         */
        updateAttributionsList() {
            var html = "";
            for (var i = 0; i < this.layers.length; i++) {
                var li = this.layers[i];
                if (li._visibility) {
                    if (li._attribution.length) {
                        html += "<li>" + li._attribution + "</li>";
                    }
                }
            }

            this._applyAttribution(html);
        }

        /**
         * Updates visible layers.
         * @public
         */
        updateVisibleLayers() {
            this.visibleTileLayers = [];
            this.visibleTileLayers.length = 0;

            this.visibleVectorLayers = [];
            this.visibleVectorLayers.length = 0;

            var html = "";
            for (var i = 0; i < this.layers.length; i++) {
                var li = this.layers[i];
                if (li._visibility) {
                    if (li._isBaseLayer) {
                        this.createDefaultTextures(li._defaultTextures[0], li._defaultTextures[1]);
                        this.baseLayer = li;
                    }

                    if (li.hasImageryTiles()) {
                        this.visibleTileLayers.push(li);
                    }

                    if (li.isVector) {
                        this.visibleVectorLayers.push(li);
                    }

                    if (li._attribution.length) {
                        html += "<li>" + li._attribution + "</li>";
                    }

                } else if (li._fading && li._fadingOpacity > 0) {
                    if (li.hasImageryTiles()) {
                        this.visibleTileLayers.push(li);
                    }

                    if (li.isVector) {
                        this.visibleVectorLayers.push(li);
                    }
                }
            }

            this._applyAttribution(html);

            this._sortLayers();
        }

        /**
         * Apply to render list of layer attributions
         * @private
         */
        _applyAttribution(html) {
            if (this.renderer) {
                if (html.length) {
                    html = "<ul>" + html + "</ul>";
                    if (this.renderer.div.attributions.innerHTML !== html) {
                        this.renderer.div.attributions.style.display = "block";
                        this.renderer.div.attributions.innerHTML = html;
                    }
                } else {
                    this.renderer.div.attributions.style.display = "none";
                    this.renderer.div.attributions.innerHTML = "";
                }
            }
        }

        /**
         * Sort visible layer - preparing for rendering.
         * @protected
         */
        _sortLayers() {
            this.visibleVectorLayers.sort(function (a, b) {
                return a._zIndex - b._zIndex || a._height - b._height;
            });

            this._visibleTileLayerSlices = [];
            this._visibleTileLayerSlices.length = 0;

            if (this.visibleTileLayers.length) {
                this.visibleTileLayers.sort(function (a, b) {
                    return a._height - b._height || a._zIndex - b._zIndex;
                });

                var k = -1;
                var currHeight = this.visibleTileLayers[0]._height;
                for (var i = 0; i < this.visibleTileLayers.length; i++) {
                    if (i % this.SLICE_SIZE === 0 || this.visibleTileLayers[i]._height !== currHeight) {
                        k++;
                        this._visibleTileLayerSlices[k] = [];
                        currHeight = this.visibleTileLayers[i]._height;
                    }
                    this._visibleTileLayerSlices[k].push(this.visibleTileLayers[i]);
                }
            }
        }

        _clearRenderedNodeList() {
            // clearing all node list
            this._renderedNodes.length = 0;
            this._renderedNodes = [];

            // clearing nodes in frustums
            for (let i = 0, len = this._renderedNodesInFrustum.length; i < len; i++) {
                this._renderedNodesInFrustum[i].length = 0;
                this._renderedNodesInFrustum[i] = [];
            }
        }

        /**
         * Collects visible quad nodes.
         * @protected
         */
        _collectRenderNodes() {
            let cam = this.camera;

            this._lodSize = lerp(cam.slope < 0.0 ? 0.0 : cam.slope, this._curLodSize, this._minLodSize);

            cam._insideSegment = null;

            // clear first
            this._clearRenderedNodeList();

            this._viewExtent.southWest.set(180, 180);
            this._viewExtent.northEast.set(-180, -180);

            this._visibleNodes = {};
            this._visibleNodesNorth = {};
            this._visibleNodesSouth = {};

            this.minCurrZoom = MAX;
            this.maxCurrZoom = MIN;

            this._quadTree.renderTree(cam, 0, null);

            if (cam.slope > this.minEqualZoomCameraSlope &&
                cam._lonLat.height < this.maxEqualZoomAltitude &&
                cam._lonLat.height > this.minEqualZoomAltitude
            ) {

                this.minCurrZoom = this.maxCurrZoom;

                let temp = this._renderedNodes,
                    rf = this._renderedNodesInFrustum,
                    temp2 = [];

                this._renderedNodes = [];

                // clearing nodes in frustums
                for (let i = 0, len = this._renderedNodesInFrustum.length; i < len; i++) {
                    this._renderedNodesInFrustum[i].length = 0;
                    this._renderedNodesInFrustum[i] = [];
                }

                for (var i = 0, len = temp.length; i < len; i++) {
                    var ri = temp[i];
                    let ht = ri.segment.centerNormal.dot(cam._b);
                    if (ri.segment.tileZoom === this.maxCurrZoom || ht < HORIZON_TANGENT) {
                        this._renderedNodes.push(ri);
                        let k = 0,
                            inFrustum = ri.inFrustum;
                        while (inFrustum) {
                            if (inFrustum & 1) {
                                rf[k].push(ri);
                            }
                            k++;
                            inFrustum >>= 1;
                        }
                    } else {
                        temp2.push(ri);
                    }
                }

                for (let i = 0, len = temp2.length; i < len; i++) {
                    temp2[i].renderTree(cam, this.maxCurrZoom, null);
                }
            }

            this._quadTreeNorth.renderTree(cam, 0, null);
            this._quadTreeSouth.renderTree(cam, 0, null);
        }

        _globalPreDraw() {
            let cam = this.camera;

            this._distBeforeMemClear += this._prevCamEye.distance(cam.eye);
            this._prevCamEye.copy(cam.eye);
            cam.checkFly();

            // free memory
            if (this._createdNodesCount > MAX_NODES && this._distBeforeMemClear > 1000.0) {
                this.terrain.clearCache();
                this.memClear();
            }

            if (this._indexesCacheToRemoveCounter > 600) {
                this.clearIndexesCache();
            }
        }

        /**
         * Render node callback.
         * @public
         */
        frame() {
            this._renderScreenNodesPASS();

            this._renderHeightPickingFramebufferPASS();

            this.drawEntityCollections(this._frustumEntityCollections);
        }

        _checkRendercompleted() {
            if (this._renderCompleted) {
                if (!this._renderCompletedActivated) {
                    this._renderCompletedActivated = true;
                    this.events.dispatch(this.events.rendercompleted, true);
                }
            } else {
                this._renderCompletedActivated = false;
            }
            this._renderCompleted = true;

            if (this._terrainCompleted) {
                if (!this._terrainCompletedActivated) {
                    this._terrainCompletedActivated = true;
                    this.events.dispatch(this.events.terraincompleted, true);
                }
            } else {
                this._terrainCompletedActivated = false;
            }

            this._terrainCompleted = true;
        }

        /**
         * @protected
         */
        _renderScreenNodesPASS() {
            let sh, shu;
            let renderer = this.renderer;
            let h = renderer.handler;
            let gl = h.gl;
            let cam = renderer.activeCamera;
            let frustumIndex = cam.getCurrentFrustum();

            gl.disable(gl.POLYGON_OFFSET_FILL);

            if (frustumIndex === cam.FARTHEST_FRUSTUM_INDEX) {
                if (this._skipPreRender/* && (!this._renderCompletedActivated || cam.isMoved)*/) {
                    this._collectRenderNodes();
                }
                this._skipPreRender = true;

                // Here is the planet node dispatches a draw event before
                // rendering begins and we have got render nodes.
                this.events.dispatch(this.events.draw, this);

                this.transformLights();

                this._normalMapCreator.frame();

                // Creating geoImages textures.
                this._geoImageCreator.frame();

                // Collect entity collections from vector layers
                this._collectVectorLayerCollections();

                // Vector tiles rasteriazation
                this._vectorTileCreator.frame();
            }


            gl.enable(gl.CULL_FACE);

            gl.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

            if (this.lightEnabled) {
                h.programs.drawnode_screen_wl.activate();
                sh = h.programs.drawnode_screen_wl._program;
                shu = sh.uniforms;

                gl.uniform4fv(shu.lightsPositions, this._lightsTransformedPositions);

                gl.uniformMatrix3fv(shu.normalMatrix, false, cam.getNormalMatrix());
                gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
                gl.uniformMatrix4fv(shu.projectionMatrix, false, cam.getProjectionMatrix());

                gl.uniform3fv(shu.diffuse, this._diffuse);
                gl.uniform3fv(shu.ambient, this._ambient);
                gl.uniform4fv(shu.specular, this._specular);

                // bind night glowing material
                gl.activeTexture(gl.TEXTURE0 + this.SLICE_SIZE);
                gl.bindTexture(gl.TEXTURE_2D,
                    (this.camera._lonLat.height > 329958.0 && (this._nightTexture || this.transparentTexture)) || this.transparentTexture
                );
                gl.uniform1i(shu.nightTexture, this.SLICE_SIZE);

                // bind specular material
                gl.activeTexture(gl.TEXTURE0 + this.SLICE_SIZE + 1);
                gl.bindTexture(gl.TEXTURE_2D, this._specularTexture || this.transparentTexture);
                gl.uniform1i(shu.specularTexture, this.SLICE_SIZE + 1);

            } else {
                h.programs.drawnode_screen_nl.activate();
                sh = h.programs.drawnode_screen_nl._program;
                shu = sh.uniforms;
                gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
                gl.uniformMatrix4fv(shu.projectionMatrix, false, cam.getProjectionMatrix());
            }

            gl.uniform3fv(shu.eyePositionHigh, cam.eyeHigh);
            gl.uniform3fv(shu.eyePositionLow, cam.eyeLow);

            // drawing planet nodes
            var rn = this._renderedNodesInFrustum[frustumIndex],
                sl = this._visibleTileLayerSlices;

            if (sl.length) {
                let sli = sl[0];
                for (var i = sli.length - 1; i >= 0; --i) {
                    let li = sli[i];
                    if (li._fading && li._refreshFadingOpacity()) {
                        sli.splice(i, 1);
                    }
                }
            }

            let isEq = this.terrain.equalizeVertices;
            i = rn.length;
            while (i--) {
                let s = rn[i].segment;
                isEq && s.equalize();
                s.readyToEngage && s.engage();
                s.screenRendering(sh, sl[0], 0);
            }

            //gl.enable(gl.POLYGON_OFFSET_FILL);
            for (let j = 1, len = sl.length; j < len; j++) {
                let slj = sl[j];
                for (i = slj.length - 1; i >= 0; --i) {
                    let li = slj[i];
                    if (li._fading && li._refreshFadingOpacity()) {
                        slj.splice(i, 1);
                    }
                }

                i = rn.length;
                //gl.polygonOffset(0, -j);
                while (i--) {
                    rn[i].segment.screenRendering(sh, sl[j], j, this.transparentTexture, true);
                }
            }

            gl.disable(gl.BLEND);
        }

        /**
         * @protected
         */
        _renderHeightPickingFramebufferPASS() {
            if (!this.terrain.isEmpty) {

                this._heightPickingFramebuffer.activate();

                let sh;
                let renderer = this.renderer;
                let h = renderer.handler;
                let gl = h.gl;
                let cam = renderer.activeCamera;
                let frustumIndex = cam.getCurrentFrustum();

                if (frustumIndex === cam.FARTHEST_FRUSTUM_INDEX) {
                    gl.clearColor(0.0, 0.0, 0.0, 1.0);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                } else {
                    gl.clear(gl.DEPTH_BUFFER_BIT);
                }

                h.programs.drawnode_heightPicking.activate();
                sh = h.programs.drawnode_heightPicking._program;
                let shu = sh.uniforms;

                gl.uniformMatrix4fv(shu.viewMatrix, false, renderer.activeCamera.getViewMatrix());
                gl.uniformMatrix4fv(shu.projectionMatrix, false, renderer.activeCamera.getProjectionMatrix());

                gl.uniform3fv(shu.eyePositionHigh, cam.eyeHigh);
                gl.uniform3fv(shu.eyePositionLow, cam.eyeLow);

                // drawing planet nodes
                var rn = this._renderedNodesInFrustum[frustumIndex],
                    sl = this._visibleTileLayerSlices;

                let i = rn.length;
                while (i--) {
                    rn[i].segment.heightPickingRendering(sh, sl[0]);
                }

                this._heightPickingFramebuffer.deactivate();
            }
        }

        /**
         * @protected
         */
        _renderColorPickingFramebufferPASS() {
            let sh;
            let renderer = this.renderer;
            let h = renderer.handler;
            let gl = h.gl;
            h.programs.drawnode_colorPicking.activate();
            sh = h.programs.drawnode_colorPicking._program;
            let shu = sh.uniforms;
            let cam = renderer.activeCamera;

            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.enable(gl.BLEND);
            gl.enable(gl.CULL_FACE);

            gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
            gl.uniformMatrix4fv(shu.projectionMatrix, false, cam.getProjectionMatrix());

            gl.uniform3fv(shu.eyePositionHigh, cam.eyeHigh);
            gl.uniform3fv(shu.eyePositionLow, cam.eyeLow);

            // drawing planet nodes
            var rn = this._renderedNodesInFrustum[cam.getCurrentFrustum()],
                sl = this._visibleTileLayerSlices;

            let i = rn.length;
            while (i--) {
                rn[i].segment.colorPickingRendering(sh, sl[0], 0);
            }

            //gl.enable(gl.POLYGON_OFFSET_FILL);
            for (let j = 1, len = sl.length; j < len; j++) {
                i = rn.length;
                //gl.polygonOffset(0, -j);
                while (i--) {
                    rn[i].segment.colorPickingRendering(sh, sl[j], j, this.transparentTexture, true);
                }
            }
            //gl.disable(gl.POLYGON_OFFSET_FILL);

            gl.disable(gl.BLEND);
        }

        /**
         * @protected
         */
        _renderDepthFramebufferPASS() {
            let sh;
            let renderer = this.renderer;
            let h = renderer.handler;
            let gl = h.gl;
            h.programs.drawnode_depth.activate();
            sh = h.programs.drawnode_depth._program;
            let shu = sh.uniforms;
            let cam = renderer.activeCamera;

            gl.disable(gl.BLEND);
            gl.disable(gl.POLYGON_OFFSET_FILL);

            gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
            gl.uniformMatrix4fv(shu.projectionMatrix, false, cam.getProjectionMatrix());

            gl.uniform3fv(shu.eyePositionHigh, cam.eyeHigh);
            gl.uniform3fv(shu.eyePositionLow, cam.eyeLow);

            gl.uniform3fv(shu.frustumPickingColor, cam.frustum._pickingColorU);

            // drawing planet nodes
            var rn = this._renderedNodesInFrustum[cam.getCurrentFrustum()],
                sl = this._visibleTileLayerSlices;

            let i = rn.length;
            while (i--) {
                rn[i].segment.depthRendering(sh, sl[0]);
            }
        }

        _collectVectorLayerCollections() {
            this._frustumEntityCollections.length = 0;
            this._frustumEntityCollections = [];

            var i = this.visibleVectorLayers.length;
            while (i--) {
                let vi = this.visibleVectorLayers[i];

                if (vi._fading && vi._refreshFadingOpacity()) {
                    this.visibleVectorLayers.splice(i, 1);
                }

                vi.collectVisibleCollections(this._frustumEntityCollections);
                vi.update();
            }
        }

        /**
         * Vector layers picking pass.
         * @protected
         */
        _frustumEntityCollectionPickingCallback() {
            this.drawPickingEntityCollections(this._frustumEntityCollections);
        }

        /**
         * Starts clear memory thread.
         * @public
         */
        memClear() {
            this._distBeforeMemClear = 0;

            this.camera._insideSegment = null;

            this.layerLock.lock(this._memKey);
            this.terrainLock.lock(this._memKey);
            this._normalMapCreator.lock(this._memKey);

            this._normalMapCreator.clear();
            this.terrain.abortLoading();
            this._tileLoader.abort();

            var that = this;
            // setTimeout(function () {
            that._quadTree.clearTree();
            that._quadTreeNorth.clearTree();
            that._quadTreeSouth.clearTree();

            that.layerLock.free(that._memKey);
            that.terrainLock.free(that._memKey);
            that._normalMapCreator.free(that._memKey);
            // }, 0);

            this._createdNodesCount = 0;
        }

        /**
         * Returns ray vector hit ellipsoid coordinates.
         * If the ray doesn't hit ellipsoit returns null.
         * @public
         * @param {Ray} ray - Ray 3d.
         * @returns {Vec3} -
         */
        getRayIntersectionEllipsoid(ray) {
            return this.ellipsoid.hitRay(ray.origin, ray.direction);
        }

        /**
         * Returns 2d screen coordanates projection point to the planet ellipsoid 3d coordinates.
         * @public
         * @param {math.Pixel} px - 2D sreen coordinates.
         * @returns {Vec3} -
         */
        getCartesianFromPixelEllipsoid(px) {
            var cam = this.renderer.activeCamera;
            return this.ellipsoid.hitRay(cam.eye, cam.unproject(px.x, px.y));
        }

        /**
         * Returns 2d screen coordanates projection point to the planet ellipsoid geographical coordinates.
         * @public
         * @param {math.Pixel} px - 2D screen coordinates.
         * @returns {LonLat} -
         */
        getLonLatFromPixelEllipsoid(px) {
            var coords = this.getCartesianFromPixelEllipsoid(px);
            if (coords) {
                return this.ellipsoid.cartesianToLonLat(coords);
            }
            return null;
        }

        /**
         * Returns 3d cartesian coordinates on the relief planet by mouse cursor
         * position or null if mouse cursor is outside the planet.
         * @public
         * @returns {Vec3} -
         */
        getCartesianFromMouseTerrain() {
            var ms = this.renderer.events.mouseState;
            var distance = this.getDistanceFromPixel(ms);
            if (distance) {
                return ms.direction.scaleTo(distance).addA(this.renderer.activeCamera.eye);
            }
            return null;
        }

        /**
         * Returns 3d cartesian coordinates on the relief planet by 2d screen coordinates.
         * position or null if input coordinates is outside the planet.
         * @public
         * @param {Vec2} px - Pixel screen 2d coordinates.
         * @param {Boolean} [force=false] - Force framebuffer rendering.
         * @returns {Vec3} -
         */
        getCartesianFromPixelTerrain(px) {
            var distance = this.getDistanceFromPixel(px);
            if (distance) {
                var direction = px.direction || this.renderer.activeCamera.unproject(px.x, px.y);
                return direction.scaleTo(distance).addA(this.renderer.activeCamera.eye);
            }
            return null;
        }

        /**
         * Returns geographical coordinates on the relief planet by 2d screen coordinates.
         * position or null if input coordinates is outside the planet.
         * @public
         * @param {Vec2} px - Pixel screen 2d coordinates.
         * @param {Boolean} [force=false] - Force framebuffer rendering.
         * @returns {LonLat} -
         */
        getLonLatFromPixelTerrain(px, force) {
            var coords = this.getCartesianFromPixelTerrain(px, force);
            if (coords) {
                return this.ellipsoid.cartesianToLonLat(coords);
            }
            return null;
        }

        /**
         * Returns projected 2d screen coordinates by 3d cartesian coordiantes.
         * @public
         * @param {Vec3} coords - Cartesian coordinates.
         * @returns {Vec2} -
         */
        getPixelFromCartesian(coords) {
            return this.renderer.activeCamera.project(coords);
        }

        /**
         * Returns projected 2d screen coordinates by geographical coordinates.
         * @public
         * @param {LonLat} lonlat - Geographical coordinates.
         * @returns {Vec2} -
         */
        getPixelFromLonLat(lonlat) {
            var coords = this.ellipsoid.lonLatToCartesian(lonlat);
            if (coords) {
                return this.renderer.activeCamera.project(coords);
            }
            return null;
        }

        /**
         * Returns distance from active camera to the the planet ellipsoid
         * coordiantes unprojected by 2d screen coordiantes, or null if screen coordinates outside the planet.
         * @public
         * @param {Vec2} px - Screen coordinates.
         * @returns {number} -
         */
        getDistanceFromPixelEllipsoid(px) {
            var coords = this.getCartesianFromPixelEllipsoid(px);
            return coords ? coords.distance(this.renderer.activeCamera.eye) : null;
        }

        /**
         * Returns distance from active camera to the the relief planet coordiantes unprojected
         * by 2d screen coordiantes, or null if screen coordinates outside the planet.
         * If screen coordinates inside the planet but relief is not exists in the
         * point than function returns distance to the planet ellipsoid.
         * @public
         * @param {Vec2} px - Screen coordinates.
         * @param {Boolean} [force=false] - Force framebuffer rendering.
         * @returns {number} -
         */
        getDistanceFromPixel(px) {
            if (this.terrain.isEmpty) {
                return this.getDistanceFromPixelEllipsoid(px) || 0;
            } else {

                let r = this.renderer,
                    cnv = this.renderer.handler.canvas;

                let spx = px.x / cnv.width,
                    spy = (cnv.height - px.y) / cnv.height;

                _tempPickingPix_[0] = _tempPickingPix_[1] = _tempPickingPix_[2] = 0.0;

                let dist = 0;

                // HEIGHT
                this._heightPickingFramebuffer.activate();
                if (this._heightPickingFramebuffer.isComplete()) {
                    this._heightPickingFramebuffer.readPixels(_tempPickingPix_, spx, spy);
                    dist = decodeFloatFromRGBAArr(_tempPickingPix_);
                }
                this._heightPickingFramebuffer.deactivate();

                if (!(_tempPickingPix_[0] || _tempPickingPix_[1] || _tempPickingPix_[2])) {
                    dist = this.getDistanceFromPixelEllipsoid(px) || 0;
                } else if (dist < DEPTH_DISTANCE) {
                    r.screenDepthFramebuffer.activate();
                    if (r.screenDepthFramebuffer.isComplete()) {
                        r.screenDepthFramebuffer.readPixels(_tempDepthColor_, spx, spy);
                        let screenPos = new Vec4(
                            spx * 2.0 - 1.0,
                            spy * 2.0 - 1.0,
                            (_tempDepthColor_[0] / 255.0) * 2.0 - 1.0,
                            1.0 * 2.0 - 1.0
                        );
                        let viewPosition = this.camera.frustums[0]._inverseProjectionMatrix.mulVec4(screenPos);
                        let dir = px.direction || this.renderer.activeCamera.unproject(px.x, px.y);
                        dist = -(viewPosition.z / viewPosition.w) / dir.dot(this.renderer.activeCamera.getForward());
                    }
                    r.screenDepthFramebuffer.deactivate();
                }
                return dist;
            }
        }

        /**
         * Sets camera to the planet geographical extent.
         * @public
         * @param {Extent} extent - Geographical extent.
         */
        viewExtent(extent) {
            this.renderer.activeCamera.viewExtent(extent);
        }

        /**
         * Sets camera to the planet geographical extent.
         * @public
         * @param {Array.<number>} extentArr - Geographical extent array, (exactly 4 entries)
         * where index 0 - southwest longitude, 1 - latitude southwest, 2 - longitude northeast, 3 - latitude northeast.
         */
        viewExtentArr(extentArr) {
            this.renderer.activeCamera.viewExtent(
                new Extent(
                    new LonLat(extentArr[0], extentArr[1]),
                    new LonLat(extentArr[2], extentArr[3])
                )
            );
        }

        /**
         * Gets current viewing geographical extent.
         * @public
         * @returns {Extent} -
         */
        getViewExtent() {
            return this._viewExtent;
            // if (this._viewExtentMerc) {
            //     var ne = this._viewExtentMerc.northEast.inverseMercator(),
            //         sw = this._viewExtentMerc.southWest.inverseMercator();
            //     if (this._viewExtentWGS84) {
            //         var e = this._viewExtentWGS84;
            //         if (e.northEast.lon > ne.lon) {
            //             ne.lon = e.northEast.lon;
            //         }
            //         if (e.northEast.lat > ne.lat) {
            //             ne.lat = e.northEast.lat;
            //         }
            //         if (e.southWest.lon < sw.lon) {
            //             sw.lon = e.southWest.lon;
            //         }
            //         if (e.southWest.lat < sw.lat) {
            //             sw.lat = e.southWest.lat;
            //         }
            //     }
            //     return new Extent(sw, ne);
            // } else if (this._viewExtentWGS84) {
            //     return this._viewExtentWGS84;
            // }
        }

        /**
         * Sets camera to the planet geographical position.
         * @public
         * @param {LonLat} lonlat - New geographical position.
         * @param {Vec3} [up] - Camera UP vector.
         */
        viewLonLat(lonlat, up) {
            this.renderer.activeCamera.setLonLat(lonlat, up);
        }

        /**
         * Fly camera to the planet geographical extent.
         * @public
         * @param {Extent} extent - Geographical extent.
         * @param {Number} [height] - Height on the end of the flight route.
         * @param {Vec3} [up] - Camera UP vector on the end of a flying.
         * @param {Number} [ampl] - Altitude amplitude factor.
         * @param {cameraCallback} [startCallback] - Callback that calls after flying when flying is finished.
         * @param {cameraCallback} [completeCallback] - Callback that calls befor the flying begins.
         */
        flyExtent(extent, height, up, ampl, completeCallback, startCallback) {
            this.renderer.activeCamera.flyExtent(
                extent,
                height,
                up,
                ampl,
                completeCallback,
                startCallback
            );
        }

        /**
         * Fly camera to the new point.
         * @public
         * @param {Vec3} cartesian - Fly coordiantes.
         * @param {Vec3} [look] - Camera "look at" point.
         * @param {Vec3} [up] - Camera UP vector on the end of a flying.
         * @param {Number} [ampl] - Altitude amplitude factor.
         * @param [completeCallback]
         * @param [startCallback]
         * @param [frameCallback]
         */
        flyCartesian(cartesian, look, up, ampl, completeCallback, startCallback, frameCallback) {
            this.renderer.activeCamera.flyCartesian(
                cartesian,
                look,
                up,
                ampl,
                completeCallback,
                startCallback,
                frameCallback
            );
        }

        /**
         * Fly camera to the new geographical position.
         * @public
         * @param {LonLat} lonlat - Fly geographical coordiantes.
         * @param {Vec3} [look] - Camera "look at" point on the end of a flying.
         * @param {Vec3} [up] - Camera UP vector on the end of a flying.
         * @param {Number} [ampl] - Altitude amplitude factor.
         * @param [completeCallback]
         * @param [startCallback]
         * @param [frameCallback]
         */
        flyLonLat(lonlat, look, up, ampl, completeCallback, startCallback, frameCallback) {
            this.renderer.activeCamera.flyLonLat(
                lonlat,
                look,
                up,
                ampl,
                completeCallback,
                startCallback,
                frameCallback
            );
        }

        /**
         * Breaks the flight.
         * @public
         */
        stopFlying() {
            this.renderer.activeCamera.stopFlying();
        }

        updateBillboardsTexCoords() {
            for (let i = 0; i < this.entityCollections.length; i++) {
                this.entityCollections[i].billboardHandler.refreshTexCoordsArr();
            }

            let readyCollections = {};
            for (let i = 0; i < this.layers.length; i++) {
                let li = this.layers[i];
                if (li instanceof Vector) {
                    li.each(function (e) {
                        if (e._entityCollection && !readyCollections[e._entityCollection.id]) {
                            e._entityCollection.billboardHandler.refreshTexCoordsArr();
                            readyCollections[e._entityCollection.id] = true;
                        }
                    });
                }
            }
        }

        getEntityTerrainPoint(entity, res) {
            let n = this._renderedNodes,
                i = n.length;
            while (i--) {
                if (n[i].segment.isEntityInside(entity)) {
                    return n[i].segment.getEntityTerrainPoint(entity, res);
                }
            }
        }

        async getHeightDefault(lonLat) {
            return new Promise((resolve, reject) => {
                this.terrain.getHeightAsync(lonLat.clone(), (alt) => {
                    resolve(alt);
                });
            });
        }

        async getHeightAboveELL(lonLat) {
            return new Promise((resolve, reject) => {
                this.terrain.getHeightAsync(lonLat.clone(), (alt) => {
                    resolve(alt + this.terrain.geoid.getHeightLonLat(lonLat));
                });
            });
        }
    }

    /**
     * @module og/shape/BaseShape
     */

    /**
     * @class
     * @param {Object} options -  Geo object parameters:
     * @param {og.Vec3} [options.position] - Geo object position.
     */

    class GeoObject {
        constructor(options) {
            options = options || {};

            this.scale = options.scale || 0.02;
            this.scaleByDistance = new Float32Array(options.scaleByDistance || [MAX32, MAX32, MAX32]);

            /**
             * Geo object center cartesian position.
             * @protected
             * @type {og.Vec3}
             */
            this._position = createVector3(options.position);

            this._positionHigh = new Vec3();

            this._positionLow = new Vec3();

            Vec3.doubleToTwoFloats(this._position, this._positionHigh, this._positionLow);

            this._pitch = options.pitch || 0.0;
            this._yaw = options.yaw || 0.0;
            this._roll = options.roll || 0.0;

            this._planet = options.planet || null;
            this._lonLatAlt = new LonLat(0, 0, 100000);

            /**
             * RGBA color.
             * @protected
             * @type {og.Vec4}
             */
            this._color = createColorRGBA(options.color);

            this._direction = new Vec3(0, 0, 0);

            this._handler = null;
            this._handlerIndex = -1;
            this._vertices = options.vertices;
            this._normals = options.normals;
            this._indices = options.indices;
            this.instanced = options.instanced;
            this.tag = options.tag || "none";
            if (options.indices) {
                this._indicesCount = options.indices.length;
            }
            if (options.vertices) {
                this._verticesCount = Math.floor(options.vertices.length / 3);
            }
        }

        get planet() {
            return this._handler && this._handler._planet;
        }

        get renderer() {
            return this.planet && this.planet.renderer;
        }

        /**
         * Sets geo object opacity.
         * @public
         * @param {number} a - Billboard opacity.
         */
        setOpacity(a) {
            this._color.w = a;
            this.setColor(this._color.x, this._color.y, this._color.z, a);
        }

        /**
         * Sets RGBA color. Each channel from 0.0 to 1.0.
         * @public
         * @param {number} r - Red.
         * @param {number} g - Green.
         * @param {number} b - Blue.
         * @param {number} a - Alpha.
         */
        setColor(r, g, b, a) {
            this._color.x = r;
            this._color.y = g;
            this._color.z = b;
            a != undefined && (this._color.w = a);
            this._handler && this._handler.setRgbaArr(this._handlerIndex, this._color);
        }

        /**
         * Sets RGBA color. Each channel from 0.0 to 1.0.
         * @public
         * @param {og.Vec4} color - RGBA vector.
         */
        setColor4v(color) {
            this._color.x = color.x;
            this._color.y = color.y;
            this._color.z = color.z;
            color.w != undefined && (this._color.w = color.w);
            this._handler && this._handler.setRgbaArr(this._handlerIndex, color);
        }

        /**
         * Sets geo object visibility.
         * @public
         * @param {boolean} visibility - Visibility flag.
         */
        setVisibility(visibility) {
            this._visibility = visibility;
            this._handler && this._handler.setVisibility(this._handlerIndex, visibility);
        }

        /**
         * Returns  geo object visibility.
         * @public
         * @returns {boolean}
         */
        getVisibility() {
            return this._visibility;
        }

        setLonLat(lon, lat, alt) {
            this._lonLatAlt.lon = lon;
            this._lonLatAlt.lat = lat;
            this._lonLatAlt.height = alt;
            this._handler._planet.ellipsoid.lonLatToCartesianRes(this._lonLatAlt, this._position);
            this.setPosition3v(this._position);
        }

        /**
         * Sets geoObject position.
         * @public
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         * @param {number} z - Z coordinate.
         */
        setPosition(x, y, z) {
            this._position.x = x;
            this._position.y = y;
            this._position.z = z;
            Vec3.doubleToTwoFloats(this._position, this._positionHigh, this._positionLow);
            this._handler &&
                this._handler.setPositionArr(this._handlerIndex, this._positionHigh, this._positionLow);
            this.updateDirection();
        }

        /**
         * Sets billboard position.
         * @public
         * @param {og.Vec3} position - Cartesian coordinates.
         */
        setPosition3v(position) {
            this._position.x = position.x;
            this._position.y = position.y;
            this._position.z = position.z;
            Vec3.doubleToTwoFloats(position, this._positionHigh, this._positionLow);
            this._handler &&
                this._handler.setPositionArr(this._handlerIndex, this._positionHigh, this._positionLow);
            this.updateDirection();
        }

        setYaw(yaw) {
            this._yaw = yaw;
            this.updateDirection();
        }

        setPitch(pitch) {
            this._pitch = pitch;
            this._handler && this._handler.setPitchRollArr(this._handlerIndex, pitch, this._roll);
        }

        setRoll(roll) {
            this._roll = roll;
            this._handler && this._handler.setPitchRollArr(this._handlerIndex, this._pitch, roll);
        }

        setScale(scale) {
            this.scale = scale;
            this._handler && this._handler.setScaleArr(this._handlerIndex, scale);
        }

        getScale() {
            return this.scale;
        }

        /**
         * Removes geo object from handler.
         * @public
         */
        remove() {
            this._entity = null;
            this._handler && this._handler.remove(this);
        }

        /**
         * Sets billboard picking color.
         * @public
         * @param {og.Vec3} color - Picking color.
         */
        setPickingColor3v(color) {
            this._handler && this._handler.setPickingColorArr(this._handlerIndex, color);
        }

        updateDirection() {
            if (this._entity && this._entity.renderNode && this._entity.renderNode.ellipsoid) {
                this._entity.renderNode.ellipsoid.lonLatToCartesianRes(this._lonLatAlt, this._position);
            }
            this._qNorthFrame = Planet.getBearingNorthRotationQuat(this._position);

            let qq = Quat.yRotation(this._yaw * RADIANS)
                .mul(this._qNorthFrame)
                .conjugate();
            this._direction = qq.mulVec3(new Vec3(0.0, 0.0, -1.0)).normalize();
            this._handler && this._handler.setDirectionArr(this._handlerIndex, this._direction);
        }
    }

    /**
     * @module og/entity/Entity
     */

    /**
     * Entity instances aggregate multiple forms of visualization into a single high-level object.
     * They can be created manually and added to entity collection.
     *
     * @class
     * @param {Object} [options] - Entity options:
     * @param {string} [options.name] - A human readable name to display to users. It does not have to be unique.
     * @param {Vec3|Array.<number>} [options.cartesian] - Spatial entities like billboard, label, sphere etc. cartesian position.
     * @param {LonLat} [options.lonlat] - Geodetic coordiantes for an entities like billboard, label, sphere etc.
     * @param {boolean} [options.aground] - True for entities that have to be placed on the relief.
     * @param {boolean} [options.visibility] - Entity visibility.
     * @param {*} [options.billboard] - Billboard options(see {@link og.Billboard}).
     * @param {*} [options.label] - Label options(see {@link og.Label}).
     * @param {*} [options.sphere] - Sphere options(see {@link og.shape.Sphere}).
     * @param {*} [options.box] - Sphere options(see {@link og.shape.Box}).
     * @param {*} [options.polyline] - Polyline options(see {@link og.Polyline}).
     * @param {*} [options.ray] - Ray options(see {@link og.Ray}).
     * @param {*} [options.pointCloud] - Point cloud options(see {@link og.PointCloud}).
     * @param {*} [options.geometry] - Geometry options (see {@link og.Geometry}), available for vector layer only.
     * @param {*} [options.properties] - Entity custom properties.
     */
    class Entity$1 {
        constructor(options) {
            options = options || {};

            options.properties = options.properties || {};

            /**
             * Unic identifier.
             * @public
             * @readonly
             */
            this.id = Entity$1._staticCounter++;

            /**
             * Entity user defined properties.
             * @public
             * @type {Object}
             */
            this.properties = options.properties || {};

            /**
             * Entity name.
             * @public
             * @type {string}
             */
            this.properties.name = this.properties.name || options.name || "";

            /**
             * Children entities.
             * @public
             * @type {Array.<Entity>}
             */
            this.childrenNodes = [];

            /**
             * Parent entity.
             * @public
             * @type {Entity}
             */
            this.parent = null;

            /**
             * Entity cartesian position.
             * @protected
             * @type {Vec3}
             */
            this._cartesian = createVector3(options.cartesian);

            /**
             * Geodetic entity coordiantes.
             * @protected
             * @type {LonLat}
             */
            this._lonlat = createLonLat(options.lonlat);

            /**
             * World Mercator entity coordinates.
             * @protected
             * @type {LonLat}
             */
            this._lonlatMerc = null;

            /**
             * Entity visible terrain altitude.
             * @protected
             * @type {number}
             */
            this._altitude = options.altitude || 0.0;

            /**
             * Visibility flag.
             * @protected
             * @type {boolean}
             */
            this._visibility = options.visibility != undefined ? options.visibility : true;

            /**
             * Entity collection that this entity belongs to.
             * @protected
             * @type {EntityCollection}
             */
            this._entityCollection = null;

            /**
             * Entity collection array store index.
             * @protected
             * @type {number}
             */
            this._entityCollectionIndex = -1;

            /**
             * Assigned vector layer pointer.
             * @protected
             * @type {layer.Vector}
             */
            this._layer = null;

            /**
             * Assigned vector layer entity array index.
             * @protected
             * @type {number}
             */
            this._layerIndex = -1;

            /**
             * Picking color.
             * @protected
             * @type {Vec3}
             */
            this._pickingColor = new Vec3(0, 0, 0);

            this._featureConstructorArray = {
                billboard: [Billboard, this.setBillboard],
                label: [Label, this.setLabel],
                sphere: [Sphere, this.setShape],
                // box: [Box, this.setShape],
                polyline: [Polyline, this.setPolyline],
                pointCloud: [PointCloud, this.setPointCloud],
                geometry: [Geometry, this.setGeometry],
                geoObject: [GeoObject, this.setGeoObject],
                strip: [Strip, this.setStrip],
                ray: [Ray, this.setRay]
            };

            /**
             * Billboard entity.
             * @public
             * @type {Billboard}
             */
            this.billboard = this._createOptionFeature("billboard", options.billboard);

            /**
             * Text label entity.
             * @public
             * @type {Label}
             */
            this.label = this._createOptionFeature("label", options.label);

            /**
             * Shape entity.
             * @public
             * @type {shape.BaseShape}
             */
            this.shape = this._createOptionFeature("sphere", options.sphere || options.box);

            /**
             * Polyline entity.
             * @public
             * @type {Polyline}
             */
            this.polyline = this._createOptionFeature("polyline", options.polyline);

            /**
             * Ray entity.
             * @public
             * @type {ray}
             */
            this.ray = this._createOptionFeature("ray", options.ray);

            /**
             * PointCloud entity.
             * @public
             * @type {PointCloud}
             */
            this.pointCloud = this._createOptionFeature("pointCloud", options.pointCloud);

            /**
             * Geometry entity(available for vector layer only).
             * @public
             * @type {Geometry}
             */
            this.geometry = this._createOptionFeature("geometry", options.geometry);

            /**
             * Geo object entity
             * @public
             * @type {og.Geometry}
             */
            this.geoObject = this._createOptionFeature("geoObject", options.geoObject);

            /**
             * Strip entity.
             * @public
             * @type {Strip}
             */
            this.strip = this._createOptionFeature("strip", options.strip);
        }

        static get _staticCounter() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set _staticCounter(n) {
            this._counter = n;
        }

        get instanceName() {
            return "Entity";
        }

        _createOptionFeature(featureName, options) {
            if (options) {
                let c = this._featureConstructorArray[featureName];
                return c[1].call(this, new c[0](options));
            }
            return null;
        }

        getCollectionIndex() {
            return this._entityCollectionIndex;
        }

        /**
         * Adds current entity into the specified entity collection.
         * @public
         * @param {EntityCollection|Vector} collection - Specified entity collection or vector layer.
         * @param {Boolean} [rightNow=false] - Entity insertion option for vector layer.
         * @returns {Entity} - This object.
         */
        addTo(collection, rightNow = false) {
            collection.add(this, rightNow);
            return this;
        }

        /**
         * Removes current entity from collection and layer.
         * @public
         */
        remove() {
            this._layer && this._layer.removeEntity(this);
            this._entityCollection && this._entityCollection.removeEntity(this);
        }

        /**
         * Sets the entity visibility.
         * @public
         * @param {boolean} visibility - Entity visibility.
         */
        setVisibility(visibility) {
            this._visibility = visibility;

            // billboards
            this.billboard && this.billboard.setVisibility(visibility);

            // geoObject
            this.geoObject && this.geoObject.setVisibility(visibility);

            // labels
            this.label && this.label.setVisibility(visibility);

            // shape
            this.shape && this.shape.setVisibility(visibility);

            // polyline
            this.polyline && this.polyline.setVisibility(visibility);

            // ray
            this.ray && this.ray.setVisibility(visibility);

            // geometry
            this.geometry && this.geometry.setVisibility(visibility);

            for (let i = 0; i < this.childrenNodes.length; i++) {
                this.childrenNodes[i].setVisibility(visibility);
            }
        }

        /**
         * Returns entity visibility.
         * @public
         * @returns {boolean} -
         */
        getVisibility() {
            return this._visibility;
        }

        /**
         * Sets entity cartesian position.
         * @public
         * @param {Vec3} cartesian - Cartesian position in 3d space.
         */
        setCartesian3v(cartesian) {
            this.setCartesian(cartesian.x, cartesian.y, cartesian.z);
        }

        /**
         * Sets entity cartesian position.
         * @public
         * @param {number} x - 3d space X - position.
         * @param {number} y - 3d space Y - position.
         * @param {number} z - 3d space Z - position.
         */
        setCartesian(x, y, z) {
            let p = this._cartesian;

            p.x = x;
            p.y = y;
            p.z = z;

            // billboards
            this.billboard && this.billboard.setPosition3v(p);

            // geoObject
            this.geoObject && this.geoObject.setPosition3v(p);

            // labels
            this.label && this.label.setPosition3v(p);

            // shape
            this.shape && this.shape.setPosition3v(p);

            for (let i = 0; i < this.childrenNodes.length; i++) {
                this.childrenNodes[i].setCartesian(x, y, z);
            }

            let ec = this._entityCollection;

            if (ec && ec.renderNode && ec.renderNode.ellipsoid) {
                this._lonlat = ec.renderNode.ellipsoid.cartesianToLonLat(p);

                if (Math.abs(this._lonlat.lat) < MAX_LAT) {
                    this._lonlatMerc = this._lonlat.forwardMercator();
                } else {
                    this._lonlatMerc = null;
                }
            }

            ec && ec.events.dispatch(ec.events.entitymove, this);
        }

        /**
         * Sets entity cartesian position without event dispatching.
         * @protected
         * @param {Vec3} cartesian - Cartesian position in 3d space.
         * @param {boolean} skipLonLat - skip geodetic calculation.
         */
        _setCartesian3vSilent(cartesian, skipLonLat) {
            let p = this._cartesian;

            p.x = cartesian.x;
            p.y = cartesian.y;
            p.z = cartesian.z;

            // billboards
            this.billboard && this.billboard.setPosition3v(p);

            // geoObject
            this.geoObject && this.geoObject.setPosition3v(p);

            // labels
            this.label && this.label.setPosition3v(p);

            // shape
            this.shape && this.shape.setPosition3v(p);

            for (let i = 0; i < this.childrenNodes.length; i++) {
                this.childrenNodes[i].setCartesian(p.x, p.y, p.z);
            }

            let ec = this._entityCollection;

            if (!skipLonLat && ec && ec.renderNode && ec.renderNode.ellipsoid) {
                this._lonlat = ec.renderNode.ellipsoid.cartesianToLonLat(p);

                if (Math.abs(this._lonlat.lat) < MAX_LAT) {
                    this._lonlatMerc = this._lonlat.forwardMercator();
                } else {
                    this._lonlatMerc = null;
                }
            }
        }

        /**
         * Gets entity geodetic coordinates.
         * @public
         * @returns {LonLat} -
         */
        getLonLat() {
            return this._lonlat.clone();
        }

        /**
         * Sets geodetic coordinates of the entity point object.
         * @public
         * @param {LonLat} lonlat - WGS84 coordinates.
         */
        setLonLat(lonlat) {
            let l = this._lonlat;

            l.lon = lonlat.lon;
            l.lat = lonlat.lat;
            l.height = lonlat.height;

            let ec = this._entityCollection;
            if (ec && ec.renderNode && ec.renderNode.ellipsoid) {
                if (Math.abs(lonlat.lat) < MAX_LAT) {
                    this._lonlatMerc = lonlat.forwardMercator();
                } else {
                    this._lonlatMerc = null;
                }

                ec.renderNode.ellipsoid.lonLatToCartesianRes(lonlat, this._cartesian);
                this.setCartesian3v(this._cartesian);
            }
        }

        /**
         * Sets entity altitude over the planet.
         * @public
         * @param {number} altitude - Altitude.
         */
        setAltitude(altitude) {
            this._altitude = altitude;
        }

        /**
         * Sets entity altitude over the planet.
         * @public
         * @return {number} Altitude.
         */
        getAltitude() {
            return this._altitude;
        }

        /**
         * Returns carteain position.
         * @public
         * @returns {Vec3} -
         */
        getCartesian() {
            return this._cartesian.clone();
        }

        /**
         * Sets entity billboard.
         * @public
         * @param {Billboard} billboard - Billboard object.
         * @returns {Billboard} -
         */
        setBillboard(billboard) {
            if (this.billboard) {
                this.billboard.remove();
            }
            this.billboard = billboard;
            this.billboard._entity = this;
            this.billboard.setPosition3v(this._cartesian);
            this.billboard.setVisibility(this._visibility);
            this._entityCollection && this._entityCollection._billboardHandler.add(billboard);
            return billboard;
        }

        /**
         * Sets entity label.
         * @public
         * @param {Label} label - Text label.
         * @returns {Label} -
         */
        setLabel(label) {
            if (this.label) {
                this.label.remove();
            }
            this.label = label;
            this.label._entity = this;
            this.label.setPosition3v(this._cartesian);
            this.label.setVisibility(this._visibility);
            this._entityCollection && this._entityCollection._labelHandler.add(label);
            return label;
        }

        /**
         * Sets entity ray.
         * @public
         * @param {Ray} ray - Ray object.
         * @returns {Ray} -
         */
        setRay(ray) {
            if (this.ray) {
                this.ray.remove();
            }
            this.ray = ray;
            this.ray._entity = this;
            this.ray.setVisibility(this._visibility);
            this._entityCollection && this._entityCollection._rayHandler.add(ray);
            return ray;
        }

        /**
         * Sets entity shape.
         * @public
         * @param {BaseShape} shape - Shape object.
         * @returns {Polyline} -
         */
        setShape(shape) {
            if (this.shape) {
                this.shape.remove();
            }
            this.shape = shape;
            this.shape._entity = this;
            this.shape.setPosition3v(this._cartesian);
            this.shape.setVisibility(this._visibility);
            this._entityCollection && this._entityCollection._shapeHandler.add(shape);
            return shape;
        }

        /**
         * Sets entity polyline.
         * @public
         * @param {Polyline} polyline - Polyline object.
         * @returns {Polyline} -
         */
        setPolyline(polyline) {
            if (this.polyline) {
                this.polyline.remove();
            }
            this.polyline = polyline;
            this.polyline._entity = this;
            this.polyline.setVisibility(this._visibility);
            this._entityCollection && this._entityCollection._polylineHandler.add(polyline);
            return polyline;
        }

        /**
         * Sets entity pointCloud.
         * @public
         * @param {PointCloud} pointCloud - PointCloud object.
         * @returns {PointCloud} -
         */
        setPointCloud(pointCloud) {
            if (this.pointCloud) {
                this.pointCloud.remove();
            }
            this.pointCloud = pointCloud;
            this.pointCloud._entity = this;
            this.pointCloud.setVisibility(this._visibility);
            this._entityCollection && this._entityCollection._pointCloudHandler.add(pointCloud);
            return pointCloud;
        }

        /**
         * Sets entity geometry.
         * @public
         * @param {Geometry} geometry - Geometry object.
         * @returns {Geometry} -
         */
        setGeometry(geometry) {
            if (this.geometry) {
                this.geometry.remove();
            }
            this.geometry = geometry;
            this.geometry._entity = this;
            this.geometry.setVisibility(this._visibility);
            this._layer && this._layer.add(this);
            return geometry;
        }

        /**
         * Sets entity geoObject.
         * @public
         * @param {GeoObject} geoObject - GeoObject.
         * @returns {GeoObject} -
         */
        setGeoObject(geoObject) {
            if (this.geoObject) {
                this.geoObject.remove();
            }
            this.geoObject = geoObject;
            this.geoObject._entity = this;
            this.geoObject.setPosition3v(this._cartesian);
            this.geoObject.setVisibility(this._visibility);
            this._entityCollection && this._entityCollection._geoObjectHandler.add(geoObject);
            return geoObject;
        }

        /**
         * Sets entity strip.
         * @public
         * @param {Strip} strip - Strip object.
         * @returns {Strip} -
         */
        setStrip(strip) {
            if (this.strip) {
                this.strip.remove();
            }
            this.strip = strip;
            this.strip._entity = this;
            this.strip.setVisibility(this._visibility);
            this._entityCollection && this._entityCollection._stripHandler.add(strip);
            return strip;
        }

        get layer() {
            return this._layer;
        }

        get rendererEvents() {
            if (this._layer) {
                return this._layer.events;
            } else if (this._entityCollection) {
                return this._entityCollection.events;
            }
            return null;
        }

        /**
         * Append child entity.
         * @public
         * @param {Entity} entity - Child entity.
         */
        appendChild(entity) {
            entity._entityCollection = this._entityCollection;
            entity._pickingColor = this._pickingColor;
            entity.parent = this;
            this.childrenNodes.push(entity);
            this._entityCollection && this._entityCollection._addRecursively(entity);
        }

        /**
         * Appends entity items(billboard, label etc.) picking color.
         * @public
         */
        setPickingColor() {
            let c = this._pickingColor;

            // billboard
            this.billboard && this.billboard.setPickingColor3v(c);

            // label
            this.label && this.label.setPickingColor3v(c);

            // shape
            this.shape && this.shape.setPickingColor3v(c);

            // polyline
            this.polyline && this.polyline.setPickingColor3v(c);

            // ray
            this.ray && this.ray.setPickingColor3v(c);

            // strip
            this.strip && this.strip.setPickingColor3v(c);

            // billboard
            this.geoObject && this.geoObject.setPickingColor3v(c);
            for (let i = 0; i < this.childrenNodes.length; i++) {
                this.childrenNodes[i].setPickingColor();
            }
        }

        /**
         * Return geodethic extent.
         * @returns {Extent} -
         */
        getExtent() {
            let res;
            let c = this._lonlat;
            if (this.billboard || this.label) {
                res = new Extent(new LonLat(c.lon, c.lat), new LonLat(c.lon, c.lat));
            } else {
                res = new Extent(new LonLat(180.0, 90.0), new LonLat(-180.0, -90.0));
            }

            let sw = res.southWest,
                ne = res.northEast;

            if (this.polyline) {
                let e = this.polyline.getExtent();
                if (e.southWest.lon < sw.lon) sw.lon = e.southWest.lon;
                if (e.southWest.lat < sw.lat) sw.lat = e.southWest.lat;
                if (e.northEast.lon > ne.lon) ne.lon = e.northEast.lon;
                if (e.northEast.lat > ne.lat) ne.lat = e.northEast.lat;
            }

            if (this.geometry) {
                let e = this.geometry.getExtent();
                if (e.southWest.lon < sw.lon) sw.lon = e.southWest.lon;
                if (e.southWest.lat < sw.lat) sw.lat = e.southWest.lat;
                if (e.northEast.lon > ne.lon) ne.lon = e.northEast.lon;
                if (e.northEast.lat > ne.lat) ne.lat = e.northEast.lat;
            }

            for (let i = 0; i < this.childrenNodes.length; i++) {
                let e = this.childrenNodes[i].getExtent();
                if (e.southWest.lon < sw.lon) sw.lon = e.southWest.lon;
                if (e.southWest.lat < sw.lat) sw.lat = e.southWest.lat;
                if (e.northEast.lon > ne.lon) ne.lon = e.northEast.lon;
                if (e.northEast.lat > ne.lat) ne.lat = e.northEast.lat;
            }

            return res;
        }

        isEqual(entity) {
            return this.id === entity.id;
        }
    }

    /**
     * @module og/layer/KML
     */

    /**
     * Layer to render KMLs files
     * @class
     * @extends {Vector}
     */
    class KML extends Vector {
        /**
         *
         * @param {string} name
         * @param {*} [options]
         */
        constructor(name, options = {}) {
            super(name, options);
            this._extent = null;
            this._billboard = options.billboard || {
                src: "https://openglobus.org/examples/billboards/carrot.png"
            };
            /**
             * @type {string}
             */
            this._color = options.color || "#6689db";
        }

        get instanceName() {
            return "KML";
        }

        /**
         * @public
         */
        _extractCoordonatesFromKml(xmlDoc) {
            const raw = Array.from(xmlDoc.getElementsByTagName("coordinates"));
            const rawText = raw.map(item => item.textContent.trim());
            const coordinates = rawText.map(item =>
                item
                    .replace(/\n/g, " ")
                    .replace(/\t/g, " ")
                    .replace(/ +/g, " ")
                    .split(" ")
                    .map((co) => co.split(",").map(parseFloat))
            );
            return coordinates;
        }

        /**
         * @private
         */
        _AGBRtoRGBA(agbr) {
            if (!agbr || agbr.length != 8) return

            const a = parseInt(agbr.slice(0, 2), 16) / 255;
            const b = parseInt(agbr.slice(2, 4), 16);
            const g = parseInt(agbr.slice(4, 6), 16);
            const r = parseInt(agbr.slice(6, 8), 16);

            return `rgba(${r},${g},${b},${a})`;
        }

        /**
         * @private
         returns array of longitude, latitude, altitude (altitude optional)
         */
        _parseKMLcoordinates(coords) {
            const coordinates = coords.innerHTML.trim()
                .replace(/\n/g, ' ')
                .replace(/\t/g, ' ')
                .replace(/ +/g, ' ')
                .split(" ")
                .map((co) => co.split(",").map(parseFloat));

            return coordinates;
        }

        /**
         * @private
         */
        _kmlPlacemarkToEntity(placemark, extent) {
            if (!placemark) return;

            const nameTags = Array.from(placemark.getElementsByTagName("name"));
            const name = nameTags && nameTags[0]?.innerHTML?.trim() || '';

            const { iconHeading, iconURL, iconColor, lineWidth, lineColor } = this._extractStyle(placemark);

            // TODO handle MultiGeometry

            const lonLats = [];
            for (const coord of placemark.getElementsByTagName("coordinates")) {
                const coordinates = this._parseKMLcoordinates(coord) || [[0, 0, 0]];

                for (const lonlatalt of coordinates) {
                    const [lon, lat, alt] = lonlatalt;

                    lonLats.push(new LonLat(lon, lat, alt));

                    if (lon < extent.southWest.lon) extent.southWest.lon = lon;
                    if (lat < extent.southWest.lat) extent.southWest.lat = lat;
                    if (lon > extent.northEast.lon) extent.northEast.lon = lon;
                    if (lat > extent.northEast.lat) extent.northEast.lat = lat;
                }
            }

            if (lonLats.length === 1) {
                const hdgrad = iconHeading * 0.01745329; // radians

                return new Entity$1({
                    name,
                    lonlat: lonLats[0],
                    billboard: {
                        src: iconURL,
                        size: [24, 24],
                        color: iconColor,
                        rotation: hdgrad
                    },
                    properties: {
                        color: iconColor,
                        heading: iconHeading
                    }
                });

            } else {
                return new Entity$1({
                    polyline: {
                        pathLonLat: [lonLats],
                        thickness: lineWidth,
                        color: lineColor,
                        isClosed: false
                    }
                });
            }
        }

        _extractStyle(placemark) {
            let iconColor;
            let iconHeading;
            let iconURL;
            let lineColor;
            let lineWidth;

            const style = placemark.getElementsByTagName("Style")[0];
            if (style) {
                let iconstyle = style.getElementsByTagName("IconStyle")[0];
                if (iconstyle) {
                    let color = iconstyle.getElementsByTagName("color")[0];
                    if (color)
                        iconColor = this._AGBRtoRGBA(color.innerHTML.trim());

                    let heading = iconstyle.getElementsByTagName("heading")[0];
                    if (heading) {
                        const hdg = parseFloat(heading.innerHTML.trim());
                        if (hdg >= 0 && hdg <= 360)
                            iconHeading = hdg % 360;
                    }

                    let icon = iconstyle.getElementsByTagName("Icon")[0];
                    if (icon) {
                        let href = icon.getElementsByTagName("href")[0];
                        if (href) {
                            iconURL = href.innerHTML.trim();
                        }
                    }
                }

                let linestyle = style.getElementsByTagName("LineStyle")[0];
                if (linestyle) {
                    let color = linestyle.getElementsByTagName("color")[0];
                    if (color)
                        lineColor = this._AGBRtoRGBA(color.innerHTML.trim());
                    let width = linestyle.getElementsByTagName("width")[0];
                    if (width !== undefined)
                        lineWidth = parseFloat(width.innerHTML.trim());
                }
            }

            if (!iconColor) iconColor = "#FFFFFF";
            if (!iconHeading) iconHeading = 0;
            if (!iconURL) iconURL = "https://openglobus.org/examples/billboards/carrot.png";

            if (!lineColor) lineColor = "#FFFFFF";
            if (!lineWidth) lineWidth = 1;

            return { iconHeading, iconURL, iconColor, lineWidth, lineColor };
        }

        _parseKML(xml, extent, entities = undefined) {
            if (!entities)
                entities = [];

            if (xml.documentElement.nodeName !== "kml")
                return entities;

            for (const placemark of xml.getElementsByTagName("Placemark")) {
                const entity = this._kmlPlacemarkToEntity(placemark, extent);
                if (entity) entities.push(entity);
            }

            return entities;
        }

        _convertKMLintoEntities(xml) {
            const extent = new Extent(new LonLat(180.0, 90.0), new LonLat(-180.0, -90.0));
            const entities = this._parseKML(xml, extent);

            return { entities, extent }
        }

        /**
         * Creates billboards or polylines from array of lonlat.
         * @public
         * @param {Array} coordonates
         * @param {string} color
         * @returns {Array<Entity>}
         */
        _convertCoordonatesIntoEntities(coordinates, color, billboard) {
            const extent = new Extent(new LonLat(180.0, 90.0), new LonLat(-180.0, -90.0));
            const addToExtent = (c) => {
                const lon = c[0],
                    lat = c[1];
                if (lon < extent.southWest.lon) extent.southWest.lon = lon;
                if (lat < extent.southWest.lat) extent.southWest.lat = lat;
                if (lon > extent.northEast.lon) extent.northEast.lon = lon;
                if (lat > extent.northEast.lat) extent.northEast.lat = lat;
            };
            const _pathes = [];
            coordinates.forEach((kmlFile) => kmlFile.forEach((p) => _pathes.push(p)));
            const entities = _pathes.map((path) => {
                if (path.length === 1) {
                    const lonlat = path[0];
                    const _entity = new Entity$1({ lonlat, billboard });
                    addToExtent(lonlat);
                    return _entity;
                } else if (path.length > 1) {
                    const pathLonLat = path.map((item) => {
                        addToExtent(item);
                        return new LonLat(item[0], item[1], item[2]);
                    });
                    const _entity = new Entity$1({
                        polyline: { pathLonLat: [pathLonLat], thickness: 3, color, isClosed: false }
                    });
                    return _entity;
                }
            });
            return { entities, extent };
        }

        /**
         * @public
         * @returns {Document}
         */
        _getXmlContent(file) {
            return new Promise((resolve) => {
                const fileReader = new FileReader();
                fileReader.onload = async (i) =>
                    resolve(new DOMParser().parseFromString(i.target.result, "text/xml"));
                fileReader.readAsText(file);
            });
        }

        /**
         * @public
         */
        _expandExtents(extent1, extent2) {
            if (!extent1) return extent2;
            if (extent2.southWest.lon < extent1.southWest.lon)
                extent1.southWest.lon = extent2.southWest.lon;
            if (extent2.southWest.lat < extent1.southWest.lat)
                extent1.southWest.lat = extent2.southWest.lat;
            if (extent2.northEast.lon > extent1.northEast.lon)
                extent1.northEast.lon = extent2.northEast.lon;
            if (extent2.northEast.lat > extent1.northEast.lat)
                extent1.northEast.lat = extent2.northEast.lat;
            return extent1;
        }

        /**
         * @public
         * @param {File[]} kmls
         * @param {string} [color]
         * @param {Billboard} [billboard]
         * @returns {Promise<{entities: Entity[], extent: Extent}>}
         */
        async addKmlFromFiles(kmls, color = null, billboard = null) {
            if (!Array.isArray(kmls)) return null
            const kmlObjs = await Promise.all(kmls.map(this._getXmlContent));
            const coordonates = kmlObjs.map(this._extractCoordonatesFromKml);
            const { entities, extent } = this._convertCoordonatesIntoEntities(
                coordonates,
                color || this._color,
                billboard || this._billboard
            );
            this._extent = this._expandExtents(this._extent, extent);
            entities.forEach(this.add.bind(this));
            return { entities, extent };
        }

        /**
         * @param {string} color
         * @public
         */
        setColor(color) {
            this._color = color;
            this._billboard.color = color;
        }

        /**
         * @public
         */
        _getKmlFromUrl(url) {
            return new Promise((resolve, reject) => {
                const request = new XMLHttpRequest();
                request.open("GET", url, true);
                request.responseType = "document";
                request.overrideMimeType("text/xml");
                request.onload = () => {
                    if (request.readyState === request.DONE && request.status === 200) {
                        resolve(request.responseXML);
                    } else {
                        reject(new Error("no valid kml file"));
                    }
                };
                request.send();
            });
        }

        /**
         * @public
         * @param {string} url - Url of the KML to display. './myFile.kml' or 'http://mySite/myFile.kml' for example.
         * @param {string} [color]
         * @param {Billboard} [billboard]
         * @returns {Promise<{entities: Entity[], extent: Extent}>}
         */
        async addKmlFromUrl(url, color = null, billboard = null) {
            const kml = await this._getKmlFromUrl(url);
            /*
                    const coordonates = this._extractCoordonatesFromKml(kml);
                    const { entities, extent } = this._convertCoordonatesIntoEntities(
                        [coordonates],
                        color || this._color,
                        billboard || this._billboard
                    );
            */
            const { entities, extent } = this._convertKMLintoEntities(kml);

            this._extent = this._expandExtents(this._extent, extent);

            entities.forEach(this.add.bind(this));

            return { entities, extent };
        }
    	
    	/**
    	* Robert - 18th July 2022
    	* @public
    	* @param {string} [color]
        * @param {Billboard} [billboard]
        * @returns {Promise<{entities: Entity[], extent: Extent}>}
    	*/
    	async addKmlFromXml( kmlAsXml , color = null, billboard = null ) {
    		const coordinates = this._extractCoordonatesFromKml(kmlAsXml);
            const { entities, extent } = this._convertCoordonatesIntoEntities(
                [coordinates],
                color || this._color,
                billboard || this._billboard
            );
            this._extent = this._expandExtents(this._extent, extent);
            entities.forEach(this.add.bind(this));
            return { entities, extent };
    		
    	}
    }

    /**
     * @module og/layer/XYZ
     */

    /**
     * Represents an imagery tiles source provider.
     * @class
     * @extends {Layer}
     * @param {string} name - Layer name.
     * @param {Object} options:
     * @param {number} [options.opacity=1.0] - Layer opacity.
     * @param {Array.<string>} [options.subdomains=['a','b','c']] - Subdomains of the tile service.
     * @param {number} [options.minZoom=0] - Minimal visibility zoom level.
     * @param {number} [options.maxZoom=0] - Maximal visibility zoom level.
     * @param {number} [options.minNativeZoom=0] - Minimal available zoom level.
     * @param {number} [options.maxNativeZoom=19] - Maximal available zoom level.
     * @param {string} [options.attribution] - Layer attribution that displayed in the attribution area on the screen.
     * @param {boolean} [options.isBaseLayer=false] - Base layer flag.
     * @param {boolean} [options.visibility=true] - Layer visibility.
     * @param {string} [options.crossOrigin=true] - If true, all tiles will have their crossOrigin attribute set to ''.
     * @param {string} options.url - Tile url source template(see example below).
     * @param {string} options.textureFilter - texture gl filter. NEAREST, LINEAR, MIPMAP, ANISOTROPHIC.
     * @param {layer.XYZ~_urlRewriteCallback} options.urlRewrite - Url rewrite function.
     * @fires og.layer.XYZ#load
     * @fires og.layer.XYZ#loadend
     *
     * @example <caption>Creates OpenStreetMap base tile layer</caption>
     * new og.layer.XYZ("OpenStreetMap", {
     *     isBaseLayer: true,
     *     url: "http://b.tile.openstreetmap.org/{z}/{x}/{y}.png",
     *     visibility: true,
     *     attribution: 'Data @ <a href="http://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="http://www.openstreetmap.org/copyright">ODbL</a>'
     * });
     */
    class XYZ extends Layer$1 {
        /**
         * @param {string} name - Layer name.
         * @param {*} options
         */
        constructor(name, options) {
            super(name, options);

            this.events.registerNames(EVENT_NAMES$2);

            /**
             * Tile url source template.
             * @public
             * @type {string}
             */
            this.url = options.url || "";

            /**
             * @protected
             */
            this._s = options.subdomains || ["a", "b", "c"];

            /**
             * Minimal native zoom level when tiles are available.
             * @public
             * @type {number}
             */
            this.minNativeZoom = options.minNativeZoom || 0;

            /**
             * Maximal native zoom level when tiles are available.
             * @public
             * @type {number}
             */
            this.maxNativeZoom = options.maxNativeZoom || 19;

            /**
             * @protected
             */
            this._crossOrigin = options.crossOrigin === undefined ? "" : options.crossOrigin;

            /**
             * Rewrites imagery tile url query.
             * @private
             * @callback og.layer.XYZ~_urlRewriteCallback
             * @param {Segment} segment - Segment to load.
             * @param {string} url - Created url.
             * @returns {string} - Url query string.
             */
            this._urlRewriteCallback = options.urlRewrite || null;
        }

        get isIdle() {
            return !this._planet || this._planet._tileLoader.isIdle(this);
        }

        get instanceName() {
            return "XYZ";
        }

        /**
         * Abort loading tiles.
         * @public
         */
        abortLoading() {
            if (this._planet) {
                this._planet._tileLoader.abort();
            }
        }

        /**
         * Sets layer visibility.
         * @public
         * @param {boolean} visibility - Layer visibility.
         */
        setVisibility(visibility) {
            if (visibility !== this._visibility) {
                super.setVisibility(visibility);

                if (!visibility) {
                    this.abortLoading();
                }
            }
        }

        /**
         * Sets imagery tiles url source template.
         * @public
         * @param {string} url - Url template.
         * @example
         * http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png
         * where {z}, {x} and {y} - replaces by current tile values, {s} - random domen.
         */
        setUrl(url) {
            this.url = url;
        }

        _checkSegment(segment) {
            return segment._projection.id === EPSG3857.id;
        }

        /**
         * Start to load tile material.
         * @public
         * @virtual
         * @param {Material} material - Loads current material.
         */
        loadMaterial(material, forceLoading) {
            let seg = material.segment;

            if (this._isBaseLayer) {
                material.texture = seg.getDefaultTexture();
            } else {
                material.texture = seg.planet.transparentTexture;
            }

            // Q: Maybe we should change "<2" to material.segment.tileZoom < (material.layer.minZoom + 1)
            if (this._planet.layerLock.isFree() || material.segment.tileZoom < 2) {
                material.isReady = false;
                material.isLoading = true;

                if (this._checkSegment(seg)) {
                    material.loadingAttempts++;

                    this._planet._tileLoader.load(
                        {
                            sender: this,
                            src: this._getHTTPRequestString(material.segment),
                            type: "imageBitmap",
                            filter: () =>
                                (seg.initialized && seg.node.getState() === RENDERING) || forceLoading,
                            options: {}
                        },
                        (response) => {
                            if (response.status === "ready") {
                                if (material.isLoading) {
                                    let e = this.events.load;
                                    if (e.handlers.length) {
                                        this.events.dispatch(e, material);
                                    }
                                    material.applyImage(response.data);
                                    response.data = null;
                                }
                            } else if (response.status === "abort") {
                                material.isLoading = false;
                            } else if (response.status === "error") {
                                if (material.isLoading) {
                                    material.textureNotExists();
                                }
                            }
                        },
                        this._id
                    );
                } else {
                    material.textureNotExists();
                }
            }
        }

        /**
         * Creates query url.
         * @protected
         * @virtual
         * @param {Segment} segment - Creates specific url for current segment.
         * @returns {String} - Returns url string.
         */
        _createUrl(segment) {
            return stringTemplate(this.url, {
                s: this._getSubdomain(),
                x: segment.tileX.toString(),
                y: segment.tileY.toString(),
                z: segment.tileZoom.toString()
            });
        }

        _getSubdomain() {
            return this._s[Math.floor(Math.random() * this._s.length)];
        }

        /**
         * Returns actual url query string.
         * @protected
         * @param {Segment} segment - Segment that loads image data.
         * @returns {string} - Url string.
         */
        _getHTTPRequestString(segment) {
            return this._urlRewriteCallback
                ? this._urlRewriteCallback(segment, this.url)
                : this._createUrl(segment);
        }

        /**
         * Sets url rewrite callback, used for custom url rewriting for every tile laoding.
         * @public
         * @param {layer.XYZ~_urlRewriteCallback} ur - The callback that returns tile custom created url.
         */
        setUrlRewriteCallback(ur) {
            this._urlRewriteCallback = ur;
        }

        applyMaterial(material) {
            if (material.isReady) {
                return material.texOffset;
            } else if (material.segment.tileZoom <= this.minNativeZoom) {
                material.textureNotExists();
            } else {

                let segment = material.segment,
                    pn = segment.node,
                    notEmpty = false;

                let mId = this._id;
                let psegm = material;
                while (pn.parentNode) {
                    pn = pn.parentNode;
                    psegm = pn.segment.materials[mId];
                    if (psegm && psegm.textureExists) {
                        notEmpty = true;
                        break;
                    }
                }

                if (segment.passReady) {
                    let maxNativeZoom = material.layer.maxNativeZoom;
                    if (pn.segment.tileZoom === maxNativeZoom) {
                        material.textureNotExists();
                    } else if (material.segment.tileZoom <= maxNativeZoom) {
                        !material.isLoading && !material.isReady && this.loadMaterial(material);
                    } else {
                        let pn = segment.node;
                        while (pn.segment.tileZoom > material.layer.maxNativeZoom) {
                            pn = pn.parentNode;
                        }
                        let pnm = pn.segment.materials[material.layer._id];
                        if (pnm) {
                            !pnm.isLoading && !pnm.isReady && this.loadMaterial(pnm, true);
                        } else {
                            pnm = pn.segment.materials[material.layer._id] = material.layer.createMaterial(
                                pn.segment
                            );
                            this.loadMaterial(pnm, true);
                        }
                    }
                }

                if (notEmpty) {
                    material.appliedNode = pn;
                    material.appliedNodeId = pn.nodeId;
                    material.texture = psegm.texture;
                    let dZ2 = 1.0 / (2 << (segment.tileZoom - pn.segment.tileZoom - 1));
                    material.texOffset[0] = segment.tileX * dZ2 - pn.segment.tileX;
                    material.texOffset[1] = segment.tileY * dZ2 - pn.segment.tileY;
                    material.texOffset[2] = dZ2;
                    material.texOffset[3] = dZ2;
                } else {
                    material.texture = segment.planet.transparentTexture;
                    material.texOffset[0] = 0.0;
                    material.texOffset[1] = 0.0;
                    material.texOffset[2] = 1.0;
                    material.texOffset[3] = 1.0;
                }
            }

            return material.texOffset;
        }

        clearMaterial(material) {
            if (material.isReady && material.textureExists) {
                !material.texture.default &&
                    material.segment.handler.gl.deleteTexture(material.texture);
                material.texture = null;

                if (material.image) {
                    material.image.src = "";
                    material.image = null;
                }
            }

            material.isReady = false;
            material.textureExists = false;
            material.isLoading = false;
        }

        /**
         * @protected
         */
        _correctFullExtent() {
            var e = this._extent,
                em = this._extentMerc;
            var ENLARGE_MERCATOR_LON = POLE + 50000;
            var ENLARGE_MERCATOR_LAT = POLE + 50000;
            if (e.northEast.lat === 90.0) {
                em.northEast.lat = ENLARGE_MERCATOR_LAT;
            }
            if (e.northEast.lon === 180.0) {
                em.northEast.lon = ENLARGE_MERCATOR_LON;
            }
            if (e.southWest.lat === -90.0) {
                em.southWest.lat = -ENLARGE_MERCATOR_LAT;
            }
            if (e.southWest.lon === -180.0) {
                em.southWest.lon = -ENLARGE_MERCATOR_LON;
            }

            if (e.northEast.lat >= MAX_LAT) {
                e.northEast.lat = MAX_LAT;
            }

            if (e.northEast.lat <= MIN_LAT) {
                e.northEast.lat = MIN_LAT;
            }
        }
    }

    const EVENT_NAMES$2 = [
        /**
         * Triggered when current tile image has loaded before rendereing.
         * @event og.layer.XYZ#load
         */
        "load",

        /**
         * Triggered when all tiles have loaded or loading has stopped.
         * @event og.layer.XYZ#loadend
         */
        "loadend"
    ];

    /**
     * @module og/layer/WMS
     */

    /**
     * Used to display WMS services as tile layers on the globe.
     * @class
     * @extends {XYZ}
     * //TODO: WMS version, format, and custom srs cpecification.
     * @param {string} name - Layer name.
     * @param {Object} options - Options:
     * @param {number} [options.opacity=1.0] - Layer opacity.
     * @param {number} [options.minZoom=0] - Minimal visibility zoom level.
     * @param {number} [options.maxZoom=0] - Maximal visibility zoom level.
     * @param {string} [options.attribution] - Layer attribution that displayed in the attribution area on the screen.
     * @param {boolean} [options.isBaseLayer=false] - Base layer flag.
     * @param {boolean} [options.visibility=true] - Layer visibility.
     * @param {string} options.url - WMS url source.
     * @param {number} [options.width=256] - Tile width.
     * @param {number} [options.height=256] - Tile height.
     * @param {string} options.layers - WMS layers string.
     * @param {string} [options.version="1.1.1"] - WMS version.
     * @example:
     * new og.layer.WMS("USA States", {
     *     isBaseLayer: false,
     *     url: "http://openglobus.org/geoserver/",
     *     layers: "topp:states",
     *     opacity: 0.5,
     *     zIndex: 50,
     *     attribution: 'USA states - geoserver WMS example',
     *     version: "1.1.1",
     *     visibility: false }
     * );
     *
     * @fires og.layer.XYZ#load
     * @fires og.layer.XYZ#loadend
     */
    class WMS extends XYZ {
        constructor(name, options) {
            super(name, options);

            if (!options.extent) {
                this.setExtent(new Extent(new LonLat(-180.0, -90), new LonLat(180.0, 90)));
            }

            /**
             * WMS layers string.
             * @public
             * @type {string}
             */
            this.layers = options.layers;

            /**
             * WMS tile width.
             * @public
             * @type {number}
             */
            this.imageWidth = options.imageWidth || 256;

            /**
             * WMS tile height.
             * @public
             * @type {number}
             */
            this.imageHeight = options.imageHeight || 256;

            this._getBbox = WMS.get_bbox_v1_1_1;

            this.setVersion(options.version);
        }

        static createRequestUrl(
            url,
            layers,
            format = "image/png",
            version = "1.1.1",
            request = "GetMap",
            srs,
            bbox,
            width = 256,
            height = 256
        ) {
            return `${url}/wms?LAYERS=${layers}&FORMAT=${format}&SERVICE=WMS&VERSION=${version}&REQUEST=${request}
        &SRS=${srs}&BBOX=${bbox}&WIDTH=${width}&HEIGHT=${height}`;
        }

        static get_bbox_v1_1_1(extent) {
            return (
                extent.getWest() +
                "," +
                extent.getSouth() +
                "," +
                extent.getEast() +
                "," +
                extent.getNorth()
            );
        }

        static get_bbox_v1_3_0(extent) {
            return (
                extent.getSouth() +
                "," +
                extent.getWest() +
                "," +
                extent.getNorth() +
                "," +
                extent.getEast()
            );
        }

        _checkSegment(segment) {
            return true;
        }

        get instanceName() {
            return "WMS";
        }

        _createUrl(segment) {
            return WMS.createRequestUrl(
                this.url,
                this.layers,
                "image/png",
                this._version,
                "GetMap",
                segment._projection.code,
                this._getBbox(segment.getExtent()),
                this.imageWidth,
                this.imageHeight
            );
        }

        setVersion(version) {
            if (version) {
                this._version = version;
            } else {
                this._version = "1.1.1";
            }

            if (this._version === "1.1.1") {
                this._getBbox = WMS.get_bbox_v1_1_1;
            } else if (version === "1.3.0") {
                this._getBbox = WMS.get_bbox_v1_3_0;
            }
        }

        _correctFullExtent() {
            var e = this._extent,
                em = this._extentMerc;
            var ENLARGE_MERCATOR_LON = POLE + 50000;
            var ENLARGE_MERCATOR_LAT = POLE + 50000;
            if (e.northEast.lat === 90.0) {
                em.northEast.lat = ENLARGE_MERCATOR_LAT;
            }
            if (e.northEast.lon === 180.0) {
                em.northEast.lon = ENLARGE_MERCATOR_LON;
            }
            if (e.southWest.lat === -90.0) {
                em.southWest.lat = -ENLARGE_MERCATOR_LAT;
            }
            if (e.southWest.lon === -180.0) {
                em.southWest.lon = -ENLARGE_MERCATOR_LON;
            }
        }
    }

    var layer = /*#__PURE__*/Object.freeze({
        __proto__: null,
        CanvasTiles: CanvasTiles,
        GeoImage: GeoImage,
        GeoTexture2d: GeoTexture2d,
        GeoVideo: GeoVideo,
        KML: KML,
        Layer: Layer$1,
        Vector: Vector,
        WMS: WMS,
        XYZ: XYZ
    });

    var index$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Box: Box,
        Sphere: Sphere$1
    });

    /**
     * @module og/scene/Axes
     */

    class Axes extends RenderNode {
        constructor(size) {
            super("Axes");

            this.size = size || 100;
            this.axesBuffer = null;
            this.axesColorBuffer = null;
        }

        init() {
            this.createAxisBuffer(this.size);
            this.drawMode = this.renderer.handler.gl.LINES;
            this.renderer.handler.addProgram(new Program("axesShader", {
                uniforms: {
                    projectionViewMatrix: 'mat4'
                },
                attributes: {
                    aVertexPosition: 'vec3',
                    aVertexColor: 'vec4'
                },
                vertexShader:
                    `attribute vec3 aVertexPosition;
            attribute vec4 aVertexColor;
            uniform mat4 projectionViewMatrix;
            varying vec4 vColor;
            void main(void) {
                gl_Position = projectionViewMatrix * vec4(aVertexPosition, 1.0);
                vColor = aVertexColor;
            }`,
                fragmentShader:
                    `precision highp float;
            varying vec4 vColor;
            void main(void) {
                gl_FragColor = vColor;
            }`
            }));
        }

        frame() {

            this.renderer.handler.programs.axesShader.activate().set({
                projectionViewMatrix: this.renderer.activeCamera.getProjectionViewMatrix(),
                aVertexPosition: this.axisBuffer,
                aVertexColor: this.axisColorBuffer
            });

            this.renderer.handler.programs.axesShader.drawArrays(this.drawMode, this.axisBuffer.numItems);
        }

        createAxisBuffer(gridSize) {

            var vertices = [
                0.0, 0.0, 0.0, gridSize - 1, 0.0, 0.0, // x - R
                0.0, 0.0, 0.0, 0.0, gridSize - 1, 0.0, // y - B  
                0.0, 0.0, 0.0, 0.0, 0.0, gridSize - 1  // z - G
            ];

            var colors = [
                1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0,   // x - R
                0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0,   // y - B
                0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0    // z - G
            ];

            this.axisBuffer = this.renderer.handler.createArrayBuffer(new Float32Array(vertices), 3, 6);
            this.axisColorBuffer = this.renderer.handler.createArrayBuffer(new Float32Array(colors), 4, 6);
        }
    }

    /**
     * @module og/shaders/skybox
     */

    function skybox() {
        return new Program("skybox", {
            uniforms: {
                projectionViewMatrix: { type: types$1.MAT4 },
                uSampler: { type: types$1.SAMPLERCUBE },
                pos: { type: types$1.VEC3 }
            },
            attributes: {
                aVertexPosition: { type: types$1.VEC3, enableArray: true }
            },
            vertexShader:
                `attribute vec3 aVertexPosition;
            uniform mat4 projectionViewMatrix;
            uniform vec3 pos;
            varying vec3 vTextureCoord;
            void main(void) {
                vTextureCoord = aVertexPosition;
                gl_Position = projectionViewMatrix * vec4(aVertexPosition + pos, 1.0);
            }`,
            fragmentShader:
                `precision lowp float;
            varying vec3 vTextureCoord;
            uniform samplerCube uSampler;
            void main(void) {
                gl_FragColor = textureCube(uSampler, vTextureCoord);
            }`
        });
    }

    /**
     * @module og/scene/SkyBox
     */

    class SkyBox extends RenderNode {
        constructor(params) {
            super("skybox");
            this.params = params;
            this.vertexPositionBuffer = null;
            this.texture = null;
        }

        static createDefault(RESOURCES_URL) {
            return new SkyBox({
                nx: RESOURCES_URL + "skybox/gal/_nx.jpg",
                px: RESOURCES_URL + "skybox/gal/_px.jpg",
                py: RESOURCES_URL + "skybox/gal/_py.jpg",
                ny: RESOURCES_URL + "skybox/gal/_ny.jpg",
                pz: RESOURCES_URL + "skybox/gal/_pz.jpg",
                nz: RESOURCES_URL + "skybox/gal/_nz.jpg"
            });
        }

        init() {
            this.renderer.handler.addProgram(skybox(), true);
            this.texture = this.renderer.handler.loadCubeMapTexture(this.params);
            this._createBuffers();
            this.drawMode = this.renderer.handler.gl.TRIANGLES;
        }

        frame() {
            var h = this.renderer.handler;
            var gl = h.gl;
            var cam = this.renderer.activeCamera;
            gl.disable(h.gl.DEPTH_TEST);

            h.programs.skybox.activate();
            var sh = h.programs.skybox._program;
            var shu = sh.uniforms;
            gl.uniformMatrix4fv(shu.projectionViewMatrix, false, cam.getProjectionViewMatrix());
            gl.uniform3fv(shu.pos, cam.eye.toVec());
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
            gl.uniform1i(shu.uSampler, 0);
            var buf = this.vertexPositionBuffer;
            gl.bindBuffer(gl.ARRAY_BUFFER, buf);
            gl.vertexAttribPointer(sh.attributes.aVertexPosition, buf.itemSize, gl.FLOAT, false, 0, 0);

            gl.drawArrays(this.drawMode, 0, buf.numItems);
            h.gl.enable(h.gl.DEPTH_TEST);
        }

        _createBuffers() {

            var vertices = new Float32Array([
                -100000000.0, 100000000.0, -100000000.0,
                -100000000.0, -100000000.0, -100000000.0,
                100000000.0, -100000000.0, -100000000.0,
                100000000.0, -100000000.0, -100000000.0,
                100000000.0, 100000000.0, -100000000.0,
                -100000000.0, 100000000.0, -100000000.0,

                -100000000.0, -100000000.0, 100000000.0,
                -100000000.0, -100000000.0, -100000000.0,
                -100000000.0, 100000000.0, -100000000.0,
                -100000000.0, 100000000.0, -100000000.0,
                -100000000.0, 100000000.0, 100000000.0,
                -100000000.0, -100000000.0, 100000000.0,

                100000000.0, -100000000.0, -100000000.0,
                100000000.0, -100000000.0, 100000000.0,
                100000000.0, 100000000.0, 100000000.0,
                100000000.0, 100000000.0, 100000000.0,
                100000000.0, 100000000.0, -100000000.0,
                100000000.0, -100000000.0, -100000000.0,

                -100000000.0, -100000000.0, 100000000.0,
                -100000000.0, 100000000.0, 100000000.0,
                100000000.0, 100000000.0, 100000000.0,
                100000000.0, 100000000.0, 100000000.0,
                100000000.0, -100000000.0, 100000000.0,
                -100000000.0, -100000000.0, 100000000.0,

                -100000000.0, 100000000.0, -100000000.0,
                100000000.0, 100000000.0, -100000000.0,
                100000000.0, 100000000.0, 100000000.0,
                100000000.0, 100000000.0, 100000000.0,
                -100000000.0, 100000000.0, 100000000.0,
                -100000000.0, 100000000.0, -100000000.0,

                -100000000.0, -100000000.0, -100000000.0,
                -100000000.0, -100000000.0, 100000000.0,
                100000000.0, -100000000.0, -100000000.0,
                100000000.0, -100000000.0, -100000000.0,
                -100000000.0, -100000000.0, 100000000.0,
                100000000.0, -100000000.0, 100000000.0
            ]);

            this.vertexPositionBuffer = this.renderer.handler.createArrayBuffer(vertices, 3, vertices.length / 3);
        }
    }

    var index$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Planet: Planet,
        Axes: Axes,
        SkyBox: SkyBox
    });

    var entity = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Entity: Entity$1,
        EntityCollection: EntityCollection$1,
        Billboard: Billboard,
        Geometry: Geometry,
        Label: Label,
        PointCloud: PointCloud,
        Polyline: Polyline
    });

    /**
     * @module og/Clock
     */

    /**
     * Class represents application timer that stores custom current julian datetime, and time speed multiplier.
     * @class
     * @param {Object} [params] - Clock parameters:
     * @param {number} [params.startDate=0.0] - Julian start date.
     * @param {number} [params.endDate=0.0] - Julian end date.
     * @param {number} [params.currentDate] - Julian current date. Default: current date.
     * @param {number} [params.multiplier=1.0] - Time speed multiolier.
     */
    class Clock {
        static get _staticCounter() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set _staticCounter(n) {
            this._counter = n;
        }

        /**
         *
         * @param {Object} [params] - Clock parameters:
         */
        constructor(params) {
            params = params || {};

            this._id = Clock._staticCounter++;

            /**
             * Clock name.
             * @public
             * @type {string}
             */
            this.name = params.name || "";

            /**
             * Clock events.
             * @public
             * @type {Events}
             */
            this.events = new Events(["tick", "end"], this);

            /**
             * Start julian date clock loop.
             * @public
             * @type {number}
             */
            this.startDate = params.startDate || 0;

            /**
             * End julian date clock loop.
             * @public
             * @type {number}
             */
            this.endDate = params.endDate || 0;

            var currentDate = params.currentDate || DateToUTC(new Date());
            if (params.startDate && currentDate < params.startDate) {
                currentDate = params.startDate;
            }
            if (params.endDate && currentDate > params.endDate) {
                currentDate = params.endDate;
            }

            /**
             * Current julian datetime.
             * @public
             * @type {number}
             */
            this.currentDate = currentDate;

            /**
             * Timer speed multiplier.
             * @public
             * @type {number}
             */
            this.multiplier = params.multiplier !== undefined ? params.multiplier : 1.0;

            /**
             * Animation frame delta time.
             * @public
             * @readonly
             * @type {number}
             */
            this.deltaTicks = 0;

            /**
             * Timer activity.
             * @public
             * @type {boolean}
             */
            this.active = true;

            this._intervalDelay = 0;
            this._intervalStart = 0;
            this._intervalCallback = null;
        }

        clearInterval() {
            this._intervalDelay = 0;
            this._intervalStart = 0;
            this._intervalCallback = null;
        }

        setInterval(delay, callback) {
            this._intervalStart = this.currentDate;
            this._intervalDelay = delay * ONE_BY_MILLISECONDS_PER_DAY;
            this._intervalCallback = callback;
        }

        /**
         * Sets current clock datetime.
         * @public
         * @param {Object} date - JavaScript Date object.
         */
        setDate(date) {
            var d = DateToUTC(date);
            if (this.startDate && d < this.startDate) {
                d = this.startDate;
            }
            if (this.endDate && d > this.endDate) {
                d = this.endDate;
            }
            this.currentDate = d;
        }

        /**
         * Returns current application date.
         * @public
         * @returns {Date} - Current date.
         */
        getDate() {
            return UTCtoDate(this.currentDate);
        }

        reset() {
            if (this.startDate) {
                this.currentDate = this.startDate;
            }
        }

        _tick(dt) {
            this.deltaTicks = dt * this.multiplier;
            if (this.active) {
                var cd = addMilliseconds(this.currentDate, this.deltaTicks);
                if (this.multiplier > 0) {
                    if (this.endDate && cd > this.endDate) {
                        this.currentDate = this.startDate;
                        this.events.dispatch(this.events.end, this);
                    } else {
                        this.currentDate = cd;
                    }
                } else {
                    if (this.startDate && cd < this.startDate) {
                        this.currentDate = this.endDate;
                        this.events.dispatch(this.events.end, this);
                    } else {
                        this.currentDate = cd;
                    }
                }

                if (this._intervalCallback) {
                    if (this.currentDate - this._intervalStart >= this._intervalDelay) {
                        this._intervalStart = this.currentDate;
                        this._intervalCallback(this);
                    }
                }

                this.events.dispatch(this.events.tick, this);
            }
        }

        /**
         * @public
         * @param {Clock} clock - Clock instance to compare.
         * @returns {boolean} - Returns true if a clock is the same instance.
         */
        equal(clock) {
            return this._id === clock._id;
        }
    }

    /**
     * This is shader program controller that used by hadler object to access the shader
     * program capabilities, like switching program during the rendering.
     * Get access to the program from ...handler.programs.<program name> etc.
     * @class
     */
    class ProgramController {
        /**
         *
         * @param {Handler} handler - Handler.
         * @param {Program} program - Shader program.
         */
        constructor(handler, program) {
            /**
             * Shader program.
             * @private
             * @type {Program}
             */
            this._program = program;

            /**
             * Handler.
             * @private
             * @type {Handler}
             */
            this._handler = handler;

            /**
             * Program current frame activation flag.
             * @private
             * @type {boolean}
             */
            this._activated = false;
        }

        /**
         * Lazy create program call.
         * @public
         */
        initialize() {
            this._program.createProgram(this._handler.gl);
        }

        /**
         * Returns controller's shader program.
         * @public
         * @return {Program} -
         */
        getProgram() {
            return this._program;
        }

        /**
         * Activates current shader program.
         * @public
         * @returns {ProgramController} -
         */
        activate() {
            if (!this._activated) {
                this._handler.activeProgram.deactivate();
                this._handler.activeProgram = this;
                var p = this._program;
                this._activated = true;
                p.enableAttribArrays();
                p.use();
            }
            return this;
        }

        /**
         * Remove program from handler
         * @public
         */
        remove() {
            var p = this._handler.programs;
            if (p[this._program.name]) {
                if (this._activated) {
                    this.deactivate();
                }
                this._program.delete();
                p[this._program.name] = null;
                delete p[this._program.name];
            }
        }

        /**
         * Deactivate shader program. This is not necessary while activae function used.
         * @public
         */
        deactivate() {
            this._program.disableAttribArrays();
            this._activated = false;
        }

        /**
         * Returns program activity.
         * @public
         * @return {boolean} -
         */
        isActive() {
            return this._activated;
        }

        /**
         * Sets program uniforms and attributes values and return controller instance.
         * @public
         * @param {Object} params - Object with variable name and value like { value: 12, someArray:[1,2,3], uSampler: texture,... }
         * @return {ProgramController} -
         */
        set(params) {
            this.activate();
            this._program.set(params);
            return this;
        }

        /**
         * Draw index buffer with this program.
         * @public
         * @param {number} mode - Gl draw mode
         * @param {WEBGLBuffer} buffer - Buffer to draw.
         * @return {ProgramController} Returns current shader controller instance.
         */
        drawIndexBuffer(mode, buffer) {
            this._program.drawIndexBuffer(mode, buffer);
            return this;
        }

        /**
         * Calls Gl drawArray function.
         * @param {number} mode - Gl draw mode.
         * @param {number} numItems - draw items count.
         * @return {ProgramController} Returns current shader controller instance.
         */
        drawArrays(mode, numItems) {
            this._program.drawArrays(mode, numItems);
            return this;
        }
    }

    /**
     * @module og/Stack
     */

    class Node {
        constructor() {
            this.next = null;
            this.prev = null;
            this.data = null;
        }
    }

    class Stack {
        /**
         *
         * @param {number} [size]
         */
        constructor(size = 256) {
            this._current = new Node();
            this._head = this._current;

            for (var i = 0; i < size; i++) {
                var n = new Node();
                n.prev = this._current;
                this._current.next = n;
                this._current = n;
            }
            this._current = this._head;
        }

        current() {
            return this._current;
        }

        push(data) {
            this._current = this._current.next;
            this._current.data = data;
        }

        pop(data) {
            this._current = this._current.prev;
            return this._current.next.data;
        }

        popPrev(data) {
            this._current = this._current.prev;
            return this._current.data;
        }
    }

    /**
     * @module og/webgl/Handler
     */

    const vendorPrefixes = ["", "WEBKIT_", "MOZ_"];

    const CONTEXT_TYPE = ["webgl2", "webgl"];

    // Maximal mipmap levels
    const MAX_LEVELS = 2;

    /**
     * A WebGL handler for accessing low-level WebGL capabilities.
     * @class
     * @param {string} id - Canvas element id that WebGL handler assing with. If it's null
     * or undefined creates hidden canvas and handler bacomes hidden.
     * @param {Object} [params] - Handler options:
     * @param {number} [params.anisotropy] - Anisotropy filter degree. 8 is default.
     * @param {number} [params.width] - Hidden handler width. 256 is default.
     * @param {number} [params.height] - Hidden handler height. 256 is default.
     * @param {Array.<string>} [params.extensions] - Additional WebGL extension list. Available by default: EXT_texture_filter_anisotropic.
     */
    class Handler$1 {
        constructor(id, params) {
            params = params || {};

            /**
             * Application default timer.
             * @public
             * @type {Clock}
             */
            this.defaultClock = new Clock();

            /**
             * Custom timers.
             * @protected
             * @type{Clock[]}
             */
            this._clocks = [];

            /**
             * Draw frame time in milliseconds.
             * @public
             * @readonly
             * @type {number}
             */
            this.deltaTime = 0;

            /**
             * WebGL rendering canvas element.
             * @public
             * @type {Object}
             */
            this.canvas = null;

            /**
             * WebGL context.
             * @public
             * @type {Object}
             */
            this.gl = null;

            /**
             * Shader program controller list.
             * @public
             * @type {Object.<og.webgl.ProgramController>}
             */
            this.programs = {};

            /**
             * Current active shader program controller.
             * @public
             * @type {ProgramController}
             */
            this.activeProgram = null;

            /**
             * Handler parameters.
             * @private
             * @type {Object}
             */
            this._params = params || {};
            this._params.anisotropy = this._params.anisotropy || 4;
            this._params.width = this._params.width || 256;
            this._params.height = this._params.height || 256;
            this._params.pixelRatio = this._params.pixelRatio || 1.0;
            this._params.context = this._params.context || {};
            this._params.extensions = this._params.extensions || [];
            this._oneByHeight = 1.0 / (this._params.height * this._params.pixelRatio);

            /**
             * Current WebGL extensions. Becomes here after context initialization.
             * @public
             * @type {Object}
             */
            this.extensions = {};

            /**
             * HTML Canvas object id.
             * @private
             * @type {Object}
             */
            this._id = id;

            this._lastAnimationFrameTime = 0;

            this._initialized = false;

            /**
             * Animation frame function assigned from outside(Ex. from Renderer).
             * @private
             * @type {frameCallback}
             */
            this._frameCallback = function () {
            };

            this.transparentTexture = null;

            this.framebufferStack = new Stack();

            this.createTexture = {
                "NEAREST": null,
                "LINEAR": null,
                "MIPMAP": null,
                "ANISOTROPIC": null
            };

            this.createTextureDefault = null;

            if (params.autoActivate || isEmpty(params.autoActivate)) {
                this.initialize();
            }

            this.createTexture_n = this.gl.type === "webgl2" ? this.createTexture_n_webgl2 : this.createTexture_n_webgl1;
        }

        /**
         * The return value is null if the extension is not supported, or an extension object otherwise.
         * @param {Object} gl - WebGl context pointer.
         * @param {String} name - Extension name.
         * @returns {Object} -
         */
        static getExtension(gl, name) {
            let i, ext;
            for (i in vendorPrefixes) {
                ext = gl.getExtension(vendorPrefixes[i] + name);
                if (ext) {
                    return ext;
                }
            }
            return null;
        }

        /**
         * Returns a drawing context on the canvas, or null if the context identifier is not supported.
         * @param {Object} canvas - HTML canvas object.
         * @param {Object} [contextAttributes] - See canvas.getContext contextAttributes.
         * @returns {Object} -
         */
        static getContext(canvas, contextAttributes) {
            let ctx = null;

            try {
                for (let i = 0; i < CONTEXT_TYPE.length; i++) {
                    ctx = canvas.getContext(CONTEXT_TYPE[i], contextAttributes);
                    if (ctx) {
                        console.log(CONTEXT_TYPE[i]);
                        ctx.type = CONTEXT_TYPE[i];
                        break;
                    }
                }
            } catch (ex) {
                cons.logErr("exception during the GL context initialization");
            }

            if (!ctx) {
                cons.logErr("could not initialise WebGL");
            }

            return ctx;
        }

        /**
         * Sets animation frame function.
         * @public
         * @param {callback} callback - Frame callback.
         */
        setFrameCallback(callback) {
            callback && (this._frameCallback = callback);
        }

        /**
         * Creates empty texture.
         * @public
         * @param {Number} [width=1] - Specifies the width of the texture image..
         * @param {Number} [height=1] - Specifies the width of the texture image..
         * @param {String} [filter="NEAREST"] - Specifies GL_TEXTURE_MIN(MAX)_FILTER texture value.
         * @param {String} [internalFormat="RGBA"] - Specifies the color components in the texture.
         * @param {String} [format="RGBA"] - Specifies the format of the texel data.
         * @param {String} [type="UNSIGNED_BYTE"] - Specifies the data type of the texel data.
         * @param {Number} [levels=0] - Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
         * @returns {Object} - WebGL texture object.
         */
        createEmptyTexture2DExt(
            width = 1,
            height = 1,
            filter = "NEAREST",
            internalFormat = "RGBA",
            format = "RGBA",
            type = "UNSIGNED_BYTE",
            level = 0
        ) {
            let gl = this.gl;
            let texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

            gl.texImage2D(
                gl.TEXTURE_2D,
                level,
                gl[internalFormat.toUpperCase()],
                width,
                height,
                0,
                gl[format.toUpperCase()],
                gl[type.toUpperCase()],
                null
            );

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl[filter.toUpperCase()]);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl[filter.toUpperCase()]);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            gl.bindTexture(gl.TEXTURE_2D, null);
            return texture;
        }

        /**
         * Creates Empty NEAREST filtered texture.
         * @public
         * @param {number} width - Empty texture width.
         * @param {number} height - Empty texture height.
         * @returns {Object} - WebGL texture object.
         */
        createEmptyTexture_n(width, height, internalFormat) {
            let gl = this.gl;
            let texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat || gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);
            return texture;
        }

        /**
         * Creates empty LINEAR filtered texture.
         * @public
         * @param {number} width - Empty texture width.
         * @param {number} height - Empty texture height.
         * @returns {Object} - WebGL texture object.
         */
        createEmptyTexture_l(width, height, internalFormat) {
            let gl = this.gl;
            let texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat || gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);
            return texture;
        }

        /**
         * Creates NEAREST filter texture.
         * @public
         * @param {Object} image - Image or Canvas object.
         * @returns {Object} - WebGL texture object.
         */
        createTexture_n_webgl1(image, internalFormat) {
            var gl = this.gl;
            var texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat || gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);
            return texture;
        }

        /**
         * Creates LINEAR filter texture.
         * @public
         * @param {Object} image - Image or Canvas object.
         * @returns {Object} - WebGL texture object.
         */
        createTexture_l_webgl1(image, internalFormat) {
            let gl = this.gl;
            let texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);

            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat || gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);
            return texture;
        }

        /**
         * Creates MIPMAP filter texture.
         * @public
         * @param {Object} image - Image or Canvas object.
         * @returns {Object} - WebGL texture object.
         */
        createTexture_mm_webgl1(image, internalFormat) {
            let gl = this.gl;
            let texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat || gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

            gl.generateMipmap(gl.TEXTURE_2D);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);
            return texture;
        }

        /**
         * Creates ANISOTROPY filter texture.
         * @public
         * @param {Object} image - Image or Canvas object.
         * @returns {Object} - WebGL texture object.
         */
        createTexture_a_webgl1(image, internalFormat) {
            let gl = this.gl;
            let texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat || gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

            gl.generateMipmap(gl.TEXTURE_2D);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
            gl.texParameterf(gl.TEXTURE_2D, this.extensions.EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._params.anisotropy);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);
            return texture;
        }

        /**
         * Creates NEAREST filter texture.
         * @public
         * @param {Object} image - Image or Canvas object.
         * @returns {Object} - WebGL texture object.
         */
        createTexture_n_webgl2(image, internalFormat) {
            var gl = this.gl;
            var texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

            gl.texStorage2D(gl.TEXTURE_2D, 1, internalFormat || gl.RGBA8, image.width, image.height);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, gl.RGBA, gl.UNSIGNED_BYTE, image);

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);
            return texture;
        }

        /**
         * Creates LINEAR filter texture.
         * @public
         * @param {Object} image - Image or Canvas object.
         * @returns {Object} - WebGL texture object.
         */
        createTexture_l_webgl2(image, internalFormat) {
            let gl = this.gl;
            let texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);

            gl.texStorage2D(gl.TEXTURE_2D, 1, internalFormat || gl.RGBA8, image.width, image.height);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, gl.RGBA, gl.UNSIGNED_BYTE, image);

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);
            return texture;
        }

        /**
         * Creates MIPMAP filter texture.
         * @public
         * @param {Object} image - Image or Canvas object.
         * @returns {Object} - WebGL texture object.
         */
        createTexture_mm_webgl2(image, internalFormat) {
            let gl = this.gl;
            let texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

            gl.texStorage2D(gl.TEXTURE_2D, MAX_LEVELS, internalFormat || gl.RGBA8, image.width, image.height);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, gl.RGBA, gl.UNSIGNED_BYTE, image);

            gl.generateMipmap(gl.TEXTURE_2D);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);
            return texture;
        }

        /**
         * Creates ANISOTROPY filter texture.
         * @public
         * @param {Object} image - Image or Canvas object.
         * @returns {Object} - WebGL texture object.
         */
        createTexture_a_webgl2(image, internalFormat) {
            let gl = this.gl;
            let texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

            gl.texStorage2D(gl.TEXTURE_2D, MAX_LEVELS, internalFormat || gl.RGBA8, image.width, image.height);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, gl.RGBA, gl.UNSIGNED_BYTE, image);

            gl.generateMipmap(gl.TEXTURE_2D);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
            gl.texParameterf(gl.TEXTURE_2D, this.extensions.EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._params.anisotropy);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);
            return texture;
        }

        /**
         * Creates cube texture.
         * @public
         * @param {Object.<string>} params - Face image urls:
         * @param {string} params.px - Positive X or right image url.
         * @param {string} params.nx - Negative X or left image url.
         * @param {string} params.py - Positive Y or up image url.
         * @param {string} params.ny - Negative Y or bottom image url.
         * @param {string} params.pz - Positive Z or face image url.
         * @param {string} params.nz - Negative Z or back image url.
         * @returns {Object} - WebGL texture object.
         */
        loadCubeMapTexture(params) {
            let gl = this.gl;
            let texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

            let faces = [
                [params.px, gl.TEXTURE_CUBE_MAP_POSITIVE_X],
                [params.nx, gl.TEXTURE_CUBE_MAP_NEGATIVE_X],
                [params.py, gl.TEXTURE_CUBE_MAP_POSITIVE_Y],
                [params.ny, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y],
                [params.pz, gl.TEXTURE_CUBE_MAP_POSITIVE_Z],
                [params.nz, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]
            ];

            let imageCanvas = new ImageCanvas();
            imageCanvas.fillEmpty();
            let emptyImage = imageCanvas.getImage();

            for (let i = 0; i < faces.length; i++) {
                let face = faces[i][1];
                gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
                gl.texImage2D(face, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, emptyImage);
            }

            for (let i = 0; i < faces.length; i++) {
                let face = faces[i][1];
                let image = new Image();
                image.crossOrigin = "";
                image.onload = (function (texture, face, image) {
                    return function () {
                        gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
                        gl.texImage2D(face, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                    };
                })(texture, face, image);
                image.src = faces[i][0];
            }
            return texture;
        }

        /**
         * Adds shader program to the handler.
         * @public
         * @param {Program} program - Shader program.
         * @param {boolean} [notActivate] - If it's true program will not compile.
         * @return {Program} -
         */
        addProgram(program, notActivate) {
            if (!this.programs[program.name]) {
                let sc = new ProgramController(this, program);
                this.programs[program.name] = sc;
                this._initProgramController(sc);
                if (notActivate) {
                    sc._activated = false;
                }
            } else {
                console.log(
                    "og.webgl.Handler:284 - shader program: '" + program.name + "' is allready exists."
                );
            }
            return program;
        }

        /**
         * Removes shader program from handler.
         * @public
         * @param {String} name - Shader program name.
         */
        removeProgram(name) {
            this.programs[name] && this.programs[name].remove();
        }

        /**
         * Adds shader programs to the handler.
         * @public
         * @param {Array.<Program>} programsArr - Shader program array.
         */
        addPrograms(programsArr) {
            for (let i = 0; i < programsArr.length; i++) {
                this.addProgram(programsArr[i]);
            }
        }

        /**
         * Used in addProgram
         * @private
         * @param {ProgramController} sc - Program controller
         */
        _initProgramController(sc) {
            if (this._initialized) {
                sc.initialize();
                if (!this.activeProgram) {
                    this.activeProgram = sc;
                    sc.activate();
                } else {
                    sc.deactivate();
                    this.activeProgram._program.enableAttribArrays();
                    this.activeProgram._program.use();
                }
            }
        }

        /**
         * Used in init function.
         * @private
         */
        _initPrograms() {
            for (let p in this.programs) {
                this._initProgramController(this.programs[p]);
            }
        }

        /**
         * Initialize additional WebGL extensions.
         * @public
         * @param {string} extensionStr - Extension name.
         * @param {boolean} showLog - Show logging.
         * @return {Object} -
         */
        initializeExtension(extensionStr, showLog) {
            if (!(this.extensions && this.extensions[extensionStr])) {
                let ext = Handler$1.getExtension(this.gl, extensionStr);
                if (ext) {
                    this.extensions[extensionStr] = ext;
                } else if (showLog) {
                    console.log(
                        "og.webgl.Handler: extension '" + extensionStr + "' doesn't initialize."
                    );
                }
            }
            return this.extensions && this.extensions[extensionStr];
        }

        /**
         * Main function that initialize handler.
         * @public
         */
        initialize() {
            if (this._id) {
                this.canvas = document.getElementById(this._id);
            } else {
                this.canvas = document.createElement("canvas");
                this.canvas.width = this._params.width;
                this.canvas.height = this._params.height;
            }

            this.gl = Handler$1.getContext(this.canvas, this._params.context);
            this._initialized = true;

            /** Sets deafult extensions */
            this._params.extensions.push("EXT_texture_filter_anisotropic");

            if (this.gl.type === "webgl") {
                this._params.extensions.push("OES_standard_derivatives");
                this._params.extensions.push("OES_element_index_uint");
                this._params.extensions.push("WEBGL_depth_texture");
                this._params.extensions.push("ANGLE_instanced_arrays");
                //this._params.extensions.push("EXT_frag_depth");
            } else {
                this._params.extensions.push("EXT_color_buffer_float");
                this._params.extensions.push("OES_texture_float_linear");
            }

            let i = this._params.extensions.length;
            while (i--) {
                this.initializeExtension(this._params.extensions[i], true);
            }

            if (this.gl.type === "webgl") {
                this.createTexture_n = this.createTexture_n_webgl1.bind(this);
                this.createTexture_l = this.createTexture_l_webgl1.bind(this);
                this.createTexture_mm = this.createTexture_mm_webgl1.bind(this);
                this.createTexture_a = this.createTexture_a_webgl1.bind(this);
            } else {
                this.createTexture_n = this.createTexture_n_webgl2.bind(this);
                this.createTexture_l = this.createTexture_l_webgl2.bind(this);
                this.createTexture_mm = this.createTexture_mm_webgl2.bind(this);
                this.createTexture_a = this.createTexture_a_webgl2.bind(this);
            }

            this.createTexture["NEAREST"] = this.createTexture_n;
            this.createTexture["LINEAR"] = this.createTexture_l;
            this.createTexture["MIPMAP"] = this.createTexture_mm;
            this.createTexture["ANISOTROPIC"] = this.createTexture_a;

            if (!this.extensions.EXT_texture_filter_anisotropic) {
                this.createTextureDefault = this.createTexture_mm;
            } else {
                this.createTextureDefault = this.createTexture_a;
            }

            /** Initilalize shaders and rendering parameters*/
            this._initPrograms();
            this._setDefaults();
        }

        /**
         * Sets default gl render parameters. Used in init function.
         * @private
         */
        _setDefaults() {
            let gl = this.gl;
            gl.depthFunc(gl.LESS);
            gl.enable(gl.DEPTH_TEST);
            this.setSize(
                this.canvas.clientWidth || this._params.width,
                this.canvas.clientHeight || this._params.height
            );
            gl.frontFace(gl.CCW);
            gl.cullFace(gl.BACK);
            gl.enable(gl.CULL_FACE);
            gl.disable(gl.BLEND);
            this.createDefaultTexture({ color: "rgba(0,0,0,0.0)" }, (t) => {
                this.transparentTexture = t;
            });
        }

        /**
         * Creates STREAM_DRAW ARRAY buffer.
         * @public
         * @param {Array.<number>} array - Input array.
         * @param {number} itemSize - Array item size.
         * @param {number} numItems - Items quantity.
         * @param {number} [usage=STATIC_DRAW] - Parameter of the bufferData call can be one of STATIC_DRAW, DYNAMIC_DRAW, or STREAM_DRAW.
         * @return {Object} -
         */
        createStreamArrayBuffer(itemSize, numItems, usage, bites = 4) {
            let buffer = this.gl.createBuffer();
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
            this.gl.bufferData(
                this.gl.ARRAY_BUFFER,
                numItems * itemSize * bites,
                usage || this.gl.STREAM_DRAW
            );
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
            buffer.itemSize = itemSize;
            buffer.numItems = numItems;
            return buffer;
        }

        /**
         * Load stream ARRAY buffer.
         * @public
         * @param {Array.<number>} array - Input array.
         * @param {number} itemSize - Array item size.
         * @param {number} numItems - Items quantity.
         * @param {number} [usage=STATIC_DRAW] - Parameter of the bufferData call can be one of STATIC_DRAW, DYNAMIC_DRAW, or STREAM_DRAW.
         * @return {Object} -
         */
        setStreamArrayBuffer(buffer, array, offset = 0) {
            let gl = this.gl;
            gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
            gl.bufferSubData(this.gl.ARRAY_BUFFER, offset, array);
            gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
            return buffer;
        }

        /**
         * Creates ARRAY buffer.
         * @public
         * @param {Array.<number>} array - Input array.
         * @param {number} itemSize - Array item size.
         * @param {number} numItems - Items quantity.
         * @param {number} [usage=STATIC_DRAW] - Parameter of the bufferData call can be one of STATIC_DRAW, DYNAMIC_DRAW, or STREAM_DRAW.
         * @return {Object} -
         */
        createArrayBuffer(array, itemSize, numItems, usage) {
            let buffer = this.gl.createBuffer();
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, array, usage || this.gl.STATIC_DRAW);
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
            buffer.itemSize = itemSize;
            buffer.numItems = numItems;
            return buffer;
        }

        /**
         * Creates ARRAY buffer specific length.
         * @public
         * @param {Array.<number>} array - Input array.
         * @param {number} itemSize - Array item size.
         * @param {number} numItems - Items quantity.
         * @param {number} [usage=STATIC_DRAW] - Parameter of the bufferData call can be one of STATIC_DRAW, DYNAMIC_DRAW, or STREAM_DRAW.
         * @return {Object} -
         */
        createArrayBufferLength(size, usage) {
            let buffer = this.gl.createBuffer();
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, size, usage || this.gl.STATIC_DRAW);
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
            buffer.itemSize = 1;
            buffer.numItems = size;
            return buffer;
        }

        /**
         * Creates ELEMENT ARRAY buffer.
         * @public
         * @param {Array.<number>} array - Input array.
         * @param {number} itemSize - Array item size.
         * @param {number} numItems - Items quantity.
         * @param {number} [usage=STATIC_DRAW] - Parameter of the bufferData call can be one of STATIC_DRAW, DYNAMIC_DRAW, or STREAM_DRAW.
         * @return {Object} -
         */
        createElementArrayBuffer(array, itemSize, numItems, usage) {
            let buffer = this.gl.createBuffer();
            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, buffer);
            this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, array, usage || this.gl.STATIC_DRAW);
            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);
            buffer.itemSize = itemSize;
            buffer.numItems = numItems || array.length;
            return buffer;
        }

        /**
         * Sets handler canvas size.
         * @public
         * @param {number} w - Canvas width.
         * @param {number} h - Canvas height.
         */
        setSize(w, h) {
            this._params.width = w;
            this._params.height = h;
            this.canvas.width = w * this._params.pixelRatio;
            this.canvas.height = h * this._params.pixelRatio;

            this._oneByHeight = 1.0 / this.canvas.height;

            this.gl && this.gl.viewport(0, 0, w, h);
            this.onCanvasResize && this.onCanvasResize(this.canvas);
        }

        get pixelRatio() {
            return this._params.pixelRatio;
        }

        set pixelRatio(pr) {
            this._params.pixelRatio = pr;
            this.setSize(this._params.width, this._params.height);
        }

        /**
         * Returns context screen width.
         * @public
         * @returns {number} -
         */
        getWidth() {
            return this.canvas.width;
        }

        /**
         * Returns context screen height.
         * @public
         * @returns {number} -
         */
        getHeight() {
            return this.canvas.height;
        }

        /**
         * Returns canvas aspect ratio.
         * @public
         * @returns {number} -
         */
        getClientAspect() {
            return this.canvas.clientWidth / this.canvas.clientHeight;
        }

        /**
         * Returns screen center coordinates.
         * @public
         * @returns {number} -
         */
        getCenter() {
            let c = this.canvas;
            return new Vec2(Math.round(c.width * 0.5), Math.round(c.height * 0.5));
        }

        /**
         * Draw single frame.
         * @public
         * @param {number} now - Frame current time milliseconds.
         */
        drawFrame() {
            /** Calculating frame time */
            let now = window.performance.now();
            this.deltaTime = now - this._lastAnimationFrameTime;
            this._lastAnimationFrameTime = now;

            this.defaultClock._tick(this.deltaTime);

            for (let i = 0; i < this._clocks.length; i++) {
                this._clocks[i]._tick(this.deltaTime);
            }

            /** Canvas resize checking */
            let canvas = this.canvas;

            if (Math.floor(canvas.clientWidth * this._params.pixelRatio) !== canvas.width || Math.floor(canvas.clientHeight * this._params.pixelRatio) !== canvas.height) {
                this.setSize(canvas.clientWidth, canvas.clientHeight);
            }

            /** Draw frame */
            this._frameCallback();
        }

        /**
         * Clearing gl frame.
         * @public
         */
        clearFrame() {
            let gl = this.gl;
            this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        }

        /**
         * Starts animation loop.
         * @public
         */
        start() {
            if (!this._requestAnimationFrameId && this._initialized) {
                this._lastAnimationFrameTime = window.performance.now();
                this.defaultClock.setDate(new Date());
                this._animationFrameCallback();
            }
        }

        stop() {
            if (this._requestAnimationFrameId) {
                window.cancelAnimationFrame(this._requestAnimationFrameId);
                this._requestAnimationFrameId = null;
            }
        }

        /**
         * Check is gl context type equals webgl2
         * @public
         */
        isWebGl2() {
            return this.gl.type === "webgl2"
        }

        /**
         * Make animation.
         * @private
         */
        _animationFrameCallback() {
            this._requestAnimationFrameId = window.requestAnimationFrame(() => {
                this.drawFrame();
                this._animationFrameCallback();
            });
        }

        /**
         * Creates default texture object
         * @public
         * @param {Object} [params] - Texture parameters:
         * @param {callback} [success] - Creation callback
         */
        createDefaultTexture(params, success) {
            let imgCnv;
            let texture;
            this.isWebGl2();

            if (params && params.color) {
                imgCnv = new ImageCanvas(2, 2);
                imgCnv.fillColor(params.color);
                texture = this.createTexture_n(imgCnv._canvas);
                texture.default = true;
                success(texture);
            } else if (params && params.url) {
                let img = new Image();
                let that = this;
                img.onload = function () {
                    texture = that.createTexture(this);
                    texture.default = true;
                    success(texture);
                };
                img.src = params.url;
            } else {
                imgCnv = new ImageCanvas(2, 2);
                imgCnv.fillColor("#C5C5C5");
                texture = this.createTexture_n(imgCnv._canvas);
                texture.default = true;
                success(texture);
            }
        }

        /**
         * @public
         */
        destroy() {
            let gl = this.gl;

            this.stop();

            for (let p in this.programs) {
                this.removeProgram(p);
            }

            gl.deleteTexture(this.transparentTexture);
            this.transparentTexture = null;

            this.framebufferStack = null;
            this.framebufferStack = new Stack();

            if (this.canvas.parentNode) {
                this.canvas.parentNode.removeChild(this.canvas);
            }
            this.canvas.width = 1;
            this.canvas.height = 1;
            this.canvas = null;

            let numAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
            let tmp = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, tmp);
            for (let ii = 0; ii < numAttribs; ++ii) {
                gl.disableVertexAttribArray(ii);
                gl.vertexAttribPointer(ii, 4, gl.FLOAT, false, 0, 0);
                gl.vertexAttrib1f(ii, 0);
            }
            gl.deleteBuffer(tmp);

            let numTextureUnits = gl.getParameter(gl.MAX_TEXTlURE_IMAGE_UNITS);
            for (let ii = 0; ii < numTextureUnits; ++ii) {
                gl.activeTexture(gl.TEXTURE0 + ii);
                gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
                gl.bindTexture(gl.TEXTURE_2D, null);
            }

            gl.activeTexture(gl.TEXTURE0);
            gl.useProgram(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            gl.disable(gl.BLEND);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.DEPTH_TEST);
            gl.disable(gl.DITHER);
            gl.disable(gl.SCISSOR_TEST);
            gl.blendColor(0, 0, 0, 0);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.ONE, gl.ZERO);
            gl.clearColor(0, 0, 0, 0);
            gl.clearDepth(1);
            gl.clearStencil(-1);

            this.gl = null;

            this._initialized = false;
        }

        addClock(clock) {
            if (!clock.__handler) {
                clock.__handler = this;
                this._clocks.push(clock);
            }
        }

        addClocks(clockArr) {
            for (let i = 0; i < clockArr.length; i++) {
                this.addClock(clockArr[i]);
            }
        }

        removeClock(clock) {
            if (clock.__handler) {
                let c = this._clocks;
                let i = c.length;
                while (i--) {
                    if (c[i].equal(clock)) {
                        clock.__handler = null;
                        c.splice(i, 1);
                        break;
                    }
                }
            }
        }
    }

    /**
     * @module og/webgl/Multisample
     */

    /**
     * Class represents multisample framebuffer.
     * @class
     * @param {Handler} handler - WebGL handler.
     * @param {Object} [options] - Framebuffer options:
     * @param {number} [options.width] - Framebuffer width. Default is handler canvas width.
     * @param {number} [options.height] - Framebuffer height. Default is handler canvas height.
     * @param {Object} [options.texture] - Texture to render.
     * @param {String} [options.depthComponent="DEPTH_COMPONENT16"] - Specifies depth buffer size.
     * @param {Boolean} [options.useDepth] - Using depth buffer during the rendering.
     */
    class Multisample {
        constructor(handler, options) {
            options = options || {};

            /**
             * WebGL handler.
             * @public
             * @type {Handler}
             */
            this.handler = handler;

            this._internalFormat = options.internalFormat
                ? options.internalFormat.toUpperCase()
                : "RGBA8";

            /**
             * Framebuffer object.
             * @private
             * @type {Object}
             */
            this._fbo = null;

            /**
             * Renderbuffer object.
             * @private
             * @type {Object}
             */
            this._depthRenderbuffer = null;

            /**
             * Framebuffer width.
             * @private
             * @type {number}
             */
            this._width = options.width || handler.canvas.width;

            /**
             * Framebuffer width.
             * @private
             * @type {number}
             */
            this._height = options.height || handler.canvas.height;

            this._msaa = options.msaa != undefined ? options.msaa : 4;

            this._useDepth = options.useDepth != undefined ? options.useDepth : true;

            this._depthComponent =
                options.depthComponent != undefined ? options.depthComponent : "DEPTH_COMPONENT16";

            /**
             * Framebuffer activity.
             * @private
             * @type {boolean}
             */
            this._active = false;

            this._size = options.size || 1;

            this._filter = options.filter || "NEAREST";

            this._glFilter = null;

            this.renderbuffers = new Array(this._size);
        }

        destroy() {
            var gl = this.handler.gl;

            for (var i = 0; i < this.renderbuffers.length; i++) {
                gl.deleteRenderbuffer(this.renderbuffers[i]);
            }
            this.renderbuffers = new Array(this._size);

            gl.deleteFramebuffer(this._fbo);
            gl.deleteRenderbuffer(this._depthRenderbuffer);

            this._depthRenderbuffer = null;
            this._fbo = null;

            this._active = false;
        }

        /**
         * Framebuffer initialization.
         * @private
         */
        init() {
            var gl = this.handler.gl;

            this._glFilter = gl[this._filter];

            this._fbo = gl.createFramebuffer();

            gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);

            let colorAttachments = [];
            for (var i = 0; i < this.renderbuffers.length; i++) {
                let rb = gl.createRenderbuffer();
                gl.bindRenderbuffer(gl.RENDERBUFFER, rb);
                gl.renderbufferStorageMultisample(
                    gl.RENDERBUFFER,
                    this._msaa,
                    gl[this._internalFormat],
                    this._width,
                    this._height
                );
                gl.framebufferRenderbuffer(
                    gl.FRAMEBUFFER,
                    gl.COLOR_ATTACHMENT0 + i,
                    gl.RENDERBUFFER,
                    rb
                );
                colorAttachments.push(gl.COLOR_ATTACHMENT0 + i);
                this.renderbuffers[i] = rb;
                gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            }
            gl.drawBuffers(colorAttachments);

            if (this._useDepth) {
                this._depthRenderbuffer = gl.createRenderbuffer();
                gl.bindRenderbuffer(gl.RENDERBUFFER, this._depthRenderbuffer);
                gl.renderbufferStorageMultisample(
                    gl.RENDERBUFFER,
                    this._msaa,
                    gl[this._depthComponent],
                    this._width,
                    this._height
                );
                gl.framebufferRenderbuffer(
                    gl.FRAMEBUFFER,
                    gl.DEPTH_ATTACHMENT,
                    gl.RENDERBUFFER,
                    this._depthRenderbuffer
                );
                gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            }

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            return this;
        }

        blitTo(framebuffer, attachmentIndex = 0) {
            let gl = this.handler.gl;

            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._fbo);
            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer._fbo);
            gl.readBuffer(gl.COLOR_ATTACHMENT0 + attachmentIndex);

            gl.clearBufferfv(gl.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);

            gl.blitFramebuffer(
                0,
                0,
                this._width,
                this._height,
                0,
                0,
                framebuffer._width,
                framebuffer._height,
                gl.COLOR_BUFFER_BIT,
                this._glFilter
            );

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
        }

        /**
         * Sets framebuffer viewport size.
         * @public
         * @param {number} width - Framebuffer width.
         * @param {number} height - Framebuffer height.
         */
        setSize(width, height, forceDestroy) {
            this._width = width;
            this._height = height;

            if (this._active) {
                this.handler.gl.viewport(0, 0, this._width, this._height);
            }

            if (this._useDepth || forceDestroy) {
                this.destroy();
                this.init();
            }
        }

        /**
         * Returns framebuffer completed.
         * @public
         * @returns {boolean} -
         */
        isComplete() {
            var gl = this.handler.gl;
            if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
                return true;
            }
            return false;
        }

        /**
         * Activate framebuffer frame to draw.
         * @public
         * @returns {Framebuffer} Returns Current framebuffer.
         */
        activate() {
            var gl = this.handler.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
            gl.viewport(0, 0, this._width, this._height);
            this._active = true;
            var c = this.handler.framebufferStack.current().data;
            c && (c._active = false);
            this.handler.framebufferStack.push(this);
            return this;
        }

        /**
         * Deactivate framebuffer frame.
         * @public
         */
        deactivate() {
            var h = this.handler,
                gl = h.gl;

            //Q: check for this._useDepth ?

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            this._active = false;

            var f = this.handler.framebufferStack.popPrev();

            if (f) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, f._fbo);
                gl.viewport(0, 0, f._width, f._height);
            } else {
                gl.viewport(0, 0, h.canvas.width, h.canvas.height);
            }
        }
    }

    var webgl = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Framebuffer: Framebuffer,
        Handler: Handler$1,
        Multisample: Multisample,
        types: types$1,
        Program: Program
    });

    /**
     * @module og/terrainProvider/EmptyTerrain
     */

    /**
     * Class represents terrain provider without elevation data.
     * @class
     */
    class EmptyTerrain {
        constructor(options = {}) {
            this.equalizeVertices = false;

            this.equalizeNormals = false;

            this.isEmpty = true;

            /**
             * Provider name is "empty"
             * @public
             * @type {string}
             */
            this.name = "empty";

            /**
             * Minimal z-index value for segment elevation data handling.
             * @public
             * @type {number}
             */
            this.minZoom = 1000000;

            /**
             * Maximal z-index value for segment elevation data handling.
             * @public
             * @type {number}
             */
            this.maxZoom = 21;

            /**
             * @public
             * @type {Array.<number>}
             */
            this.gridSizeByZoom = options.gridSizeByZoom || [
                32, 16, 16, 8, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
            ];
            //this.gridSizeByZoom = options.gridSizeByZoom || [32, 16, 16, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2];

            this._maxNodeZoom = this.gridSizeByZoom.length - 1;

            /**
             * Elevation grid size. Currend is 2x2 is the smallest grid size.
             * @public
             * @type {number}
             */
            this.plainGridSize = 2;

            /**
             * Planet node.
             * @protected
             * @type {Planet}
             */
            this._planet = null;

            this._geoid =
                options.geoid ||
                new Geoid({
                    src: options.geoidSrc || null
                });

            this._isReady = false;

            // const _ellToAltFn = [
            //     (lon, lat, alt, callback) => callback(alt),
            //     (lon, lat, alt, callback) => callback(alt - this._geoid.getHeight(lon, lat)),
            //     (lon, lat, alt, callback) => {

            //         let x = mercator.getTileX(lon, zoom),
            //             y = mercator.getTileY(lat, zoom);

            //         let mslAlt = alt - this._geoid.getHeight(lon, lat);

            //         if (true) {

            //         } else {

            //         }

            //         return callback(mslAlt);
            //     },
            // ];
        }

        static checkNoDataValue(noDataValues, value) {
            return binarySearchFast(noDataValues, value) !== -1;
        }

        isBlur() {
            return false;
        }

        set maxNodeZoom(val) {
            if (val > this.gridSizeByZoom.length - 1) {
                val = this.gridSizeByZoom.length - 1;
            }
            this._maxNodeZoom = val;
        }

        get maxNodeZoom() {
            return this._maxNodeZoom;
        }

        set geoid(geoid) {
            this._geoid = geoid;
        }

        get geoid() {
            return this._geoid;
        }

        getGeoid() {
            return this._geoid;
        }

        /**
         * Loads or creates segment elevation data.
         * @public
         * @virtual
         * @param {Segment} segment - Segment to create elevation data.
         */
        handleSegmentTerrain(segment) {
            segment.terrainIsLoading = false;
            segment.terrainReady = true;
            segment.terrainExists = true;
        }

        isReady() {
            return this._isReady;
        }

        /**
         * Abstract function
         * @public
         * @abstract
         */
        abortLoading() {
        }

        /**
         * Abstract function
         * @public
         * @abstract
         */
        clearCache() {
        }

        getHeightAsync(lonLat, callback) {
            callback(0);
            return true;
        }
    }

    /**
     * Datasource http://www.viewfinderpanoramas.org/ srtm 3 arc second
     */

    const EVENT_NAMES$1 = [
        /**
         * Triggered when current elevation tile has loaded but before rendereing.
         * @event og.terrain.GlobusTerrain#load
         */
        "load",

        /**
         * Triggered when all elevation tiles have loaded or loading has stopped.
         * @event og.terrain.GlobusTerrain#loadend
         */
        "loadend"
    ];

    /**
     * Class that loads segment elevation data, converts it to the array and passes it to the planet segment.
     * @class
     * @extends {EmptyTerrain}
     * @param {string} [name=""] - Terrain provider name.
     * @param {Object} [options] - Provider options:
     * @param {number} [options.minZoom=3] - Minimal visible zoom index when terrain handler works.
     * @param {number} [options.minZoom=14] - Maximal visible zoom index when terrain handler works.
     * @param {string} [options.url="//openglobus.org/heights/srtm3/{z}/{y}/{x}.ddm"] - Terrain source path url template. Default is openglobus ddm elevation file.
     * @param {Array.<number>} [options.gridSizeByZoom] - Array of segment triangulation grid sizes where array index agreed to the segment zoom index.
     * @param {number} [options.plainGridSize=32] - Elevation grid size. Default is 32x32. Must be power of two.
     * @param {string} [options.responseType="arraybuffer"] - Ajax responce type.
     * @param {number} [options.MAX_LOADING_TILES] - Maximum at one time loading tiles.
     * @param {Array.<number>} [gridSizeByZoom] - Array of values, where each value corresponds to the size of a tile(or segment) on the globe. Each value must be power of two.
     * @fires og.terrain.GlobusTerrain#load
     * @fires og.terrain.GlobusTerrain#loadend
     */
    class GlobusTerrain extends EmptyTerrain {
        /**
         * @param {string} [name]
         * @param {*} [options]
         */
        constructor(name, options = {}) {
            super({ geoidSrc: "//openglobus.org/geoid/egm84-30.pgm", ...options });

            /**
             * Events handler.
             * @public
             * @type {Events}
             */
            this.events = new Events(EVENT_NAMES$1, this);

            this.isEmpty = false;

            this.equalizeNormals = true;

            /**
             * Provider name.
             * @public
             * @type {string}
             */
            this.name = name || "";

            /**
             * Minimal visible zoom index when terrain handler works.
             * @public
             * @type {number}
             */
            this.minZoom = options.minZoom || 2;

            /**
             * Maximal visible zoom index when terrain handler works.
             * @public
             * @type {number}
             */
            this.maxZoom = options.maxZoom || 14;

            /**
             * Terrain source path url template.
             * 9th March 2022 - Robert PASTOR
             * @public
             * @type {string}
             */
            //this.url = options.url || "//srtm3.openglobus.org/{z}/{y}/{x}.ddm";
            this.url = options.url;

            /**
             * Array of segment triangulation grid sizes where array index agreed to the segment zoom index.
             * @public
             * @type {Array.<number>}
             */
            this.gridSizeByZoom = options.gridSizeByZoom || [
                64, 32, 32, 16, 16, 8, 8, 8, 8, 16, 16, 16, 16, 32, 32, 16, 8, 4, 2, 2, 2, 2, 2, 2
            ];

            this.noDataValues = options.noDataValues || [];

            /**
             * Elevation tile grid size.
             * @public
             * @type {number}
             */
            this.plainGridSize = options.plainGridSize || 32;

            this._extent = createExtent(
                options.extent,
                new Extent(new LonLat(-180.0, -90.0), new LonLat(180.0, 90.0))
            );

            this._dataType = "arrayBuffer";

            this._maxNodeZoom = this.gridSizeByZoom.length - 1;

            this._elevationCache = {};

            this._fetchCache = {};

            this._loader = new Loader();

            /**
             * Rewrites elevation storage url query.
             * @private
             * @callback og.terrain.GlobusTerrain~_urlRewriteCallback
             * @param {Segment} segment - Segment to load.
             * @param {string} url - Created url.
             * @returns {string} - Url query string.
             */
            this._urlRewriteCallback = options.urlRewrite || null;
        }

        clearCache() {
            //?
            for (let c in this._elevationCache) {
                this._elevationCache[c].heights = null;
                this._elevationCache[c].extent = null;
                delete this._elevationCache[c];
            }
            this._elevationCache = null;
            this._elevationCache = {};

            //?
            for (let c in this._fetchCache) {
                this._fetchCache[c] = null;
                delete this._fetchCache[c];
            }
            this._fetchCache = null;
            this._fetchCache = {};
        }

        isBlur(segment) {
            if (segment.tileZoom >= 8) {
                return true;
            }
            return false;
        }

        getHeightAsync(lonLat, callback, zoom) {
            if (!lonLat || lonLat.lat > MAX_LAT || lonLat.lat < MIN_LAT) {
                callback(0);
                return true;
            }

            let z = zoom || this.maxZoom,
                z2 = Math.pow(2, z),
                size = POLE2 / z2,
                merc = forward(lonLat),
                x = Math.floor((POLE + merc.lon) / size),
                y = Math.floor((POLE - merc.lat) / size);

            let tileIndex = Layer$1.getTileIndex(x, y, z);

            let cache = this._elevationCache[tileIndex];

            if (cache) {
                if (!cache.heights) {
                    callback(0);
                } else {
                    callback(this._getGroundHeightMerc(merc, cache));
                }
                return true;
            } else {
                if (!this._fetchCache[tileIndex]) {
                    let url = stringTemplate(this.url, {
                        x: x,
                        y: y,
                        z: z
                    });
                    this._fetchCache[tileIndex] = this._loader.fetch({
                        src: url,
                        type: this._dataType
                    });
                }

                this._fetchCache[tileIndex].then((response) => {

                    let extent = getTileExtent(x, y, z);

                    if (response.status === "ready") {
                        let cache = {
                            heights: this._createHeights(response.data, tileIndex, x, y, z, extent),
                            extent: extent
                        };
                        this._elevationCache[tileIndex] = cache;
                        callback(this._getGroundHeightMerc(merc, cache));
                    } else if (response.status === "error") {
                        let cache = {
                            heights: null,
                            extent: extent
                        };
                        this._elevationCache[tileIndex] = cache;
                        callback(0);
                    } else {
                        this._fetchCache[tileIndex] = null;
                        delete this._fetchCache[tileIndex];
                    }
                });
            }

            return false;
        }

        getTileCache(lonLat, z) {
            if (!lonLat || lonLat.lat > MAX_LAT || lonLat.lat < MIN_LAT) {
                return;
            }

            let z2 = Math.pow(2, z),
                size = POLE2 / z2,
                merc = forward(lonLat),
                x = Math.floor((POLE + merc.lon) / size),
                y = Math.floor((POLE - merc.lat) / size);

            let tileIndex = Layer$1.getTileIndex(x, y, z);

            return this._elevationCache[tileIndex];
        }

        _getGroundHeightMerc(merc, tileData) {
            if (!(tileData.extent && tileData.heights)) {
                return 0;
            }

            let w = tileData.extent.getWidth(),
                gs = Math.sqrt(tileData.heights.length);

            let size = w / (gs - 1);

            /*
            v2-----------v3
            |            |
            |            |
            |            |
            v0-----------v1
            */

            let i = gs - Math.ceil((merc.lat - tileData.extent.southWest.lat) / size) - 1,
                j = Math.floor((merc.lon - tileData.extent.southWest.lon) / size);

            let v0Ind = (i + 1) * gs + j,
                v1Ind = v0Ind + 1,
                v2Ind = i * gs + j,
                v3Ind = v2Ind + 1;

            let h0 = tileData.heights[v0Ind],
                h1 = tileData.heights[v1Ind],
                h2 = tileData.heights[v2Ind],
                h3 = tileData.heights[v3Ind];

            let v0 = new Vec3(
                tileData.extent.southWest.lon + size * j,
                h0,
                tileData.extent.northEast.lat - size * i - size
            ),
                v1 = new Vec3(v0.x + size, h1, v0.z),
                v2 = new Vec3(v0.x, h2, v0.z + size),
                v3 = new Vec3(v0.x + size, h3, v0.z + size);

            let xyz = new Vec3(merc.lon, 100000.0, merc.lat),
                ray = new Ray$1(xyz, new Vec3(0, -1, 0));

            let res = new Vec3();
            let d = ray.hitTriangle(v0, v1, v2, res);

            if (d === Ray$1.INSIDE) {
                return res.y;
            }

            d = ray.hitTriangle(v1, v3, v2, res);
            if (d === Ray$1.INSIDE) {
                return res.y;
            }
        }

        /**
         * Stop loading.
         * @public
         */
        abortLoading() {
            this._loader.abort();
        }

        /**
         * Sets terrain data url template.
         * @public
         * @param {string} url - Url template.
         * @example <caption>Default openglobus url template:</caption>:
         * "http://earth3.openglobus.org/{z}/{y}/{x}.ddm"
         */
        setUrl(url) {
            this.url = url;
        }

        /**
         * Sets provider name.
         * @public
         * @param {string} name - Name.
         */
        setName(name) {
            this.name = name;
        }

        isReadyToLoad(segment) {
            return (
                segment._projection.id === EPSG3857.id &&
                this._extent.overlaps(segment.getExtentLonLat())
            );
        }

        /**
         * Starts to load segment data.
         * @public
         * @virtual
         * @param {Segment} segment - Segment that wants a terrain data.
         * @param {boolean} forceLoading
         */
        loadTerrain(segment, forceLoading) {
            if (this._planet.terrainLock.isFree()) {
                segment.terrainReady = false;
                segment.terrainIsLoading = true;
                if (this.isReadyToLoad(segment)) {
                    let cache = this._elevationCache[segment.tileIndex];
                    if (cache) {
                        this._applyElevationsData(segment, cache.heights);
                    } else {
                        this._loader.load(
                            {
                                src: this._getHTTPRequestString(segment),
                                segment: segment,
                                type: this._dataType,
                                filter: () =>
                                    (segment.plainReady && segment.node.getState() !== NOTRENDERING) ||
                                    forceLoading
                            },
                            (response) => {
                                if (response.status === "ready") {

                                    let heights = this._createHeights(response.data,
                                        segment.tileIndex,
                                        segment.tileX, segment.tileY, segment.tileZoom,
                                        segment.getExtent()
                                    );

                                    this._elevationCache[segment.tileIndex] = {
                                        heights: heights,
                                        extent: segment.getExtent()
                                    };

                                    this._applyElevationsData(segment, heights);

                                } else if (response.status === "abort") {
                                    segment.terrainIsLoading = false;
                                } else if (response.status === "error") {
                                    this._applyElevationsData(segment, null);
                                } else {
                                    segment.terrainIsLoading = false;
                                }
                            }
                        );
                    }
                } else {
                    segment.elevationsNotExists();
                }
            } else {
                segment.terrainIsLoading = false;
            }
        }

        /**
         * Creates query url.
         * @protected
         * @virtual
         * @param {Segment} segment -
         * @returns {string} -
         */
        _createUrl(segment) {
            return stringTemplate(this.url, {
                x: segment.tileX.toString(),
                y: segment.tileY.toString(),
                z: segment.tileZoom.toString()
            });
        }

        /**
         * Returns actual url query string.
         * @protected
         * @param {Segment} segment - Segment that loads image data.
         * @returns {string} - Url string.
         */
        _getHTTPRequestString(segment) {
            return this._urlRewriteCallback
                ? this._urlRewriteCallback(segment, this.url)
                : this._createUrl(segment);
        }

        /**
         * Sets url rewrite callback, used for custom url rewriting for every tile laoding.
         * @public
         * @param {GlobusTerrain~_urlRewriteCallback} ur - The callback that returns tile custom created url.
         */
        setUrlRewriteCallback(ur) {
            this._urlRewriteCallback = ur;
        }

        /**
         * Converts loaded data to segment elevation data type(columr major elevation data array in meters)
         * @public
         * @virtual
         * @param {*} data - Loaded elevation data.
         * @returns {Array.<number>} -
         */
        _createHeights(data) {
            return new Float32Array(data);
        }

        /**
         * @protected
         * @param {Segment} segment -
         * @param {*} data -
         */
        _applyElevationsData(segment, elevations) {
            if (segment) {
                var e = this.events.load;
                if (e.handlers.length) {
                    this.events.dispatch(e, {
                        elevations: elevations,
                        segment: segment
                    });
                }
                segment.applyTerrain(elevations);
            }
        }
    }

    const KEY =
        "pk.eyJ1IjoiZm94bXVsZGVyODMiLCJhIjoiY2pqYmR3dG5oM2Z1bzNrczJqYm5pODhuNSJ9.Y4DRmEPhb-XSlCR9CAXACQ";

    class MapboxTerrain extends GlobusTerrain {
        constructor(name, options = {}) {
            super(name, options);

            this.equalizeVertices =
                options.equalizeVertices != undefined ? options.equalizeVertices : true;

            this.equalizeNormals = options.equalizeNormals || false;

            this.minZoom = options.minZoom != undefined ? options.minZoom : 2;

            this.maxZoom = options.maxZoom != undefined ? options.maxZoom : 17;

            this.gridSizeByZoom = options.gridSizeByZoom || [
                64, 32, 16, 8, 8, 8, 8, 16, 16, 16, 16, 16, 32, 16, 32, 16, 32, 16, 32, 16, 8, 4
            ];

            this.url =
                options.url != undefined
                    ? options.url
                    : `//api.mapbox.com/v4/mapbox.terrain-rgb/{z}/{x}/{y}.pngraw?access_token=${
                    options.key || KEY
                }`;

            this.noDataValues = options.noDataValues || [-65537, -10000];

            this.plainGridSize = options.plainGridSize || 128;

            this._dataType = "imageBitmap";

            this._imageSize = options.imageSize || 256;

            this._ctx = this._createTemporalCanvas(this._imageSize);
        }

        isBlur(segment) {
            if (segment.tileZoom >= 13) {
                return true;
            }
            return false;
        }

        _createTemporalCanvas(size) {
            let canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;
            return canvas.getContext("2d");
        }

        _createHeights(data, tileIndex, tileX, tileY, tileZoom, extent) {
            const SIZE = data.width;

            this._ctx.clearRect(0, 0, SIZE, SIZE);
            this._ctx.drawImage(data, 0, 0);
            let rgbaData = this._ctx.getImageData(0, 0, SIZE, SIZE).data;

            //
            //Non power of two images
            //
            if (!isPowerOfTwo(this._imageSize) && SIZE === this._imageSize) {
                let outCurrenElevations = new Float32Array(SIZE * SIZE);
                extractElevationTilesMapboxNonPowerOfTwo(rgbaData, outCurrenElevations);
                return outCurrenElevations;
            }

            // TODO:
            //if (this._imageSize === this.plainGridSize) {
            //    let elevationsSize = (this.plainGridSize + 1) * (this.plainGridSize + 1);
            //    let d = SIZE / this.plainGridSize;

            //    let outCurrenElevations = new Float32Array(elevationsSize);

            //    for (let i = 0, len = outCurrenElevations.length; i < len; i++) {
            //        let i4 = i * 4;
            //        outCurrenElevations[i] = -10000 + 0.1 * (rgbaData[i4] * 256 * 256 + rgbaData[i4 + 1] * 256 + rgbaData[i4 + 2]);
            //    }

            //    return outCurrenElevations;
            //}

            //
            // Power of two images
            //
            let elevationsSize = (this.plainGridSize + 1) * (this.plainGridSize + 1);
            let d = SIZE / this.plainGridSize;

            let outCurrenElevations = new Float32Array(elevationsSize);
            let outChildrenElevations = new Array(d);

            for (let i = 0; i < d; i++) {
                outChildrenElevations[i] = [];
                for (let j = 0; j < d; j++) {
                    outChildrenElevations[i][j] = new Float32Array(elevationsSize);
                }
            }

            extractElevationTilesMapbox(
                rgbaData,
                this.noDataValues,
                outCurrenElevations,
                outChildrenElevations
            );

            this._elevationCache[tileIndex] = {
                heights: outCurrenElevations,
                extent: extent//segment.getExtent()
            };

            for (let i = 0; i < d; i++) {
                for (let j = 0; j < d; j++) {
                    let x = tileX * 2 + j,
                        y = tileY * 2 + i,
                        z = tileZoom + 1;
                    let tileIndex = Layer$1.getTileIndex(x, y, z);
                    this._elevationCache[tileIndex] = {
                        heights: outChildrenElevations[i][j],
                        extent: getTileExtent(x, y, z)
                    };
                }
            }

            return outCurrenElevations;
        }
    }

    function extractElevationTilesMapboxNonPowerOfTwo(rgbaData, outCurrenElevations) {
        for (let i = 0, len = outCurrenElevations.length; i < len; i++) {
            let i4 = i * 4;
            outCurrenElevations[i] =
                -10000 + 0.1 * (rgbaData[i4] * 256 * 256 + rgbaData[i4 + 1] * 256 + rgbaData[i4 + 2]);
        }
    }

    function extractElevationTilesMapbox(
        rgbaData,
        noDataValues,
        outCurrenElevations,
        outChildrenElevations
    ) {
        let destSize = Math.sqrt(outCurrenElevations.length) - 1;
        let destSizeOne = destSize + 1;
        let sourceSize = Math.sqrt(rgbaData.length / 4);
        let dt = sourceSize / destSize;

        let rightHeight = 0,
            bottomHeight = 0,
            sourceSize4 = 0;

        for (
            let k = 0, currIndex = 0, sourceDataLength = rgbaData.length / 4;
            k < sourceDataLength;
            k++
        ) {
            let k4 = k * 4;

            let height =
                -10000 + 0.1 * (rgbaData[k4] * 256 * 256 + rgbaData[k4 + 1] * 256 + rgbaData[k4 + 2]);

            let isNoDataCurrent = MapboxTerrain.checkNoDataValue(noDataValues, height),
                isNoDataRight = false,
                isNoDataBottom = false;

            let i = Math.floor(k / sourceSize),
                j = k % sourceSize;

            let tileX = Math.floor(j / destSize),
                tileY = Math.floor(i / destSize);

            let destArr = outChildrenElevations[tileY][tileX];

            let ii = i % destSize,
                jj = j % destSize;

            let destIndex = (ii + tileY) * destSizeOne + jj + tileX;

            destArr[destIndex] = height;

            if ((i + tileY) % dt === 0 && (j + tileX) % dt === 0) {
                outCurrenElevations[currIndex++] = height;
            }

            if ((j + 1) % destSize === 0 && j !== sourceSize - 1) {
                //current tile
                rightHeight =
                    -10000 +
                    0.1 * (rgbaData[k4 + 4] * 256 * 256 + rgbaData[k4 + 5] * 256 + rgbaData[k4 + 6]);

                isNoDataRight = MapboxTerrain.checkNoDataValue(noDataValues, rightHeight);

                let middleHeight = height;

                if (!(isNoDataCurrent || isNoDataRight)) {
                    middleHeight = (height + rightHeight) * 0.5;
                }

                destIndex = (ii + tileY) * destSizeOne + jj + 1;
                destArr[destIndex] = middleHeight;

                if ((i + tileY) % dt === 0) {
                    outCurrenElevations[currIndex++] = middleHeight;
                }

                //next right tile
                let rightindex = (ii + tileY) * destSizeOne + ((jj + 1) % destSize);
                outChildrenElevations[tileY][tileX + 1][rightindex] = middleHeight;
            }

            if ((i + 1) % destSize === 0 && i !== sourceSize - 1) {
                //current tile
                sourceSize4 = sourceSize * 4;

                bottomHeight =
                    -10000 +
                    0.1 *
                    (rgbaData[k4 + sourceSize4] * 256 * 256 +
                        rgbaData[k4 + sourceSize4 + 1] * 256 +
                        rgbaData[k4 + sourceSize4 + 2]);

                isNoDataBottom = MapboxTerrain.checkNoDataValue(noDataValues, bottomHeight);

                let middleHeight = (height + bottomHeight) * 0.5;

                if (!(isNoDataCurrent || isNoDataBottom)) {
                    middleHeight = (height + bottomHeight) * 0.5;
                }

                destIndex = (ii + 1) * destSizeOne + jj + tileX;
                destArr[destIndex] = middleHeight;

                if ((j + tileX) % dt === 0) {
                    outCurrenElevations[currIndex++] = middleHeight;
                }

                //next bottom tile
                let bottomindex = ((ii + 1) % destSize) * destSizeOne + jj + tileX;
                outChildrenElevations[tileY + 1][tileX][bottomindex] = middleHeight;
            }

            if (
                (j + 1) % destSize === 0 &&
                j !== sourceSize - 1 &&
                (i + 1) % destSize === 0 &&
                i !== sourceSize - 1
            ) {
                //current tile
                let rightBottomHeight =
                    -10000 +
                    0.1 *
                    (rgbaData[k4 + sourceSize4 + 4] * 256 * 256 +
                        rgbaData[k4 + sourceSize4 + 5] * 256 +
                        rgbaData[k4 + sourceSize4 + 6]);

                let isNoDataRightBottom = MapboxTerrain.checkNoDataValue(
                    noDataValues,
                    rightBottomHeight
                );

                let middleHeight = height;

                if (!(isNoDataCurrent || isNoDataRight || isNoDataBottom || isNoDataRightBottom)) {
                    middleHeight = (height + rightHeight + bottomHeight + rightBottomHeight) * 0.25;
                }

                destIndex = (ii + 1) * destSizeOne + (jj + 1);
                destArr[destIndex] = middleHeight;

                outCurrenElevations[currIndex++] = middleHeight;

                //next right tile
                let rightindex = (ii + 1) * destSizeOne;
                outChildrenElevations[tileY][tileX + 1][rightindex] = middleHeight;

                //next bottom tile
                let bottomindex = destSize;
                outChildrenElevations[tileY + 1][tileX][bottomindex] = middleHeight;

                //next right bottom tile
                let rightBottomindex = 0;
                outChildrenElevations[tileY + 1][tileX + 1][rightBottomindex] = middleHeight;
            }
        }
    }

    class BilTerrain extends GlobusTerrain {
        constructor(options) {
            super("bil", options);

            options = options || {};

            this.equalizeVertices = true;

            this.equalizeNormals = true;

            this.minZoom = options.minZoom || 2;

            this.maxZoom = options.maxZoom || 14;

            this.noDataValues = options.noDataValues || [-9999, 32767];

            this.url = options.url || "";

            this._format = "application/bil16";

            this._layers = options.layers || "";

            this._imageSize = options.imageSize || 256;

            this.plainGridSize =
                options.plainGridSize != undefined
                    ? options.plainGridSize
                    : isPowerOfTwo(this._imageSize)
                    ? this._imageSize / 2
                    : nextHighestPowerOfTwo(this._imageSize) / 2;

            this._dataType = "arrayBuffer";
        }

        isBlur(segment) {
            if (segment.tileZoom >= 18) {
                return true;
            }
            return false;
        }

        _createUrl(segment) {
            return WMS.createRequestUrl(
                this.url,
                this._layers,
                this._format,
                "1.1.1",
                "GetMap",
                segment._projection.code,
                WMS.get_bbox_v1_1_1(segment.getExtent()),
                this._imageSize,
                this._imageSize
            );
        }

        _createHeights(data, segment) {
            let bil16 = new Int16Array(data);

            //
            //Non power of two images
            //
            if (!isPowerOfTwo(this._imageSize)) {
                let outCurrenElevations = new Float32Array(bil16.length);
                //TODO: optimize
                extractElevationTilesNonPowerOfTwo(bil16, outCurrenElevations);
                return outCurrenElevations;
            }

            let elevationsSize = (this.plainGridSize + 1) * (this.plainGridSize + 1);

            let d = 4;

            let outChildrenElevations = new Array(d);

            for (let i = 0; i < d; i++) {
                outChildrenElevations[i] = [];
                for (let j = 0; j < d; j++) {
                    outChildrenElevations[i][j] = new Float32Array(elevationsSize);
                }
            }

            let outCurrenElevations = new Float32Array(elevationsSize);

            extractElevationTiles(bil16, this.noDataValues, outCurrenElevations, outChildrenElevations);

            this._elevationCache[segment.tileIndex] = {
                heights: outCurrenElevations,
                extent: segment.getExtent()
            };

            let dd = this._imageSize / this.plainGridSize;

            for (let i = 0; i < dd; i++) {
                for (let j = 0; j < dd; j++) {
                    let x = segment.tileX * 2 + j,
                        y = segment.tileY * 2 + i,
                        z = segment.tileZoom + 1;
                    let tileIndex = Layer$1.getTileIndex(x, y, z);
                    this._elevationCache[tileIndex] = {
                        heights: outChildrenElevations[i][j],
                        extent: getTileExtent(x, y, z)
                    };
                }
            }

            return outCurrenElevations;
        }
    }

    function extractElevationTilesNonPowerOfTwo(data, outCurrenElevations) {
        for (let i = 0, len = outCurrenElevations.length; i < len; i++) {
            outCurrenElevations[i] = data[i];
        }
    }

    function extractElevationTiles(data, noDataValues, outCurrenElevations, outChildrenElevations) {
        let destSize = Math.sqrt(outCurrenElevations.length) - 1;
        let destSizeOne = destSize + 1;
        let sourceSize = Math.sqrt(data.length);
        let dt = sourceSize / destSize;

        let rightHeight = 0,
            bottomHeight = 0;

        for (let k = 0, currIndex = 0, sourceDataLength = data.length; k < sourceDataLength; k++) {
            let height = data[k];

            let isNoDataCurrent = BilTerrain.checkNoDataValue(noDataValues, height),
                isNoDataRight = false,
                isNoDataBottom = false;

            let i = Math.floor(k / sourceSize),
                j = k % sourceSize;

            let tileX = Math.floor(j / destSize),
                tileY = Math.floor(i / destSize);

            let destArr = outChildrenElevations[tileY][tileX];

            let ii = i % destSize,
                jj = j % destSize;

            let destIndex = (ii + tileY) * destSizeOne + jj + tileX;

            destArr[destIndex] = height;

            if ((i + tileY) % dt === 0 && (j + tileX) % dt === 0) {
                outCurrenElevations[currIndex++] = height;
            }

            if ((j + 1) % destSize === 0 && j !== sourceSize - 1) {
                //current tile
                rightHeight = data[k];

                isNoDataRight = BilTerrain.checkNoDataValue(noDataValues, rightHeight);

                let middleHeight = height;
                if (!(isNoDataCurrent || isNoDataRight)) {
                    middleHeight = (height + rightHeight) * 0.5;
                }

                destIndex = (ii + tileY) * destSizeOne + jj + 1;
                destArr[destIndex] = middleHeight;

                if ((i + tileY) % dt === 0) {
                    outCurrenElevations[currIndex++] = middleHeight;
                }

                //next right tile
                let rightindex = (ii + tileY) * destSizeOne + ((jj + 1) % destSize);
                outChildrenElevations[tileY][tileX + 1][rightindex] = middleHeight;
            }

            if ((i + 1) % destSize === 0 && i !== sourceSize - 1) {
                //current tile
                bottomHeight = data[k + sourceSize];

                isNoDataBottom = BilTerrain.checkNoDataValue(noDataValues, bottomHeight);

                let middleHeight = height;

                if (!(isNoDataCurrent || isNoDataBottom)) {
                    middleHeight = (height + bottomHeight) * 0.5;
                }

                destIndex = (ii + 1) * destSizeOne + jj + tileX;
                destArr[destIndex] = middleHeight;

                if ((j + tileX) % dt === 0) {
                    outCurrenElevations[currIndex++] = middleHeight;
                }

                //next bottom tile
                let bottomindex = ((ii + 1) % destSize) * destSizeOne + jj + tileX;
                outChildrenElevations[tileY + 1][tileX][bottomindex] = middleHeight;
            }

            if (
                (j + 1) % destSize === 0 &&
                j !== sourceSize - 1 &&
                (i + 1) % destSize === 0 &&
                i !== sourceSize - 1
            ) {
                //current tile
                let rightBottomHeight = data[k + sourceSize + 1];

                let isNoDataRightBottom = BilTerrain.checkNoDataValue(noDataValues, rightBottomHeight);

                let middleHeight = height;

                if (!(isNoDataCurrent || isNoDataRight || isNoDataBottom || isNoDataRightBottom)) {
                    middleHeight = (height + rightHeight + bottomHeight + rightBottomHeight) * 0.25;
                }

                destIndex = (ii + 1) * destSizeOne + (jj + 1);
                destArr[destIndex] = middleHeight;

                outCurrenElevations[currIndex++] = middleHeight;

                //next right tile
                let rightindex = (ii + 1) * destSizeOne;
                outChildrenElevations[tileY][tileX + 1][rightindex] = middleHeight;

                //next bottom tile
                let bottomindex = destSize;
                outChildrenElevations[tileY + 1][tileX][bottomindex] = middleHeight;

                //next right bottom tile
                let rightBottomindex = 0;
                outChildrenElevations[tileY + 1][tileX + 1][rightBottomindex] = middleHeight;
            }
        }
    }

    var index = /*#__PURE__*/Object.freeze({
        __proto__: null,
        EmptyTerrain: EmptyTerrain,
        GlobusTerrain: GlobusTerrain,
        MapboxTerrain: MapboxTerrain,
        BilTerrain: BilTerrain
    });

    /**
     * @module og/control/ZoomControl
     */

    const scale = [
        1, 2, 3, 5, 10, 20, 30, 50, 100, 200, 300, 500, 1e3, 2e3, 3e3, 5e3, 10e3, 20e3, 30e3, 50e3,
        100e3, 200e3, 300e3, 500e3, 1000e3, 2000e3, 3000e3, 5000e3, 10000e3
    ];

    const TEMPLATE$1 = `<div class="og-scale-container">
      <div class="og-scale-label"></div>
      <div class="og-scale-ruler"></div>
    </div>`;

    /**
     * Planet zoom buttons control.
     * @class
     * @extends {Control}
     * @params {Object} [options] - Control options.
     */
    class ScaleControl extends Control$1 {
        constructor(options = {}) {
            if (!options.name || options.name === "") {
                options.name = "scaleControl";
            }
            super(options);
            options = options || {};

            this._template = TEMPLATE$1;

            this.planet = null;

            this._minWidth = 100;
            this._maxWidth = 150;
        }

        _renderTemplate() {
            return parseHTML(this._template)[0];
        }

        oninit() {
            this.el = this._renderTemplate();

            this._scaleLabelEl = this.el.querySelector(".og-scale-label");

            this.renderer.div.appendChild(this.el);

            this.renderer.events.on("draw", (e) => {
                if (e.events.pointerEvent()) {
                    this._draw();
                }
            });

            this.renderer.activeCamera.events.on("moveend", (e) => {
                this._draw(e);
            });
        }

        _draw(e) {
            let cam = this.renderer.activeCamera;
            let s0 = this.planet.renderer.handler.getCenter();
            let dist = this.planet.getDistanceFromPixel(s0);
            let p0 = cam.getForward().scaleTo(dist).addA(cam.eye);
            let tempSize = dist * Math.tan(cam._viewAngle * RADIANS);
            let p1 = p0.add(cam.getRight().scaleTo(tempSize));
            let s1 = cam.project(p1);
            this._mPx = tempSize / s1.distance(s0);

            let metersInMinSize = this._mPx * this._minWidth;

            let index = binarySearch(scale, metersInMinSize, (a, b) => a - b);
            if (index < 0) {
                index = ~index;
            }
            let minMeters = scale[index],
                maxMeters = scale[index + 1];

            let t = (minMeters - metersInMinSize) / (maxMeters - minMeters);
            this.currWidth = this._minWidth + t * (this._maxWidth - this._minWidth);

            if (minMeters > 1000) {
                this._scaleLabelEl.innerText = `${minMeters / 1000} km`;
            } else {
                this._scaleLabelEl.innerText = `${minMeters} m`;
            }

            this._metersInMinSize = metersInMinSize;

            this.el.style.width = this.currWidth + "px";
        }
    }

    /**
     * @module og/input/KeyboardHandler
     */

    class KeyboardHandler {

        constructor() {
            var _currentlyPressedKeys = {};
            var _pressedKeysCallbacks = {};
            var _unpressedKeysCallbacks = {};
            var _charkeysCallbacks = {};
            var _that = this;
            var _anykeyCallback = null;
            var _event = null;

            var _active = true;

            if (KeyboardHandler.prototype._instance) {
                return KeyboardHandler.prototype._instance;
            } else {
                KeyboardHandler.prototype._instance = this;

                document.onkeydown = function (event) { _event = event; _active && _that.handleKeyDown(); };
                document.onkeyup = function (event) { _event = event; _active && _that.handleKeyUp(); };
            }

            var _sortByPriority = function (a, b) {
                return a.priority < b.priority;
            };

            this.removeEvent = function (events, callback) {
                //
                // TODO:...
                //
            };

            this.setActivity = function (activity) {
                _active = activity;
            };

            this.releaseKeys = function () {
                _currentlyPressedKeys = {};
            };

            this.addEvent = function (event, sender, callback, keyCode, priority) {
                if (priority === undefined) {
                    priority = 1600;
                }
                switch (event) {
                    case "keyfree":
                        if (!_unpressedKeysCallbacks[keyCode]) {
                            _unpressedKeysCallbacks[keyCode] = [];
                        }
                        _unpressedKeysCallbacks[keyCode].push({ callback: callback, sender: sender, priority: priority });
                        _unpressedKeysCallbacks[keyCode].sort(_sortByPriority);
                        break;

                    case "keypress":
                        if (keyCode == null) {
                            _anykeyCallback = { callback: callback, sender: sender || _that };
                        } else {
                            if (!_pressedKeysCallbacks[keyCode]) {
                                _pressedKeysCallbacks[keyCode] = [];
                            }
                            _pressedKeysCallbacks[keyCode].push({ callback: callback, sender: sender, priority: priority });
                            _pressedKeysCallbacks[keyCode].sort(_sortByPriority);
                        }
                        break;

                    case "charkeypress":
                        if (!_charkeysCallbacks[keyCode]) {
                            _charkeysCallbacks[keyCode] = [];
                        }
                        _charkeysCallbacks[keyCode].push({ callback: callback, sender: sender, priority: priority });
                        _charkeysCallbacks[keyCode].sort(_sortByPriority);
                        break;
                }
            };

            this.isKeyPressed = function (keyCode) {
                return _currentlyPressedKeys[keyCode];
            };

            this.handleKeyDown = function () {
                _anykeyCallback && _anykeyCallback.callback.call(_anykeyCallback.sender, _event);
                _currentlyPressedKeys[_event.keyCode] = true;
                for (var ch in _charkeysCallbacks) {
                    if (String.fromCharCode(_event.keyCode) == String.fromCharCode(ch)) {
                        var ccl = _charkeysCallbacks[ch];
                        for (var i = 0; i < ccl.length; i++) {
                            ccl[i].callback.call(ccl[i].sender, _event);
                        }
                    }
                }

                if (_event.keyCode == input.KEY_ALT || _event.keyCode == input.KEY_SHIFT) {
                    _event.preventDefault();
                }
            };

            this.handleKeyUp = function () {
                if (_currentlyPressedKeys[_event.keyCode] || _event.keyCode === input.KEY_PRINTSCREEN) {
                    for (var pk in _unpressedKeysCallbacks) {
                        if (_currentlyPressedKeys[pk] || _event.keyCode === input.KEY_PRINTSCREEN && pk == input.KEY_PRINTSCREEN) {
                            var cpk = _unpressedKeysCallbacks[pk];
                            for (var i = 0; i < cpk.length; i++) {
                                cpk[i].callback.call(cpk[i].sender, _event);
                            }
                        }
                    }
                }
                _currentlyPressedKeys[_event.keyCode] = false;
            };

            this.handleEvents = function () {
                for (var pk in _pressedKeysCallbacks) {
                    if (_currentlyPressedKeys[pk]) {
                        var cpk = _pressedKeysCallbacks[pk];
                        for (var i = 0; i < cpk.length; i++) {
                            cpk[i].callback.call(cpk[i].sender, _event);
                        }
                    }
                }
            };
        }
    }

    /**
     * @module og/input/MouseHandler
     */

    class MouseHandler {

        constructor(htmlObject) {
            this._htmlObject = htmlObject;
        }

        setEvent(event, sender, callback) {
            switch (event) {
                case "mousewheel":
                    this._htmlObject.addEventListener('mousewheel', function (evt) {
                        var delta = evt.deltaY || evt.detail || evt.wheelDelta;
                        if (evt.wheelDelta == undefined) {
                            evt.wheelDelta = delta * (-120);
                        }
                        callback.call(sender, evt);
                        evt.preventDefault();
                    }, false);

                    this._htmlObject.addEventListener('wheel', function (evt) {
                        var delta = evt.deltaY || evt.detail || evt.wheelDelta;
                        if (evt.wheelDelta == undefined) {
                            evt.wheelDelta = delta * (-120);
                        }
                        callback.call(sender, evt);
                        evt.preventDefault();
                    }, false);
                    break;

                case "mousedown":
                    this._htmlObject.addEventListener('mousedown', function (event) {
                        var rect = this.getBoundingClientRect();
                        callback.call(sender, {
                            button: event.button,
                            clientX: event.clientX - rect.left,
                            clientY: event.clientY - rect.top
                        }, event);
                    });
                    this._htmlObject.addEventListener('contextmenu', function (event) {
                        event.preventDefault();
                        return false;
                    });
                    break;

                case "mouseup":
                    this._htmlObject.addEventListener('mouseup', function (event) {
                        var rect = this.getBoundingClientRect();
                        callback.call(sender, {
                            button: event.button,
                            clientX: event.clientX - rect.left,
                            clientY: event.clientY - rect.top
                        }, event);
                    });
                    break;

                case "mousemove":
                    this._htmlObject.addEventListener('mousemove', function (event) {
                        var rect = this.getBoundingClientRect();
                        callback.call(sender, {
                            clientX: event.clientX - rect.left,
                            clientY: event.clientY - rect.top
                        }, event);
                    });
                    break;

                case "mouseleave":
                    this._htmlObject.addEventListener('mouseleave', function (event) {
                        callback.call(sender, event);
                    });
                    break;

                case "mouseout":
                    this._htmlObject.addEventListener('mouseout', function (event) {
                        callback.call(sender, event);
                    });
                    break;

                case "mouseover":
                    this._htmlObject.addEventListener('mouseover', function (event) {
                        callback.call(sender, event);
                    });
                    break;

                case "mouseenter":
                    this._htmlObject.addEventListener('mouseenter', function (event) {
                        callback.call(sender, event);
                    });
                    break;
            }
        }
    }

    /**
     * @module og/input/TouchHandler
     */

    class TouchHandler {

        constructor(htmlObject) {
            this._htmlObject = htmlObject;
        }

        setEvent(event, sender, callback) {
            switch (event) {
                case "touchcancel":
                    this._htmlObject.addEventListener('touchcancel', function (event) {
                        event.preventDefault();
                        var rect = this.getBoundingClientRect();
                        event.offsetLeft = rect.left;
                        event.offsetTop = rect.top;
                        callback.call(sender, event);
                        event.preventDefault();
                    });
                    break;

                case "touchstart":
                    this._htmlObject.addEventListener('touchstart', function (event) {
                        event.preventDefault();
                        var rect = this.getBoundingClientRect();
                        event.offsetLeft = rect.left;
                        event.offsetTop = rect.top;
                        callback.call(sender, event);
                        event.preventDefault();
                    });
                    break;

                case "touchend":
                    this._htmlObject.addEventListener('touchend', function (event) {
                        event.preventDefault();
                        var rect = this.getBoundingClientRect();
                        event.offsetLeft = rect.left;
                        event.offsetTop = rect.top;
                        callback.call(sender, event);
                        event.preventDefault();
                    });
                    break;

                case "touchmove":
                    this._htmlObject.addEventListener('touchmove', function (event) {
                        event.preventDefault();
                        var rect = this.getBoundingClientRect();
                        event.offsetLeft = rect.left;
                        event.offsetTop = rect.top;
                        callback.call(sender, event);
                        event.preventDefault();
                    });
                    break;
            }
        }
    }

    /**
     * @module og/renderer/RendererEvents
     */

    const LB_M = 0b0001;
    const RB_M = 0b0010;
    const MB_M = 0b0100;

    /**
     * Renderer events handler.
     * @class
     * @param {Renderer} renderer - Renderer object, events that works for.
     */
    class RendererEvents extends Events {
        constructor(renderer) {
            super(EVENT_NAMES);

            /**
             * Assigned renderer.
             * @public
             * @type {Renderer}
             */
            this.renderer = renderer;

            /**
             * Low level touch events handler.
             * @private
             * @type {input.TouchHandler}
             */
            this._touchHandler = new TouchHandler(renderer.handler.canvas);

            /**
             * Low level mouse events handler.
             * @private
             * @type {input.MouseHandler}
             */
            this._mouseHandler = new MouseHandler(renderer.handler.canvas);

            /**
             * Low level keyboard events handler.
             * @private
             * @type {input.KeyboardHandler}
             */
            this._keyboardHandler = new KeyboardHandler();

            this._active = true;

            this.clickRadius = 15;

            /**
             * Current mouse state.
             * @public
             * @enum {Object}
             */
            this.mouseState = {
                /** Current screen mouse X position. */
                clientX: 0,
                /** Current screen mouse Y position. */
                clientY: 0,
                /** Current viewport mouse X position. */
                x: 0,
                /** Current viewport mouse Y position. */
                y: 0,
                /** Current mouse X position from 0 to 1 */
                nx: 0,
                /** Current mouse Y position from 0 to 1 */
                ny: 0,
                /** Previous mouse X position. */
                prev_x: 0,
                /** Previous mouse Y position. */
                prev_y: 0,
                /** Screen mouse position world direction. */
                direction: new Vec3(),
                /** Left mouse button has stopped pushing down right now.*/
                leftButtonUp: false,
                /** Right mouse button has stopped pushing down right now.*/
                rightButtonUp: false,
                /** Middle mouse button has stopped pushing down right now.*/
                middleButtonUp: false,
                /** Left mouse button has pushed now.*/
                leftButtonDown: false,
                /** Right mouse button has pushed now.*/
                rightButtonDown: false,
                /** Middle mouse button has pushed now.*/
                middleButtonDown: false,
                /** Left mouse button is pushing.*/
                leftButtonHold: false,
                /** Right mouse button is pushing.*/
                rightButtonHold: false,
                /** Middle mouse button is pushing.*/
                middleButtonHold: false,
                /** Left mouse button has clicked twice now.*/
                leftButtonDoubleClick: false,
                /** Right mouse button has clicked twice now.*/
                rightButtonDoubleClick: false,
                /** Middle mouse button has clicked twice now.*/
                middleButtonDoubleClick: false,
                /** Left mouse button has clicked now. */
                leftButtonClick: false,
                /** Right mouse button has clicked now. */
                rightButtonClick: false,
                /** Middle mouse button has clicked now. */
                middleButtonClick: false,
                /** Mouse is moving now. */
                moving: false,
                /** Mouse has just stopped now. */
                justStopped: false,
                /** Mose double click delay response time.*/
                doubleClickDelay: 500,
                /** Mose click delay response time.*/
                clickDelay: 200,
                /** Mouse wheel. */
                wheelDelta: 0,
                /** JavaScript mouse system event message. */
                sys: null,
                /** Current picking object. */
                pickingObject: null,
                /** Renderer instanve. */
                renderer: renderer
            };

            /**
             * Current touch state.
             * @public
             * @enum {Object}
             */
            this.touchState = {
                /** Touching is moving now. */
                moving: false,
                /** Touch has ended right now.*/
                touchEnd: false,
                /** Touch has started right now.*/
                touchStart: false,
                /** Touch canceled.*/
                touchCancel: false,
                /** Touched twice.*/
                doubleTouch: false,
                /** Double touching responce delay.*/
                doubleTouchDelay: 550,
                /** Double touching responce radius in screen pixels.*/
                doubleTouchRadius: 10,
                /** Current touch X - coordinate. */
                x: 0,
                /** Current touch Y - coordinate. */
                y: 0,
                /** Current touch X - coordinate from 0 to 1 */
                nx: 0,
                /** Current touch Y - coordinate from 0 to 1 */
                ny: 0,
                /** Previous touch X coordinate. */
                prev_x: 0,
                /** Previous touch Y coordinate. */
                prev_y: 0,
                /** Screen touch position world direction. */
                direction: new Vec3(),
                /** JavaScript touching system event message. */
                sys: null,
                /** Current touched(picking) object. */
                pickingObject: null,
                /** Renderer instanve. */
                renderer: renderer
            };

            this._dblTchCoords = new Vec2();
            this._oneTouchStart = false;
            this._dblTchBegins = 0;
            /**
             * @type {number}
             */
            this._mousestopThread = null;
            this._ldblClkBegins = 0;
            this._rdblClkBegins = 0;
            this._mdblClkBegins = 0;
            this._lClkBegins = 0;
            this._rClkBegins = 0;
            this._mClkBegins = 0;
            this._lclickX = 0;
            this._lclickY = 0;
            this._rclickX = 0;
            this._rclickY = 0;
            this._mclickX = 0;
            this._mclickY = 0;
        }

        pointerEvent() {
            let ms = this.mouseState,
                ts = this.touchState;
            return (
                ms.moving ||
                ms.justStopped ||
                ms.wheelDelta ||
                ts.moving ||
                ts.touchStart ||
                ts.touchEnd
            )
        }

        get active() {
            return this._active;
        }

        set active(act) {
            this._active = act;
            this._keyboardHandler.setActivity(act);
        }

        /**
         * Used in render node frame.
         * @public
         */
        handleEvents() {
            if (this._active) {
                this.mouseState.direction = this.renderer.activeCamera.unproject(
                    this.mouseState.x,
                    this.mouseState.y
                );
                //
                // TODO: Replace in some other place with a thought that we do            
                // not need to make unproject when we do not make touching
                this.touchState.direction = this.renderer.activeCamera.unproject(
                    this.touchState.x,
                    this.touchState.y
                );
                this.entityPickingEvents();
                this._keyboardHandler.handleEvents();
                this.handleMouseEvents();
                this.handleTouchEvents();
            }
        }

        /**
         * Set render event callback.
         * @public
         * @param {string} name - Event name
         * @param {eventCallback} callback - Callback function
         * @param {number} [key] - Key code from og.input
         * @param {*} sender - Callback context
         * @param {number} [priority] - Event callback priority
         */
        on(name, p0, p1, p2, p3) {
            if (name === "keypress" || name === "charkeypress" || name === "keyfree") {
                this._keyboardHandler.addEvent(name, p2, p1, p0, p3);
            } else {
                super.on(name, p0, p1, p2);
            }
        }

        /**
         * TODO: DOESNT WORK!!!
         * @param {any} name
         * @param {any} callback
         */
        off(name, callback) {
            if (name === "keypress" || name === "charkeypress" || name === "keyfree") {
                this._keyboardHandler.removeEvent(name, callback);
            } else {
                super.off(name, callback);
            }
        }

        /**
         * Check key is pressed.
         * @public
         * @param {number} keyCode - Key code
         * @return {boolean}
         */
        isKeyPressed(keyCode) {
            return this._keyboardHandler.isKeyPressed(keyCode);
        }

        releaseKeys() {
            this._keyboardHandler.releaseKeys();
        }

        /**
         * Renderer events initialization.
         * @public
         */
        initialize() {
            this._mouseHandler.setEvent("mouseup", this, this.onMouseUp);
            this._mouseHandler.setEvent("mousemove", this, this.onMouseMove);
            this._mouseHandler.setEvent("mousedown", this, this.onMouseDown);
            this._mouseHandler.setEvent("mousewheel", this, this.onMouseWheel);
            this._mouseHandler.setEvent("mouseleave", this, this.onMouseLeave);
            this._mouseHandler.setEvent("mouseenter", this, this.onMouseEnter);

            this._touchHandler.setEvent("touchstart", this, this.onTouchStart);
            this._touchHandler.setEvent("touchend", this, this.onTouchEnd);
            this._touchHandler.setEvent("touchcancel", this, this.onTouchCancel);
            this._touchHandler.setEvent("touchmove", this, this.onTouchMove);
        }

        /**
         * @private
         */
        onMouseWheel(event) {
            this.mouseState.wheelDelta = event.wheelDelta;
        }

        /**
         * @protected
         */
        updateButtonsStates(buttons) {
            var ms = this.mouseState;
            if (buttons & LB_M) {
                ms.leftButtonDown = true;
            } else {
                ms.leftButtonHold = false;
                ms.leftButtonDown = false;
            }

            if (buttons & RB_M) {
                ms.rightButtonDown = true;
            } else {
                ms.rightButtonHold = false;
                ms.rightButtonDown = false;
            }

            if (buttons & MB_M) {
                ms.middleButtonDown = true;
            } else {
                ms.middleButtonHold = false;
                ms.middleButtonDown = false;
            }
        }

        /**
         * @private
         */
        onMouseMove(event, sys) {
            var ms = this.mouseState;
            this.updateButtonsStates(sys.buttons);
            ms.sys = event;

            let ex = event.clientX,
                ey = event.clientY,
                r = this.clickRadius;

            if (Math.abs(this._lclickX - ex) >= r && Math.abs(this._lclickY - ey) >= r) {
                this._ldblClkBegins = 0;
                this._lClkBegins = 0;
            }

            if (Math.abs(this._rclickX - ex) >= r && Math.abs(this._rclickY - ey) >= r) {
                this._rdblClkBegins = 0;
                this._rClkBegins = 0;
            }

            if (Math.abs(this._mclickX - ex) >= r && Math.abs(this._mclickY - ey) >= r) {
                this._mdblClkBegins = 0;
                this._mClkBegins = 0;
            }

            if (ms.clientX === event.clientX && ms.clientY === event.clientY) {
                return;
            }

            ms.clientX = event.clientX;
            ms.clientY = event.clientY;

            let h = this.renderer.handler;

            ms.x = event.clientX * h.pixelRatio;
            ms.y = event.clientY * h.pixelRatio;

            ms.nx = ms.x / h.canvas.width;
            ms.ny = ms.y / h.canvas.height;

            ms.moving = true;

            //dispatch stop mouse event
            clearTimeout(this._mousestopThread);
            this._mousestopThread = setTimeout(function () {
                ms.justStopped = true;
            }, 100);
        }

        onMouseLeave(event) {
            this.dispatch(this.mouseleave, event);
        }

        onMouseEnter(event) {
            this.dispatch(this.mouseenter, event);
        }

        /**
         * @private
         */
        onMouseDown(event) {
            if (event.button === input.MB_LEFT) {
                this._lClkBegins = window.performance.now();
                this._lclickX = event.clientX;
                this._lclickY = event.clientY;
                this.mouseState.sys = event;
                this.mouseState.leftButtonDown = true;
            } else if (event.button === input.MB_RIGHT) {
                this._rClkBegins = window.performance.now();
                this._rclickX = event.clientX;
                this._rclickY = event.clientY;
                this.mouseState.sys = event;
                this.mouseState.rightButtonDown = true;
            } else if (event.button === input.MB_MIDDLE) {
                this._mClkBegins = window.performance.now();
                this._mclickX = event.clientX;
                this._mclickY = event.clientY;
                this.mouseState.sys = event;
                this.mouseState.middleButtonDown = true;
            }
        }

        /**
         * @private
         */
        onMouseUp(event) {
            var ms = this.mouseState;
            ms.sys = event;
            var t = window.performance.now();

            if (event.button === input.MB_LEFT) {
                ms.leftButtonDown = false;
                ms.leftButtonUp = true;

                if (
                    Math.abs(this._lclickX - event.clientX) < this.clickRadius &&
                    Math.abs(this._lclickY - event.clientY) < this.clickRadius &&
                    t - this._lClkBegins <= ms.clickDelay
                ) {
                    if (this._ldblClkBegins) {
                        let deltatime = window.performance.now() - this._ldblClkBegins;
                        if (deltatime <= ms.doubleClickDelay) {
                            ms.leftButtonDoubleClick = true;
                        }
                        this._ldblClkBegins = 0;
                    } else {
                        this._ldblClkBegins = window.performance.now();
                    }

                    ms.leftButtonClick = true;
                    this._lClkBegins = 0;
                }
            } else if (event.button === input.MB_RIGHT) {
                ms.rightButtonDown = false;
                ms.rightButtonUp = true;

                if (
                    Math.abs(this._rclickX - event.clientX) < this.clickRadius &&
                    Math.abs(this._rclickY - event.clientY) < this.clickRadius &&
                    t - this._rClkBegins <= ms.clickDelay
                ) {
                    if (this._rdblClkBegins) {
                        let deltatime = window.performance.now() - this._rdblClkBegins;
                        if (deltatime <= ms.doubleClickDelay) {
                            ms.rightButtonDoubleClick = true;
                        }
                        this._rdblClkBegins = 0;
                    } else {
                        this._rdblClkBegins = window.performance.now();
                    }

                    ms.rightButtonClick = true;
                    this._rClkBegins = 0;
                }
            } else if (event.button === input.MB_MIDDLE) {
                ms.middleButtonDown = false;
                ms.middleButtonUp = true;

                if (
                    Math.abs(this._mclickX - event.clientX) < this.clickRadius &&
                    Math.abs(this._mclickY - event.clientY) < this.clickRadius &&
                    t - this._mClkBegins <= ms.clickDelay
                ) {
                    if (this._mdblClkBegins) {
                        var deltatime = window.performance.now() - this._mdblClkBegins;
                        if (deltatime <= ms.doubleClickDelay) {
                            ms.middleButtonDoubleClick = true;
                        }
                        this._mdblClkBegins = 0;
                    } else {
                        this._mdblClkBegins = window.performance.now();
                    }

                    ms.middleButtonClick = true;
                    this._mClkBegins = 0;
                }
            }
        }

        /**
         * @private
         */
        onTouchStart(event) {
            var ts = this.touchState;
            ts.sys = event;

            ts.clientX = event.touches.item(0).clientX - event.offsetLeft;
            ts.clientY = event.touches.item(0).clientY - event.offsetTop;

            let h = this.renderer.handler;

            ts.x = ts.clientX * h.pixelRatio;
            ts.y = ts.clientY * h.pixelRatio;

            ts.nx = ts.x / h.canvas.width;
            ts.ny = ts.y / h.canvas.height;
            ts.prev_x = ts.x;
            ts.prev_y = ts.y;
            ts.touchStart = true;

            if (event.touches.length === 1) {
                this._dblTchCoords.x = ts.x;
                this._dblTchCoords.y = ts.y;
                this._oneTouchStart = true;
            } else {
                this._oneTouchStart = false;
            }
        }

        /**
         * @private
         */
        onTouchEnd(event) {
            var ts = this.touchState;
            ts.sys = event;
            ts.touchEnd = true;

            if (event.touches.length === 0) {
                ts.prev_x = ts.x;
                ts.prev_y = ts.y;

                if (this._oneTouchStart) {
                    if (this._dblTchBegins) {
                        var deltatime = window.performance.now() - this._dblTchBegins;
                        if (deltatime <= ts.doubleTouchDelay) {
                            ts.doubleTouch = true;
                        }
                        this._dblTchBegins = 0;
                    }
                    this._dblTchBegins = window.performance.now();
                    this._oneTouchStart = false;
                }
            }
        }

        /**
         * @private
         */
        onTouchCancel(event) {
            var ts = this.touchState;
            ts.sys = event;
            ts.touchCancel = true;
        }

        /**
         * @private
         */
        onTouchMove(event) {
            var ts = this.touchState;
            ts.clientX = event.touches.item(0).clientX - event.offsetLeft;
            ts.clientY = event.touches.item(0).clientY - event.offsetTop;

            var h = this.renderer.handler;

            ts.x = ts.clientX * h.pixelRatio;
            ts.y = ts.clientY * h.pixelRatio;

            ts.nx = ts.x / h.canvas.width;
            ts.ny = ts.y / h.canvas.height;

            ts.sys = event;
            ts.moving = true;

            var dX = ts.x - ts.prev_x;
            var dY = ts.y - ts.prev_y;
            if (Math.abs(dX) > 9 || Math.abs(dY) > 9) {
                this._dblTchBegins = 0;
                this._oneTouchStart = false;
            }
        }

        /**
         * @private
         */
        entityPickingEvents() {
            var ts = this.touchState,
                ms = this.mouseState;

            if (!(ms.leftButtonHold || ms.rightButtonHold || ms.middleButtonHold)) {
                var r = this.renderer;

                var o = r.colorObjects;

                var c = r._currPickingColor,
                    p = r._prevPickingColor;

                ms.pickingObject = null;
                ts.pickingObject = null;

                var co = o && o[c[0] + "_" + c[1] + "_" + c[2]];

                ms.pickingObject = co;
                ts.pickingObject = co;

                //object changed
                if (c[0] != p[0] || c[1] != p[1] || c[2] != p[2]) {
                    //current black
                    if (!(c[0] || c[1] || c[2])) {
                        let po = o[p[0] + "_" + p[1] + "_" + p[2]];
                        if (po) {
                            let pe = po.rendererEvents;
                            ms.pickingObject = po;
                            pe && pe.dispatch(pe.mouseleave, ms);
                            ts.pickingObject = po;
                            pe && pe.dispatch(pe.touchleave, ts);
                        }
                    } else {
                        //current not black

                        //previous not black
                        if (p[0] || p[1] || p[2]) {
                            let po = o[p[0] + "_" + p[1] + "_" + p[2]];
                            if (po) {
                                let pe = po.rendererEvents;
                                ms.pickingObject = po;
                                pe && pe.dispatch(pe.mouseleave, ms);
                                ts.pickingObject = po;
                                pe && pe.dispatch(pe.touchleave, ts);
                            }
                        }

                        if (co) {
                            var ce = co.rendererEvents;
                            ms.pickingObject = co;
                            ce && ce.dispatch(ce.mouseenter, ms);
                            ts.pickingObject = co;
                            ce && ce.dispatch(ce.touchenter, ts);
                        }
                    }
                }
            }
        }

        /**
         * @private
         */
        handleMouseEvents() {
            let ms = this.mouseState;
            let po = ms.pickingObject,
                pe = null;

            if (ms.leftButtonClick) {
                if (po) {
                    pe = po.rendererEvents;
                    pe && pe.dispatch(pe.lclick, ms);
                }
                this.dispatch(this.lclick, ms);
                ms.leftButtonClick = false;
            }

            if (ms.rightButtonClick) {
                if (po) {
                    pe = po.rendererEvents;
                    pe && pe.dispatch(pe.rclick, ms);
                }
                this.dispatch(this.rclick, ms);
                ms.rightButtonClick = false;
            }

            if (ms.middleButtonClick) {
                if (po) {
                    pe = po.rendererEvents;
                    pe && pe.dispatch(pe.mclick, ms);
                }
                this.dispatch(this.mclick, ms);
                ms.middleButtonClick = false;
            }

            if (ms.leftButtonDown) {
                if (ms.leftButtonHold) {
                    if (po) {
                        pe = po.rendererEvents;
                        pe && pe.dispatch(pe.lhold, ms);
                    }
                    this.dispatch(this.lhold, ms);
                } else {
                    ms.leftButtonHold = true;
                    if (po) {
                        pe = po.rendererEvents;
                        pe && pe.dispatch(pe.ldown, ms);
                    }
                    this.dispatch(this.ldown, ms);
                }
            }

            if (ms.rightButtonDown) {
                if (ms.rightButtonHold) {
                    if (po) {
                        pe = po.rendererEvents;
                        pe && pe.dispatch(pe.rhold, ms);
                    }
                    this.dispatch(this.rhold, ms);
                } else {
                    ms.rightButtonHold = true;
                    if (po) {
                        pe = po.rendererEvents;
                        pe && pe.dispatch(pe.rdown, ms);
                    }
                    this.dispatch(this.rdown, ms);
                }
            }

            if (ms.middleButtonDown) {
                if (ms.middleButtonHold) {
                    if (po) {
                        pe = po.rendererEvents;
                        pe && pe.dispatch(pe.mhold, ms);
                    }
                    this.dispatch(this.mhold, ms);
                } else {
                    ms.middleButtonHold = true;
                    if (po) {
                        pe = po.rendererEvents;
                        pe && pe.dispatch(pe.mdown, ms);
                    }
                    this.dispatch(this.mdown, ms);
                }
            }

            if (ms.leftButtonUp) {
                if (po) {
                    pe = po.rendererEvents;
                    pe && pe.dispatch(pe.lup, ms);
                }
                this.dispatch(this.lup, ms);
                ms.leftButtonUp = false;
                ms.leftButtonHold = false;
            }

            if (ms.rightButtonUp) {
                if (po) {
                    pe = po.rendererEvents;
                    pe && pe.dispatch(pe.rup, ms);
                }
                this.dispatch(this.rup, ms);
                ms.rightButtonUp = false;
                ms.rightButtonHold = false;
            }

            if (ms.middleButtonUp) {
                if (po) {
                    pe = po.rendererEvents;
                    pe && pe.dispatch(pe.mup, ms);
                }
                this.dispatch(this.mup, ms);
                ms.middleButtonUp = false;
                ms.middleButtonHold = false;
            }

            if (ms.leftButtonDoubleClick) {
                if (po) {
                    pe = po.rendererEvents;
                    pe && pe.dispatch(pe.ldblclick, ms);
                }
                this.dispatch(this.ldblclick, ms);
                ms.leftButtonDoubleClick = false;
            }

            if (ms.rightButtonDoubleClick) {
                if (po) {
                    pe = po.rendererEvents;
                    pe && pe.dispatch(pe.rdblclick, ms);
                }
                this.dispatch(this.rdblclick, ms);
                ms.rightButtonDoubleClick = false;
            }

            if (ms.middleButtonDoubleClick) {
                if (po) {
                    pe = po.rendererEvents;
                    pe && pe.dispatch(pe.mdblclick, ms);
                }
                this.dispatch(this.mdblclick, ms);
                ms.middleButtonDoubleClick = false;
            }

            if (ms.wheelDelta) {
                if (po) {
                    pe = po.rendererEvents;
                    pe && pe.dispatch(pe.mousewheel, ms);
                }
                this.dispatch(this.mousewheel, ms);
            }

            if (ms.moving) {
                if (po) {
                    pe = po.rendererEvents;
                    pe && pe.dispatch(pe.mousemove, ms);
                }
                this.dispatch(this.mousemove, ms);
                ms.prev_x = ms.x;
                ms.prev_y = ms.y;
            }

            if (ms.justStopped) {
                this.dispatch(this.mousestop, ms);
            }
        }

        /**
         * @private
         */
        handleTouchEvents() {
            var ts = this.touchState;

            var tpo = ts.pickingObject,
                tpe = null;

            if (ts.touchCancel) {
                this.dispatch(this.touchcancel, ts);
                ts.touchCancel = false;
            }

            if (ts.touchStart) {
                var r = this.renderer;

                r.pickingFramebuffer.activate();
                r.pickingFramebuffer.readPixels(r._currPickingColor, ts.nx, 1.0 - ts.ny, 1);
                r.pickingFramebuffer.deactivate();

                var o = r.colorObjects;
                var c = r._currPickingColor;
                var co = o[c[0] + "_" + c[1] + "_" + c[2]];
                tpo = ts.pickingObject = co;
                if (tpo) {
                    tpe = tpo.rendererEvents;
                    tpe && tpe.dispatch(tpe.touchstart, ts);
                }
                this.dispatch(this.touchstart, ts);
                ts.touchStart = false;
            }

            if (ts.doubleTouch) {
                if (tpo) {
                    tpe = tpo.rendererEvents;
                    tpe && tpe.dispatch(tpe.doubletouch, ts);
                }
                this.dispatch(this.doubletouch, ts);
                ts.doubleTouch = false;
            }

            if (ts.touchEnd) {
                if (tpo) {
                    tpe = tpo.rendererEvents;
                    tpe && tpe.dispatch(tpe.touchend, ts);
                }
                this.dispatch(this.touchend, ts);
                ts.x = 0;
                ts.y = 0;
                ts.touchEnd = false;
            }

            if (ts.moving) {
                if (tpo) {
                    tpe = tpo.rendererEvents;
                    tpe && tpe.dispatch(tpe.touchmove, ts);
                }
                this.dispatch(this.touchmove, ts);
                ts.prev_x = ts.x;
                ts.prev_y = ts.y;
            }
        }
    }

    const EVENT_NAMES = [
        /**
         * Triggered before scene frame is rendered(before render nodes).
         * @event og.RendererEvents#draw
         */
        "draw",

        /**
         * Triggered after scene frame is rendered(after render nodes).
         * @event og.RendererEvents#postdraw
         */
        "postdraw",

        /**
         * Triggered when screen is resized.
         * @event og.RendererEvents#resize
         */
        "resize",

        /**
         * Mouse enters the work screen
         * @event og.RendererEvents#mouseenter
         */
        "mouseenter",

        /**
         * Mouse leaves the work screen
         * @event og.RendererEvents#mouseleave
         */
        "mouseleave",

        /**
         * Mouse is moving.
         * @event og.RendererEvents#mousemove
         */
        "mousemove",

        /**
         * Mouse is just stopped.
         * @event og.RendererEvents#mousestop
         */
        "mousestop",

        /**
         * Mouse left button clicked.
         * @event og.RendererEvents#lclick
         */
        "lclick",

        /**
         * Mouse right button clicked.
         * @event og.RendererEvents#rclick
         */
        "rclick",

        /**
         * Mouse middle button clicked.
         * @event og.RendererEvents#mclick
         */
        "mclick",

        /**
         * Mouse left button double click.
         * @event og.RendererEvents#ldblclick
         */
        "ldblclick",

        /**
         * Mouse right button double click.
         * @event og.RendererEvents#rdblclick
         */
        "rdblclick",

        /**
         * Mouse middle button double click.
         * @event og.RendererEvents#mdblclick
         */
        "mdblclick",

        /**
         * Mouse left button up(stop pressing).
         * @event og.RendererEvents#lup
         */
        "lup",

        /**
         * Mouse right button up(stop pressing).
         * @event og.RendererEvents#rup
         */
        "rup",

        /**
         * Mouse middle button up(stop pressing).
         * @event og.RendererEvents#mup
         */
        "mup",

        /**
         * Mouse left button is just pressed down(start pressing).
         * @event og.RendererEvents#ldown
         */
        "ldown",

        /**
         * Mouse right button is just pressed down(start pressing).
         * @event og.RendererEvents#rdown
         */
        "rdown",

        /**
         * Mouse middle button is just pressed down(start pressing).
         * @event og.RendererEvents#mdown
         */
        "mdown",

        /**
         * Mouse left button is pressing.
         * @event og.RendererEvents#lhold
         */
        "lhold",

        /**
         * Mouse right button is pressing.
         * @event og.RendererEvents#rhold
         */
        "rhold",

        /**
         * Mouse middle button is pressing.
         * @event og.RendererEvents#mhold
         */
        "mhold",

        /**
         * Mouse wheel is rotated.
         * @event og.RendererEvents#mousewheel
         */
        "mousewheel",

        /**
         * Triggered when touching starts.
         * @event og.RendererEvents#touchstart
         */
        "touchstart",

        /**
         * Triggered when touching ends.
         * @event og.RendererEvents#touchend
         */
        "touchend",

        /**
         * Triggered when touching cancel.
         * @event og.RendererEvents#touchcancel
         */
        "touchcancel",

        /**
         * Triggered when touch is move.
         * @event og.RendererEvents#touchmove
         */
        "touchmove",

        /**
         * Triggered when double touch.
         * @event og.RendererEvents#doubletouch
         */
        "doubletouch",

        /**
         * Triggered when touch leaves picked object.
         * @event og.RendererEvents#touchleave
         */
        "touchleave",

        /**
         * Triggered when touch enter picking object.
         * @event og.RendererEvents#touchenter
         */
        "touchenter"
    ];

    function toneMapping() {
        return new Program("toneMapping", {
            uniforms: {
                hdrBuffer: "sampler2d",
                exposure: "float",
                gamma: "float",
                whitepoint: "float"
            },
            attributes: {
                corners: "vec3"
            },
            vertexShader:
                `#version 300 es
            
            in vec2 corners;
            
            out vec2 tc;

            void main(void) {
                gl_Position = vec4(corners, 0.0, 1.0);
                tc = corners * 0.5 + 0.5;
            }`,
            fragmentShader:
                `#version 300 es

            precision highp float;

            #ifndef saturate
                #define saturate(a) clamp(a, 0.0, 1.0)
            #endif

            uniform sampler2D hdrBuffer;

            uniform float whitepoint;
            uniform float exposure;
            uniform float gamma;

            vec3 LinearToneMapping(vec3 color) {
                return exposure * color;
            }

            vec3 ReinhardToneMapping2(vec3 color) {
                return vec3(1.0) - exp(-color * exposure);
            }

            vec3 ReinhardToneMapping(vec3 color) {
                color *= exposure;
                return saturate(color / (vec3(1.0) + color));
            }

            #define Uncharted2Helper(x) max(((x * (0.15 * x + 0.10 * 0.50) + 0.20 * 0.02) / (x * (0.15 * x + 0.50) + 0.20 * 0.30)) - 0.02 / 0.30, vec3(0.0))

            vec3 Uncharted2ToneMapping(vec3 color) {
                color *= exposure;
                return saturate(Uncharted2Helper(color) / Uncharted2Helper(vec3(whitepoint)));
            }

            vec3 OptimizedCineonToneMapping(vec3 color) {
                color *= exposure;
                color = max(vec3(0.0), color - 0.004);
                return pow((color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06), vec3(2.2));
            }

            vec3 ACESFilmicToneMapping(vec3 color) {
                color *= exposure;
                return saturate((color * (2.51 * color + 0.03)) / (color * (2.43 * color + 0.59) + 0.14));
            }

            in vec2 tc;

            layout(location = 0) out vec4 fragColor;
            
            void main(void) {
                vec3 hdrColor = texture(hdrBuffer, tc).rgb;
                
                float oneByGamma = gamma / gamma;
                float oneByWhitePoint = whitepoint / whitepoint;
                vec3 mapped = ReinhardToneMapping2(hdrColor) * oneByGamma * oneByWhitePoint;
                //vec3 mapped = ACESFilmicToneMapping(hdrColor) * oneByGamma * oneByWhitePoint;

                mapped = pow(mapped, vec3(1.0 / gamma));

                fragColor = vec4(mapped, 1.0);
            }`
        });
    }

    function screenFrame() {
        return new Program("screenFrame", {
            uniforms: {
                texture: "sampler2d"
            },
            attributes: {
                corners: "vec3"
            },
            vertexShader:
                `attribute vec2 corners;
            
            varying vec2 tc;
            void main(void) {
                gl_Position = vec4(corners, 0.0, 1.0);
                tc = corners * 0.5 + 0.5;
            }`,
            fragmentShader:
                `precision highp float;
            uniform sampler2D texture;
            
            varying vec2 tc;
            
            void main(void) {
                gl_FragColor = texture2D( texture, tc );
            }`
        });
    }

    /**
     * 2D Rectangle class.
     * @class
     * @param {number} [left] - Left coordinate. 0 - default.
     * @param {number} [top] - Top coordinate. 0 - default.
     * @param {number} [right] - Right coordinate. 0 - default.
     * @param {number} [bottom] - Bottom coordinate. 0 - default.
     */
    class Rectangle {
        /**
         * @param {number} [left] - Left coordinate. 0 - default.
         * @param {number} [top] - Top coordinate. 0 - default.
         * @param {number} [right] - Right coordinate. 0 - default.
         * @param {number} [bottom] - Bottom coordinate. 0 - default.
         */
        constructor(left = 0, top = 0, right = 0, bottom = 0) {
            /**
             * Left coordinate.
             * @public
             * @type {number}
             */
            this.left = left;

            /**
             * Right coordinate.
             * @public
             * @type {number}
             */
            this.right = right;

            /**
             * Top coordinate.
             * @public
             * @type {number}
             */
            this.top = top;

            /**
             * Top coordinate.
             * @public
             * @type {number}
             */
            this.bottom = bottom;
        }

        /**
         * Clone rectangle object.
         * @public
         * @returns {Rectangle}
         */
        clone() {
            return new Rectangle(this.left, this.top, this.right, this.bottom);
        }

        /**
         * Returns rectangle width.
         * @public
         * @type {number}
         */
        getWidth() {
            return Math.abs(this.right - this.left);
        }

        /**
         * Returns rectangle height.
         * @public
         * @type {number}
         */
        getHeight() {
            return Math.abs(this.bottom - this.top);
        }

        /**
         * Returns rectangle area.
         * @public
         * @type {number}
         */
        getSquare() {
            return this.getHeight() * this.getWidth();
        }

        /**
         * Returns rectangle diagonal size.
         * @public
         * @type {number}
         */
        getDiagonal() {
            var w = this.getWidth(),
                h = this.getHeight();
            return Math.sqrt(h * h + w * w);
        }

        /**
         * Returns true if rectangle fits their size in width and height.
         * @public
         * @param {number} width - Width.
         * @param {number} height - Height.
         * @type {boolean}
         */
        fit(width, height) {
            return this.getWidth() == width && this.getHeight() == height;
        }

        isInside(x, y) {
            return x >= this.left && x <= this.right && y >= this.top && y <= this.bottom;
        }
    }

    class ImagesCacheManager {
        constructor() {
            this.imagesCache = {};

            this._counter = 0;
            this._pendingsQueue = new QueueArray();
            this._imageIndexCounter = 0;
        }

        load(src, success) {
            if (this.imagesCache[src]) {
                success(this.imagesCache[src]);
            } else {
                var req = { "src": src, "success": success };
                if (this._counter >= 1) {
                    this._pendingsQueue.unshift(req);
                } else {
                    this._exec(req);
                }
            }
        }

        _exec(req) {
            this._counter++;
            var that = this;

            var img = new Image();
            img.crossOrigin = '';
            img.onload = function () {
                that.imagesCache[req.src] = img;
                this.__nodeIndex = that._imageIndexCounter++;
                req.success(this);
                that._dequeueRequest();
            };

            img.onerror = function () {
                that._dequeueRequest();
            };

            img.src = req.src;
        }

        _dequeueRequest() {
            this._counter--;
            if (this._pendingsQueue.length && this._counter < 1) {
                while (this._pendingsQueue.length) {
                    var req = this._pendingsQueue.pop();
                    if (req) {
                        if (this.imagesCache[req.src]) {
                            if (this._counter <= 0) {
                                this._counter = 0;
                            } else {
                                this._counter--;
                            }
                            req.success(this.imagesCache[req.src]);
                        } else {
                            this._exec(req);
                            break;
                        }
                    }
                }
            }
        }
    }

    /**
     * Texture atlas stores images in one texture. Each image has its own
     * atlas texture coordinates.
     * @class
     * @param {number} [width] - Texture atlas width, if it hasn't 1024 default.
     * @param {number} [height] - Texture atlas height, if it hasn't 1024 default..
     */
    class TextureAtlas {
        constructor(width = 1024, height = 1024) {
            /**
             * Atlas nodes where input images store. It can be access by image.__nodeIndex.
             * @public
             * @type {Array.<utils.TextureAtlasNode >}
             */
            this.nodes = new Map();

            /**
             * Created gl texture.
             * @public
             */
            this.texture = null;

            /**
             * Atlas canvas.
             * @public
             * @type {canvas}
             */
            this.canvas = new ImageCanvas(width, height);
            this.clearCanvas();

            this._handler = null;
            this._images = [];
            this._btree = null;
            this._imagesCacheManager = new ImagesCacheManager();
            this.borderSize = 4;
        }

        /**
         * Returns atlas javascript image object.
         * @public
         * @returns {Object} -
         */
        getImage() {
            return this.canvas.getImage();
        }

        /**
         * Returns canvas object.
         * @public
         * @returns {Object} -
         */
        getCanvas() {
            return this.canvas._canvas;
        }

        /**
         * Clear atlas with black.
         * @public
         */
        clearCanvas() {
            this.canvas.fillEmpty("black");
        }

        /**
         * Sets openglobus gl handler that creates gl texture.
         * @public
         * @param {Handler} handler - WebGL handler.
         */
        assignHandler(handler) {
            this._handler = handler;
            this.createTexture();
        }

        /**
         * Returns image diagonal size.
         * @param {Object} image - JavaSript image object.
         * @returns {number} -
         */
        getDiagonal(image) {
            var w = image.atlasWidth || image.width,
                h = image.atlasHeight || image.height;
            return Math.sqrt(w * w + h * h);
        }

        /**
         * Adds image to the atlas and returns creted node with texture coordinates of the stored image.
         * @public
         * @param {Object} image - Input javascript image object.
         * @param {boolean} [fastInsert] - If it's true atlas doesnt restore all images again
         * and store image in the curent atlas sheme.
         * @returns {utils.TextureAtlasNode} -
         */
        addImage(image, fastInsert) {
            if (!(image.width && image.height)) {
                return;
            }

            this._images.push(image);

            this._makeAtlas(fastInsert);

            return this.get(image.__nodeIndex);
        }

        _completeNode(nodes, node) {
            if (node) {
                var w = this.canvas.getWidth(),
                    h = this.canvas.getHeight();
                var im = node.image;
                var r = node.rect;
                var bs = Math.round(this.borderSize * 0.5);
                this.canvas.drawImage(im, r.left + bs, r.top + bs, im.atlasWidth, im.atlasHeight);
                var tc = node.texCoords;

                tc[0] = (r.left + bs) / w;
                tc[1] = (r.top + bs) / h;

                tc[2] = (r.left + bs) / w;
                tc[3] = (r.bottom - bs) / h;

                tc[4] = (r.right - bs) / w;
                tc[5] = (r.bottom - bs) / h;

                tc[6] = (r.right - bs) / w;
                tc[7] = (r.bottom - bs) / h;

                tc[8] = (r.right - bs) / w;
                tc[9] = (r.top + bs) / h;

                tc[10] = (r.left + bs) / w;
                tc[11] = (r.top + bs) / h;

                nodes.set(im.__nodeIndex, node);
            }
        }

        /**
         * Main atlas making function.
         * @private
         * @param {boolean} [fastInsert] - If it's true atlas doesnt restore all images again
         * and store image in the curent atlas sheme.
         */
        _makeAtlas(fastInsert) {
            if (fastInsert && this._btree) {
                let im = this._images[this._images.length - 1];
                this._completeNode(this.nodes, this._btree.insert(im));
            } else {
                let im = this._images.slice(0);

                im.sort(function (b, a) {
                    return (
                        (a.atlasWidth || a.width) - (b.atlasWidth || b.width) ||
                        (a.atlasHeight || a.height) - (b.atlasHeight || b.height)
                    );
                });

                this._btree = new TextureAtlasNode(
                    new Rectangle(0, 0, this.canvas.getWidth(), this.canvas.getHeight())
                );
                this._btree.atlas = this;

                this.clearCanvas();

                var newNodes = new Map();
                for (var i = 0; i < im.length; i++) {
                    this._completeNode(newNodes, this._btree.insert(im[i]));
                }
                this.nodes = null;
                this.nodes = newNodes;
            }
        }

        get(key) {
            return this.nodes.get(key);
        }

        set(key, value) {
            this.nodes.set(key, value);
        }

        /**
         * Creates atlas gl texture.
         * @public
         */
        createTexture(img, internalFormat) {
            if (this._handler) {
                this._handler.gl.deleteTexture(this.texture);
                if (img) {
                    this.canvas.resize(img.width, img.height);
                    this.canvas.drawImage(img, 0, 0, img.width, img.height);
                }
                this.texture = this._handler.createTexture_l(this.canvas._canvas, internalFormat);
            }
        }

        /**
         * Image handler callback.
         * @callback Object~successCallback
         * @param {Image} img - Loaded image.
         */

        /**
         * Asynchronous function that loads and creates image to the image cache, and call success callback when it's done.
         * @public
         * @param {string} src - Image object src string.
         * @param {Object~successCallback} success - The callback that handles the image loads done.
         */
        loadImage(src, success) {
            this._imagesCacheManager.load(src, success);
        }

        getImageTexCoordinates(img) {
            if (img.__nodeIndex != null) {
                let n = this.get(img.__nodeIndex);
                if (n) {
                    return n.texCoords;
                }
            }
        }
    }

    /**
     * Atlas binary tree node.
     * @class
     * @param {Rectangle} rect - Node image rectangle.
     */
    class TextureAtlasNode {
        constructor(rect, texCoords = []) {
            this.childNodes = null;
            this.image = null;
            this.rect = rect;
            this.texCoords = texCoords;
            this.atlas = null;
        }

        insert(img) {
            if (this.childNodes) {
                var newNode = this.childNodes[0].insert(img);

                if (newNode != null) {
                    return newNode;
                }

                return this.childNodes[1].insert(img);
            } else {
                if (this.image != null) {
                    return null;
                }

                var rc = this.rect;
                var w = (img.atlasWidth || img.width) + this.atlas.borderSize;
                var h = (img.atlasHeight || img.height) + this.atlas.borderSize;

                if (w > rc.getWidth() || h > rc.getHeight()) {
                    return null;
                }

                if (rc.fit(w, h)) {
                    this.image = img;
                    return this;
                }

                this.childNodes = new Array(2);
                this.childNodes[0] = new TextureAtlasNode();
                this.childNodes[0].atlas = this.atlas;
                this.childNodes[1] = new TextureAtlasNode();
                this.childNodes[1].atlas = this.atlas;

                var dw = rc.getWidth() - w;
                var dh = rc.getHeight() - h;

                if (dw > dh) {
                    this.childNodes[0].rect = new Rectangle(rc.left, rc.top, rc.left + w, rc.bottom);
                    this.childNodes[1].rect = new Rectangle(rc.left + w, rc.top, rc.right, rc.bottom);
                } else {
                    this.childNodes[0].rect = new Rectangle(rc.left, rc.top, rc.right, rc.top + h);
                    this.childNodes[1].rect = new Rectangle(rc.left, rc.top + h, rc.right, rc.bottom);
                }

                return this.childNodes[0].insert(img);
            }
        }
    }

    function Deferred() {
        this.resolve = null;
        this.reject = null;
        this.promise = new Promise(function (resolve, reject) {
            this.resolve = resolve;
            this.reject = reject;
        }.bind(this));
        Object.freeze(this);
    }

    /**
     * @module og/utils/FontAtlas
     */

    //TODO: get the value from shader module
    const MAX_SIZE = 11;

    class FontAtlas {
        constructor() {
            this.atlasesArr = [];
            this.atlasIndexes = {};
            this.atlasIndexesDeferred = [];
            this.tokenImageSize = 64;
            this.samplerArr = new Uint32Array(MAX_SIZE);
            this.sdfParamsArr = new Float32Array(MAX_SIZE * 4);
            this._handler = null;
        }

        assignHandler(handler) {
            this._handler = handler;
        }

        getFontIndex(face) {
            let fullName = this.getFullIndex(face);
            if (!this.atlasIndexesDeferred[fullName]) {
                this.atlasIndexesDeferred[fullName] = new Deferred();
            }
            return this.atlasIndexesDeferred[fullName].promise;
        }

        getFullIndex(face) {
            return face.trim().toLowerCase();
        }

        _applyFontDataToAtlas(atlas, data, index = 0) {
            let chars = data.chars;

            atlas.height = data.common.scaleH;
            atlas.width = data.common.scaleW;
            atlas.gliphSize = data.info.size;
            atlas.distanceRange = data.distanceField.distanceRange;

            let w = atlas.width,
                h = atlas.height,
                s = atlas.gliphSize;

            this.sdfParamsArr[index * 4] = w;
            this.sdfParamsArr[index * 4 + 1] = h;
            this.sdfParamsArr[index * 4 + 2] = s;
            this.sdfParamsArr[index * 4 + 3] = atlas.distanceRange;

            let idToChar = {};

            for (let i = 0; i < chars.length; i++) {
                let ci = chars[i];
                let ti = ci.char;

                idToChar[ci.id] = ti;

                let r = new Rectangle(ci.x, ci.y, ci.x + ci.width, ci.y + ci.height);

                let tc = new Array(12);

                tc[0] = r.left / w;
                tc[1] = r.top / h;

                tc[2] = r.left / w;
                tc[3] = r.bottom / h;

                tc[4] = r.right / w;
                tc[5] = r.bottom / h;

                tc[6] = r.right / w;
                tc[7] = r.bottom / h;

                tc[8] = r.right / w;
                tc[9] = r.top / h;

                tc[10] = r.left / w;
                tc[11] = r.top / h;

                let taNode = new TextureAtlasNode(r, tc);
                let ciNorm = ci.char.normalize('NFKC');
                let ciCode = ciNorm.charCodeAt();
                taNode.metrics = ci;
                taNode.metrics.nChar = ciNorm;
                taNode.metrics.nCode = ciCode;
                taNode.metrics.nWidth = taNode.metrics.width / s;
                taNode.metrics.nHeight = taNode.metrics.height / s;
                taNode.metrics.nAdvance = taNode.metrics.xadvance / s;
                taNode.metrics.nXOffset = taNode.metrics.xoffset / s;
                taNode.metrics.nYOffset = 1.0 - taNode.metrics.yoffset / s;
                taNode.emptySize = 1;

                atlas.nodes.set(ciNorm.charCodeAt(), taNode);
            }

            atlas.kernings = {};

            for (let i = 0; i < data.kernings.length; i++) {
                let ki = data.kernings[i];

                let first = ki.first,
                    second = ki.second;

                //let charFirst = idToChar[first],
                //    charSecond = idToChar[second];

                // if (!atlas.kernings[charFirst]) {
                //     atlas.kernings[charFirst] = {};
                // }
                //
                // atlas.kernings[charFirst][charSecond] = ki.amount / s;

                if (!atlas.kernings[first]) {
                    atlas.kernings[first] = {};
                }

                atlas.kernings[first][second] = ki.amount / s;
            }
        }

        initFont(faceName, dataJson, imageBase64) {
            let index = this.atlasesArr.length;
            let fullName = this.getFullIndex(faceName);

            this.atlasIndexes[fullName] = index;

            let def = this.atlasIndexesDeferred[fullName];
            if (!def) {
                def = this.atlasIndexesDeferred[fullName] = new Deferred();
            }

            this.samplerArr[this.atlasesArr.length] = index;

            // TODO: FontTextureAtlas();
            let atlas = new TextureAtlas();

            atlas.height = 0;
            atlas.width = 0;
            atlas.gliphSize = 0;
            atlas.distanceRange = 0;
            atlas.kernings = {};

            atlas.assignHandler(this._handler);

            this.atlasesArr[index] = atlas;

            this._applyFontDataToAtlas(atlas, dataJson, index);

            let img = new Image();
            img.onload = () => {
                this._createTexture(atlas, img);
                def.resolve(index);
            };
            img.src = ARIAL_FONT_B64;
        }

        _createTexture(atlas, img) {
            atlas.createTexture(img);
        }

        loadFont(faceName, srcDir, atlasUrl) {

            let index = this.atlasesArr.length;
            let fullName = this.getFullIndex(faceName);

            this.atlasIndexes[fullName] = index;

            let def = this.atlasIndexesDeferred[fullName];
            if (!def) {
                def = this.atlasIndexesDeferred[fullName] = new Deferred();
            }

            this.samplerArr[this.atlasesArr.length] = index;

            // TODO: FontTextureAtlas();
            let atlas = new TextureAtlas();

            atlas.height = 0;
            atlas.width = 0;
            atlas.gliphSize = 0;
            atlas.distanceRange = 0;
            atlas.kernings = {};

            atlas.assignHandler(this._handler);
            this.atlasesArr[index] = atlas;

            fetch(`${srcDir}/${atlasUrl}`)
                .then(response => {
                    if (!response.ok) {
                        throw Error(`Unable to load "${srcDir}/${atlasUrl}"`);
                    }
                    return response.json(response);
                })
                .then(data => {

                    this._applyFontDataToAtlas(atlas, data, index);

                    let img = new Image();
                    img.onload = () => {
                        this._createTexture(atlas, img);
                        def.resolve(index);
                    };

                    img.src = `${srcDir}/${data.pages[0]}`;
                    img.crossOrigin = "Anonymous";
                })
                .catch(err => {
                    def.reject();
                    return { 'status': "error", 'msg': err.toString() };
                });
        }
    }

    const data = {
        "pages": [
            "arial.ttf.png"
        ],
        "chars": [
            {
                "id": 1033,
                "index": 564,
                "char": "Љ",
                "width": 40,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 34,
                "chnl": 15,
                "x": 0,
                "y": 0,
                "page": 0
            },
            {
                "id": 106,
                "index": 77,
                "char": "j",
                "width": 14,
                "height": 38,
                "xoffset": -5,
                "yoffset": 4,
                "xadvance": 7,
                "chnl": 15,
                "x": 0,
                "y": 32,
                "page": 0
            },
            {
                "id": 1106,
                "index": 635,
                "char": "ђ",
                "width": 24,
                "height": 38,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 0,
                "y": 71,
                "page": 0
            },
            {
                "id": 1112,
                "index": 641,
                "char": "ј",
                "width": 14,
                "height": 38,
                "xoffset": -5,
                "yoffset": 4,
                "xadvance": 7,
                "chnl": 15,
                "x": 15,
                "y": 32,
                "page": 0
            },
            {
                "id": 1118,
                "index": 646,
                "char": "ў",
                "width": 23,
                "height": 38,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 16,
                "chnl": 15,
                "x": 0,
                "y": 110,
                "page": 0
            },
            {
                "id": 946,
                "index": 533,
                "char": "β",
                "width": 23,
                "height": 38,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 0,
                "y": 149,
                "page": 0
            },
            {
                "id": 950,
                "index": 535,
                "char": "ζ",
                "width": 21,
                "height": 38,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 14,
                "chnl": 15,
                "x": 0,
                "y": 188,
                "page": 0
            },
            {
                "id": 958,
                "index": 543,
                "char": "ξ",
                "width": 20,
                "height": 38,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 14,
                "chnl": 15,
                "x": 0,
                "y": 227,
                "page": 0
            },
            {
                "id": 40,
                "index": 11,
                "char": "(",
                "width": 16,
                "height": 38,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 11,
                "chnl": 15,
                "x": 0,
                "y": 266,
                "page": 0
            },
            {
                "id": 41,
                "index": 12,
                "char": ")",
                "width": 16,
                "height": 38,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 11,
                "chnl": 15,
                "x": 0,
                "y": 305,
                "page": 0
            },
            {
                "id": 123,
                "index": 94,
                "char": "{",
                "width": 17,
                "height": 38,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 11,
                "chnl": 15,
                "x": 0,
                "y": 344,
                "page": 0
            },
            {
                "id": 64,
                "index": 35,
                "char": "@",
                "width": 38,
                "height": 38,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 32,
                "chnl": 15,
                "x": 17,
                "y": 266,
                "page": 0
            },
            {
                "id": 125,
                "index": 96,
                "char": "}",
                "width": 17,
                "height": 38,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 11,
                "chnl": 15,
                "x": 21,
                "y": 227,
                "page": 0
            },
            {
                "id": 268,
                "index": 253,
                "char": "Č",
                "width": 28,
                "height": 37,
                "xoffset": -2,
                "yoffset": -2,
                "xadvance": 23,
                "chnl": 15,
                "x": 17,
                "y": 305,
                "page": 0
            },
            {
                "id": 262,
                "index": 251,
                "char": "Ć",
                "width": 28,
                "height": 37,
                "xoffset": -2,
                "yoffset": -2,
                "xadvance": 23,
                "chnl": 15,
                "x": 22,
                "y": 188,
                "page": 0
            },
            {
                "id": 352,
                "index": 226,
                "char": "Š",
                "width": 26,
                "height": 37,
                "xoffset": -3,
                "yoffset": -2,
                "xadvance": 21,
                "chnl": 15,
                "x": 39,
                "y": 226,
                "page": 0
            },
            {
                "id": 87,
                "index": 58,
                "char": "W",
                "width": 37,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 30,
                "chnl": 15,
                "x": 24,
                "y": 110,
                "page": 0
            },
            {
                "id": 381,
                "index": 228,
                "char": "Ž",
                "width": 26,
                "height": 37,
                "xoffset": -3,
                "yoffset": -2,
                "xadvance": 20,
                "chnl": 15,
                "x": 25,
                "y": 71,
                "page": 0
            },
            {
                "id": 1168,
                "index": 648,
                "char": "Ґ",
                "width": 20,
                "height": 37,
                "xoffset": -1,
                "yoffset": -2,
                "xadvance": 16,
                "chnl": 15,
                "x": 30,
                "y": 32,
                "page": 0
            },
            {
                "id": 1046,
                "index": 576,
                "char": "Ж",
                "width": 37,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 30,
                "chnl": 15,
                "x": 41,
                "y": 0,
                "page": 0
            },
            {
                "id": 1034,
                "index": 565,
                "char": "Њ",
                "width": 37,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 32,
                "chnl": 15,
                "x": 51,
                "y": 32,
                "page": 0
            },
            {
                "id": 1038,
                "index": 568,
                "char": "Ў",
                "width": 28,
                "height": 37,
                "xoffset": -4,
                "yoffset": -1,
                "xadvance": 20,
                "chnl": 15,
                "x": 24,
                "y": 142,
                "page": 0
            },
            {
                "id": 1062,
                "index": 592,
                "char": "Ц",
                "width": 28,
                "height": 37,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 24,
                "chnl": 15,
                "x": 52,
                "y": 64,
                "page": 0
            },
            {
                "id": 1039,
                "index": 569,
                "char": "Џ",
                "width": 26,
                "height": 37,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 23,
                "chnl": 15,
                "x": 51,
                "y": 180,
                "page": 0
            },
            {
                "id": 1065,
                "index": 595,
                "char": "Щ",
                "width": 34,
                "height": 37,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 30,
                "chnl": 15,
                "x": 53,
                "y": 142,
                "page": 0
            },
            {
                "id": 1092,
                "index": 622,
                "char": "ф",
                "width": 32,
                "height": 37,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 26,
                "chnl": 15,
                "x": 62,
                "y": 102,
                "page": 0
            },
            {
                "id": 194,
                "index": 198,
                "char": "Â",
                "width": 29,
                "height": 37,
                "xoffset": -4,
                "yoffset": -2,
                "xadvance": 21,
                "chnl": 15,
                "x": 81,
                "y": 64,
                "page": 0
            },
            {
                "id": 202,
                "index": 199,
                "char": "Ê",
                "width": 25,
                "height": 37,
                "xoffset": -1,
                "yoffset": -2,
                "xadvance": 21,
                "chnl": 15,
                "x": 89,
                "y": 0,
                "page": 0
            },
            {
                "id": 212,
                "index": 208,
                "char": "Ô",
                "width": 30,
                "height": 37,
                "xoffset": -2,
                "yoffset": -2,
                "xadvance": 25,
                "chnl": 15,
                "x": 0,
                "y": 383,
                "page": 0
            },
            {
                "id": 91,
                "index": 62,
                "char": "[",
                "width": 14,
                "height": 37,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 9,
                "chnl": 15,
                "x": 18,
                "y": 343,
                "page": 0
            },
            {
                "id": 93,
                "index": 64,
                "char": "]",
                "width": 14,
                "height": 37,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 9,
                "chnl": 15,
                "x": 0,
                "y": 421,
                "page": 0
            },
            {
                "id": 162,
                "index": 132,
                "char": "¢",
                "width": 22,
                "height": 37,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 0,
                "y": 459,
                "page": 0
            },
            {
                "id": 1044,
                "index": 574,
                "char": "Д",
                "width": 29,
                "height": 36,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 22,
                "chnl": 15,
                "x": 15,
                "y": 421,
                "page": 0
            },
            {
                "id": 1025,
                "index": 556,
                "char": "Ё",
                "width": 25,
                "height": 36,
                "xoffset": -1,
                "yoffset": -1,
                "xadvance": 21,
                "chnl": 15,
                "x": 31,
                "y": 381,
                "page": 0
            },
            {
                "id": 1031,
                "index": 562,
                "char": "Ї",
                "width": 17,
                "height": 36,
                "xoffset": -4,
                "yoffset": -1,
                "xadvance": 9,
                "chnl": 15,
                "x": 33,
                "y": 343,
                "page": 0
            },
            {
                "id": 1049,
                "index": 579,
                "char": "Й",
                "width": 26,
                "height": 36,
                "xoffset": -1,
                "yoffset": -1,
                "xadvance": 23,
                "chnl": 15,
                "x": 46,
                "y": 305,
                "page": 0
            },
            {
                "id": 1070,
                "index": 600,
                "char": "Ю",
                "width": 36,
                "height": 32,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 32,
                "chnl": 15,
                "x": 51,
                "y": 342,
                "page": 0
            },
            {
                "id": 1113,
                "index": 642,
                "char": "љ",
                "width": 36,
                "height": 25,
                "xoffset": -4,
                "yoffset": 10,
                "xadvance": 29,
                "chnl": 15,
                "x": 89,
                "y": 38,
                "page": 0
            },
            {
                "id": 910,
                "index": 502,
                "char": "Ύ",
                "width": 36,
                "height": 31,
                "xoffset": -5,
                "yoffset": 4,
                "xadvance": 27,
                "chnl": 15,
                "x": 115,
                "y": 0,
                "page": 0
            },
            {
                "id": 939,
                "index": 527,
                "char": "Ϋ",
                "width": 29,
                "height": 36,
                "xoffset": -4,
                "yoffset": -1,
                "xadvance": 21,
                "chnl": 15,
                "x": 56,
                "y": 264,
                "page": 0
            },
            {
                "id": 258,
                "index": 258,
                "char": "Ă",
                "width": 29,
                "height": 36,
                "xoffset": -4,
                "yoffset": -1,
                "xadvance": 21,
                "chnl": 15,
                "x": 73,
                "y": 301,
                "page": 0
            },
            {
                "id": 36,
                "index": 7,
                "char": "$",
                "width": 23,
                "height": 36,
                "xoffset": -3,
                "yoffset": 2,
                "xadvance": 18,
                "chnl": 15,
                "x": 66,
                "y": 218,
                "page": 0
            },
            {
                "id": 196,
                "index": 98,
                "char": "Ä",
                "width": 29,
                "height": 36,
                "xoffset": -4,
                "yoffset": -1,
                "xadvance": 21,
                "chnl": 15,
                "x": 78,
                "y": 180,
                "page": 0
            },
            {
                "id": 214,
                "index": 103,
                "char": "Ö",
                "width": 30,
                "height": 36,
                "xoffset": -2,
                "yoffset": -1,
                "xadvance": 25,
                "chnl": 15,
                "x": 88,
                "y": 140,
                "page": 0
            },
            {
                "id": 220,
                "index": 104,
                "char": "Ü",
                "width": 26,
                "height": 36,
                "xoffset": -1,
                "yoffset": -1,
                "xadvance": 23,
                "chnl": 15,
                "x": 95,
                "y": 102,
                "page": 0
            },
            {
                "id": 1026,
                "index": 557,
                "char": "Ђ",
                "width": 34,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 28,
                "chnl": 15,
                "x": 111,
                "y": 64,
                "page": 0
            },
            {
                "id": 81,
                "index": 52,
                "char": "Q",
                "width": 30,
                "height": 33,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 25,
                "chnl": 15,
                "x": 86,
                "y": 255,
                "page": 0
            },
            {
                "id": 1035,
                "index": 566,
                "char": "Ћ",
                "width": 33,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 27,
                "chnl": 15,
                "x": 126,
                "y": 32,
                "page": 0
            },
            {
                "id": 904,
                "index": 498,
                "char": "Έ",
                "width": 33,
                "height": 31,
                "xoffset": -5,
                "yoffset": 4,
                "xadvance": 25,
                "chnl": 15,
                "x": 152,
                "y": 0,
                "page": 0
            },
            {
                "id": 905,
                "index": 499,
                "char": "Ή",
                "width": 33,
                "height": 31,
                "xoffset": -5,
                "yoffset": 4,
                "xadvance": 27,
                "chnl": 15,
                "x": 90,
                "y": 217,
                "page": 0
            },
            {
                "id": 908,
                "index": 501,
                "char": "Ό",
                "width": 33,
                "height": 32,
                "xoffset": -5,
                "yoffset": 4,
                "xadvance": 25,
                "chnl": 15,
                "x": 108,
                "y": 177,
                "page": 0
            },
            {
                "id": 416,
                "index": 1130,
                "char": "Ơ",
                "width": 33,
                "height": 32,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 27,
                "chnl": 15,
                "x": 119,
                "y": 139,
                "page": 0
            },
            {
                "id": 37,
                "index": 8,
                "char": "%",
                "width": 33,
                "height": 32,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 28,
                "chnl": 15,
                "x": 122,
                "y": 96,
                "page": 0
            },
            {
                "id": 67,
                "index": 38,
                "char": "C",
                "width": 28,
                "height": 32,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 23,
                "chnl": 15,
                "x": 23,
                "y": 458,
                "page": 0
            },
            {
                "id": 71,
                "index": 42,
                "char": "G",
                "width": 29,
                "height": 32,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 25,
                "chnl": 15,
                "x": 45,
                "y": 418,
                "page": 0
            },
            {
                "id": 79,
                "index": 50,
                "char": "O",
                "width": 30,
                "height": 32,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 25,
                "chnl": 15,
                "x": 57,
                "y": 375,
                "page": 0
            },
            {
                "id": 83,
                "index": 54,
                "char": "S",
                "width": 26,
                "height": 32,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 52,
                "y": 451,
                "page": 0
            },
            {
                "id": 103,
                "index": 74,
                "char": "g",
                "width": 23,
                "height": 32,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 75,
                "y": 408,
                "page": 0
            },
            {
                "id": 1028,
                "index": 559,
                "char": "Є",
                "width": 28,
                "height": 32,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 23,
                "chnl": 15,
                "x": 88,
                "y": 338,
                "page": 0
            },
            {
                "id": 1047,
                "index": 577,
                "char": "З",
                "width": 25,
                "height": 32,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 19,
                "chnl": 15,
                "x": 88,
                "y": 371,
                "page": 0
            },
            {
                "id": 1029,
                "index": 560,
                "char": "Ѕ",
                "width": 26,
                "height": 32,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 103,
                "y": 289,
                "page": 0
            },
            {
                "id": 1054,
                "index": 584,
                "char": "О",
                "width": 30,
                "height": 32,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 25,
                "chnl": 15,
                "x": 117,
                "y": 249,
                "page": 0
            },
            {
                "id": 1057,
                "index": 587,
                "char": "С",
                "width": 28,
                "height": 32,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 23,
                "chnl": 15,
                "x": 124,
                "y": 210,
                "page": 0
            },
            {
                "id": 1064,
                "index": 594,
                "char": "Ш",
                "width": 32,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 29,
                "chnl": 15,
                "x": 146,
                "y": 64,
                "page": 0
            },
            {
                "id": 1066,
                "index": 596,
                "char": "Ъ",
                "width": 32,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 25,
                "chnl": 15,
                "x": 160,
                "y": 32,
                "page": 0
            },
            {
                "id": 1069,
                "index": 599,
                "char": "Э",
                "width": 28,
                "height": 32,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 23,
                "chnl": 15,
                "x": 142,
                "y": 172,
                "page": 0
            },
            {
                "id": 1073,
                "index": 603,
                "char": "б",
                "width": 24,
                "height": 32,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 153,
                "y": 129,
                "page": 0
            },
            {
                "id": 920,
                "index": 300,
                "char": "Θ",
                "width": 30,
                "height": 32,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 25,
                "chnl": 15,
                "x": 156,
                "y": 96,
                "page": 0
            },
            {
                "id": 927,
                "index": 517,
                "char": "Ο",
                "width": 30,
                "height": 32,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 25,
                "chnl": 15,
                "x": 79,
                "y": 441,
                "page": 0
            },
            {
                "id": 934,
                "index": 301,
                "char": "Φ",
                "width": 31,
                "height": 32,
                "xoffset": -3,
                "yoffset": 3,
                "xadvance": 26,
                "chnl": 15,
                "x": 99,
                "y": 404,
                "page": 0
            },
            {
                "id": 952,
                "index": 537,
                "char": "θ",
                "width": 23,
                "height": 32,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 114,
                "y": 371,
                "page": 0
            },
            {
                "id": 912,
                "index": 504,
                "char": "ΐ",
                "width": 19,
                "height": 32,
                "xoffset": -6,
                "yoffset": 3,
                "xadvance": 7,
                "chnl": 15,
                "x": 79,
                "y": 474,
                "page": 0
            },
            {
                "id": 944,
                "index": 532,
                "char": "ΰ",
                "width": 21,
                "height": 32,
                "xoffset": -2,
                "yoffset": 3,
                "xadvance": 18,
                "chnl": 15,
                "x": 99,
                "y": 474,
                "page": 0
            },
            {
                "id": 911,
                "index": 503,
                "char": "Ώ",
                "width": 32,
                "height": 31,
                "xoffset": -5,
                "yoffset": 4,
                "xadvance": 24,
                "chnl": 15,
                "x": 186,
                "y": 0,
                "page": 0
            },
            {
                "id": 431,
                "index": 1132,
                "char": "Ư",
                "width": 32,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 27,
                "chnl": 15,
                "x": 179,
                "y": 64,
                "page": 0
            },
            {
                "id": 35,
                "index": 6,
                "char": "#",
                "width": 25,
                "height": 32,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 110,
                "y": 437,
                "page": 0
            },
            {
                "id": 47,
                "index": 18,
                "char": "/",
                "width": 17,
                "height": 32,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 9,
                "chnl": 15,
                "x": 131,
                "y": 404,
                "page": 0
            },
            {
                "id": 38,
                "index": 9,
                "char": "&",
                "width": 27,
                "height": 32,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 121,
                "y": 470,
                "page": 0
            },
            {
                "id": 92,
                "index": 63,
                "char": "\\",
                "width": 17,
                "height": 32,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 9,
                "chnl": 15,
                "x": 136,
                "y": 437,
                "page": 0
            },
            {
                "id": 174,
                "index": 138,
                "char": "®",
                "width": 32,
                "height": 32,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 24,
                "chnl": 15,
                "x": 149,
                "y": 470,
                "page": 0
            },
            {
                "id": 169,
                "index": 139,
                "char": "©",
                "width": 32,
                "height": 32,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 24,
                "chnl": 15,
                "x": 117,
                "y": 322,
                "page": 0
            },
            {
                "id": 8364,
                "index": 188,
                "char": "€",
                "width": 26,
                "height": 32,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 130,
                "y": 282,
                "page": 0
            },
            {
                "id": 163,
                "index": 133,
                "char": "£",
                "width": 24,
                "height": 32,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 148,
                "y": 243,
                "page": 0
            },
            {
                "id": 223,
                "index": 137,
                "char": "ß",
                "width": 24,
                "height": 32,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 20,
                "chnl": 15,
                "x": 153,
                "y": 205,
                "page": 0
            },
            {
                "id": 65,
                "index": 36,
                "char": "A",
                "width": 29,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 193,
                "y": 32,
                "page": 0
            },
            {
                "id": 66,
                "index": 37,
                "char": "B",
                "width": 25,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 219,
                "y": 0,
                "page": 0
            },
            {
                "id": 68,
                "index": 39,
                "char": "D",
                "width": 27,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 23,
                "chnl": 15,
                "x": 171,
                "y": 162,
                "page": 0
            },
            {
                "id": 272,
                "index": 264,
                "char": "Đ",
                "width": 29,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 23,
                "chnl": 15,
                "x": 178,
                "y": 129,
                "page": 0
            },
            {
                "id": 69,
                "index": 40,
                "char": "E",
                "width": 25,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 187,
                "y": 96,
                "page": 0
            },
            {
                "id": 70,
                "index": 41,
                "char": "F",
                "width": 23,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 20,
                "chnl": 15,
                "x": 212,
                "y": 64,
                "page": 0
            },
            {
                "id": 72,
                "index": 43,
                "char": "H",
                "width": 26,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 23,
                "chnl": 15,
                "x": 223,
                "y": 32,
                "page": 0
            },
            {
                "id": 73,
                "index": 44,
                "char": "I",
                "width": 11,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 9,
                "chnl": 15,
                "x": 245,
                "y": 0,
                "page": 0
            },
            {
                "id": 74,
                "index": 45,
                "char": "J",
                "width": 21,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 16,
                "chnl": 15,
                "x": 138,
                "y": 355,
                "page": 0
            },
            {
                "id": 75,
                "index": 46,
                "char": "K",
                "width": 27,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 150,
                "y": 315,
                "page": 0
            },
            {
                "id": 76,
                "index": 47,
                "char": "L",
                "width": 22,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 157,
                "y": 276,
                "page": 0
            },
            {
                "id": 77,
                "index": 48,
                "char": "M",
                "width": 30,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 27,
                "chnl": 15,
                "x": 173,
                "y": 238,
                "page": 0
            },
            {
                "id": 78,
                "index": 49,
                "char": "N",
                "width": 26,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 23,
                "chnl": 15,
                "x": 178,
                "y": 194,
                "page": 0
            },
            {
                "id": 80,
                "index": 51,
                "char": "P",
                "width": 25,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 199,
                "y": 161,
                "page": 0
            },
            {
                "id": 82,
                "index": 53,
                "char": "R",
                "width": 28,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 23,
                "chnl": 15,
                "x": 208,
                "y": 128,
                "page": 0
            },
            {
                "id": 84,
                "index": 55,
                "char": "T",
                "width": 26,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 20,
                "chnl": 15,
                "x": 213,
                "y": 96,
                "page": 0
            },
            {
                "id": 85,
                "index": 56,
                "char": "U",
                "width": 26,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 23,
                "chnl": 15,
                "x": 236,
                "y": 64,
                "page": 0
            },
            {
                "id": 86,
                "index": 57,
                "char": "V",
                "width": 29,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 250,
                "y": 32,
                "page": 0
            },
            {
                "id": 88,
                "index": 59,
                "char": "X",
                "width": 29,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 257,
                "y": 0,
                "page": 0
            },
            {
                "id": 89,
                "index": 60,
                "char": "Y",
                "width": 29,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 149,
                "y": 387,
                "page": 0
            },
            {
                "id": 90,
                "index": 61,
                "char": "Z",
                "width": 26,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 20,
                "chnl": 15,
                "x": 160,
                "y": 347,
                "page": 0
            },
            {
                "id": 98,
                "index": 69,
                "char": "b",
                "width": 22,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 178,
                "y": 308,
                "page": 0
            },
            {
                "id": 269,
                "index": 254,
                "char": "č",
                "width": 22,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 16,
                "chnl": 15,
                "x": 180,
                "y": 270,
                "page": 0
            },
            {
                "id": 263,
                "index": 252,
                "char": "ć",
                "width": 22,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 16,
                "chnl": 15,
                "x": 154,
                "y": 419,
                "page": 0
            },
            {
                "id": 100,
                "index": 71,
                "char": "d",
                "width": 22,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 177,
                "y": 419,
                "page": 0
            },
            {
                "id": 273,
                "index": 255,
                "char": "đ",
                "width": 25,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 179,
                "y": 379,
                "page": 0
            },
            {
                "id": 102,
                "index": 73,
                "char": "f",
                "width": 18,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 9,
                "chnl": 15,
                "x": 187,
                "y": 340,
                "page": 0
            },
            {
                "id": 104,
                "index": 75,
                "char": "h",
                "width": 22,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 201,
                "y": 302,
                "page": 0
            },
            {
                "id": 105,
                "index": 76,
                "char": "i",
                "width": 11,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 7,
                "chnl": 15,
                "x": 203,
                "y": 270,
                "page": 0
            },
            {
                "id": 107,
                "index": 78,
                "char": "k",
                "width": 22,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 16,
                "chnl": 15,
                "x": 204,
                "y": 226,
                "page": 0
            },
            {
                "id": 108,
                "index": 79,
                "char": "l",
                "width": 11,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 7,
                "chnl": 15,
                "x": 205,
                "y": 193,
                "page": 0
            },
            {
                "id": 112,
                "index": 83,
                "char": "p",
                "width": 22,
                "height": 31,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 217,
                "y": 193,
                "page": 0
            },
            {
                "id": 113,
                "index": 84,
                "char": "q",
                "width": 22,
                "height": 31,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 225,
                "y": 160,
                "page": 0
            },
            {
                "id": 353,
                "index": 227,
                "char": "š",
                "width": 22,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 16,
                "chnl": 15,
                "x": 237,
                "y": 128,
                "page": 0
            },
            {
                "id": 116,
                "index": 87,
                "char": "t",
                "width": 16,
                "height": 31,
                "xoffset": -3,
                "yoffset": 5,
                "xadvance": 9,
                "chnl": 15,
                "x": 240,
                "y": 96,
                "page": 0
            },
            {
                "id": 119,
                "index": 90,
                "char": "w",
                "width": 31,
                "height": 25,
                "xoffset": -4,
                "yoffset": 10,
                "xadvance": 23,
                "chnl": 15,
                "x": 257,
                "y": 96,
                "page": 0
            },
            {
                "id": 121,
                "index": 92,
                "char": "y",
                "width": 23,
                "height": 31,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 16,
                "chnl": 15,
                "x": 263,
                "y": 64,
                "page": 0
            },
            {
                "id": 382,
                "index": 229,
                "char": "ž",
                "width": 23,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 16,
                "chnl": 15,
                "x": 280,
                "y": 32,
                "page": 0
            },
            {
                "id": 1040,
                "index": 570,
                "char": "А",
                "width": 29,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 287,
                "y": 0,
                "page": 0
            },
            {
                "id": 1041,
                "index": 571,
                "char": "Б",
                "width": 25,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 287,
                "y": 64,
                "page": 0
            },
            {
                "id": 1042,
                "index": 572,
                "char": "В",
                "width": 25,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 304,
                "y": 32,
                "page": 0
            },
            {
                "id": 1043,
                "index": 573,
                "char": "Г",
                "width": 23,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 17,
                "chnl": 15,
                "x": 317,
                "y": 0,
                "page": 0
            },
            {
                "id": 1045,
                "index": 575,
                "char": "Е",
                "width": 25,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 215,
                "y": 258,
                "page": 0
            },
            {
                "id": 1048,
                "index": 578,
                "char": "И",
                "width": 26,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 23,
                "chnl": 15,
                "x": 227,
                "y": 225,
                "page": 0
            },
            {
                "id": 1030,
                "index": 561,
                "char": "І",
                "width": 11,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 9,
                "chnl": 15,
                "x": 240,
                "y": 192,
                "page": 0
            },
            {
                "id": 1032,
                "index": 563,
                "char": "Ј",
                "width": 21,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 16,
                "chnl": 15,
                "x": 248,
                "y": 160,
                "page": 0
            },
            {
                "id": 1050,
                "index": 580,
                "char": "К",
                "width": 24,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 19,
                "chnl": 15,
                "x": 252,
                "y": 192,
                "page": 0
            },
            {
                "id": 1051,
                "index": 581,
                "char": "Л",
                "width": 26,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 260,
                "y": 122,
                "page": 0
            },
            {
                "id": 1052,
                "index": 582,
                "char": "М",
                "width": 30,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 27,
                "chnl": 15,
                "x": 270,
                "y": 154,
                "page": 0
            },
            {
                "id": 1053,
                "index": 583,
                "char": "Н",
                "width": 26,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 23,
                "chnl": 15,
                "x": 287,
                "y": 122,
                "page": 0
            },
            {
                "id": 1055,
                "index": 585,
                "char": "П",
                "width": 26,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 23,
                "chnl": 15,
                "x": 313,
                "y": 64,
                "page": 0
            },
            {
                "id": 1056,
                "index": 586,
                "char": "Р",
                "width": 25,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 330,
                "y": 32,
                "page": 0
            },
            {
                "id": 1058,
                "index": 588,
                "char": "Т",
                "width": 26,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 20,
                "chnl": 15,
                "x": 341,
                "y": 0,
                "page": 0
            },
            {
                "id": 1059,
                "index": 589,
                "char": "У",
                "width": 28,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 20,
                "chnl": 15,
                "x": 182,
                "y": 451,
                "page": 0
            },
            {
                "id": 1060,
                "index": 590,
                "char": "Ф",
                "width": 30,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 24,
                "chnl": 15,
                "x": 200,
                "y": 411,
                "page": 0
            },
            {
                "id": 1061,
                "index": 591,
                "char": "Х",
                "width": 29,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 205,
                "y": 372,
                "page": 0
            },
            {
                "id": 1063,
                "index": 593,
                "char": "Ч",
                "width": 25,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 206,
                "y": 334,
                "page": 0
            },
            {
                "id": 1067,
                "index": 597,
                "char": "Ы",
                "width": 31,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 28,
                "chnl": 15,
                "x": 224,
                "y": 290,
                "page": 0
            },
            {
                "id": 1068,
                "index": 598,
                "char": "Ь",
                "width": 25,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 241,
                "y": 257,
                "page": 0
            },
            {
                "id": 1071,
                "index": 601,
                "char": "Я",
                "width": 28,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 23,
                "chnl": 15,
                "x": 254,
                "y": 224,
                "page": 0
            },
            {
                "id": 1169,
                "index": 649,
                "char": "ґ",
                "width": 18,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 13,
                "chnl": 15,
                "x": 277,
                "y": 186,
                "page": 0
            },
            {
                "id": 1105,
                "index": 634,
                "char": "ё",
                "width": 23,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 232,
                "y": 322,
                "page": 0
            },
            {
                "id": 1110,
                "index": 639,
                "char": "і",
                "width": 11,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 7,
                "chnl": 15,
                "x": 211,
                "y": 443,
                "page": 0
            },
            {
                "id": 1111,
                "index": 640,
                "char": "ї",
                "width": 17,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 9,
                "chnl": 15,
                "x": 211,
                "y": 475,
                "page": 0
            },
            {
                "id": 1081,
                "index": 611,
                "char": "й",
                "width": 22,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 223,
                "y": 443,
                "page": 0
            },
            {
                "id": 1114,
                "index": 643,
                "char": "њ",
                "width": 31,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 26,
                "chnl": 15,
                "x": 289,
                "y": 96,
                "page": 0
            },
            {
                "id": 1088,
                "index": 618,
                "char": "р",
                "width": 22,
                "height": 31,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 229,
                "y": 475,
                "page": 0
            },
            {
                "id": 1115,
                "index": 644,
                "char": "ћ",
                "width": 24,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 231,
                "y": 404,
                "page": 0
            },
            {
                "id": 1091,
                "index": 621,
                "char": "у",
                "width": 23,
                "height": 31,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 16,
                "chnl": 15,
                "x": 246,
                "y": 436,
                "page": 0
            },
            {
                "id": 1097,
                "index": 627,
                "char": "щ",
                "width": 31,
                "height": 29,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 26,
                "chnl": 15,
                "x": 252,
                "y": 468,
                "page": 0
            },
            {
                "id": 913,
                "index": 505,
                "char": "Α",
                "width": 29,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 235,
                "y": 354,
                "page": 0
            },
            {
                "id": 914,
                "index": 506,
                "char": "Β",
                "width": 25,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 256,
                "y": 386,
                "page": 0
            },
            {
                "id": 915,
                "index": 299,
                "char": "Γ",
                "width": 22,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 270,
                "y": 418,
                "page": 0
            },
            {
                "id": 916,
                "index": 507,
                "char": "Δ",
                "width": 29,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 284,
                "y": 450,
                "page": 0
            },
            {
                "id": 917,
                "index": 508,
                "char": "Ε",
                "width": 25,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 256,
                "y": 289,
                "page": 0
            },
            {
                "id": 918,
                "index": 509,
                "char": "Ζ",
                "width": 26,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 20,
                "chnl": 15,
                "x": 256,
                "y": 321,
                "page": 0
            },
            {
                "id": 919,
                "index": 510,
                "char": "Η",
                "width": 26,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 23,
                "chnl": 15,
                "x": 267,
                "y": 256,
                "page": 0
            },
            {
                "id": 921,
                "index": 511,
                "char": "Ι",
                "width": 11,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 9,
                "chnl": 15,
                "x": 265,
                "y": 353,
                "page": 0
            },
            {
                "id": 922,
                "index": 512,
                "char": "Κ",
                "width": 27,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 282,
                "y": 288,
                "page": 0
            },
            {
                "id": 923,
                "index": 513,
                "char": "Λ",
                "width": 29,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 277,
                "y": 353,
                "page": 0
            },
            {
                "id": 924,
                "index": 514,
                "char": "Μ",
                "width": 30,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 27,
                "chnl": 15,
                "x": 282,
                "y": 385,
                "page": 0
            },
            {
                "id": 925,
                "index": 515,
                "char": "Ν",
                "width": 26,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 23,
                "chnl": 15,
                "x": 283,
                "y": 320,
                "page": 0
            },
            {
                "id": 926,
                "index": 516,
                "char": "Ξ",
                "width": 25,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 293,
                "y": 417,
                "page": 0
            },
            {
                "id": 928,
                "index": 518,
                "char": "Π",
                "width": 26,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 23,
                "chnl": 15,
                "x": 307,
                "y": 352,
                "page": 0
            },
            {
                "id": 929,
                "index": 519,
                "char": "Ρ",
                "width": 25,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 313,
                "y": 384,
                "page": 0
            },
            {
                "id": 931,
                "index": 520,
                "char": "Σ",
                "width": 24,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 20,
                "chnl": 15,
                "x": 283,
                "y": 218,
                "page": 0
            },
            {
                "id": 932,
                "index": 521,
                "char": "Τ",
                "width": 26,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 20,
                "chnl": 15,
                "x": 296,
                "y": 186,
                "page": 0
            },
            {
                "id": 933,
                "index": 522,
                "char": "Υ",
                "width": 29,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 301,
                "y": 154,
                "page": 0
            },
            {
                "id": 935,
                "index": 523,
                "char": "Χ",
                "width": 29,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 314,
                "y": 122,
                "page": 0
            },
            {
                "id": 936,
                "index": 524,
                "char": "Ψ",
                "width": 31,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 27,
                "chnl": 15,
                "x": 294,
                "y": 250,
                "page": 0
            },
            {
                "id": 937,
                "index": 525,
                "char": "Ω",
                "width": 29,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 24,
                "chnl": 15,
                "x": 308,
                "y": 218,
                "page": 0
            },
            {
                "id": 947,
                "index": 534,
                "char": "γ",
                "width": 23,
                "height": 31,
                "xoffset": -4,
                "yoffset": 10,
                "xadvance": 16,
                "chnl": 15,
                "x": 323,
                "y": 186,
                "page": 0
            },
            {
                "id": 948,
                "index": 303,
                "char": "δ",
                "width": 24,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 331,
                "y": 154,
                "page": 0
            },
            {
                "id": 951,
                "index": 536,
                "char": "η",
                "width": 21,
                "height": 31,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 340,
                "y": 64,
                "page": 0
            },
            {
                "id": 955,
                "index": 540,
                "char": "λ",
                "width": 23,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 16,
                "chnl": 15,
                "x": 356,
                "y": 32,
                "page": 0
            },
            {
                "id": 956,
                "index": 541,
                "char": "μ",
                "width": 21,
                "height": 31,
                "xoffset": -1,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 368,
                "y": 0,
                "page": 0
            },
            {
                "id": 961,
                "index": 545,
                "char": "ρ",
                "width": 23,
                "height": 31,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 344,
                "y": 96,
                "page": 0
            },
            {
                "id": 966,
                "index": 307,
                "char": "φ",
                "width": 27,
                "height": 31,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 21,
                "chnl": 15,
                "x": 362,
                "y": 64,
                "page": 0
            },
            {
                "id": 967,
                "index": 548,
                "char": "χ",
                "width": 24,
                "height": 31,
                "xoffset": -4,
                "yoffset": 10,
                "xadvance": 17,
                "chnl": 15,
                "x": 380,
                "y": 32,
                "page": 0
            },
            {
                "id": 968,
                "index": 549,
                "char": "ψ",
                "width": 27,
                "height": 31,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 23,
                "chnl": 15,
                "x": 390,
                "y": 0,
                "page": 0
            },
            {
                "id": 940,
                "index": 528,
                "char": "ά",
                "width": 24,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 19,
                "chnl": 15,
                "x": 314,
                "y": 449,
                "page": 0
            },
            {
                "id": 902,
                "index": 497,
                "char": "Ά",
                "width": 29,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 21,
                "chnl": 15,
                "x": 314,
                "y": 481,
                "page": 0
            },
            {
                "id": 941,
                "index": 529,
                "char": "έ",
                "width": 20,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 14,
                "chnl": 15,
                "x": 319,
                "y": 416,
                "page": 0
            },
            {
                "id": 943,
                "index": 531,
                "char": "ί",
                "width": 14,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 7,
                "chnl": 15,
                "x": 339,
                "y": 448,
                "page": 0
            },
            {
                "id": 970,
                "index": 551,
                "char": "ϊ",
                "width": 17,
                "height": 31,
                "xoffset": -5,
                "yoffset": 4,
                "xadvance": 7,
                "chnl": 15,
                "x": 344,
                "y": 480,
                "page": 0
            },
            {
                "id": 906,
                "index": 500,
                "char": "Ί",
                "width": 18,
                "height": 31,
                "xoffset": -5,
                "yoffset": 4,
                "xadvance": 12,
                "chnl": 15,
                "x": 310,
                "y": 282,
                "page": 0
            },
            {
                "id": 972,
                "index": 553,
                "char": "ό",
                "width": 24,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 326,
                "y": 250,
                "page": 0
            },
            {
                "id": 973,
                "index": 554,
                "char": "ύ",
                "width": 21,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 338,
                "y": 218,
                "page": 0
            },
            {
                "id": 971,
                "index": 552,
                "char": "ϋ",
                "width": 21,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 347,
                "y": 186,
                "page": 0
            },
            {
                "id": 259,
                "index": 259,
                "char": "ă",
                "width": 23,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 310,
                "y": 314,
                "page": 0
            },
            {
                "id": 226,
                "index": 107,
                "char": "â",
                "width": 23,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 329,
                "y": 282,
                "page": 0
            },
            {
                "id": 234,
                "index": 114,
                "char": "ê",
                "width": 23,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 351,
                "y": 250,
                "page": 0
            },
            {
                "id": 244,
                "index": 123,
                "char": "ô",
                "width": 24,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 360,
                "y": 218,
                "page": 0
            },
            {
                "id": 49,
                "index": 20,
                "char": "1",
                "width": 16,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 356,
                "y": 128,
                "page": 0
            },
            {
                "id": 50,
                "index": 21,
                "char": "2",
                "width": 23,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 368,
                "y": 96,
                "page": 0
            },
            {
                "id": 51,
                "index": 22,
                "char": "3",
                "width": 23,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 390,
                "y": 64,
                "page": 0
            },
            {
                "id": 52,
                "index": 23,
                "char": "4",
                "width": 24,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 405,
                "y": 32,
                "page": 0
            },
            {
                "id": 53,
                "index": 24,
                "char": "5",
                "width": 23,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 418,
                "y": 0,
                "page": 0
            },
            {
                "id": 54,
                "index": 25,
                "char": "6",
                "width": 23,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 369,
                "y": 160,
                "page": 0
            },
            {
                "id": 55,
                "index": 26,
                "char": "7",
                "width": 23,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 373,
                "y": 128,
                "page": 0
            },
            {
                "id": 56,
                "index": 27,
                "char": "8",
                "width": 23,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 392,
                "y": 96,
                "page": 0
            },
            {
                "id": 57,
                "index": 28,
                "char": "9",
                "width": 23,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 414,
                "y": 64,
                "page": 0
            },
            {
                "id": 48,
                "index": 19,
                "char": "0",
                "width": 23,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 430,
                "y": 32,
                "page": 0
            },
            {
                "id": 63,
                "index": 34,
                "char": "?",
                "width": 23,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 442,
                "y": 0,
                "page": 0
            },
            {
                "id": 33,
                "index": 4,
                "char": "!",
                "width": 11,
                "height": 31,
                "xoffset": -1,
                "yoffset": 4,
                "xadvance": 9,
                "chnl": 15,
                "x": 466,
                "y": 0,
                "page": 0
            },
            {
                "id": 165,
                "index": 150,
                "char": "¥",
                "width": 26,
                "height": 31,
                "xoffset": -4,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 478,
                "y": 0,
                "page": 0
            },
            {
                "id": 228,
                "index": 108,
                "char": "ä",
                "width": 23,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 454,
                "y": 32,
                "page": 0
            },
            {
                "id": 246,
                "index": 124,
                "char": "ö",
                "width": 24,
                "height": 31,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 478,
                "y": 32,
                "page": 0
            },
            {
                "id": 252,
                "index": 129,
                "char": "ü",
                "width": 21,
                "height": 31,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 18,
                "chnl": 15,
                "x": 334,
                "y": 314,
                "page": 0
            },
            {
                "id": 109,
                "index": 80,
                "char": "m",
                "width": 30,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 27,
                "chnl": 15,
                "x": 369,
                "y": 192,
                "page": 0
            },
            {
                "id": 1078,
                "index": 608,
                "char": "ж",
                "width": 30,
                "height": 25,
                "xoffset": -4,
                "yoffset": 10,
                "xadvance": 21,
                "chnl": 15,
                "x": 353,
                "y": 282,
                "page": 0
            },
            {
                "id": 969,
                "index": 550,
                "char": "ω",
                "width": 30,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 25,
                "chnl": 15,
                "x": 393,
                "y": 160,
                "page": 0
            },
            {
                "id": 1076,
                "index": 606,
                "char": "д",
                "width": 26,
                "height": 29,
                "xoffset": -4,
                "yoffset": 10,
                "xadvance": 19,
                "chnl": 15,
                "x": 182,
                "y": 483,
                "page": 0
            },
            {
                "id": 1094,
                "index": 624,
                "char": "ц",
                "width": 23,
                "height": 29,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 284,
                "y": 482,
                "page": 0
            },
            {
                "id": 1119,
                "index": 647,
                "char": "џ",
                "width": 21,
                "height": 29,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 375,
                "y": 250,
                "page": 0
            },
            {
                "id": 1096,
                "index": 626,
                "char": "ш",
                "width": 29,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 26,
                "chnl": 15,
                "x": 397,
                "y": 128,
                "page": 0
            },
            {
                "id": 1102,
                "index": 632,
                "char": "ю",
                "width": 29,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 24,
                "chnl": 15,
                "x": 385,
                "y": 218,
                "page": 0
            },
            {
                "id": 960,
                "index": 652,
                "char": "π",
                "width": 29,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 22,
                "chnl": 15,
                "x": 416,
                "y": 96,
                "page": 0
            },
            {
                "id": 59,
                "index": 30,
                "char": ";",
                "width": 11,
                "height": 29,
                "xoffset": -1,
                "yoffset": 10,
                "xadvance": 9,
                "chnl": 15,
                "x": 400,
                "y": 186,
                "page": 0
            },
            {
                "id": 7838,
                "index": 0,
                "char": "ẞ",
                "width": 24,
                "height": 28,
                "xoffset": 0,
                "yoffset": 7,
                "xadvance": 24,
                "chnl": 15,
                "x": 52,
                "y": 484,
                "page": 0
            },
            {
                "id": 1099,
                "index": 629,
                "char": "ы",
                "width": 27,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 23,
                "chnl": 15,
                "x": 438,
                "y": 64,
                "page": 0
            },
            {
                "id": 417,
                "index": 1131,
                "char": "ơ",
                "width": 27,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 21,
                "chnl": 15,
                "x": 412,
                "y": 186,
                "page": 0
            },
            {
                "id": 1084,
                "index": 614,
                "char": "м",
                "width": 26,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 22,
                "chnl": 15,
                "x": 424,
                "y": 154,
                "page": 0
            },
            {
                "id": 1098,
                "index": 628,
                "char": "ъ",
                "width": 26,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 20,
                "chnl": 15,
                "x": 427,
                "y": 122,
                "page": 0
            },
            {
                "id": 963,
                "index": 305,
                "char": "σ",
                "width": 26,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 20,
                "chnl": 15,
                "x": 446,
                "y": 90,
                "page": 0
            },
            {
                "id": 432,
                "index": 1133,
                "char": "ư",
                "width": 26,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 21,
                "chnl": 15,
                "x": 466,
                "y": 64,
                "page": 0
            },
            {
                "id": 97,
                "index": 68,
                "char": "a",
                "width": 23,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 334,
                "y": 346,
                "page": 0
            },
            {
                "id": 99,
                "index": 70,
                "char": "c",
                "width": 22,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 16,
                "chnl": 15,
                "x": 321,
                "y": 96,
                "page": 0
            },
            {
                "id": 101,
                "index": 72,
                "char": "e",
                "width": 23,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 356,
                "y": 308,
                "page": 0
            },
            {
                "id": 110,
                "index": 81,
                "char": "n",
                "width": 21,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 473,
                "y": 90,
                "page": 0
            },
            {
                "id": 111,
                "index": 82,
                "char": "o",
                "width": 24,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 339,
                "y": 372,
                "page": 0
            },
            {
                "id": 114,
                "index": 85,
                "char": "r",
                "width": 17,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 11,
                "chnl": 15,
                "x": 493,
                "y": 64,
                "page": 0
            },
            {
                "id": 115,
                "index": 86,
                "char": "s",
                "width": 22,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 16,
                "chnl": 15,
                "x": 358,
                "y": 334,
                "page": 0
            },
            {
                "id": 117,
                "index": 88,
                "char": "u",
                "width": 21,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 380,
                "y": 308,
                "page": 0
            },
            {
                "id": 118,
                "index": 89,
                "char": "v",
                "width": 23,
                "height": 25,
                "xoffset": -4,
                "yoffset": 10,
                "xadvance": 16,
                "chnl": 15,
                "x": 384,
                "y": 280,
                "page": 0
            },
            {
                "id": 120,
                "index": 91,
                "char": "x",
                "width": 24,
                "height": 25,
                "xoffset": -4,
                "yoffset": 10,
                "xadvance": 16,
                "chnl": 15,
                "x": 397,
                "y": 244,
                "page": 0
            },
            {
                "id": 122,
                "index": 93,
                "char": "z",
                "width": 23,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 16,
                "chnl": 15,
                "x": 415,
                "y": 212,
                "page": 0
            },
            {
                "id": 1072,
                "index": 602,
                "char": "а",
                "width": 23,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 340,
                "y": 398,
                "page": 0
            },
            {
                "id": 1074,
                "index": 604,
                "char": "в",
                "width": 22,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 17,
                "chnl": 15,
                "x": 354,
                "y": 424,
                "page": 0
            },
            {
                "id": 1075,
                "index": 605,
                "char": "г",
                "width": 18,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 12,
                "chnl": 15,
                "x": 354,
                "y": 450,
                "page": 0
            },
            {
                "id": 1077,
                "index": 607,
                "char": "е",
                "width": 23,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 362,
                "y": 476,
                "page": 0
            },
            {
                "id": 1108,
                "index": 637,
                "char": "є",
                "width": 22,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 16,
                "chnl": 15,
                "x": 373,
                "y": 450,
                "page": 0
            },
            {
                "id": 1079,
                "index": 609,
                "char": "з",
                "width": 21,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 15,
                "chnl": 15,
                "x": 386,
                "y": 476,
                "page": 0
            },
            {
                "id": 1109,
                "index": 638,
                "char": "ѕ",
                "width": 22,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 16,
                "chnl": 15,
                "x": 454,
                "y": 116,
                "page": 0
            },
            {
                "id": 1080,
                "index": 610,
                "char": "и",
                "width": 22,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 477,
                "y": 116,
                "page": 0
            },
            {
                "id": 1082,
                "index": 612,
                "char": "к",
                "width": 20,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 14,
                "chnl": 15,
                "x": 364,
                "y": 360,
                "page": 0
            },
            {
                "id": 1083,
                "index": 613,
                "char": "л",
                "width": 24,
                "height": 25,
                "xoffset": -4,
                "yoffset": 10,
                "xadvance": 19,
                "chnl": 15,
                "x": 381,
                "y": 334,
                "page": 0
            },
            {
                "id": 1085,
                "index": 615,
                "char": "н",
                "width": 21,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 402,
                "y": 306,
                "page": 0
            },
            {
                "id": 1086,
                "index": 616,
                "char": "о",
                "width": 24,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 408,
                "y": 270,
                "page": 0
            },
            {
                "id": 1087,
                "index": 617,
                "char": "п",
                "width": 21,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 17,
                "chnl": 15,
                "x": 422,
                "y": 238,
                "page": 0
            },
            {
                "id": 1089,
                "index": 619,
                "char": "с",
                "width": 22,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 16,
                "chnl": 15,
                "x": 439,
                "y": 212,
                "page": 0
            },
            {
                "id": 1090,
                "index": 620,
                "char": "т",
                "width": 21,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 15,
                "chnl": 15,
                "x": 440,
                "y": 180,
                "page": 0
            },
            {
                "id": 1093,
                "index": 623,
                "char": "х",
                "width": 24,
                "height": 25,
                "xoffset": -4,
                "yoffset": 10,
                "xadvance": 16,
                "chnl": 15,
                "x": 451,
                "y": 148,
                "page": 0
            },
            {
                "id": 1095,
                "index": 625,
                "char": "ч",
                "width": 21,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 17,
                "chnl": 15,
                "x": 364,
                "y": 386,
                "page": 0
            },
            {
                "id": 1100,
                "index": 630,
                "char": "ь",
                "width": 22,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 17,
                "chnl": 15,
                "x": 385,
                "y": 360,
                "page": 0
            },
            {
                "id": 1101,
                "index": 631,
                "char": "э",
                "width": 22,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 16,
                "chnl": 15,
                "x": 406,
                "y": 332,
                "page": 0
            },
            {
                "id": 1103,
                "index": 633,
                "char": "я",
                "width": 23,
                "height": 25,
                "xoffset": -4,
                "yoffset": 10,
                "xadvance": 17,
                "chnl": 15,
                "x": 424,
                "y": 296,
                "page": 0
            },
            {
                "id": 945,
                "index": 302,
                "char": "α",
                "width": 24,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 19,
                "chnl": 15,
                "x": 433,
                "y": 264,
                "page": 0
            },
            {
                "id": 949,
                "index": 304,
                "char": "ε",
                "width": 20,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 14,
                "chnl": 15,
                "x": 444,
                "y": 238,
                "page": 0
            },
            {
                "id": 953,
                "index": 538,
                "char": "ι",
                "width": 11,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 7,
                "chnl": 15,
                "x": 344,
                "y": 128,
                "page": 0
            },
            {
                "id": 954,
                "index": 539,
                "char": "κ",
                "width": 22,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 16,
                "chnl": 15,
                "x": 377,
                "y": 412,
                "page": 0
            },
            {
                "id": 957,
                "index": 542,
                "char": "ν",
                "width": 23,
                "height": 25,
                "xoffset": -4,
                "yoffset": 10,
                "xadvance": 16,
                "chnl": 15,
                "x": 386,
                "y": 386,
                "page": 0
            },
            {
                "id": 959,
                "index": 544,
                "char": "ο",
                "width": 24,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 408,
                "y": 358,
                "page": 0
            },
            {
                "id": 964,
                "index": 306,
                "char": "τ",
                "width": 19,
                "height": 25,
                "xoffset": -3,
                "yoffset": 10,
                "xadvance": 13,
                "chnl": 15,
                "x": 429,
                "y": 322,
                "page": 0
            },
            {
                "id": 965,
                "index": 547,
                "char": "υ",
                "width": 21,
                "height": 25,
                "xoffset": -2,
                "yoffset": 10,
                "xadvance": 18,
                "chnl": 15,
                "x": 448,
                "y": 290,
                "page": 0
            },
            {
                "id": 58,
                "index": 29,
                "char": ":",
                "width": 11,
                "height": 25,
                "xoffset": -1,
                "yoffset": 10,
                "xadvance": 9,
                "chnl": 15,
                "x": 356,
                "y": 160,
                "page": 0
            },
            {
                "id": 60,
                "index": 31,
                "char": "<",
                "width": 23,
                "height": 24,
                "xoffset": -2,
                "yoffset": 8,
                "xadvance": 19,
                "chnl": 15,
                "x": 458,
                "y": 264,
                "page": 0
            },
            {
                "id": 62,
                "index": 33,
                "char": ">",
                "width": 23,
                "height": 24,
                "xoffset": -2,
                "yoffset": 8,
                "xadvance": 19,
                "chnl": 15,
                "x": 482,
                "y": 142,
                "page": 0
            },
            {
                "id": 43,
                "index": 14,
                "char": "+",
                "width": 23,
                "height": 23,
                "xoffset": -2,
                "yoffset": 8,
                "xadvance": 19,
                "chnl": 15,
                "x": 482,
                "y": 167,
                "page": 0
            },
            {
                "id": 247,
                "index": 183,
                "char": "÷",
                "width": 23,
                "height": 21,
                "xoffset": -3,
                "yoffset": 9,
                "xadvance": 18,
                "chnl": 15,
                "x": 23,
                "y": 491,
                "page": 0
            },
            {
                "id": 61,
                "index": 32,
                "char": "=",
                "width": 23,
                "height": 18,
                "xoffset": -2,
                "yoffset": 11,
                "xadvance": 19,
                "chnl": 15,
                "x": 154,
                "y": 451,
                "page": 0
            },
            {
                "id": 215,
                "index": 238,
                "char": "×",
                "width": 22,
                "height": 22,
                "xoffset": -1,
                "yoffset": 9,
                "xadvance": 19,
                "chnl": 15,
                "x": 482,
                "y": 191,
                "page": 0
            },
            {
                "id": 42,
                "index": 13,
                "char": "*",
                "width": 18,
                "height": 18,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 12,
                "chnl": 15,
                "x": 462,
                "y": 174,
                "page": 0
            },
            {
                "id": 45,
                "index": 16,
                "char": "-",
                "width": 17,
                "height": 11,
                "xoffset": -3,
                "yoffset": 17,
                "xadvance": 11,
                "chnl": 15,
                "x": 178,
                "y": 226,
                "page": 0
            },
            {
                "id": 8216,
                "index": 181,
                "char": "‘",
                "width": 11,
                "height": 16,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 7,
                "chnl": 15,
                "x": 235,
                "y": 386,
                "page": 0
            },
            {
                "id": 8217,
                "index": 182,
                "char": "’",
                "width": 11,
                "height": 16,
                "xoffset": -2,
                "yoffset": 4,
                "xadvance": 7,
                "chnl": 15,
                "x": 256,
                "y": 418,
                "page": 0
            },
            {
                "id": 8220,
                "index": 179,
                "char": "“",
                "width": 16,
                "height": 16,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 11,
                "chnl": 15,
                "x": 465,
                "y": 193,
                "page": 0
            },
            {
                "id": 8221,
                "index": 180,
                "char": "”",
                "width": 16,
                "height": 16,
                "xoffset": -3,
                "yoffset": 4,
                "xadvance": 11,
                "chnl": 15,
                "x": 465,
                "y": 210,
                "page": 0
            },
            {
                "id": 44,
                "index": 15,
                "char": ",",
                "width": 11,
                "height": 16,
                "xoffset": -1,
                "yoffset": 24,
                "xadvance": 9,
                "chnl": 15,
                "x": 270,
                "y": 450,
                "page": 0
            },
            {
                "id": 46,
                "index": 17,
                "char": ".",
                "width": 11,
                "height": 11,
                "xoffset": -1,
                "yoffset": 24,
                "xadvance": 9,
                "chnl": 15,
                "x": 86,
                "y": 289,
                "page": 0
            },
            {
                "id": 32,
                "index": 3,
                "char": " ",
                "width": 0,
                "height": 0,
                "xoffset": -4,
                "yoffset": 27,
                "xadvance": 9,
                "chnl": 15,
                "x": 22,
                "y": 226,
                "page": 0
            }
        ],
        "info": {
            "face": "arial",
            "size": 32,
            "bold": 0,
            "italic": 0,
            "charset": [
                " ",
                "A",
                "B",
                "C",
                "Č",
                "Ć",
                "D",
                "Đ",
                "E",
                "F",
                "G",
                "H",
                "I",
                "J",
                "K",
                "L",
                "M",
                "N",
                "O",
                "P",
                "Q",
                "R",
                "S",
                "Š",
                "T",
                "U",
                "V",
                "W",
                "X",
                "Y",
                "Z",
                "Ž",
                "a",
                "b",
                "c",
                "č",
                "ć",
                "d",
                "đ",
                "e",
                "f",
                "g",
                "h",
                "i",
                "j",
                "k",
                "l",
                "m",
                "n",
                "o",
                "p",
                "q",
                "r",
                "s",
                "š",
                "t",
                "u",
                "v",
                "w",
                "x",
                "y",
                "z",
                "ž",
                "А",
                "Б",
                "В",
                "Г",
                "Ґ",
                "Д",
                "Ђ",
                "Е",
                "Ё",
                "Є",
                "Ж",
                "З",
                "Ѕ",
                "И",
                "І",
                "Ї",
                "Й",
                "Ј",
                "К",
                "Л",
                "Љ",
                "М",
                "Н",
                "Њ",
                "О",
                "П",
                "Р",
                "С",
                "Т",
                "Ћ",
                "У",
                "Ў",
                "Ф",
                "Х",
                "Ц",
                "Ч",
                "Џ",
                "Ш",
                "Щ",
                "Ъ",
                "Ы",
                "Ь",
                "Э",
                "Ю",
                "Я",
                "а",
                "б",
                "в",
                "г",
                "ґ",
                "д",
                "ђ",
                "е",
                "ё",
                "є",
                "ж",
                "з",
                "ѕ",
                "и",
                "і",
                "ї",
                "й",
                "ј",
                "к",
                "л",
                "љ",
                "м",
                "н",
                "њ",
                "о",
                "п",
                "р",
                "с",
                "т",
                "ћ",
                "у",
                "ў",
                "ф",
                "х",
                "ц",
                "ч",
                "џ",
                "ш",
                "щ",
                "ъ",
                "ы",
                "ь",
                "э",
                "ю",
                "я",
                "Α",
                "Β",
                "Γ",
                "Δ",
                "Ε",
                "Ζ",
                "Η",
                "Θ",
                "Ι",
                "Κ",
                "Λ",
                "Μ",
                "Ν",
                "Ξ",
                "Ο",
                "Π",
                "Ρ",
                "Σ",
                "Τ",
                "Υ",
                "Φ",
                "Χ",
                "Ψ",
                "Ω",
                "α",
                "β",
                "γ",
                "δ",
                "ε",
                "ζ",
                "η",
                "θ",
                "ι",
                "κ",
                "λ",
                "μ",
                "ν",
                "ξ",
                "ο",
                "π",
                "ρ",
                "σ",
                "τ",
                "υ",
                "φ",
                "χ",
                "ψ",
                "ω",
                "ά",
                "Ά",
                "έ",
                "Έ",
                "Ή",
                "ί",
                "ϊ",
                "ΐ",
                "Ί",
                "ό",
                "Ό",
                "ύ",
                "ΰ",
                "ϋ",
                "Ύ",
                "Ϋ",
                "Ώ",
                "Ă",
                "Â",
                "Ê",
                "Ô",
                "Ơ",
                "Ư",
                "ă",
                "â",
                "ê",
                "ô",
                "ơ",
                "ư",
                "1",
                "2",
                "3",
                "4",
                "5",
                "6",
                "7",
                "8",
                "9",
                "0",
                "‘",
                "?",
                "’",
                "“",
                "!",
                "”",
                "(",
                "%",
                ")",
                "[",
                "#",
                "]",
                "{",
                "@",
                "}",
                "/",
                "&",
                "\\",
                "<",
                "-",
                "+",
                "÷",
                "×",
                "=",
                ">",
                "®",
                "©",
                "$",
                "€",
                "£",
                "¥",
                "¢",
                ":",
                ";",
                ",",
                ".",
                "*",
                "Ä",
                "ä",
                "Ö",
                "ö",
                "Ü",
                "ü",
                "ẞ",
                "ß"
            ],
            "unicode": 1,
            "stretchH": 100,
            "smooth": 1,
            "aa": 1,
            "padding": [
                4,
                4,
                4,
                4
            ],
            "spacing": [
                0,
                0
            ]
        },
        "common": {
            "lineHeight": 35,
            "base": 27,
            "scaleW": 512,
            "scaleH": 512,
            "pages": 1,
            "packed": 0,
            "alphaChnl": 0,
            "redChnl": 0,
            "greenChnl": 0,
            "blueChnl": 0
        },
        "distanceField": {
            "fieldType": "msdf",
            "distanceRange": 8
        },
        "kernings": []
    };

    function depth() {
        return new Program("depth", {
            uniforms: {
                depthTexture: "sampler2d"
            },
            attributes: {
                corners: "vec2"
            },
            vertexShader:
                `#version 300 es
            
            in vec2 corners;
            
            out vec2 tc;

            void main(void) {
                gl_Position = vec4(corners, 0.0, 1.0);
                tc = corners * 0.5 + 0.5;
            }`,
            fragmentShader:
                `#version 300 es

            precision highp float;

            #define MAX_FRUSTUMS 4

            uniform sampler2D depthTexture;
           
            in vec2 tc;

            layout(location = 0) out vec4 fragColor;

            float LinearizeDepth(in vec2 uv)
            {
                float depth = texture(depthTexture, tc).x;
                return depth;//(2.0 * zNear) / (zFar + zNear - depth * (zFar - zNear));
            }
            
            void main(void) {
                float c = LinearizeDepth(tc);
                fragColor = vec4(c, c, c, 1.0);
            }`
        });
    }

    let __pickingCallbackCounter__ = 0;

    let __depthCallbackCounter__ = 0;

    /**
     * Represents high level WebGL context interface that starts WebGL handler working in real time.
     * @class
     * @param {Handler} handler - WebGL handler context.
     * @param {Object} [params] - Renderer parameters:
     * @fires og.RendererEvents#draw
     * @fires og.RendererEvents#resize
     * @fires og.RendererEvents#mousemove
     * @fires og.RendererEvents#mousestop
     * @fires og.RendererEvents#lclick
     * @fires og.RendererEvents#rclick
     * @fires og.RendererEvents#mclick
     * @fires og.RendererEvents#ldblclick
     * @fires og.RendererEvents#rdblclick
     * @fires og.RendererEvents#mdblclick
     * @fires og.RendererEvents#lup
     * @fires og.RendererEvents#rup
     * @fires og.RendererEvents#mup
     * @fires og.RendererEvents#ldown
     * @fires og.RendererEvents#rdown
     * @fires og.RendererEvents#mdown
     * @fires og.RendererEvents#lhold
     * @fires og.RendererEvents#rhold
     * @fires og.RendererEvents#mhold
     * @fires og.RendererEvents#mousewheel
     * @fires og.RendererEvents#touchstart
     * @fires og.RendererEvents#touchend
     * @fires og.RendererEvents#touchcancel
     * @fires og.RendererEvents#touchmove
     * @fires og.RendererEvents#doubletouch
     * @fires og.RendererEvents#touchleave
     * @fires og.RendererEvents#touchenter
     */
    class Renderer {
        constructor(handler, params) {
            params = params || {};

            /**
             * Div element with WebGL canvas. Assigned in Globe class.
             * @public
             * @type {object}
             */
            this.div = null;

            /**
             * WebGL handler context.
             * @public
             * @type {Handler}
             */
            this.handler = handler;

            this.exposure = 3.01;

            this.gamma = 0.47;

            this.whitepoint = 1.0;

            this.brightThreshold = 0.9;

            this.backgroundColor = params.backgroundColor || new Vec3(115 / 255, 203 / 255, 249 / 255);

            /**
             * Render nodes drawing queue.
             * @private
             * @type {Array.<scene.RenderNode>}
             */
            this._renderNodesArr = [];

            /**
             * Render nodes store for the comfortable access by the node name.
             * @public
             * @type {Object.<og.scene.RenderNode>}
             */
            this.renderNodes = {};

            /**
             * Current active camera.
             * @public
             * @type {Camera}
             */
            this.activeCamera = null;

            /**
             * Renderer events. Represents interface for setting events like mousemove, draw, keypress etc.
             * @public
             * @type {RendererEvents}
             */
            this.events = new RendererEvents(this);

            /**
             * OpenGlobus controls array.
             * @public
             * @type {Object}
             */
            this.controls = {};

            if (params.controls) {
                for (let i in params.controls) {
                    this.controls[params.controls[i].name] = params.controls[i];
                }
            }

            /**
             * Provides exchange between controls.
             * @public
             * @type {Object}
             */
            this.controlsBag = {};

            /**
             * Hash table for drawing objects.
             * @public
             * @type {Object}
             */
            this.colorObjects = {};

            /**
             * Color picking objects rendering queue.
             * @type {Array.<Renderer~pickingCallback>}
             */
            this._pickingCallbacks = [];

            /**
             * Picking objects(labels and billboards) framebuffer.
             * @public
             * @type {Framebuffer}
             */
            this.pickingFramebuffer = null;

            /**
             * Depth objects rendering queue.
             * @type {Array.<Renderer~depthCallback>}
             */
            this._depthCallbacks = [];

            this.depthFramebuffer = null;

            this._msaa = params.msaa || 4;
            this._internalFormat = "RGBA16F";
            this._format = "RGBA";
            this._type = "FLOAT";

            this.sceneFramebuffer = null;

            this.blitFramebuffer = null;

            this.toneMappingFramebuffer = null;

            /**
             * Stores current picking rgb color.
             * @private
             * @type {Array.<number>} - (exactly 3 entries)
             */
            this._currPickingColor = new Uint8Array(4);

            /**
             * Stores previous picked rgb color.
             * @private
             * @type {Array.<number>} - (exactly 3 entries)
             */
            this._prevPickingColor = new Uint8Array(4);
            this._tempPickingColor_ = new Uint8Array(4);

            this._initialized = false;

            /**
             * Texture atlas for the billboards images. One atlas per node.
             * @protected
             * @type {utils.TextureAtlas}
             */
            this.billboardsTextureAtlas = new TextureAtlas();

            /**
             * Texture font atlas for the font families and styles. One atlas per node.
             * @public
             * @type {utils.FontAtlas}
             */
            this.fontAtlas = new FontAtlas();

            this._entityCollections = [];

            if (params.autoActivate || isEmpty(params.autoActivate)) {
                this.initialize();
                this.start();
            }

            this._currentOutput = "screen";

            this.labelWorker = new LabelWorker(4);
        }

        /**
         * Sets renderer events activity.
         * @param {Boolean} activity - Events activity.
         */
        setEventsActivity(activity) {
            this.events.active = activity;
        }

        addDepthCallback(sender, callback) {
            var id = __depthCallbackCounter__++;
            this._depthCallbacks.push({
                id: id,
                callback: callback,
                sender: sender
            });
            return id;
        }

        removeDepthCallback(id) {
            for (var i = 0; i < this._depthCallbacks.length; i++) {
                if (id === this._depthCallbacks[i].id) {
                    this._depthCallbacks.splice(i, 1);
                    break;
                }
            }
        }

        /**
         * Adds picking rendering callback function.
         * @param {object} sender - Callback context.
         * @param {Renderer~pickingCallback} callback - Rendering callback.
         * @returns {Number} Handler id
         */
        addPickingCallback(sender, callback) {
            var id = __pickingCallbackCounter__++;
            this._pickingCallbacks.push({
                id: id,
                callback: callback,
                sender: sender
            });
            return id;
        }

        /**
         * Removes picking rendering callback function.
         * @param {Number} id - Handler id to remove.
         */
        removePickingCallback(id) {
            for (var i = 0; i < this._pickingCallbacks.length; i++) {
                if (id === this._pickingCallbacks[i].id) {
                    this._pickingCallbacks.splice(i, 1);
                    break;
                }
            }
        }

        getPickingObjectByColor(r, g, b) {
            return this.colorObjects[r + "_" + g + "_" + b];
        }

        /**
         * Assign picking color to the object.
         * @public
         * @param {Object} obj - Object that pressume to be picked.
         */
        assignPickingColor(obj) {
            if (!obj._pickingColor || obj._pickingColor.isZero()) {
                var r = 0,
                    g = 0,
                    b = 0;
                var str = "0_0_0";
                while (!(r || g || b) || this.colorObjects[str]) {
                    r = randomi(1, 255);
                    g = randomi(1, 255);
                    b = randomi(1, 255);
                    str = r + "_" + g + "_" + b;
                }

                if (!obj._pickingColor) {
                    obj._pickingColor = new Vec3(r, g, b);
                } else {
                    obj._pickingColor.set(r, g, b);
                }

                obj._pickingColorU = new Float32Array([r / 255, g / 255, b / 255]);

                this.colorObjects[str] = obj;
            }
        }

        /**
         * Removes picking color from object.
         * @public
         * @param {Object} obj - Object to remove picking color.
         */
        clearPickingColor(obj) {
            if (!obj._pickingColor.isZero()) {
                var c = obj._pickingColor;
                if (!c.isZero()) {
                    this.colorObjects[c.x + "_" + c.y + "_" + c.z] = null;
                    delete this.colorObjects[c.x + "_" + c.y + "_" + c.z];
                    c.x = c.y = c.z = 0;
                }
            }
        }

        /**
         * Get the client width.
         * @public
         * @returns {number} -
         */
        getWidth() {
            return this.handler.canvas.clientWidth;
        }

        /**
         * Get the client height.
         * @public
         * @returns {number} -
         */
        getHeight() {
            return this.handler.canvas.clientHeight;
        }

        /**
         * Get center of the screen
         * @public
         * @returns {math.Vec2} -
         */
        getCenter() {
            var cnv = this.handler.canvas;
            return new Vec2(Math.round(cnv.clientWidth * 0.5), Math.round(cnv.clientHeight * 0.5));
        }

        /**
         * Add the given control to the renderer.
         * @param {control.Control} control - Control.
         */
        addControl(control) {
            control.addTo(this);
        }

        /**
         * Add the given controls array to the planet node.
         * @param {Array.<control.Control>} cArr - Control array.
         */
        addControls(cArr) {
            for (var i = 0; i < cArr.length; i++) {
                cArr[i].addTo(this);
            }
        }

        /**
         * Remove control from the renderer.
         * @param {control.Control} control  - Control.
         */
        removeControl(control) {
            control.remove();
        }

        /**
         * Renderer initialization.
         * @public
         */
        initialize() {
            if (this._initialized) {
                return;
            } else {
                this._initialized = true;
            }

            var that = this;

            this.billboardsTextureAtlas.assignHandler(this.handler);

            this.fontAtlas.assignHandler(this.handler);

            this.handler.setFrameCallback(function () {
                that.draw();
            });

            this.activeCamera = new Camera(this, {
                eye: new Vec3(0, 0, 0),
                look: new Vec3(0, 0, -1),
                up: new Vec3(0, 1, 0)
            });

            this.events.initialize();

            // Bind console key
            this.events.on("charkeypress", input.KEY_APOSTROPHE, function () {
                cons.setVisibility(!cons.getVisibility());
            });

            this.handler.addProgram(screenFrame());

            this.pickingFramebuffer = new Framebuffer(this.handler, {
                width: 640,
                height: 480
            }).init();

            this.depthFramebuffer = new Framebuffer(this.handler, {
                size: 2,
                internalFormat: ["RGBA", "DEPTH_COMPONENT24"],
                format: ["RGBA", "DEPTH_COMPONENT"],
                type: ["UNSIGNED_BYTE", "UNSIGNED_INT"],
                attachment: ["COLOR_ATTACHMENT", "DEPTH_ATTACHMENT"],
                useDepth: false
            }).init();

            this.screenDepthFramebuffer = new Framebuffer(this.handler, {
                useDepth: false
            }).init();

            if (this.handler.gl.type === "webgl") {
                this.sceneFramebuffer = new Framebuffer(this.handler);
                this.sceneFramebuffer.init();

                this._fnScreenFrame = this._screenFrameNoMSAA;

                this.screenTexture = {
                    screen: this.sceneFramebuffer.textures[0],
                    picking: this.pickingFramebuffer.textures[0],
                    depth: this.screenDepthFramebuffer.textures[0]
                };
            } else {
                let _maxMSAA = this.getMaxMSAA(this._internalFormat);

                if (this._msaa > _maxMSAA) {
                    this._msaa = _maxMSAA;
                }

                this.handler.addPrograms([toneMapping()]);

                this.handler.addPrograms([depth()]);

                this.sceneFramebuffer = new Multisample(this.handler, {
                    size: 1,
                    msaa: this._msaa,
                    internalFormat: this._internalFormat,
                    filter: "LINEAR"
                }).init();

                this.blitFramebuffer = new Framebuffer(this.handler, {
                    useDepth: false,
                    internalFormat: this._internalFormat,
                    format: this._format,
                    type: this._type,
                    filter: "NEAREST"
                }).init();

                this.toneMappingFramebuffer = new Framebuffer(this.handler, {
                    useDepth: false
                }).init();

                this._fnScreenFrame = this._screenFrameMSAA;

                this.screenTexture = {
                    screen: this.toneMappingFramebuffer.textures[0],
                    picking: this.pickingFramebuffer.textures[0],
                    depth: this.screenDepthFramebuffer.textures[0],
                    frustum: this.depthFramebuffer.textures[0]
                };
            }

            this.handler.onCanvasResize = () => {
                this.resize();
                this.events.dispatch(this.events.resize, this.handler.canvas);
            };

            this._screenFrameCornersBuffer = this.handler.createArrayBuffer(
                new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]),
                2,
                4
            );

            let temp = this.controls;
            this.controls = {};
            for (let i in temp) {
                this.addControl(temp[i]);
            }

            this.outputTexture = this.screenTexture.screen;

            this.fontAtlas.initFont("arial", data, ARIAL_FONT_B64);
        }

        setCurrentScreen(screenName) {
            this._currentOutput = screenName;
            if (this.screenTexture[screenName]) {
                this.outputTexture = this.screenTexture[screenName];
            }
        }

        resize() {
            let c = this.handler.canvas;
            this.activeCamera.setAspectRatio(c.width / c.height);
            this.sceneFramebuffer.setSize(c.width, c.height);

            this.blitFramebuffer &&
            this.blitFramebuffer.setSize(c.width, c.height, true);

            this.toneMappingFramebuffer &&
            this.toneMappingFramebuffer.setSize(c.width, c.height, true);

            this.depthFramebuffer &&
            this.depthFramebuffer.setSize(c.clientWidth, c.clientHeight, true);

            this.screenDepthFramebuffer &&
            this.screenDepthFramebuffer.setSize(c.clientWidth, c.clientHeight, true);

            if (this.handler.gl.type === "webgl") {
                this.screenTexture.screen = this.sceneFramebuffer.textures[0];
                this.screenTexture.picking = this.pickingFramebuffer.textures[0];
                this.screenTexture.depth = this.screenDepthFramebuffer.textures[0];
                this.screenTexture.frustum = this.depthFramebuffer.textures[0];
            } else {
                this.screenTexture.screen = this.toneMappingFramebuffer.textures[0];
                this.screenTexture.picking = this.pickingFramebuffer.textures[0];
                this.screenTexture.depth = this.screenDepthFramebuffer.textures[0];
                this.screenTexture.frustum = this.depthFramebuffer.textures[0];
            }

            this.setCurrentScreen(this._currentOutput);
        }

        removeNode(renderNode) {
            renderNode.remove();
        }

        /**
         * Adds render node to the renderer.
         * @public
         * @param {RenderNode} renderNode - Render node.
         */
        addNode(renderNode) {
            if (!this.renderNodes[renderNode.name]) {
                renderNode.assign(this);
                this._renderNodesArr.unshift(renderNode);
                this.renderNodes[renderNode.name] = renderNode;
            } else {
                cons.logWrn("Node name " + renderNode.name + " allready exists.");
            }
        }

        /**
         * Adds render node to the renderer before specific node.
         * @public
         * @param {RenderNode} renderNode - Render node.
         */
        addNodeBefore(renderNode, renderNodeBefore) {
            if (!this.renderNodes[renderNode.name]) {
                renderNode.assign(this);
                this.renderNodes[renderNode.name] = renderNode;
                for (let i = 0; i < this._renderNodesArr.length; i++) {
                    if (this._renderNodesArr[i].isEqual(renderNodeBefore)) {
                        this._renderNodesArr.splice(i, 0, renderNode);
                        break;
                    }
                }
                this._renderNodesArr.unshift(renderNode);
            } else {
                cons.logWrn("Node name " + renderNode.name + " allready exists.");
            }
        }

        /**
         * Adds render nodes array to the renderer.
         * @public
         * @param {Array.<scene.RenderNode>} nodesArr - Render nodes array.
         */
        addNodes(nodesArr) {
            for (var i = 0; i < nodesArr.length; i++) {
                this.addNode(nodesArr[i]);
            }
        }

        getMaxMSAA(internalFormat) {
            var gl = this.handler.gl;
            let samples = gl.getInternalformatParameter(
                gl.RENDERBUFFER,
                gl[internalFormat],
                gl.SAMPLES
            );
            return samples[0];
        }

        getMSAA() {
            return this._msaa;
        }

        /**
         * TODO: replace with cahce frendly linked list by bilboardHandler, label handler etc.
         */
        enqueueEntityCollectionsToDraw(ecArr) {
            this._entityCollections.push.apply(this._entityCollections, ecArr);
        }

        /**
         * Draws entity collections.
         * @public
         * @param {Array<og.EntityCollection>} ec - Entity collection array.
         */
        _drawEntityCollections() {
            let ec = this._entityCollections;

            if (ec.length) {
                var gl = this.handler.gl;

                gl.enable(gl.BLEND);
                gl.blendEquation(gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
                gl.disable(gl.CULL_FACE);

                // billboards pass
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.billboardsTextureAtlas.texture);

                var i = ec.length;
                while (i--) {
                    var eci = ec[i];
                    if (eci._fadingOpacity) {
                        // first begin draw event
                        eci.events.dispatch(eci.events.draw, eci);
                        eci.billboardHandler.draw();
                    }
                }

                // labels pass
                var fa = this.fontAtlas.atlasesArr;
                for (i = 0; i < fa.length; i++) {
                    gl.activeTexture(gl.TEXTURE0 + i);
                    gl.bindTexture(gl.TEXTURE_2D, fa[i].texture);
                }

                i = ec.length;
                while (i--) {
                    ec[i]._fadingOpacity && ec[i].labelHandler.draw();
                }

                //geoObject
                i = ec.length;
                while (i--) {
                    ec[i]._fadingOpacity && ec[i].geoObjectHandler.draw();
                }

                // rays
                i = ec.length;
                while (i--) {
                    ec[i]._fadingOpacity && ec[i].rayHandler.draw();
                }

                // polyline pass
                i = ec.length;
                while (i--) {
                    ec[i]._fadingOpacity && ec[i].polylineHandler.draw();
                }

                gl.enable(gl.CULL_FACE);

                // pointClouds pass
                i = ec.length;
                while (i--) {
                    if (ec[i]._fadingOpacity) {
                        ec[i].pointCloudHandler.draw();
                    }
                }

                // shapes pass
                i = ec.length;
                while (i--) {
                    eci = ec[i];
                    if (eci._fadingOpacity) {
                        eci.shapeHandler.draw();
                    }
                }

                // Strip pass
                i = ec.length;
                while (i--) {
                    if (ec[i]._fadingOpacity) {
                        ec[i].stripHandler.draw();
                        // post draw event
                        eci.events.dispatch(eci.events.drawend, eci);
                    }
                }

                this._entityCollections.length = 0;
                this._entityCollections = [];
            }
        }

        /**
         * Draw nodes.
         * @public
         */
        draw() {
            this.activeCamera.checkMoveEnd();

            let e = this.events;
            e.handleEvents();

            let sfb = this.sceneFramebuffer;
            sfb.activate();

            let h = this.handler;

            h.gl.clearColor(
                this.backgroundColor.x,
                this.backgroundColor.y,
                this.backgroundColor.z,
                1.0
            );
            h.gl.clear(h.gl.COLOR_BUFFER_BIT | h.gl.DEPTH_BUFFER_BIT);

            e.dispatch(e.draw, this);

            let frustums = this.activeCamera.frustums;

            let pointerEvent = e.pointerEvent() || this.activeCamera.isMoved;

            // Rendering scene nodes and entityCollections
            let rn = this._renderNodesArr;
            let k = frustums.length;
            while (k--) {
                this.activeCamera.setCurrentFrustum(k);
                h.gl.clear(h.gl.DEPTH_BUFFER_BIT);
                let i = rn.length;
                while (i--) {
                    rn[i].drawNode();
                }
                this._drawEntityCollections();

                if (pointerEvent) {
                    this._drawPickingBuffer(k);
                }
            }

            sfb.deactivate();

            this.blitFramebuffer && sfb.blitTo(this.blitFramebuffer);

            if (pointerEvent) {
                // It works ONLY for 0 (closest) frustum
                if (h.isWebGl2()) {
                    this._drawDepthBuffer();
                }

                this._readPickingColor();
            }

            // Tone mapping followed by rendering on the screen
            this._fnScreenFrame();

            e.dispatch(e.postdraw, this);

            e.mouseState.wheelDelta = 0;
            e.mouseState.justStopped = false;
            e.mouseState.moving = false;
            e.touchState.moving = false;
        }

        _screenFrameMSAA() {
            var h = this.handler;

            var sh = h.programs.toneMapping,
                p = sh._program,
                gl = h.gl;

            gl.disable(gl.DEPTH_TEST);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._screenFrameCornersBuffer);
            gl.vertexAttribPointer(p.attributes.corners, 2, gl.FLOAT, false, 0, 0);

            this.toneMappingFramebuffer.activate();

            sh.activate();

            // screen texture
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this.blitFramebuffer.textures[0]);
            gl.uniform1i(p.uniforms.hdrBuffer, 0);

            gl.uniform1f(p.uniforms.gamma, this.gamma);
            gl.uniform1f(p.uniforms.exposure, this.exposure);
            gl.uniform1f(p.uniforms.whitepoint, this.whitepoint);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            this.toneMappingFramebuffer.deactivate();

            sh = h.programs.screenFrame;
            p = sh._program;
            gl = h.gl;

            sh.activate();
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this.outputTexture);
            gl.uniform1i(p.uniforms.texture, 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            gl.enable(gl.DEPTH_TEST);
        }

        _screenFrameNoMSAA() {
            var h = this.handler;
            var sh = h.programs.screenFrame,
                p = sh._program,
                gl = h.gl;

            gl.disable(gl.DEPTH_TEST);
            sh.activate();
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this.outputTexture);
            gl.uniform1i(p.uniforms.texture, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._screenFrameCornersBuffer);
            gl.vertexAttribPointer(p.attributes.corners, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            gl.enable(gl.DEPTH_TEST);
        }

        /**
         * Draw picking objects framebuffer.
         * @private
         */
        _drawPickingBuffer(frustumIndex) {
            this.pickingFramebuffer.activate();

            var h = this.handler;
            var gl = h.gl;

            if (frustumIndex === this.activeCamera.FARTHEST_FRUSTUM_INDEX) {
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            } else {
                gl.clear(gl.DEPTH_BUFFER_BIT);
            }

            gl.disable(h.gl.BLEND);

            var dp = this._pickingCallbacks;
            var i = dp.length;
            while (i--) {
                /**
                 * This callback renders picking frame.
                 * @callback og.Renderer~pickingCallback
                 */
                dp[i].callback.call(dp[i].sender);
            }

            this.pickingFramebuffer.deactivate();
        }

        _drawDepthBuffer() {
            this.depthFramebuffer.activate();

            var h = this.handler;
            var gl = h.gl;

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.enable(gl.DEPTH_TEST);

            var dp = this._depthCallbacks;
            var i = dp.length;
            while (i--) {
                /**
                 * This callback renders depth frame.
                 * @callback og.Renderer~depthCallback
                 */
                dp[i].callback.call(dp[i].sender);
            }

            this.depthFramebuffer.deactivate();

            //
            // PASS to depth visualization
            this.screenDepthFramebuffer.activate();
            var sh = h.programs.depth,
                p = sh._program;

            gl = h.gl;

            gl.bindBuffer(gl.ARRAY_BUFFER, this._screenFrameCornersBuffer);
            gl.vertexAttribPointer(p.attributes.corners, 2, gl.FLOAT, false, 0, 0);

            sh.activate();

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this.depthFramebuffer.textures[1]);
            gl.uniform1i(p.uniforms.depthTexture, 0);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            this.screenDepthFramebuffer.deactivate();
        }

        _readPickingColor() {
            var ms = this.events.mouseState;
            var ts = this.events.touchState;

            if (!(ms.leftButtonHold || ms.rightButtonHold || ms.middleButtonHold)) {
                this._prevPickingColor[0] = this._currPickingColor[0];
                this._prevPickingColor[1] = this._currPickingColor[1];
                this._prevPickingColor[2] = this._currPickingColor[2];

                var pc = this._currPickingColor;
                if (ts.x || ts.y) {
                    this.pickingFramebuffer.activate();
                    this.pickingFramebuffer.readPixels(pc, ts.nx, 1.0 - ts.ny);
                    this.pickingFramebuffer.deactivate();
                } else {
                    this.pickingFramebuffer.activate();
                    this.pickingFramebuffer.readPixels(pc, ms.nx, 1.0 - ms.ny);
                    this.pickingFramebuffer.deactivate();
                }
            }
        }

        /**
         * Function starts rendering.
         * @public
         */
        start() {
            this.handler.start();
        }
    }

    /**
     * @module og/Globe
     */

    /** @const {string} */
    const CANVAS_ID_PREFIX = "globus_viewport_";
    /** @const {string} */
    const PLANET_NAME_PREFIX = "globus_planet_";

    /**
     * Creates a WebGL context with globe.
     * @class
     *
     * @example <caption>Basic initialization</caption>
     * globus = new og.Globe({
     *     'atmosphere': false,
     *     'target': 'globus',
     *     'name': 'Earth',
     *     'controls': [
     *          new og.control.MouseNavigation({ autoActivate: true }),
     *          new og.control.KeyboardNavigation({ autoActivate: true }),
     *          new og.control.EarthCoordinates({ autoActivate: true, center: false }),
     *          new og.control.LayerSwitcher({ autoActivate: true }),
     *          new og.control.ZoomControl({ autoActivate: true }),
     *          new og.control.TouchNavigation({ autoActivate: true }),
     *          new og.control.Sun({ autoActivate: true })
     *      ],
     *     'terrain': new og.terrain.GlobusTerrain(),
     *     'layers': [
     *          new og.layer.XYZ("OpenStreetMap", { isBaseLayer: true, url: "http://b.tile.openstreetmap.org/{z}/{x}/{y}.png", visibility: true, attribution: 'Data @ <a href="http://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="http://www.openstreetmap.org/copyright">ODbL</a>' })
     *      ],
     *     'autoActivate': true
     * });
     *
     * @param {object} options - Options:
     * @param {string} options.target - HTML element id where planet canvas have to be created.
     * @param {RenderNode} [options.skybox] - Render skybox. null - default.
     * @param {string} [options.name] - Planet name. Default is unic identifier.
     * @param {Terrain} [options.terrain] - Terrain provider. Default no terrain - og.terrain.EmptyTerrain.
     * @param {Array.<control.Control>} [options.controls] - Renderer controls array.
     * @param {Array.<Layer>} [options.layers] - Planet layers.
     * @param {Extent} [options.viewExtent] - Viewable starting extent.
     * @param {boolean} [options.autoActivate] - Globe rendering auto activation flag. True is default.
     * @param {DOMElement} [options.attributionContainer] - Container for attribution list.
     * @param {Number} [options.maxGridSize] = Maximal segment grid size. 128 is default
     * @param {boolean} [options.useSpecularTexture] - use specular water mask
     * @param {boolean} [options.useNightTexture] - show night cities
     * @param {Number} [options.maxAltitude=15000000.0] - Maximal camera altitude above terrain
     * @param {Number} [options.minAltitude=1.0] - Minimal camera altitude above terrain
     * @param {Number} [options.maxEqualZoomAltitude=15000000.0] - Maximal altitude since segments on the screen bacame the same zoom level
     * @param {Number} [options.minEqualZoomAltitude=10000.0] - Minimal altitude since segments on the screen bacame the same zoom level
     * @param {Number} [options.minEqualZoomCameraSlope=0.8] - Minimal camera slope above te globe where segments on the screen bacame the same zoom level
     * @param {Number} [options.loadingBatchSize=12] - 
     */

    class Globe {
        /**
         * @param {*} options
         */
        constructor(options) {
            // Canvas creation
            var _canvasId = CANVAS_ID_PREFIX + Globe._staticCounter++;

            this._canvas = document.createElement("canvas");
            this._canvas.id = _canvasId;
            this._canvas.style.width = "100%";
            this._canvas.style.height = "100%";
            this._canvas.style.display = "block";
            this._canvas.style.opacity = "0.0";
            this._canvas.style.transition = "opacity 1.0s";

            /**
             * Dom element where WebGL canvas creates
             * @public
             * @type {Element}
             */
            if (options.target instanceof HTMLElement) {
                this.div = options.target;
            } else {
                this.div =
                    document.getElementById(options.target) || document.querySelector(options.target);
            }

            this.div.appendChild(this._canvas);
            this.div.classList.add("ogViewport");

            document.addEventListener("visibilitychange", () => {
                if (document.visibilityState === 'visible') {
                    this.renderer.handler.start();
                    this.renderer && this.renderer.resize();
                } else {
                    this.renderer.handler.stop();
                }
            });

            function _disableWheel(e) {
                e.preventDefault();
            }

            this.div.onmouseenter = function () {
                document.addEventListener("mousewheel", _disableWheel, {
                    capture: false,
                    passive: false
                });
            };
            this.div.onmouseleave = function () {
                document.removeEventListener("mousewheel", _disableWheel);
            };

            /**
             * Interface for the renderer context(events, input states, renderer nodes etc.)
             * @public
             * @type {Renderer}
             */
            this.renderer = new Renderer(
                new Handler$1(_canvasId, {
                    pixelRatio: window.devicePixelRatio + 0.15,
                    context: {
                        alpha: false,
                        antialias: false,
                        powerPreference: "high-performance"
                    }
                }), {
                autoActivate: false,
                backgroundColor: createColorRGB(options.backgroundColor, new Vec3(115 / 255, 203 / 255, 249 / 255))
            }
            );
            this.renderer.initialize();
            this.renderer.div = this.div;
            this.renderer.div.attributions = document.createElement("div");
            if (options.attributionContainer) {
                options.attributionContainer.appendChild(this.div.attributions);
            } else {
                this.div.attributions.classList.add("ogAttribution");
                this.div.appendChild(this.div.attributions);
            }

            // Skybox
            if (options.skybox) {
                this.renderer.addNode(options.skybox);
            }

            /**
             * Planet node name. Access with this.renderer.<name>
             * @private
             * @type {String}
             */
            this._planetName = options.name ? options.name : PLANET_NAME_PREFIX + Globe._staticCounter;

            if (options.atmosphere) ; else {
                this.planet = new Planet({
                    name: this._planetName,
                    frustums: options.frustums,
                    ellipsoid: options.ellipsoid,
                    maxGridSize: options.maxGridSize,
                    useNightTexture: options.useNightTexture,
                    useSpecularTexture: options.useSpecularTexture,
                    minAltitude: options.minAltitude,
                    maxAltitude: options.maxAltitude || 15000000,
                    maxEqualZoomAltitude: options.maxEqualZoomAltitude,
                    minEqualZoomAltitude: options.minEqualZoomAltitude,
                    minEqualZoomCameraSlope: options.minEqualZoomCameraSlope,
                    loadingBatchSize: options.loadingBatchSize
                });
            }

            // Attach terrain provider
            if (options.terrain) {
                this.planet.setTerrain(options.terrain);
            } else {
                this.planet.setTerrain(new EmptyTerrain());
            }

            this.renderer.addNode(this.planet);

            // Add controls
            if (options.controls) {
                this.planet.addControls(options.controls);
            } else {
                this.planet.addControls([
                    new ZoomControl(),
                    options.useEarthNavigation
                        ? new EarthNavigation()
                        : new MouseNavigation({
                            minSlope: options.minSlope
                        }),
                    new TouchNavigation(),
                    new EarthCoordinates(),
                    new ScaleControl(),
                    new CompassButton(options)
                ]);
            }

            var _controls = this.renderer.controls;
            for (var i in _controls) {
                if (_controls[i] instanceof Sun) {
                    this.sun = _controls[i];
                    break;
                }
            }

            if (!this.sun) {
                this.sun = new Sun();
                this.planet.addControl(this.sun);
            }

            if (options.sun) {
                if (options.sun.active !== undefined && !options.sun.active) {
                    this.sun.deactivate();
                }
            }

            if (options.layers) {
                this.planet.addLayers(options.layers);
            }

            // TODO: view center, altitude, extent
            let ve = options.viewExtent;
            if (ve) {
                if (ve instanceof Array) {
                    this.planet.viewExtentArr(ve);
                } else {
                    this.planet.viewExtent(ve);
                }
            }

            this._opacityCounter = 0;
            this._fadeHandler = null;
            this._stopHandler = null;

            // Run!
            if (options.autoActivate || isEmpty(options.autoActivate)) {
                this.renderer.start();
                this.fadeIn();
            }
        }

        /**
         * Starts screen brightness fading in effect by the duration time.
         * @public
         */
        fadeIn() {
            this._canvas.style.opacity = 1.0;
        }

        /**
         * Starts screen brightness fading out effect by the duration time.
         * @public
         * @param {number} duration - Fadeout duration time.
         */
        fadeOut() {
            this._canvas.style.opacity = 0.0;
        }

        static get _staticCounter() {
            if (!this._counter && this._counter !== 0) {
                this._counter = 0;
            }
            return this._counter;
        }

        static set _staticCounter(n) {
            this._counter = n;
        }
    }

    const TEMPLATE = `<div class="og-popup {className}">
      <div class="og-popup-content-wrapper">
        <div class="og-popup-content"></div>
      </div>
      <div class="og-popup-tip-container">
        <div class="og-popup-tip"></div>
      </div>
      <div class="og-popup-toolbar">
        <div class="og-popup-btn og-popup-close">×</div>
      </div>
      <div class="og-popup-title">
      </div>
    </div>`;

    class Popup {
        /**
         *
         * @param {*} options
         */
        constructor(options) {
            this._id = Popup._staticCounter++;

            this.events = new Events(["open", "close"]);

            this._template = getHTML(TEMPLATE, { className: options.className });

            this.el = null;

            this._title = options.title || "";

            this._content = options.content || null;

            this._contentEl = null;

            this._titleEl = null;

            this._planet = options.planet;

            this._offset = options.offset || [0, 0];

            this._lonLat = createLonLat(options.lonLat);

            this._cartPos = new Vec3();

            this._visibility = options.visibility || false;

            this.render();
        }

        static get _staticCounter() {
            if (!this.__counter__ && this.__counter__ !== 0) {
                this.__counter__ = 0;
            }
            return this.__counter__;
        }

        static set _staticCounter(n) {
            this.__counter__ = n;
        }

        _renderTemplate() {
            return parseHTML(this._template)[0];
        }

        _updatePosition() {
            this.setCartesian3v(this._cartPos);
        }

        setScreen(p) {
            if (this._planet) {
                let r = this._planet.renderer.handler.pixelRatio;
                this.el.style.transform =
                    "translate(" +
                    (p.x / r - this.clientWidth * 0.5) +
                    "px, " +
                    (p.y / r - this._planet.renderer.handler.canvas.clientHeight - this._tipEl.clientHeight) +
                    "px)";
            }
        }

        get clientWidth() {
            return this.el.clientWidth;
        }

        get clientHeight() {
            return this.el.clientHeight;
        }

        setOffset(x = 0, y = 0) {
            this._offset[0] = x;
            this._offset[1] = y;
            if (this.el) {
                this.el.style.left = `${x}px`;
                this.el.style.bottom = `${y}px`;
            }
            return this;
        }

        render(params) {
            this.el = this._renderTemplate(params);
            this._contentEl = this.el.querySelector(".og-popup-content");
            this._titleEl = this.el.querySelector(".og-popup-title");
            this._tipEl = this.el.querySelector(".og-popup-tip-container");
            this.setOffset(this._offset[0], this._offset[1]);
            this.setContent(this._content);
            this.setTitle(this._title);
            this.setLonLat(this._lonLat);
            this.setVisibility(this._visibility);
            this.el.querySelector(".og-popup-close").addEventListener("click", () => {
                this.hide();
            });
            return this;
        }

        setVisibility(visibility) {
            if (visibility) {
                this.show();
            } else {
                this.hide();
            }
            return this;
        }

        getContainer() {
            return this._contentEl;
        }

        getToolbarContainer() {
            return this.el.querySelector(".og-popup-toolbar");
        }

        show() {
            this._visibility = true;
            if (this._planet) {
                this._planet.events.on("draw", this._updatePosition, this);
                this._planet.renderer.div.appendChild(this.el);
                this.events.dispatch(this.events.open, this);
            }
            return this;
        }

        hide() {
            this._visibility = false;
            if (this.el.parentNode) {
                this._planet.events.off("draw", this._updatePosition);
                this.el.parentNode.removeChild(this.el);
                this.events.dispatch(this.events.close, this);
            }
            return this;
        }

        setCartesian3v(cart, height = 0) {
            this._cartPos = cart;

            if (this._planet) {
                let cam = this._planet.camera;
                let f = this._planet.ellipsoid._a + height,
                    g = cam._lonLat.height;

                let look = cart.sub(cam.eye),
                    v = Math.sqrt((f + g) * (f + g) - f * f);

                if (v > look.length() && cam.getForward().dot(look.normalize()) > 0.0) {
                    this.el.style.display = "block";
                    this.setScreen(cam.project(cart));
                } else {
                    this.el.style.display = "none";
                }
            }
            return this;
        }

        setTitle(html) {
            this._title = html;
            this._titleEl.innerHTML = html;
            return this;
        }

        setLonLat(lonLat) {
            this._lonLat = lonLat;
            if (this._planet) {
                this.setCartesian3v(this._planet.ellipsoid.lonLatToCartesian(lonLat), lonLat.height);
            }
            return this;
        }

        setContent(content) {
            if (content) {
                this.clear();
                this._content = content;
                if (typeof content === "string") {
                    this._contentEl.innerHTML = content;
                } else {
                    this._contentEl.appendChild(content);
                }
            }
            return this;
        }

        clear() {
            this._content = null;
            this._contentEl.innerHTML = "";
        }
    }

    var name = "@openglobus/og";
    var version$1 = "0.13.7";
    var description = "[OpenGlobus](http://www.openglobus.org/) is a javascript library designed to display interactive 3d maps and planets with map tiles, imagery and vector data, markers and 3d objects. It uses the WebGL technology, open source and completely free.";
    var directories = {
    	example: "./sandbox"
    };
    var main = "./src/og/index.js";
    var style = "./css/og.css";
    var types = "./types/index.d.ts";
    var scripts = {
    	api: "jsdoc -t ./jsdoc -r ./src/ -c ./jsdoc/conf.json -d ./api",
    	serve: "ws",
    	build: "rollup -c",
    	webgl: "rollup -c --environment entry:webgl",
    	core: "rollup -c --environment entry:core",
    	test: "jest --env=jsdom",
    	test_watch: "jest --env=jsdom --watch",
    	lint: "eslint -c ./.eslintrc.js src/og",
    	generate_types: "rm -rf types; tsc src/**/*.js --declaration --allowJs --emitDeclarationOnly --outDir types",
    	compile_js_as_ts: "tsc src/og/index.js --AllowJs --checkJs --outDir dist/@openglobus/src/"
    };
    var repository = {
    	type: "git",
    	url: "git+https://github.com/openglobus/openglobus.git"
    };
    var author = "Zemledelec";
    var license = "MIT";
    var bugs = {
    	url: "https://github.com/openglobus/openglobus/issues",
    	email: "mgevlich@gmail.com"
    };
    var homepage = "http://www.openglobus.org";
    var exports$1 = {
    	".": "./src/og/index.js",
    	"./layer": "./src/og/layer/index.js",
    	"./bv": "./src/og/bv/index.js",
    	"./terrain": "./src/og/terrain/index.js",
    	"./entity": "./src/og/entity/index.js",
    	"./control": "./src/og/control/index.js",
    	"./webgl": "./src/og/webgl/index.js",
    	"./scene": "./src/og/scene/index.js",
    	"./css/og.css": "./css/og.css"
    };
    var devDependencies = {
    	"@babel/preset-env": "^7.16.11",
    	"@rollup/plugin-json": "^4.1.0",
    	"@types/jest": "^27.4.0",
    	eslint: "^8.7.0",
    	"jaguarjs-jsdoc": "^1.1.0",
    	jest: "^27.4.7",
    	"jest-canvas-mock": "^2.3.1",
    	"jest-webgl-canvas-mock": "^0.2.3",
    	jsdoc: "^3.6.10",
    	"lint-staged": "^12.3.1",
    	"local-web-server": "^5.1.1",
    	"msdf-bmfont-xml": "^2.5.4",
    	postcss: "^8.4.5",
    	prettier: "^2.5.1",
    	rollup: "^2.66.1",
    	"rollup-plugin-postcss": "^4.0.2",
    	"rollup-plugin-terser": "^7.0.2",
    	typescript: "^4.5.5"
    };
    var files = [
    	"src/**/*",
    	"dist/**/*",
    	"css/**/*",
    	"types/**/*"
    ];
    var keywords = [
    	"map",
    	"3D",
    	"webgl",
    	"globe",
    	"og"
    ];
    var pkg = {
    	name: name,
    	version: version$1,
    	description: description,
    	directories: directories,
    	main: main,
    	style: style,
    	types: types,
    	scripts: scripts,
    	repository: repository,
    	author: author,
    	license: license,
    	bugs: bugs,
    	homepage: homepage,
    	exports: exports$1,
    	devDependencies: devDependencies,
    	"lint-staged": {
    	"*.{js,ts}": [
    		"prettier --write"
    	]
    },
    	files: files,
    	keywords: keywords
    };

    const { Handler } = webgl, { Control } = control;
    const { Layer } = layer;
    const {
        EntityCollection,
        Entity
    } = entity;

    const version = {
        version: pkg.version
    };

    exports.Camera = Camera;
    exports.Clock = Clock;
    exports.Control = Control;
    exports.Ellipsoid = Ellipsoid;
    exports.Entity = Entity;
    exports.EntityCollection = EntityCollection;
    exports.Events = Events;
    exports.Extent = Extent;
    exports.Geoid = Geoid;
    exports.Globe = Globe;
    exports.Handler = Handler;
    exports.Layer = Layer;
    exports.LightSource = LightSource;
    exports.Line2 = Line2;
    exports.Line3 = Line3;
    exports.LonLat = LonLat;
    exports.Mat3 = Mat3;
    exports.Mat4 = Mat4;
    exports.Plane = Plane;
    exports.PlanetCamera = PlanetCamera;
    exports.Popup = Popup;
    exports.Quat = Quat;
    exports.Ray = Ray$1;
    exports.RenderNode = RenderNode;
    exports.Renderer = Renderer;
    exports.Vec2 = Vec2;
    exports.Vec3 = Vec3;
    exports.Vec4 = Vec4;
    exports.bv = index$2;
    exports.control = control;
    exports.entity = entity;
    exports.input = input;
    exports.jd = jd;
    exports.layer = layer;
    exports.math = math;
    exports.mercator = mercator;
    exports.scene = index$1;
    exports.terrain = index;
    exports.utils = shared;
    exports.version = version;
    exports.webgl = webgl;
    exports.wgs84 = wgs84;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=og.umd.js.map
