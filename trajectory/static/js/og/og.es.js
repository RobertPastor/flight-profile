const e = 2 * Math.PI;
const t = Math.PI / 2;
const i = 0;
const s = 1;
const r = 2;
const n = 3;
const o = Number.MAX_VALUE || 17976931348623157e292;
const a = Math.log(2);
const l = 2147483647;
const h = 549755748352;
const c = -549755748352;
const d = Math.PI / 180;
const u = 180 / Math.PI;
const _ = 2 * u;
const f = 0.5 * d;
const g = 484813681109536e-20;
const p = 3.819718634205488;
const m = 0.26179938779914946;
const v = 15;
const y = 1 / 15;
const x = Math.sqrt(0.5);
const b = 0.1;
const w = 0.01;
const C = 1e-3;
const T = 1e-4;
const E = 1e-5;
const A = 1e-6;
const L = 1e-7;
const P = 1e-8;
const S = 1e-9;
const R = 1e-10;
const M = 1e-11;
const B = 1e-12;
const k = 1e-13;
const I = 1e-14;
const z = 1e-15;
const D = 1e-16;
const F = 1e-17;
const N = 1e-18;
const O = 1e-19;
const H = 1e-20;
function V(e4, t2) {
  return Math.log(e4) / Math.log(t2);
}
function U(e4, t2, i2) {
  return Math.max(t2, Math.min(e4, i2));
}
function G(e4) {
  return e4 * d;
}
function W(e4) {
  return e4 * u;
}
function j(e4) {
  return (e4 & e4 - 1) === 0;
}
function Y(e4, t2 = 4096) {
  --e4;
  for (let t3 = 1; t3 < 32; t3 <<= 1) {
    e4 = e4 | e4 >> t3;
  }
  return e4 + 1 > t2 ? t2 : e4 + 1;
}
function q(e4 = 0, t2 = 1) {
  return Math.floor(Math.random() * (t2 - e4)) + e4;
}
function $(e4 = 0, t2 = 1) {
  return Math.random() * (t2 - e4) + e4;
}
function X(e4, t2, i2, s2) {
  if (s2) {
    return e4 + t2 / 60 + i2 / 3600;
  } else {
    return -e4 - t2 / 60 - i2 / 3600;
  }
}
function Z(e4, t2) {
  return (e4 % t2 + t2) % t2;
}
function K(t2) {
  const i2 = Z(t2, e);
  if (Math.abs(i2) < I && Math.abs(t2) > I) {
    return e;
  }
  return i2;
}
function Q(e4, t2) {
  return t2 < e4 ? 0 : 1;
}
function J(e4) {
  const t2 = Math.abs(e4);
  return t2 - Math.floor(t2);
}
function ee(e4) {
  return Math.log(e4) / a;
}
function te(e4) {
  return Math.pow(2, e4);
}
function ie(e4) {
  return 2 << e4 - 1;
}
function se(e4, t2, i2) {
  return e4 * (t2 - i2);
}
function re(e4, t2, i2) {
  return i2 + e4 * (t2 - i2);
}
function ne(e4) {
  return e4 * e4 * e4;
}
function oe(e4) {
  return e4 * e4;
}
function ae(e4, t2, i2, s2, r2) {
  return ne(1 - e4) * t2 + 3 * oe(1 - e4) * e4 * i2 + 3 * (1 - e4) * oe(e4) * s2 + ne(e4) * r2;
}
function le(e4, t2, i2, s2, r2) {
  let n2 = 1 - e4;
  let o2 = e4 * e4;
  let a2 = n2 * n2;
  let l2 = a2 * n2;
  let h2 = o2 * e4;
  return t2.scaleTo(l2).addA(i2.scaleTo(3 * a2 * e4)).addA(s2.scaleTo(3 * n2 * o2)).addA(r2.scaleTo(h2));
}
function he(e4) {
  return e4 - Math.floor(e4 / 360) * 360;
}
function ce(e4) {
  return e4 > 180 ? (e4 + 180) % 360 - 180 : e4 < -180 ? (e4 - 180) % 360 + 180 : e4;
}
function de(e4) {
  return K(e4 + Math.PI) - Math.PI;
}
function ue(e4, t2, i2) {
  let s2 = 0;
  let r2 = t2;
  for (let t3 = 0; t3 < i2; t3++) {
    s2 = r2;
    r2 = e4(s2);
  }
  return r2;
}
function _e(e4, t2, i2, s2 = 50) {
  let r2 = 0;
  let n2 = t2;
  for (let t3 = 0; t3 < s2; t3++) {
    r2 = n2;
    n2 = e4(r2);
    if (Math.abs(n2 - r2) < i2) {
      return n2;
    }
  }
  return n2;
}
function fe(e4, t2) {
  e4 = K(e4);
  t2 = K(t2);
  return ((e4 - t2) % 360 + 360 + 180) % 360 - 180;
}
const ge = Object.freeze(Object.defineProperty({ __proto__: null, ARCSECONDS_TO_RADIANS: g, DEG2RAD: G, DEGREES: u, DEGREES_DOUBLE: _, DEGREES_TO_HOURS: y, EPS1: b, EPS10: R, EPS11: M, EPS12: B, EPS13: k, EPS14: I, EPS15: z, EPS16: D, EPS17: F, EPS18: N, EPS19: O, EPS2: w, EPS20: H, EPS3: C, EPS4: T, EPS5: E, EPS6: A, EPS7: L, EPS8: P, EPS9: S, HOURS_TO_DEGREES: v, HOURS_TO_RADIANS: m, LOG2: a, MAX: h, MAX32: l, MAX_FLOAT: o, MIN: c, PI_TWO: t, RAD2DEG: W, RADIANS: d, RADIANS_HALF: f, RADIANS_TO_HOURS: p, SQRT_HALF: x, TWO_PI: e, W: n, X: i, Y: s, Z: r, bezier1v: ae, bezier3v: le, clamp: U, cube: ne, degToDec: X, exp2: te, frac: J, getAngleBetweenAzimuths: fe, isPowerOfTwo: j, lerp: re, log: V, log2: ee, mod: Z, negativePItoPI: de, nextHighestPowerOfTwo: Y, norm_lon: ce, pow2i: ie, random: $, randomi: q, rev: he, slice: se, solve_iteration: _e, solve_iteration_fixed: ue, square: oe, step: Q, zeroTwoPI: K }, Symbol.toStringTag, { value: "Module" }));
const pe = Math.PI * 0.5;
const me = 180 / Math.PI;
const ve = me * 2;
const ye = Math.PI / 360;
const xe = me * pe;
class be {
  constructor(e4 = 0, t2 = 0, i2 = 0) {
    this.lon = 0;
    this.lat = 0;
    this.height = 0;
    this.lon = e4;
    this.lat = t2;
    this.height = i2;
  }
  isZero() {
    return this.lon === 0 && this.lat === 0 && this.height === 0;
  }
  static join(e4) {
    let t2 = [];
    for (let i2 = 0; i2 < e4.length; i2++) {
      let s2 = e4[i2];
      t2[i2] = new be(s2[0], s2[1], s2[2]);
    }
    return t2;
  }
  static createFromArray(e4) {
    return new be(e4[0], e4[1], e4[2]);
  }
  static toArray(e4) {
    return [e4.lon, e4.lat, e4.height];
  }
  toArray() {
    return be.toArray(this);
  }
  static forwardMercator(e4, t2, i2) {
    return new be(e4 * Le, Math.log(Math.tan((90 + t2) * ye)) * Ee, i2);
  }
  static forwardMercatorRes(e4, t2) {
    t2.lon = e4.lon * Le;
    t2.lat = Math.log(Math.tan((90 + e4.lat) * ye)) * Ee, t2.height = e4.height;
    return t2;
  }
  static inverseMercator(e4, t2, i2 = 0) {
    return new be(e4 * Pe, ve * Math.atan(Math.exp(t2 * Te)) - xe, i2);
  }
  set(e4 = 0, t2 = 0, i2 = 0) {
    this.lon = e4;
    this.lat = t2;
    this.height = i2;
    return this;
  }
  copy(e4) {
    this.lon = e4.lon;
    this.lat = e4.lat;
    this.height = e4.height;
    return this;
  }
  clone() {
    return new be(this.lon, this.lat, this.height);
  }
  forwardMercator() {
    return be.forwardMercator(this.lon, this.lat, this.height);
  }
  forwardMercatorEPS01() {
    let e4 = this.lat;
    if (e4 > 89.9) {
      e4 = 89.9;
    } else if (e4 < -89.9) {
      e4 = -89.9;
    }
    return new be(this.lon * Le, Math.log(Math.tan((90 + e4) * ye)) * Ee);
  }
  inverseMercator() {
    return be.inverseMercator(this.lon, this.lat, this.height);
  }
  equal(e4) {
    if (e4.height) {
      return this.lon === e4.lon && this.lat === e4.lat && this.height === e4.height;
    } else {
      return this.lon === e4.lon && this.lat === e4.lat;
    }
  }
}
const we = 2003750834e-2;
const Ce = we * 2;
const Te = Math.PI / we;
const Ee = we / Math.PI;
const Ae = Math.PI * 0.5;
const Le = we / 180;
const Pe = 180 / we;
const Se = Math.PI / 360;
const Re = Math.PI / 180;
const Me = 180 / Math.PI;
const Be = 2 * we;
const ke = 1 / Be;
function Ie(e4) {
  return new be(e4.lon * we / 180, Math.log(Math.tan((90 + e4.lat) * Se)) * Ee, e4.height);
}
function ze(e4) {
  return e4 * we / 180;
}
function De(e4) {
  return Math.log(Math.tan((90 + e4) * Se)) * Ee;
}
function Fe(e4) {
  return 180 * e4 / we;
}
function Ne(e4) {
  return Me * (2 * Math.atan(Math.exp(e4 * Te)) - Ae);
}
function Oe(e4, t2) {
  return Math.floor((e4 + 180) / 360 * Math.pow(2, t2));
}
function He(e4, t2) {
  return Math.floor((1 - Math.log(Math.tan(e4 * Re) + 1 / Math.cos(e4 * Re)) / Math.PI) * 0.5 * Math.pow(2, t2));
}
function Ve(e4) {
  let t2 = [];
  for (let i2 = 0; i2 < e4.length; i2++) {
    t2.push(e4[i2].forwardMercator());
  }
  return t2;
}
function Ue(e4, t2, i2) {
  let s2 = Ce / (1 << i2), r2 = new be(-2003750834e-2 + e4 * s2, we - t2 * s2 - s2);
  return new Ye(r2, new be(r2.lon + s2, r2.lat + s2));
}
const Ge = Ne(we);
const We = -Ge;
const je = Object.freeze(Object.defineProperty({ __proto__: null, INV_POLE_BY_180: Pe, MAX_LAT: Ge, MIN_LAT: We, ONE_BY_POLE_DOUBLE: ke, PI_BY_POLE: Te, POLE: we, POLE2: Ce, POLE_BY_180: Le, POLE_BY_PI: Ee, POLE_DOUBLE: Be, forward: Ie, forwardArray: Ve, forward_lat: De, forward_lon: ze, getTileExtent: Ue, getTileX: Oe, getTileY: He, inverse_lat: Ne, inverse_lon: Fe }, Symbol.toStringTag, { value: "Module" }));
class Ye {
  constructor(e4 = new be(), t2 = new be()) {
    this.southWest = e4;
    this.northEast = t2;
  }
  static createFromArray(e4) {
    return new Ye(new be(e4[0], e4[1]), new be(e4[2], e4[3]));
  }
  static createByCoordinates(e4) {
    let t2 = h, i2 = c, s2 = h, r2 = c;
    for (let n2 = 0; n2 < e4.length; n2++) {
      const o2 = e4[n2];
      if (o2.lon < t2) t2 = o2.lon;
      if (o2.lon > i2) i2 = o2.lon;
      if (o2.lat < s2) s2 = o2.lat;
      if (o2.lat > r2) r2 = o2.lat;
    }
    return new Ye(new be(t2, s2), new be(i2, r2));
  }
  static createByCoordinatesArr(e4) {
    let t2 = h, i2 = c, s2 = h, r2 = c;
    for (let n2 = 0; n2 < e4.length; n2++) {
      const o2 = e4[n2];
      if (o2[0] < t2) t2 = o2[0];
      if (o2[0] > i2) i2 = o2[0];
      if (o2[1] < s2) s2 = o2[1];
      if (o2[1] > r2) r2 = o2[1];
    }
    return new Ye(new be(t2, s2), new be(i2, r2));
  }
  static fromTile(e4, t2, i2, s2 = Be, r2 = Be) {
    const n2 = 1 << i2;
    const o2 = n2;
    const a2 = s2 / o2;
    const l2 = r2 / n2;
    const h2 = -s2 * 0.5 + e4 * a2, c2 = r2 * 0.5 - t2 * l2, d2 = c2 - l2, u2 = h2 + a2;
    return new Ye(new be(h2, d2), new be(u2, c2));
  }
  setByCoordinates(e4) {
    let t2 = h, i2 = c, s2 = h, r2 = c;
    for (let n2 = 0; n2 < e4.length; n2++) {
      const o2 = e4[n2];
      if (o2.lon < t2) t2 = o2.lon;
      if (o2.lon > i2) i2 = o2.lon;
      if (o2.lat < s2) s2 = o2.lat;
      if (o2.lat > r2) r2 = o2.lat;
    }
    this.southWest.lon = t2;
    this.southWest.lat = s2;
    this.northEast.lon = i2;
    this.northEast.lat = r2;
    return this;
  }
  isInside(e4) {
    const t2 = this.southWest;
    const i2 = this.northEast;
    return e4.lon >= t2.lon && e4.lon <= i2.lon && e4.lat >= t2.lat && e4.lat <= i2.lat;
  }
  overlaps(e4) {
    const t2 = this.southWest;
    const i2 = this.northEast;
    return t2.lon <= e4.northEast.lon && i2.lon >= e4.southWest.lon && t2.lat <= e4.northEast.lat && i2.lat >= e4.southWest.lat;
  }
  getWidth() {
    return this.northEast.lon - this.southWest.lon;
  }
  getHeight() {
    return this.northEast.lat - this.southWest.lat;
  }
  clone() {
    return new Ye(this.southWest.clone(), this.northEast.clone());
  }
  getCenter() {
    const e4 = this.southWest;
    const t2 = this.northEast;
    return new be(e4.lon + (t2.lon - e4.lon) * 0.5, e4.lat + (t2.lat - e4.lat) * 0.5);
  }
  getNorthWest() {
    return new be(this.southWest.lon, this.northEast.lat);
  }
  getNorthEast() {
    return new be(this.northEast.lon, this.northEast.lat);
  }
  getSouthWest() {
    return new be(this.southWest.lon, this.southWest.lat);
  }
  getSouthEast() {
    return new be(this.northEast.lon, this.southWest.lat);
  }
  getNorth() {
    return this.northEast.lat;
  }
  getEast() {
    return this.northEast.lon;
  }
  getWest() {
    return this.southWest.lon;
  }
  getSouth() {
    return this.southWest.lat;
  }
  equals(e4) {
    return this.southWest.lon === e4.southWest.lon && this.southWest.lat === e4.southWest.lat && this.northEast.lon === e4.northEast.lon && this.northEast.lat === e4.northEast.lat;
  }
  forwardMercator() {
    return new Ye(this.southWest.forwardMercator(), this.northEast.forwardMercator());
  }
  inverseMercator() {
    return new Ye(this.southWest.inverseMercator(), this.northEast.inverseMercator());
  }
  getCartesianBounds(e4) {
    let t2 = h, i2 = c, s2 = h, r2 = c, n2 = h, o2 = c;
    const a2 = [new be(this.southWest.lon, this.southWest.lat), new be(this.southWest.lon, this.northEast.lat), new be(this.northEast.lon, this.northEast.lat), new be(this.northEast.lon, this.southWest.lat)];
    for (let l2 = 0; l2 < a2.length; l2++) {
      const h2 = e4.lonLatToCartesian(a2[l2]);
      const c2 = h2.x;
      const d2 = h2.y;
      const u2 = h2.z;
      if (c2 < t2) t2 = c2;
      if (c2 > i2) i2 = c2;
      if (d2 < s2) s2 = d2;
      if (d2 > r2) r2 = d2;
      if (u2 < n2) n2 = u2;
      if (u2 > o2) o2 = u2;
    }
    return [t2, s2, n2, i2, r2, o2];
  }
  toString() {
    return `[${this.southWest.lon.toFixed(5)}, ${this.southWest.lat.toFixed(5)}, ${this.northEast.lon.toFixed(5)}, ${this.northEast.lat.toFixed(5)}]`;
  }
}
class qe {
  constructor() {
    this._m = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  }
  set(e4) {
    this._m[0] = e4[0];
    this._m[1] = e4[1];
    this._m[2] = e4[2];
    this._m[3] = e4[3];
    this._m[4] = e4[4];
    this._m[5] = e4[5];
    this._m[6] = e4[6];
    this._m[7] = e4[7];
    this._m[8] = e4[8];
    return this;
  }
  clone() {
    let e4 = new qe();
    e4.set(this._m);
    return e4;
  }
  copy(e4) {
    return this.set(e4._m);
  }
  transposeTo() {
    let e4 = new qe();
    let t2 = this._m;
    e4._m[0] = t2[0];
    e4._m[1] = t2[3];
    e4._m[2] = t2[6];
    e4._m[3] = t2[1];
    e4._m[4] = t2[4];
    e4._m[5] = t2[7];
    e4._m[6] = t2[2];
    e4._m[7] = t2[5];
    e4._m[8] = t2[8];
    return e4;
  }
  setIdentity() {
    this._m[0] = 1;
    this._m[1] = 0;
    this._m[2] = 0;
    this._m[3] = 0;
    this._m[4] = 1;
    this._m[5] = 0;
    this._m[6] = 0;
    this._m[7] = 0;
    this._m[8] = 1;
    return this;
  }
  mulVec(e4) {
    let t2 = e4.x, i2 = e4.y, s2 = e4.z;
    let r2 = this._m;
    return new Ke(r2[0] * t2 + r2[3] * i2 + r2[6] * s2, r2[1] * t2 + r2[4] * i2 + r2[7] * s2, r2[2] * t2 + r2[5] * i2 + r2[8] * s2);
  }
  getMat4() {
    let e4 = new Xe();
    let t2 = e4._m;
    let i2 = this._m;
    t2[0] = i2[0];
    t2[1] = i2[1];
    t2[2] = i2[2];
    t2[3] = 0;
    t2[4] = i2[3];
    t2[5] = i2[4];
    t2[6] = i2[5];
    t2[7] = 0;
    t2[8] = i2[6];
    t2[9] = i2[7];
    t2[10] = i2[8];
    t2[11] = 0;
    t2[12] = 0;
    t2[13] = 0;
    t2[14] = 0;
    t2[15] = 1;
    return e4;
  }
}
class $e {
  constructor(e4 = 0, t2 = 0, i2 = 0, s2 = 0) {
    this.x = e4;
    this.y = t2;
    this.z = i2;
    this.w = s2;
  }
  static get identity() {
    return new $e(0, 0, 0, 1);
  }
  static fromVec(e4) {
    return new $e(e4[0], e4[1], e4[2], e4[3]);
  }
  toVec3() {
    return new Ke(this.x, this.y, this.z);
  }
  clone() {
    return new $e(this.x, this.y, this.z, this.w);
  }
  equal(e4) {
    return this.x === e4.x && this.y === e4.y && this.z === e4.z && this.w === e4.w;
  }
  copy(e4) {
    this.x = e4.x;
    this.y = e4.y;
    this.z = e4.z;
    this.w = e4.w;
    return this;
  }
  toArray() {
    return [this.x, this.y, this.z, this.w];
  }
  toArray3() {
    return [this.x, this.y, this.z];
  }
  set(e4, t2, i2, s2) {
    this.x = e4;
    this.y = t2;
    this.z = i2;
    this.w = s2;
    return this;
  }
  addA(e4) {
    this.x += e4.x;
    this.y += e4.y;
    this.z += e4.z;
    this.w += e4.w;
    return this;
  }
  subA(e4) {
    this.x -= e4.x;
    this.y -= e4.y;
    this.z -= e4.z;
    this.w -= e4.w;
    return this;
  }
  scale(e4) {
    this.x *= e4;
    this.y *= e4;
    this.z *= e4;
    this.w *= e4;
    return this;
  }
  affinity() {
    let e4 = 1 / this.w;
    this.x *= e4;
    this.y *= e4;
    this.z *= e4;
    this.w = 1;
    return this;
  }
  scaleTo(e4) {
    return new $e(this.x * e4, this.y * e4, this.z * e4, this.w * e4);
  }
  getStep(e4) {
    return new $e(this.x < e4 ? 0 : 1, this.y < e4 ? 0 : 1, this.z < e4 ? 0 : 1, this.w < e4 ? 0 : 1);
  }
  getFrac(e4) {
    return new $e(J(e4.x), J(e4.y), J(e4.z), J(e4.w));
  }
  dot(e4) {
    return e4.x * this.x + e4.y * this.y + e4.z * this.z + e4.w * this.w;
  }
  isZero() {
    return !(this.x || this.y || this.z || this.w);
  }
}
class Xe {
  constructor() {
    this._m = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  }
  static identity() {
    let e4 = new Xe();
    e4._m[0] = 1;
    e4._m[1] = 0;
    e4._m[2] = 0;
    e4._m[3] = 0;
    e4._m[4] = 0;
    e4._m[5] = 1;
    e4._m[6] = 0;
    e4._m[7] = 0;
    e4._m[8] = 0;
    e4._m[9] = 0;
    e4._m[10] = 1;
    e4._m[11] = 0;
    e4._m[12] = 0;
    e4._m[13] = 0;
    e4._m[14] = 0;
    e4._m[15] = 1;
    return e4;
  }
  static getRotationAroundPoint(e4, t2 = Ke.ZERO, i2 = Ke.UP) {
    let s2 = Xe.getRotation(e4, i2);
    let r2 = new Xe().setIdentity().translate(t2);
    let n2 = new Xe().setIdentity().translate(t2.negateTo());
    return r2.mul(s2).mul(n2);
  }
  static getRotation(e4, t2 = Ke.UP) {
    return new Xe().setRotation(t2, e4);
  }
  set(e4) {
    this._m[0] = e4[0];
    this._m[1] = e4[1];
    this._m[2] = e4[2];
    this._m[3] = e4[3];
    this._m[4] = e4[4];
    this._m[5] = e4[5];
    this._m[6] = e4[6];
    this._m[7] = e4[7];
    this._m[8] = e4[8];
    this._m[9] = e4[9];
    this._m[10] = e4[10];
    this._m[11] = e4[11];
    this._m[12] = e4[12];
    this._m[13] = e4[13];
    this._m[14] = e4[14];
    this._m[15] = e4[15];
    return this;
  }
  clone() {
    let e4 = new Xe();
    e4.set(this._m);
    return e4;
  }
  copy(e4) {
    return this.set(e4._m);
  }
  getMat3() {
    let e4 = new qe();
    let t2 = this._m, i2 = e4._m;
    i2[0] = t2[0];
    i2[1] = t2[1];
    i2[2] = t2[2];
    i2[3] = t2[4];
    i2[4] = t2[5];
    i2[5] = t2[6];
    i2[6] = t2[8];
    i2[7] = t2[9];
    i2[8] = t2[10];
    return e4;
  }
  mulVec3(e4) {
    let t2 = e4.x, i2 = e4.y, s2 = e4.z;
    return new Ke(this._m[0] * t2 + this._m[4] * i2 + this._m[8] * s2 + this._m[12], this._m[1] * t2 + this._m[5] * i2 + this._m[9] * s2 + this._m[13], this._m[2] * t2 + this._m[6] * i2 + this._m[10] * s2 + this._m[14]);
  }
  mulVec4(e4) {
    let t2 = e4.x, i2 = e4.y, s2 = e4.z, r2 = e4.w;
    return new $e(this._m[0] * t2 + this._m[4] * i2 + this._m[8] * s2 + this._m[12] * r2, this._m[1] * t2 + this._m[5] * i2 + this._m[9] * s2 + this._m[13] * r2, this._m[2] * t2 + this._m[6] * i2 + this._m[10] * s2 + this._m[14] * r2, this._m[3] * t2 + this._m[7] * i2 + this._m[11] * s2 + this._m[15] * r2);
  }
  toInverseMatrix3() {
    let e4 = this._m;
    let t2 = e4[0], i2 = e4[1], s2 = e4[2], r2 = e4[4], n2 = e4[5], o2 = e4[6], a2 = e4[8], l2 = e4[9], h2 = e4[10], c2 = h2 * n2 - o2 * l2, d2 = -h2 * r2 + o2 * a2, u2 = l2 * r2 - n2 * a2, _2 = t2 * c2 + i2 * d2 + s2 * u2;
    if (!_2) {
      return;
    }
    _2 = 1 / _2;
    let f2 = new qe();
    f2._m[0] = c2 * _2;
    f2._m[1] = (-h2 * i2 + s2 * l2) * _2;
    f2._m[2] = (o2 * i2 - s2 * n2) * _2;
    f2._m[3] = d2 * _2;
    f2._m[4] = (h2 * t2 - s2 * a2) * _2;
    f2._m[5] = (-o2 * t2 + s2 * r2) * _2;
    f2._m[6] = u2 * _2;
    f2._m[7] = (-l2 * t2 + i2 * a2) * _2;
    f2._m[8] = (n2 * t2 - i2 * r2) * _2;
    return f2;
  }
  inverseTo(e4 = new Xe()) {
    let t2 = this._m[0], i2 = this._m[1], s2 = this._m[2], r2 = this._m[3], n2 = this._m[4], o2 = this._m[5], a2 = this._m[6], l2 = this._m[7], h2 = this._m[8], c2 = this._m[9], d2 = this._m[10], u2 = this._m[11], _2 = this._m[12], f2 = this._m[13], g2 = this._m[14], p2 = this._m[15], m2 = t2 * o2 - i2 * n2, v2 = t2 * a2 - s2 * n2, y2 = t2 * l2 - r2 * n2, x2 = i2 * a2 - s2 * o2, b2 = i2 * l2 - r2 * o2, w2 = s2 * l2 - r2 * a2, C2 = h2 * f2 - c2 * _2, T2 = h2 * g2 - d2 * _2, E2 = h2 * p2 - u2 * _2, A2 = c2 * g2 - d2 * f2, L2 = c2 * p2 - u2 * f2, P2 = d2 * p2 - u2 * g2, S2 = 1 / (m2 * P2 - v2 * L2 + y2 * A2 + x2 * E2 - b2 * T2 + w2 * C2);
    e4._m[0] = (o2 * P2 - a2 * L2 + l2 * A2) * S2;
    e4._m[1] = (-i2 * P2 + s2 * L2 - r2 * A2) * S2;
    e4._m[2] = (f2 * w2 - g2 * b2 + p2 * x2) * S2;
    e4._m[3] = (-c2 * w2 + d2 * b2 - u2 * x2) * S2;
    e4._m[4] = (-n2 * P2 + a2 * E2 - l2 * T2) * S2;
    e4._m[5] = (t2 * P2 - s2 * E2 + r2 * T2) * S2;
    e4._m[6] = (-_2 * w2 + g2 * y2 - p2 * v2) * S2;
    e4._m[7] = (h2 * w2 - d2 * y2 + u2 * v2) * S2;
    e4._m[8] = (n2 * L2 - o2 * E2 + l2 * C2) * S2;
    e4._m[9] = (-t2 * L2 + i2 * E2 - r2 * C2) * S2;
    e4._m[10] = (_2 * b2 - f2 * y2 + p2 * m2) * S2;
    e4._m[11] = (-h2 * b2 + c2 * y2 - u2 * m2) * S2;
    e4._m[12] = (-n2 * A2 + o2 * T2 - a2 * C2) * S2;
    e4._m[13] = (t2 * A2 - i2 * T2 + s2 * C2) * S2;
    e4._m[14] = (-_2 * x2 + f2 * v2 - g2 * m2) * S2;
    e4._m[15] = (h2 * x2 - c2 * v2 + d2 * m2) * S2;
    return e4;
  }
  transposeTo() {
    let e4 = new Xe();
    e4._m[0] = this._m[0];
    e4._m[1] = this._m[4];
    e4._m[2] = this._m[8];
    e4._m[3] = this._m[12];
    e4._m[4] = this._m[1];
    e4._m[5] = this._m[5];
    e4._m[6] = this._m[9];
    e4._m[7] = this._m[13];
    e4._m[8] = this._m[2];
    e4._m[9] = this._m[6];
    e4._m[10] = this._m[10];
    e4._m[11] = this._m[14];
    e4._m[12] = this._m[3];
    e4._m[13] = this._m[7];
    e4._m[14] = this._m[11];
    e4._m[15] = this._m[15];
    return e4;
  }
  setIdentity() {
    this._m[0] = 1;
    this._m[1] = 0;
    this._m[2] = 0;
    this._m[3] = 0;
    this._m[4] = 0;
    this._m[5] = 1;
    this._m[6] = 0;
    this._m[7] = 0;
    this._m[8] = 0;
    this._m[9] = 0;
    this._m[10] = 1;
    this._m[11] = 0;
    this._m[12] = 0;
    this._m[13] = 0;
    this._m[14] = 0;
    this._m[15] = 1;
    return this;
  }
  mul(e4) {
    let t2 = this._m[0], i2 = this._m[1], s2 = this._m[2], r2 = this._m[3], n2 = this._m[4], o2 = this._m[5], a2 = this._m[6], l2 = this._m[7], h2 = this._m[8], c2 = this._m[9], d2 = this._m[10], u2 = this._m[11], _2 = this._m[12], f2 = this._m[13], g2 = this._m[14], p2 = this._m[15];
    let m2 = e4._m[0], v2 = e4._m[1], y2 = e4._m[2], x2 = e4._m[3], b2 = e4._m[4], w2 = e4._m[5], C2 = e4._m[6], T2 = e4._m[7], E2 = e4._m[8], A2 = e4._m[9], L2 = e4._m[10], P2 = e4._m[11], S2 = e4._m[12], R2 = e4._m[13], M2 = e4._m[14], B2 = e4._m[15];
    let k2 = new Xe();
    k2._m[0] = m2 * t2 + v2 * n2 + y2 * h2 + x2 * _2;
    k2._m[1] = m2 * i2 + v2 * o2 + y2 * c2 + x2 * f2;
    k2._m[2] = m2 * s2 + v2 * a2 + y2 * d2 + x2 * g2;
    k2._m[3] = m2 * r2 + v2 * l2 + y2 * u2 + x2 * p2;
    k2._m[4] = b2 * t2 + w2 * n2 + C2 * h2 + T2 * _2;
    k2._m[5] = b2 * i2 + w2 * o2 + C2 * c2 + T2 * f2;
    k2._m[6] = b2 * s2 + w2 * a2 + C2 * d2 + T2 * g2;
    k2._m[7] = b2 * r2 + w2 * l2 + C2 * u2 + T2 * p2;
    k2._m[8] = E2 * t2 + A2 * n2 + L2 * h2 + P2 * _2;
    k2._m[9] = E2 * i2 + A2 * o2 + L2 * c2 + P2 * f2;
    k2._m[10] = E2 * s2 + A2 * a2 + L2 * d2 + P2 * g2;
    k2._m[11] = E2 * r2 + A2 * l2 + L2 * u2 + P2 * p2;
    k2._m[12] = S2 * t2 + R2 * n2 + M2 * h2 + B2 * _2;
    k2._m[13] = S2 * i2 + R2 * o2 + M2 * c2 + B2 * f2;
    k2._m[14] = S2 * s2 + R2 * a2 + M2 * d2 + B2 * g2;
    k2._m[15] = S2 * r2 + R2 * l2 + M2 * u2 + B2 * p2;
    return k2;
  }
  translate(e4) {
    let t2 = e4.x, i2 = e4.y, s2 = e4.z;
    let r2 = this._m;
    r2[12] = r2[0] * t2 + r2[4] * i2 + r2[8] * s2 + r2[12];
    r2[13] = r2[1] * t2 + r2[5] * i2 + r2[9] * s2 + r2[13];
    r2[14] = r2[2] * t2 + r2[6] * i2 + r2[10] * s2 + r2[14];
    r2[15] = r2[3] * t2 + r2[7] * i2 + r2[11] * s2 + r2[15];
    return this;
  }
  translateToPosition(e4) {
    let t2 = this._m;
    t2[12] = e4.x;
    t2[13] = e4.y;
    t2[14] = e4.z;
    return this;
  }
  rotate(e4, t2) {
    let i2 = Math.cos(t2), s2 = Math.sin(t2);
    let r2 = new Xe();
    let n2 = r2._m;
    n2[0] = i2 + (1 - i2) * e4.x * e4.x;
    n2[1] = (1 - i2) * e4.y * e4.x - s2 * e4.z;
    n2[2] = (1 - i2) * e4.z * e4.x + s2 * e4.y;
    n2[3] = 0;
    n2[4] = (1 - i2) * e4.x * e4.y + s2 * e4.z;
    n2[5] = i2 + (1 - i2) * e4.y * e4.y;
    n2[6] = (1 - i2) * e4.z * e4.y - s2 * e4.x;
    n2[7] = 0;
    n2[8] = (1 - i2) * e4.x * e4.z - s2 * e4.y;
    n2[9] = (1 - i2) * e4.y * e4.z + s2 * e4.x;
    n2[10] = i2 + (1 - i2) * e4.z * e4.z;
    n2[11] = 0;
    n2[12] = 0;
    n2[13] = 0;
    n2[14] = 0;
    n2[15] = 1;
    return this.mul(r2);
  }
  setRotation(e4, t2) {
    let i2 = Math.cos(t2), s2 = Math.sin(t2);
    let r2 = this._m;
    r2[0] = i2 + (1 - i2) * e4.x * e4.x;
    r2[1] = (1 - i2) * e4.y * e4.x - s2 * e4.z;
    r2[2] = (1 - i2) * e4.z * e4.x + s2 * e4.y;
    r2[3] = 0;
    r2[4] = (1 - i2) * e4.x * e4.y + s2 * e4.z;
    r2[5] = i2 + (1 - i2) * e4.y * e4.y;
    r2[6] = (1 - i2) * e4.z * e4.y - s2 * e4.x;
    r2[7] = 0;
    r2[8] = (1 - i2) * e4.x * e4.z - s2 * e4.y;
    r2[9] = (1 - i2) * e4.y * e4.z + s2 * e4.x;
    r2[10] = i2 + (1 - i2) * e4.z * e4.z;
    r2[11] = 0;
    r2[12] = 0;
    r2[13] = 0;
    r2[14] = 0;
    r2[15] = 1;
    return this;
  }
  rotateBetweenVectors(e4, t2) {
    let i2 = Ze.getRotationBetweenVectors(e4, t2);
    return i2.getMat4();
  }
  scale(e4) {
    let t2 = this._m;
    t2[0] = t2[0] * e4.x;
    t2[1] = t2[1] * e4.x;
    t2[2] = t2[2] * e4.x;
    t2[3] = t2[3] * e4.x;
    t2[4] = t2[4] * e4.y;
    t2[5] = t2[5] * e4.y;
    t2[6] = t2[6] * e4.y;
    t2[7] = t2[7] * e4.y;
    t2[8] = t2[8] * e4.z;
    t2[9] = t2[9] * e4.z;
    t2[10] = t2[10] * e4.z;
    t2[11] = t2[11] * e4.z;
    return this;
  }
  setPerspective(e4, t2, i2, s2, r2, n2) {
    let o2 = t2 - e4, a2 = s2 - i2, l2 = r2 - n2, h2 = 2 * r2;
    let c2 = this._m;
    c2[0] = h2 / o2;
    c2[1] = 0;
    c2[2] = 0;
    c2[3] = 0;
    c2[4] = 0;
    c2[5] = h2 / a2;
    c2[6] = 0;
    c2[7] = 0;
    c2[8] = (t2 + e4) / o2;
    c2[9] = (s2 + i2) / a2;
    c2[10] = (n2 + r2) / l2;
    c2[11] = -1;
    c2[12] = 0;
    c2[13] = 0;
    c2[14] = h2 * n2 / l2;
    c2[15] = 0;
    return this;
  }
  setOrtho(e4, t2, i2, s2, r2, n2) {
    let o2 = 1 / (e4 - t2), a2 = 1 / (i2 - s2), l2 = 1 / (r2 - n2), h2 = this._m;
    h2[0] = -2 * o2;
    h2[1] = 0;
    h2[2] = 0;
    h2[3] = 0;
    h2[4] = 0;
    h2[5] = -2 * a2;
    h2[6] = 0;
    h2[7] = 0;
    h2[8] = 0;
    h2[9] = 0;
    h2[10] = 2 * l2;
    h2[11] = 0;
    h2[12] = (e4 + t2) * o2;
    h2[13] = (s2 + i2) * a2;
    h2[14] = (n2 + r2) * l2;
    h2[15] = 1;
    return this;
  }
  eulerToMatrix(e4, t2, i2) {
    let s2 = Math.cos(e4), r2 = Math.sin(e4), n2 = Math.cos(t2), o2 = Math.sin(t2), a2 = Math.cos(i2), l2 = Math.sin(i2);
    let h2 = s2 * o2, c2 = r2 * o2;
    let d2 = this._m;
    d2[0] = n2 * a2;
    d2[1] = -n2 * l2;
    d2[2] = -o2;
    d2[4] = -c2 * a2 + s2 * l2;
    d2[5] = c2 * l2 + s2 * a2;
    d2[6] = -r2 * n2;
    d2[8] = h2 * a2 + r2 * l2;
    d2[9] = -h2 * l2 + r2 * a2;
    d2[10] = s2 * n2;
    d2[3] = d2[7] = d2[11] = d2[12] = d2[13] = d2[14] = 0;
    d2[15] = 1;
    return this;
  }
}
class Ze {
  constructor(e4 = 0, t2 = 0, i2 = 0, s2 = 0) {
    this.x = e4;
    this.y = t2;
    this.z = i2;
    this.w = s2;
  }
  static get IDENTITY() {
    return new Ze(0, 0, 0, 1);
  }
  static xRotation(e4) {
    e4 *= 0.5;
    return new Ze(Math.sin(e4), 0, 0, Math.cos(e4));
  }
  static yRotation(e4) {
    e4 *= 0.5;
    return new Ze(0, Math.sin(e4), 0, Math.cos(e4));
  }
  static zRotation(e4) {
    e4 *= 0.5;
    return new Ze(0, 0, Math.sin(e4), Math.cos(e4));
  }
  static axisAngleToQuat(e4, t2 = 0) {
    let i2 = e4.getNormal();
    let s2 = t2 * 0.5;
    let r2 = Math.sin(s2);
    return new Ze(i2.x * r2, i2.y * r2, i2.z * r2, Math.cos(s2));
  }
  static getLookRotation(e4, t2) {
    let i2 = e4.getNormal().negate();
    let s2 = t2.cross(i2).normalize();
    let r2 = i2.cross(s2);
    let n2 = 1 + s2.x + r2.y + i2.z;
    if (n2 > 1e-6) {
      let e5 = 1 / (2 * Math.sqrt(n2));
      return new Ze((i2.y - r2.z) * e5, (s2.z - i2.x) * e5, (r2.x - s2.y) * e5, 0.25 / e5);
    }
    if (s2.x > r2.y && s2.x > i2.z) {
      let e5 = 1 / (2 * Math.sqrt(1 + s2.x - r2.y - i2.z));
      return new Ze(0.25 / e5, (r2.x + s2.y) * e5, (s2.z + i2.x) * e5, (i2.y - r2.z) * e5);
    }
    if (r2.y > i2.z) {
      let e5 = 1 / (2 * Math.sqrt(1 + r2.y - s2.x - i2.z));
      return new Ze((r2.x + s2.y) * e5, 0.25 / e5, (i2.y + r2.z) * e5, (s2.z - i2.x) * e5);
    }
    let o2 = 1 / (2 * Math.sqrt(1 + i2.z - s2.x - r2.y));
    return new Ze((s2.z + i2.x) * o2, (i2.y + r2.z) * o2, 0.25 / o2, (r2.x - s2.y) * o2);
  }
  static getLookAtSourceDest(e4, t2) {
    let i2 = t2.subA(e4).normalize();
    let s2 = Ke.FORWARD.dot(i2);
    if (Math.abs(s2 - -1) < 1e-6) {
      return Ze.axisAngleToQuat(Ke.UP, Math.PI);
    }
    if (Math.abs(s2 - 1) < 1e-6) {
      return new Ze(0, 0, 0, 1);
    }
    let r2 = Math.acos(s2);
    let n2 = Ke.FORWARD.cross(i2).normalize();
    return Ze.axisAngleToQuat(n2, r2);
  }
  static getRotationBetweenVectors(e4, t2) {
    let i2 = e4.cross(t2);
    let s2 = new Ze(i2.x, i2.y, i2.z, 1 + e4.dot(t2));
    return s2.normalize();
  }
  static getRotationBetweenVectorsRes(e4, t2, i2) {
    let s2 = e4.cross(t2);
    i2.set(s2.x, s2.y, s2.z, 1 + e4.dot(t2));
    return i2.normalize();
  }
  static getRotationBetweenVectorsUp(e4, t2, i2) {
    let s2 = e4.dot(t2);
    if (Math.abs(s2 + 1) < 1e-6) {
      return Ze.axisAngleToQuat(i2, Math.PI);
    }
    if (Math.abs(s2 - 1) < 1e-6) {
      return new Ze(0, 0, 0, 1);
    }
    let r2 = Math.acos(s2);
    let n2 = e4.cross(t2).normalize();
    return Ze.axisAngleToQuat(n2, r2);
  }
  isZero() {
    return this.x === 0 && this.y === 0 && this.z === 0 && this.w === 0;
  }
  isNaN() {
    return isNaN(this.x) || isNaN(this.y) || isNaN(this.z) || isNaN(this.w);
  }
  clear() {
    this.x = this.y = this.z = this.w = 0;
    return this;
  }
  set(e4, t2, i2, s2) {
    this.x = e4;
    this.y = t2;
    this.z = i2;
    this.w = s2;
    return this;
  }
  copy(e4) {
    this.x = e4.x;
    this.y = e4.y;
    this.z = e4.z;
    this.w = e4.w;
    return this;
  }
  setIdentity() {
    this.x = 0;
    this.y = 0;
    this.z = 0;
    this.w = 1;
    return this;
  }
  clone() {
    return new Ze(this.x, this.y, this.z, this.w);
  }
  add(e4) {
    return new Ze(this.x + e4.x, this.y + e4.y, this.z + e4.z, this.w + e4.w);
  }
  addRes(e4, t2) {
    return t2.set(this.x + e4.x, this.y + e4.y, this.z + e4.z, this.w + e4.w);
  }
  sub(e4) {
    return new Ze(this.x - e4.x, this.y - e4.y, this.z - e4.z, this.w - e4.w);
  }
  scaleTo(e4) {
    return new Ze(this.x * e4, this.y * e4, this.z * e4, this.w * e4);
  }
  scale(e4) {
    this.x *= e4;
    this.y *= e4;
    this.z *= e4;
    this.w *= e4;
    return this;
  }
  toVec() {
    return [this.x, this.y, this.z, this.w];
  }
  get xyz() {
    return new Ke(this.x, this.y, this.z);
  }
  setLookRotation(e4, t2) {
    let i2 = e4.getNormal().negate();
    let s2 = t2.cross(i2).normalize();
    let r2 = i2.cross(s2);
    let n2 = 1 + s2.x + r2.y + i2.z;
    if (n2 > 1e-6) {
      let e5 = 1 / (2 * Math.sqrt(n2));
      this.x = (i2.y - r2.z) * e5;
      this.y = (s2.z - i2.x) * e5;
      this.z = (r2.x - s2.y) * e5;
      this.w = 0.25 / e5;
    } else if (s2.x > r2.y && s2.x > i2.z) {
      let e5 = 1 / (2 * Math.sqrt(1 + s2.x - r2.y - i2.z));
      this.x = 0.25 / e5;
      this.y = (r2.x + s2.y) * e5;
      this.z = (s2.z + i2.x) * e5;
      this.w = (i2.y - r2.z) * e5;
    } else if (r2.y > i2.z) {
      let e5 = 1 / (2 * Math.sqrt(1 + r2.y - s2.x - i2.z));
      this.x = (r2.x + s2.y) * e5;
      this.y = 0.25 / e5;
      this.z = (i2.y + r2.z) * e5;
      this.w = (s2.z - i2.x) * e5;
    } else {
      let e5 = 1 / (2 * Math.sqrt(1 + i2.z - s2.x - r2.y));
      this.x = (s2.z + i2.x) * e5;
      this.y = (i2.y + r2.z) * e5;
      this.z = 0.25 / e5;
      this.w = (r2.x - s2.y) * e5;
    }
    return this;
  }
  setFromSphericalCoords(e4, t2, i2) {
    let s2 = Math.sin(i2 / 2);
    let r2 = Math.cos(i2 / 2);
    let n2 = Math.sin(e4);
    let o2 = Math.cos(e4);
    let a2 = Math.sin(t2);
    let l2 = Math.cos(t2);
    this.x = s2 * o2 * a2;
    this.y = s2 * n2;
    this.z = s2 * n2 * l2;
    this.w = r2;
    return this;
  }
  getSphericalCoords() {
    let e4 = this.w;
    let t2 = Math.sqrt(1 - e4 * e4);
    if (Math.abs(t2) < 5e-4) {
      t2 = 1;
    }
    let i2 = this.x / t2;
    let s2 = this.y / t2;
    let r2 = this.z / t2;
    let n2, o2 = -Math.asin(s2);
    if (i2 * i2 + r2 * r2 < 5e-4) {
      n2 = 0;
    } else {
      n2 = Math.atan2(i2, r2);
    }
    if (n2 < 0) {
      n2 += 360;
    }
    return { lat: o2, lon: n2, alpha: Math.acos(e4) };
  }
  setFromAxisAngle(e4, t2) {
    let i2 = e4.getNormal();
    let s2 = t2 * 0.5;
    let r2 = Math.sin(s2);
    this.set(i2.x * r2, i2.y * r2, i2.z * r2, Math.cos(s2));
    return this;
  }
  getAxisAngle() {
    let e4 = this.x, t2 = this.y, i2 = this.z, s2 = this.w;
    let r2 = Math.sqrt(e4 * e4 + t2 * t2 + i2 * i2);
    let n2, o2;
    if (r2 > 1e-7) {
      let a2 = 1 / r2;
      n2 = new Ke(e4 * a2, t2 * a2, i2 * a2);
      if (s2 < 0) {
        o2 = 2 * Math.atan2(-r2, -s2);
      } else {
        o2 = 2 * Math.atan2(r2, s2);
      }
    } else {
      n2 = new Ke(0, 0, 0);
      o2 = 0;
    }
    return { axis: n2, angle: o2 };
  }
  getPitch() {
    let e4 = -2 * (this.y * this.z - this.w * this.x);
    return Math.abs(e4) >= 1 ? Math.sign(e4) * t : Math.asin(e4);
  }
  getYaw() {
    return -Math.atan2(2 * (this.x * this.z + this.w * this.y), 1 - 2 * (this.y * this.y + this.x * this.x));
  }
  getRoll() {
    return Math.atan2(2 * (this.x * this.y + this.w * this.z), 1 - 2 * (this.z * this.z + this.x * this.x));
  }
  setPitchYawRoll(e4, t2, i2, s2 = Ze.IDENTITY) {
    let r2 = Ze.xRotation(-e4);
    let n2 = Ze.yRotation(t2);
    let o2 = Ze.zRotation(-i2);
    return this.copy(o2.mul(r2).mul(n2).mul(s2).conjugate());
  }
  setFromEulerAngles(e4, t2, i2) {
    let s2 = e4 * f, r2 = t2 * f, n2 = i2 * f;
    let o2 = Math.cos(s2), a2 = Math.cos(r2), l2 = Math.cos(n2);
    let h2 = Math.sin(s2), c2 = Math.sin(r2), d2 = Math.sin(n2);
    let u2 = a2 * l2, _2 = c2 * d2;
    this.w = o2 * u2 + h2 * _2;
    this.x = h2 * u2 - o2 * _2;
    this.y = o2 * c2 * l2 + h2 * a2 * d2;
    this.z = o2 * a2 * d2 - h2 * c2 * l2;
    return this.normalize();
  }
  getEulerAngles() {
    let e4 = this.x, t2 = this.y, i2 = this.z, s2 = this.w;
    let r2 = t2 * t2;
    let n2 = Math.atan2(2 * (s2 * e4 + t2 * i2), 1 - 2 * (e4 * e4 + r2));
    let o2 = s2 * t2 - i2 * e4;
    if (o2 < -1) {
      o2 = -1;
    } else if (o2 > 1) {
      o2 = 1;
    }
    let a2 = Math.asin(2 * o2);
    let l2 = Math.atan2(2 * (s2 * i2 + e4 * t2), 1 - 2 * (r2 + i2 * i2));
    return { roll: n2, pitch: a2, yaw: l2 };
  }
  setFromMatrix4(e4) {
    let t2, i2, s2 = [];
    let r2, n2, o2;
    let a2 = e4._m;
    let l2 = [1, 2, 0];
    t2 = a2[0] + a2[5] + a2[10];
    if (t2 > 0) {
      i2 = Math.sqrt(t2 + 1);
      this.w = i2 / 2;
      i2 = 0.5 / i2;
      this.x = (a2[6] - a2[9]) * i2;
      this.y = (a2[8] - a2[2]) * i2;
      this.z = (a2[1] - a2[4]) * i2;
    } else {
      r2 = 0;
      if (a2[5] > a2[0]) r2 = 1;
      if (a2[10] > a2[r2 * 5]) r2 = 2;
      n2 = l2[r2];
      o2 = l2[n2];
      i2 = Math.sqrt(a2[r2 * 5] - (a2[n2 * 5] + a2[o2 * 5]) + 1);
      s2[r2] = i2 * 0.5;
      if (i2 !== 0) i2 = 0.5 / i2;
      s2[3] = (a2[n2 * 4 + o2] - a2[o2 * 4 + n2]) * i2;
      s2[n2] = (a2[r2 * 4 + n2] + a2[n2 * 4 + r2]) * i2;
      s2[o2] = (a2[r2 * 4 + o2] + a2[o2 * 4 + r2]) * i2;
      this.x = s2[0];
      this.y = s2[1];
      this.z = s2[2];
      this.w = s2[3];
    }
    return this;
  }
  getMat4(e4 = new Xe()) {
    let t2 = this.x + this.x;
    let i2 = this.y + this.y;
    let s2 = this.z + this.z;
    let r2 = this.w * t2;
    let n2 = this.w * i2;
    let o2 = this.w * s2;
    let a2 = this.x * t2;
    let l2 = this.x * i2;
    let h2 = this.x * s2;
    let c2 = this.y * i2;
    let d2 = this.y * s2;
    let u2 = this.z * s2;
    return e4.set([1 - (c2 + u2), l2 - o2, h2 + n2, 0, l2 + o2, 1 - (a2 + u2), d2 - r2, 0, h2 - n2, d2 + r2, 1 - (a2 + c2), 0, 0, 0, 0, 1]);
  }
  getMat3() {
    let e4 = new qe();
    let t2 = e4._m;
    let i2 = this.x, s2 = this.y, r2 = this.z, n2 = this.w, o2 = i2 + i2, a2 = s2 + s2, l2 = r2 + r2, h2 = i2 * o2, c2 = i2 * a2;
    i2 = i2 * l2;
    let d2 = s2 * a2;
    s2 = s2 * l2;
    r2 = r2 * l2;
    o2 = n2 * o2;
    a2 = n2 * a2;
    n2 = n2 * l2;
    t2[0] = 1 - (d2 + r2);
    t2[1] = c2 - n2;
    t2[2] = i2 + a2;
    t2[3] = c2 + n2;
    t2[4] = 1 - (h2 + r2);
    t2[5] = s2 - o2;
    t2[6] = i2 - a2;
    t2[7] = s2 + o2;
    t2[8] = 1 - (h2 + d2);
    return e4;
  }
  mulVec3(e4) {
    let t2 = e4.x, i2 = e4.y, s2 = e4.z;
    let r2 = this.x, n2 = this.y, o2 = this.z, a2 = this.w;
    let l2 = a2 * t2 + n2 * s2 - o2 * i2, h2 = a2 * i2 + o2 * t2 - r2 * s2, c2 = a2 * s2 + r2 * i2 - n2 * t2;
    t2 = -r2 * t2 - n2 * i2 - o2 * s2;
    return new Ke(l2 * a2 + t2 * -r2 + h2 * -o2 - c2 * -n2, h2 * a2 + t2 * -n2 + c2 * -r2 - l2 * -o2, c2 * a2 + t2 * -o2 + l2 * -n2 - h2 * -r2);
  }
  mulVec3Res(e4, t2) {
    let i2 = e4.x, s2 = e4.y, r2 = e4.z;
    let n2 = this.x, o2 = this.y, a2 = this.z, l2 = this.w;
    let h2 = l2 * i2 + o2 * r2 - a2 * s2, c2 = l2 * s2 + a2 * i2 - n2 * r2, d2 = l2 * r2 + n2 * s2 - o2 * i2;
    i2 = -n2 * i2 - o2 * s2 - a2 * r2;
    return t2.set(h2 * l2 + i2 * -n2 + c2 * -a2 - d2 * -o2, c2 * l2 + i2 * -o2 + d2 * -n2 - h2 * -a2, d2 * l2 + i2 * -a2 + h2 * -o2 - c2 * -n2);
  }
  mul(e4) {
    let t2 = this.x, i2 = this.y, s2 = this.z, r2 = this.w;
    let n2 = e4.x, o2 = e4.y, a2 = e4.z, l2 = e4.w;
    return new Ze(t2 * l2 + r2 * n2 + i2 * a2 - s2 * o2, i2 * l2 + r2 * o2 + s2 * n2 - t2 * a2, s2 * l2 + r2 * a2 + t2 * o2 - i2 * n2, r2 * l2 - t2 * n2 - i2 * o2 - s2 * a2);
  }
  mulRes(e4, t2) {
    let i2 = this.x, s2 = this.y, r2 = this.z, n2 = this.w;
    let o2 = e4.x, a2 = e4.y, l2 = e4.z, h2 = e4.w;
    return t2.set(i2 * h2 + n2 * o2 + s2 * l2 - r2 * a2, s2 * h2 + n2 * a2 + r2 * o2 - i2 * l2, r2 * h2 + n2 * l2 + i2 * a2 - s2 * o2, n2 * h2 - i2 * o2 - s2 * a2 - r2 * l2);
  }
  mulA(e4) {
    let t2 = this.x, i2 = this.y, s2 = this.z, r2 = this.w;
    let n2 = e4.x, o2 = e4.y, a2 = e4.z, l2 = e4.w;
    this.x = t2 * l2 + r2 * n2 + i2 * a2 - s2 * o2;
    this.y = i2 * l2 + r2 * o2 + s2 * n2 - t2 * a2;
    this.z = s2 * l2 + r2 * a2 + t2 * o2 - i2 * n2;
    this.w = r2 * l2 - t2 * n2 - i2 * o2 - s2 * a2;
    return this;
  }
  conjugate() {
    return new Ze(-this.x, -this.y, -this.z, this.w);
  }
  inverse() {
    let e4 = 1 / this.magnitude2();
    return new Ze(-this.x * e4, -this.y * e4, -this.z * e4, this.w * e4);
  }
  magnitude() {
    let e4 = this.x, t2 = this.y, i2 = this.z, s2 = this.w;
    return Math.sqrt(e4 * e4 + t2 * t2 + i2 * i2 + s2 * s2);
  }
  magnitude2() {
    let e4 = this.x, t2 = this.y, i2 = this.z, s2 = this.w;
    return e4 * e4 + t2 * t2 + i2 * i2 + s2 * s2;
  }
  dot(e4) {
    return this.x * e4.x + this.y * e4.y + this.z * e4.z;
  }
  normalize() {
    let e4 = this.x, t2 = this.y, i2 = this.z, s2 = this.w, r2 = Math.sqrt(e4 * e4 + t2 * t2 + i2 * i2 + s2 * s2);
    if (r2 === 0) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 0;
      return this;
    }
    r2 = 1 / r2;
    this.x = e4 * r2;
    this.y = t2 * r2;
    this.z = i2 * r2;
    this.w = s2 * r2;
    return this;
  }
  isEqual(e4) {
    let t2 = this.dot(e4);
    if (Math.abs(t2 - 1) < 1e-3) {
      return true;
    }
    return false;
  }
  slerp(e4, t2) {
    let i2 = this.x, s2 = this.y, r2 = this.z, n2 = this.w, o2 = e4.x, a2 = e4.y, l2 = e4.z, h2 = e4.w;
    let c2, d2, u2, _2, f2;
    d2 = i2 * o2 + s2 * a2 + r2 * l2 + n2 * h2;
    if (d2 < 0) {
      d2 = -d2;
      o2 = -o2;
      a2 = -a2;
      l2 = -l2;
      h2 = -h2;
    }
    if (1 - d2 > 1e-6) {
      c2 = Math.acos(d2);
      u2 = Math.sin(c2);
      _2 = Math.sin((1 - t2) * c2) / u2;
      f2 = Math.sin(t2 * c2) / u2;
    } else {
      _2 = 1 - t2;
      f2 = t2;
    }
    return new Ze(_2 * i2 + f2 * o2, _2 * s2 + f2 * a2, _2 * r2 + f2 * l2, _2 * n2 + f2 * h2);
  }
}
class Ke {
  constructor(e4 = 0, t2 = 0, i2 = 0) {
    this.x = e4;
    this.y = t2;
    this.z = i2;
  }
  static get UP() {
    return new Ke(0, 1, 0);
  }
  static get DOWN() {
    return new Ke(0, -1, 0);
  }
  static get RIGHT() {
    return new Ke(1, 0, 0);
  }
  static get LEFT() {
    return new Ke(-1, 0, 0);
  }
  static get FORWARD() {
    return new Ke(0, 0, -1);
  }
  static get BACKWARD() {
    return new Ke(0, 0, 1);
  }
  static get ZERO() {
    return new Ke();
  }
  static get UNIT_X() {
    return new Ke(1, 0, 0);
  }
  static get UNIT_Y() {
    return new Ke(0, 1, 0);
  }
  static get UNIT_Z() {
    return new Ke(0, 0, 1);
  }
  static get NORTH() {
    return Ke.UNIT_Z;
  }
  static doubleToTwoFloats(e4, t2, i2) {
    let s2 = e4.x, r2 = e4.y, n2 = e4.z;
    if (s2 >= 0) {
      let e5 = Math.floor(s2 / 65536) * 65536;
      t2.x = Math.fround(e5);
      i2.x = Math.fround(s2 - e5);
    } else {
      let e5 = Math.floor(-s2 / 65536) * 65536;
      t2.x = Math.fround(-e5);
      i2.x = Math.fround(s2 + e5);
    }
    if (r2 >= 0) {
      let e5 = Math.floor(r2 / 65536) * 65536;
      t2.y = Math.fround(e5);
      i2.y = Math.fround(r2 - e5);
    } else {
      let e5 = Math.floor(-r2 / 65536) * 65536;
      t2.y = Math.fround(-e5);
      i2.y = Math.fround(r2 + e5);
    }
    if (n2 >= 0) {
      let e5 = Math.floor(n2 / 65536) * 65536;
      t2.z = Math.fround(e5);
      i2.z = Math.fround(n2 - e5);
    } else {
      let e5 = Math.floor(-n2 / 65536) * 65536;
      t2.z = Math.fround(-e5);
      i2.z = Math.fround(n2 + e5);
    }
  }
  static doubleToTwoFloat32Array(e4, t2, i2) {
    let s2 = e4.x, r2 = e4.y, n2 = e4.z;
    if (s2 >= 0) {
      let e5 = Math.floor(s2 / 65536) * 65536;
      t2[0] = Math.fround(e5);
      i2[0] = Math.fround(s2 - e5);
    } else {
      let e5 = Math.floor(-s2 / 65536) * 65536;
      t2[0] = Math.fround(-e5);
      i2[0] = Math.fround(s2 + e5);
    }
    if (r2 >= 0) {
      let e5 = Math.floor(r2 / 65536) * 65536;
      t2[1] = Math.fround(e5);
      i2[1] = Math.fround(r2 - e5);
    } else {
      let e5 = Math.floor(-r2 / 65536) * 65536;
      t2[1] = Math.fround(-e5);
      i2[1] = Math.fround(r2 + e5);
    }
    if (n2 >= 0) {
      let e5 = Math.floor(n2 / 65536) * 65536;
      t2[2] = Math.fround(e5);
      i2[2] = Math.fround(n2 - e5);
    } else {
      let e5 = Math.floor(-n2 / 65536) * 65536;
      t2[2] = Math.fround(-e5);
      i2[2] = Math.fround(n2 + e5);
    }
  }
  static fromVec(e4) {
    return new Ke(e4[0], e4[1], e4[2]);
  }
  static angle(e4, t2) {
    let i2 = e4.dot(t2);
    let s2 = e4.cross(t2).length();
    return Math.atan2(s2, i2);
  }
  static lerp(e4, t2, i2) {
    return new Ke(e4.x + (t2.x - e4.x) * i2, e4.y + (t2.y - e4.y) * i2, e4.z + (t2.z - e4.z) * i2);
  }
  static add(e4, t2) {
    let i2 = new Ke(e4.x, e4.y, e4.z);
    i2.addA(t2);
    return i2;
  }
  static sub(e4, t2) {
    let i2 = new Ke(e4.x, e4.y, e4.z);
    i2.subA(t2);
    return i2;
  }
  static scale(e4, t2) {
    return e4.scaleTo(t2);
  }
  static mul(e4, t2) {
    let i2 = new Ke(e4.x, e4.y, e4.z);
    i2.mulA(t2);
    return i2;
  }
  static noncollinear(e4, t2) {
    return Boolean(e4.y * t2.z - e4.z * t2.y || e4.z * t2.x - e4.x * t2.z || e4.x * t2.y - e4.y * t2.z);
  }
  static proj_b_to_plane(e4, t2, i2) {
    let s2 = e4.sub(t2.scaleTo(t2.dot(e4) / t2.dot(t2)));
    if (i2 && s2.isZero()) {
      return new Ke(i2.x, i2.y, i2.z);
    }
    return s2;
  }
  static proj_b_to_a(e4, t2) {
    return t2.scaleTo(t2.dot(e4) / t2.dot(t2));
  }
  static orthoNormalize(e4, t2) {
    e4 = e4.getNormal();
    e4.scale(t2.dot(e4));
    return t2.subA(e4).normalize();
  }
  static div(e4, t2) {
    let i2 = new Ke(e4.x, e4.y, e4.z);
    i2.divA(t2);
    return i2;
  }
  static length2(e4) {
    return e4.length2();
  }
  static dot(e4, t2) {
    return e4.dot(t2);
  }
  toVec4() {
    return new $e(this.x, this.y, this.z, 1);
  }
  clone() {
    return new Ke(this.x, this.y, this.z);
  }
  toString() {
    return `(${this.x},${this.y},${this.z})`;
  }
  isZero() {
    return !(this.x || this.y || this.z);
  }
  projToVec(e4) {
    return e4.scaleTo(e4.dot(this) / e4.dot(e4));
  }
  equal(e4) {
    return this.x === e4.x && this.y === e4.y && this.z === e4.z;
  }
  copy(e4) {
    this.x = e4.x;
    this.y = e4.y;
    this.z = e4.z;
    return this;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  length2() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  getQuat() {
    return new Ze(this.x, this.y, this.z);
  }
  addA(e4) {
    this.x += e4.x;
    this.y += e4.y;
    this.z += e4.z;
    return this;
  }
  add(e4) {
    return new Ke(this.x + e4.x, this.y + e4.y, this.z + e4.z);
  }
  addRes(e4, t2) {
    return t2.set(this.x + e4.x, this.y + e4.y, this.z + e4.z);
  }
  subA(e4) {
    this.x -= e4.x;
    this.y -= e4.y;
    this.z -= e4.z;
    return this;
  }
  sub(e4) {
    return new Ke(this.x - e4.x, this.y - e4.y, this.z - e4.z);
  }
  scale(e4) {
    this.x *= e4;
    this.y *= e4;
    this.z *= e4;
    return this;
  }
  scaleTo(e4) {
    return new Ke(this.x * e4, this.y * e4, this.z * e4);
  }
  mulA(e4) {
    this.x *= e4.x;
    this.y *= e4.y;
    this.z *= e4.z;
    return this;
  }
  mul(e4) {
    return new Ke(this.x * e4.x, this.y * e4.y, this.z * e4.z);
  }
  mulRes(e4, t2) {
    return t2.set(this.x * e4.x, this.y * e4.y, this.z * e4.z);
  }
  divA(e4) {
    this.x /= e4.x;
    this.y /= e4.y;
    this.z /= e4.z;
    return this;
  }
  div(e4) {
    return new Ke(this.x / e4.x, this.y / e4.y, this.z / e4.z);
  }
  dot(e4) {
    return e4.x * this.x + e4.y * this.y + e4.z * this.z;
  }
  dotArr(e4) {
    return e4[0] * this.x + e4[1] * this.y + e4[2] * this.z;
  }
  cross(e4) {
    return new Ke(this.y * e4.z - this.z * e4.y, this.z * e4.x - this.x * e4.z, this.x * e4.y - this.y * e4.x);
  }
  clear() {
    this.x = this.y = this.z = 0;
    return this;
  }
  getNormal() {
    let e4 = new Ke();
    e4.copy(this);
    let t2 = 1 / e4.length();
    e4.x *= t2;
    e4.y *= t2;
    e4.z *= t2;
    return e4;
  }
  normal() {
    let e4 = new Ke();
    e4.copy(this);
    let t2 = 1 / e4.length();
    e4.x *= t2;
    e4.y *= t2;
    e4.z *= t2;
    return e4;
  }
  normalNegate() {
    let e4 = new Ke();
    e4.copy(this);
    let t2 = -1 / e4.length();
    e4.x *= t2;
    e4.y *= t2;
    e4.z *= t2;
    return e4;
  }
  normalNegateScale(e4) {
    let t2 = new Ke();
    t2.copy(this);
    let i2 = -e4 / t2.length();
    t2.x *= i2;
    t2.y *= i2;
    t2.z *= i2;
    return t2;
  }
  normalScale(e4) {
    let t2 = new Ke();
    t2.copy(this);
    let i2 = e4 / t2.length();
    t2.x *= i2;
    t2.y *= i2;
    t2.z *= i2;
    return t2;
  }
  normalize() {
    let e4 = 1 / this.length();
    this.x *= e4;
    this.y *= e4;
    this.z *= e4;
    return this;
  }
  toVec() {
    return [this.x, this.y, this.z];
  }
  toArray() {
    return [this.x, this.y, this.z];
  }
  distance(e4) {
    let t2 = this.x - e4.x, i2 = this.y - e4.y, s2 = this.z - e4.z;
    return Math.sqrt(t2 * t2 + i2 * i2 + s2 * s2);
  }
  distance2(e4) {
    let t2 = this.x - e4.x, i2 = this.y - e4.y, s2 = this.z - e4.z;
    return t2 * t2 + i2 * i2 + s2 * s2;
  }
  set(e4, t2, i2) {
    this.x = e4;
    this.y = t2;
    this.z = i2;
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  negateTo() {
    return new Ke(-this.x, -this.y, -this.z);
  }
  projToRay(e4, t2) {
    let i2 = Ke.proj_b_to_a(Ke.sub(this, e4), t2);
    i2.addA(e4);
    return i2;
  }
  angle(e4) {
    return Ke.angle(this, e4);
  }
  lerp(e4, t2) {
    return new Ke(this.x + (e4.x - this.x) * t2, this.y + (e4.y - this.y) * t2, this.z + (e4.z - this.z) * t2);
  }
  smerp(e4, t2) {
    let i2 = 1 - t2;
    return new Ke(this.x * t2 + e4.x * i2, this.y * t2 + e4.y * i2, this.z * t2 + e4.z * i2);
  }
  static get LERP_DELTA() {
    return 1e-6;
  }
  slerp(e4, t2) {
    let i2 = new Ke();
    if (t2 <= 0) {
      i2.copy(this);
      return i2;
    } else if (t2 >= 1) {
      i2.copy(e4);
      return i2;
    }
    let s2, r2, n2, o2;
    let a2 = this.dot(e4);
    if (1 - a2 > Ke.LERP_DELTA) {
      s2 = Math.acos(a2);
      r2 = Math.sin(s2);
      n2 = Math.sin((1 - t2) * s2) / r2;
      o2 = Math.sin(t2 * s2) / r2;
    } else {
      n2 = 1 - t2;
      o2 = t2;
    }
    return Ke.add(this.scaleTo(n2), e4.scale(o2));
  }
  mulVecA(e4) {
    this.x *= e4.x;
    this.y *= e4.y;
    this.z *= e4.z;
    return this;
  }
  getRotationTo(e4, t2) {
    let i2 = this.clone();
    let s2 = e4.clone();
    i2.normalize();
    s2.normalize();
    let r2 = i2.dot(s2);
    if (r2 >= 1) {
      return Ze.IDENTITY.clone();
    }
    if (r2 < 1e-6 - 1) {
      if (!t2.equal(Ke.ZERO)) {
        return Ze.axisAngleToQuat(t2, Math.PI);
      } else {
        let e5 = Ke.UNIT_X.cross(i2);
        if (e5.isZero()) {
          e5 = Ke.UNIT_Y.cross(i2);
        }
        e5.normalize();
        return Ze.axisAngleToQuat(e5, Math.PI);
      }
    } else {
      let e5 = Math.sqrt((1 + r2) * 2);
      let t3 = 1 / e5;
      let n2 = i2.cross(s2);
      let o2 = new Ze(n2.x * t3, n2.y * t3, n2.z * t3, e5 * 0.5);
      o2.normalize();
      return o2;
    }
  }
}
class Qe {
  constructor(e4 = 0, t2 = 0) {
    this.x = e4;
    this.y = t2;
  }
  static get UP() {
    return new Qe(0, 1);
  }
  static get DOWN() {
    return new Qe(0, -1);
  }
  static get RIGHT() {
    return new Qe(1, 0);
  }
  static get LEFT() {
    return new Qe(-1, 0);
  }
  static get ZERO() {
    return new Qe();
  }
  static add(e4, t2) {
    const i2 = new Qe(e4.x, e4.y);
    i2.addA(t2);
    return i2;
  }
  static sub(e4, t2) {
    var i2 = new Qe(e4.x, e4.y);
    i2.subA(t2);
    return i2;
  }
  static scale(e4, t2) {
    let i2 = new Qe(e4.x, e4.y);
    i2.scale(t2);
    return i2;
  }
  static mul(e4, t2) {
    let i2 = new Qe(e4.x, e4.y);
    i2.mulA(t2);
    return i2;
  }
  static div(e4, t2) {
    let i2 = new Qe(e4.x, e4.y);
    i2.divA(t2);
    return i2;
  }
  static proj_b_to_a(e4, t2) {
    return t2.scaleTo(t2.dot(e4) / t2.dot(t2));
  }
  static angle(e4, t2) {
    return Math.acos(e4.dot(t2) / Math.sqrt(e4.length2() * t2.length2()));
  }
  static orthoNormalize(e4, t2) {
    e4 = e4.normal();
    e4.scale(t2.dot(e4));
    return t2.sub(e4).normalize();
  }
  static proj_b_to_plane(e4, t2, i2) {
    let s2 = e4.sub(t2.scaleTo(t2.dot(e4) / t2.dot(t2)));
    if (i2 && s2.isZero()) {
      return new Qe(i2.x, i2.y);
    }
    return s2;
  }
  toVector3() {
    return new Ke(this.x, this.y, 0);
  }
  clone() {
    return new Qe(this.x, this.y);
  }
  equal(e4) {
    return this.x === e4.x && this.y === e4.y;
  }
  copy(e4) {
    this.x = e4.x;
    this.y = e4.y;
    return this;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  length2() {
    return this.x * this.x + this.y * this.y;
  }
  addA(e4) {
    this.x += e4.x;
    this.y += e4.y;
    return this;
  }
  add(e4) {
    return new Qe(this.x + e4.x, this.y + e4.y);
  }
  subA(e4) {
    this.x -= e4.x;
    this.y -= e4.y;
    return this;
  }
  sub(e4) {
    return new Qe(this.x - e4.x, this.y - e4.y);
  }
  scale(e4) {
    this.x *= e4;
    this.y *= e4;
    return this;
  }
  scaleTo(e4) {
    return new Qe(this.x * e4, this.y * e4);
  }
  mulA(e4) {
    this.x *= e4.x;
    this.y *= e4.y;
    return this;
  }
  mul(e4) {
    return new Qe(this.x * e4.x, this.y * e4.y);
  }
  divA(e4) {
    this.x /= e4.x;
    this.y /= e4.y;
    return this;
  }
  dot(e4) {
    return e4.x * this.x + e4.y * this.y;
  }
  dotArr(e4) {
    return e4[0] * this.x + e4[1] * this.y;
  }
  cross(e4) {
    return this.x * e4.y - this.y * e4.x;
  }
  clear() {
    this.x = this.y = 0;
    return this;
  }
  normal() {
    return this.getNormal();
  }
  getNormal() {
    let e4 = new Qe();
    e4.copy(this);
    let t2 = 1 / e4.length();
    e4.x *= t2;
    e4.y *= t2;
    return e4;
  }
  normalize() {
    let e4 = 1 / this.length();
    this.x *= e4;
    this.y *= e4;
    return this;
  }
  toVec() {
    return [this.x, this.y];
  }
  distance(e4) {
    let t2 = Qe.sub(this, e4);
    return t2.length();
  }
  set(e4, t2) {
    this.x = e4;
    this.y = t2;
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  negateTo() {
    return new Qe(-this.x, -this.y);
  }
  projToRay(e4, t2) {
    let i2 = Qe.proj_b_to_a(Qe.sub(this, e4), t2);
    i2.add(e4);
    return i2;
  }
  angle(e4) {
    return Qe.angle(this, e4);
  }
  lerp(e4, t2, i2) {
    let s2 = this.clone();
    if (i2 <= 0) {
      s2.copy(e4);
    } else if (i2 >= 1) {
      s2.copy(t2);
    } else {
      s2 = Qe.add(e4, Qe.sub(t2, e4).scale(i2));
    }
    return s2;
  }
  static get LERP_DELTA() {
    return 1e-6;
  }
  slerp(e4, t2) {
    let i2 = new Qe();
    if (t2 <= 0) {
      i2.copy(this);
      return i2;
    } else if (t2 >= 1) {
      i2.copy(e4);
      return i2;
    }
    let s2, r2, n2, o2;
    let a2 = this.dot(e4);
    if (1 - a2 > Qe.LERP_DELTA) {
      s2 = Math.acos(a2);
      r2 = Math.sin(s2);
      n2 = Math.sin((1 - t2) * s2) / r2;
      o2 = Math.sin(t2 * s2) / r2;
    } else {
      n2 = 1 - t2;
      o2 = t2;
    }
    return Qe.add(this.scale(n2), e4.scale(o2));
  }
  isZero() {
    return !(this.x || this.y);
  }
}
const Je = { aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aqua: "#00ffff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", black: "#000000", blanchedalmond: "#ffebcd", blue: "#0000ff", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dodgerblue: "#1e90ff", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", fuchsia: "#ff00ff", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", gold: "#ffd700", goldenrod: "#daa520", gray: "#808080", green: "#008000", greenyellow: "#adff2f", honeydew: "#f0fff0", hotpink: "#ff69b4", "indianred ": "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavender: "#e6e6fa", lavenderblush: "#fff0f5", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgrey: "#d3d3d3", lightgreen: "#90ee90", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslategray: "#778899", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", lime: "#00ff00", limegreen: "#32cd32", linen: "#faf0e6", magenta: "#ff00ff", maroon: "#800000", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370d8", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", navy: "#000080", oldlace: "#fdf5e6", olive: "#808000", olivedrab: "#6b8e23", orange: "#ffa500", orangered: "#ff4500", orchid: "#da70d6", palegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#d87093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", purple: "#800080", rebeccapurple: "#663399", red: "#ff0000", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", wheat: "#f5deb3", white: "#ffffff", whitesmoke: "#f5f5f5", yellow: "#ffff00", yellowgreen: "#9acd32" };
class et {
  constructor(e4 = 1, t2 = 1) {
    this._a = e4;
    this._b = t2;
    this._flattening = (e4 - t2) / e4;
    this._f = 1 / this._flattening;
    this._a2 = e4 * e4;
    this._b2 = t2 * t2;
    const i2 = Math.sqrt(this._a2 - this._b2);
    this._e = i2 / e4;
    this._e2 = this._e * this._e;
    this._e22 = this._e2 * this._e2;
    this._k = i2 / t2;
    this._k2 = this._k * this._k;
    this._radii = new Ke(e4, e4, t2);
    this._radii2 = new Ke(this._a2, this._a2, this._b2);
    this._invRadii = new Ke(1 / e4, 1 / e4, 1 / t2);
    this._invRadii2 = new Ke(1 / this._a2, 1 / this._a2, 1 / this._b2);
  }
  rhumbDistanceTo(e4, t2) {
    const i2 = e4.lat * d;
    const s2 = t2.lat * d;
    const r2 = s2 - i2;
    let n2 = Math.abs(t2.lon - e4.lon) * d;
    if (Math.abs(n2) > Math.PI) n2 = n2 > 0 ? -(2 * Math.PI - n2) : 2 * Math.PI + n2;
    const o2 = Math.log(Math.tan(s2 / 2 + Math.PI / 4) / Math.tan(i2 / 2 + Math.PI / 4));
    const a2 = Math.abs(o2) > 1e-11 ? r2 / o2 : Math.cos(i2);
    const l2 = Math.sqrt(r2 * r2 + a2 * a2 * n2 * n2);
    return l2 * this._a;
  }
  getIntermediatePointOnGreatCircle(e4, t2, i2) {
    if (i2 == 0) return e4.clone();
    if (i2 == 1) return t2.clone();
    const s2 = this.inverse(e4, t2);
    const r2 = s2.distance;
    const n2 = s2.initialAzimuth;
    return isNaN(n2) ? e4 : this.getGreatCircleDestination(e4, n2, r2 * i2);
  }
  static getBearing(e4, t2) {
    let i2 = e4.lat * d, s2 = e4.lon * d;
    let r2 = t2.lat * d, n2 = t2.lon * d;
    let o2 = Math.sin(n2 - s2) * Math.cos(r2);
    let a2 = Math.cos(i2) * Math.sin(r2) - Math.sin(i2) * Math.cos(r2) * Math.cos(n2 - s2);
    return Math.atan2(o2, a2) * u;
  }
  getFlattening() {
    return this._flattening;
  }
  getEquatorialSize() {
    return this._a;
  }
  get equatorialSize() {
    return this._a;
  }
  get equatorialSizeSqr() {
    return this._a2;
  }
  getPolarSize() {
    return this._b;
  }
  get polarSize() {
    return this._b;
  }
  get polarSizeSqr() {
    return this._b2;
  }
  lonLatToCartesian(e4) {
    return this.geodeticToCartesian(e4.lon, e4.lat, e4.height);
  }
  lonLatToCartesianRes(e4, t2) {
    return this.geodeticToCartesian(e4.lon, e4.lat, e4.height, t2);
  }
  geodeticToCartesian(e4, t2, i2 = 0, s2 = new Ke()) {
    let r2 = d * t2, n2 = d * e4;
    let o2 = Math.sin(r2);
    let a2 = this._a / Math.sqrt(1 - this._e2 * o2 * o2);
    let l2 = (a2 + i2) * Math.cos(r2);
    s2.x = l2 * Math.cos(n2);
    s2.y = l2 * Math.sin(n2);
    s2.z = (a2 * (1 - this._e2) + i2) * o2;
    return s2;
  }
  projToSurface(e4) {
    let t2 = e4.x || 0, i2 = e4.y || 0, s2 = e4.z || 0;
    let r2 = Math.sqrt(t2 * t2 + i2 * i2 + s2 * s2);
    if (r2 === 0) {
      return this.lonLatToCartesian(new be());
    }
    let n2 = this._invRadii2.x, o2 = this._invRadii2.y, a2 = this._invRadii2.z;
    let l2 = t2 * t2 * n2, h2 = i2 * i2 * o2, c2 = s2 * s2 * a2;
    let d2 = l2 + h2 + c2;
    let u2 = Math.sqrt(1 / d2);
    let _2 = e4.scaleTo(u2);
    if (d2 < b) {
      return !Number.isFinite(u2) ? new Ke() : _2;
    }
    let f2 = (1 - u2) * r2 / _2.mulA(this._invRadii2).length();
    let g2 = 0, p2 = 0, m2 = 0;
    do {
      g2 = 1 / (1 + f2 * n2);
      p2 = 1 / (1 + f2 * o2);
      m2 = 1 / (1 + f2 * a2);
      let e5 = g2 * g2, t3 = p2 * p2, i3 = m2 * m2;
      let s3 = l2 * e5 + h2 * t3 + c2 * i3 - 1;
      if (Math.abs(s3) < B) {
        break;
      }
      let r3 = e5 * g2, d3 = t3 * p2, u3 = i3 * m2;
      f2 += 0.5 * s3 / (l2 * r3 * n2 + h2 * d3 * o2 + c2 * u3 * a2);
    } while (true);
    return new Ke(t2 * g2, i2 * p2, s2 * m2);
  }
  cartesianToLonLat(e4) {
    return this.cartesianToLonLatRes(e4);
  }
  cartesianToLonLatRes(e4, t2 = new be()) {
    let i2 = this.projToSurface(e4);
    let s2 = this.getSurfaceNormal3v(i2), r2 = e4.sub(i2);
    t2.lon = Math.atan2(s2.y, s2.x) * u;
    t2.lat = Math.asin(s2.z) * u;
    t2.height = Math.sign(r2.dot(e4)) * r2.length();
    return t2;
  }
  getSurfaceNormal3v(e4) {
    let t2 = this._invRadii2;
    let i2 = e4.x * t2.x, s2 = e4.y * t2.y, r2 = e4.z * t2.z;
    let n2 = 1 / Math.sqrt(i2 * i2 + s2 * s2 + r2 * r2);
    return new Ke(i2 * n2, s2 * n2, r2 * n2);
  }
  getGreatCircleDistance(e4, t2) {
    return this.inverse(e4, t2).distance;
  }
  getGreatCircleDestination(e4, t2, i2) {
    return this.direct(e4, t2, i2).destination;
  }
  inverse(e4, t2) {
    let i2 = this._a, s2 = this._b, r2 = this._flattening;
    const n2 = e4.lat * d, o2 = e4.lon * d;
    const a2 = t2.lat * d, l2 = t2.lon * d;
    const h2 = l2 - o2;
    const c2 = (1 - r2) * Math.tan(n2), _2 = 1 / Math.sqrt(1 + c2 * c2), f2 = c2 * _2;
    const g2 = (1 - r2) * Math.tan(a2), p2 = 1 / Math.sqrt(1 + g2 * g2), m2 = g2 * p2;
    const v2 = Math.abs(h2) > Math.PI / 2 || Math.abs(a2 - n2) > Math.PI / 2;
    let y2 = h2, x2 = null, b2 = null;
    let w2 = v2 ? Math.PI : 0, C2 = 0, T2 = v2 ? -1 : 1, E2 = null;
    let A2 = 1;
    let L2 = 1;
    let P2 = null, S2 = 0;
    do {
      x2 = Math.sin(y2);
      b2 = Math.cos(y2);
      E2 = (p2 * x2) ** 2 + (_2 * m2 - f2 * p2 * b2) ** 2;
      if (Math.abs(E2) < 1e-24) break;
      C2 = Math.sqrt(E2);
      T2 = f2 * m2 + _2 * p2 * b2;
      w2 = Math.atan2(C2, T2);
      const e5 = _2 * p2 * x2 / C2;
      L2 = 1 - e5 * e5;
      A2 = L2 != 0 ? T2 - 2 * f2 * m2 / L2 : 0;
      const t3 = r2 / 16 * L2 * (4 + r2 * (4 - 3 * L2));
      P2 = y2;
      y2 = h2 + (1 - t3) * r2 * e5 * (w2 + t3 * C2 * (A2 + t3 * T2 * (-1 + 2 * A2 * A2)));
    } while (Math.abs(y2 - P2) > B && ++S2 < 1e3);
    const R2 = L2 * (i2 * i2 - s2 * s2) / (s2 * s2);
    const M2 = 1 + R2 / 16384 * (4096 + R2 * (-768 + R2 * (320 - 175 * R2)));
    const k2 = R2 / 1024 * (256 + R2 * (-128 + R2 * (74 - 47 * R2)));
    const I2 = k2 * C2 * (A2 + k2 / 4 * (T2 * (-1 + 2 * A2 * A2) - k2 / 6 * A2 * (-3 + 4 * C2 * C2) * (-3 + 4 * A2 * A2)));
    const z2 = s2 * M2 * (w2 - I2);
    const D2 = Math.abs(E2) < Number.EPSILON ? 0 : Math.atan2(p2 * x2, _2 * m2 - f2 * p2 * b2);
    const F2 = Math.abs(E2) < Number.EPSILON ? Math.PI : Math.atan2(_2 * x2, -f2 * p2 + _2 * m2 * b2);
    return { distance: z2, initialAzimuth: Math.abs(z2) < Number.EPSILON ? NaN : K(D2) * u, finalAzimuth: Math.abs(z2) < Number.EPSILON ? NaN : K(F2) * u };
  }
  direct(e4, t2, i2) {
    let s2 = e4.lon, r2 = e4.lat;
    let n2 = this._a, o2 = this._b, a2 = this._flattening, l2 = i2, h2 = t2 * d, c2 = Math.sin(h2), _2 = Math.cos(h2), f2 = (1 - a2) * Math.tan(r2 * d), g2 = 1 / Math.sqrt(1 + f2 * f2), p2 = f2 * g2, m2 = Math.atan2(f2, _2), v2 = g2 * c2, y2 = 1 - v2 * v2, x2 = y2 * (n2 * n2 - o2 * o2) / (o2 * o2), b2 = 1 + x2 / 16384 * (4096 + x2 * (-768 + x2 * (320 - 175 * x2))), w2 = x2 / 1024 * (256 + x2 * (-128 + x2 * (74 - 47 * x2))), C2 = l2 / (o2 * b2), T2 = 2 * Math.PI;
    let E2 = 0, A2 = 0, L2 = 0, P2 = 0;
    while (Math.abs(C2 - T2) > 1e-12) {
      E2 = Math.cos(2 * m2 + C2);
      A2 = Math.sin(C2);
      L2 = Math.cos(C2);
      P2 = w2 * A2 * (E2 + w2 / 4 * (L2 * (-1 + 2 * E2 * E2) - w2 / 6 * E2 * (-3 + 4 * A2 * A2) * (-3 + 4 * E2 * E2)));
      T2 = C2;
      C2 = l2 / (o2 * b2) + P2;
    }
    let S2 = p2 * A2 - g2 * L2 * _2, R2 = Math.atan2(p2 * L2 + g2 * A2 * _2, (1 - a2) * Math.sqrt(v2 * v2 + S2 * S2)), M2 = Math.atan2(A2 * c2, g2 * L2 - p2 * A2 * _2), B2 = a2 / 16 * y2 * (4 + a2 * (4 - 3 * y2)), k2 = M2 - (1 - B2) * a2 * v2 * (C2 + B2 * A2 * (E2 + B2 * L2 * (-1 + 2 * E2 * E2))), I2 = Math.atan2(v2, -S2);
    return { destination: new be(s2 + k2 * u, R2 * u), finalAzimuth: I2 * u };
  }
  hitRay(e4, t2) {
    let i2 = this._invRadii.mul(e4);
    let s2 = this._invRadii.mul(t2);
    let r2 = i2.dot(i2);
    let n2 = i2.dot(s2);
    let o2, a2, l2, h2, c2;
    if (r2 > 1) {
      if (n2 >= 0) {
        return void 0;
      }
      var d2 = n2 * n2;
      o2 = r2 - 1;
      a2 = s2.dot(s2);
      l2 = a2 * o2;
      let i3 = Math.abs(d2 - l2);
      if (i3 > z && d2 < l2) {
        return void 0;
      } else if (d2 > l2) {
        h2 = n2 * n2 - l2;
        c2 = -n2 + Math.sqrt(h2);
        var u2 = c2 / a2;
        var _2 = o2 / c2;
        if (u2 < _2) {
          return e4.add(t2.scaleTo(u2));
        }
        return e4.add(t2.scaleTo(_2));
      } else {
        var f2 = Math.sqrt(o2 / a2);
        return e4.add(t2.scaleTo(f2));
      }
    } else if (r2 < 1) {
      o2 = r2 - 1;
      a2 = s2.dot(s2);
      l2 = a2 * o2;
      h2 = n2 * n2 - l2;
      c2 = -n2 + Math.sqrt(h2);
      return e4.add(t2.scaleTo(c2 / a2));
    } else {
      if (n2 < 0) {
        a2 = s2.dot(s2);
        return e4.add(t2.scaleTo(-n2 / a2));
      }
    }
  }
  getNorthFrameRotation(e4) {
    let t2 = this.getSurfaceNormal3v(e4);
    let i2 = Ke.proj_b_to_plane(Ke.NORTH, t2);
    return Ze.getLookRotation(i2, t2);
  }
  getBearingDestination(e4, t2 = 0, i2 = 0) {
    t2 = t2 * d;
    var s2 = (e4.lon + 540) % 360 - 180;
    var r2 = e4.lat * d, n2 = s2 * d;
    var o2 = i2 / this._a;
    var a2 = Math.asin(Math.sin(r2) * Math.cos(o2) + Math.cos(r2) * Math.sin(o2) * Math.cos(t2));
    return new be((n2 + Math.atan2(Math.sin(t2) * Math.sin(o2) * Math.cos(r2), Math.cos(o2) - Math.sin(r2) * Math.sin(a2))) * u, a2 * u);
  }
  static getIntermediatePointOnGreatCircle(e4, t2, i2) {
    var s2 = e4.lat * d, r2 = e4.lon * d;
    var n2 = t2.lat * d, o2 = t2.lon * d;
    var a2 = Math.sin(s2), l2 = Math.cos(s2), h2 = Math.sin(r2), c2 = Math.cos(r2);
    var _2 = Math.sin(n2), f2 = Math.cos(n2), g2 = Math.sin(o2), p2 = Math.cos(o2);
    var m2 = n2 - s2, v2 = o2 - r2;
    var y2 = Math.sin(m2 / 2) * Math.sin(m2 / 2) + Math.cos(s2) * Math.cos(n2) * Math.sin(v2 / 2) * Math.sin(v2 / 2);
    var x2 = 2 * Math.atan2(Math.sqrt(y2), Math.sqrt(1 - y2));
    var b2 = Math.sin((1 - i2) * x2) / Math.sin(x2);
    var w2 = Math.sin(i2 * x2) / Math.sin(x2);
    var C2 = b2 * l2 * c2 + w2 * f2 * p2;
    var T2 = b2 * l2 * h2 + w2 * f2 * g2;
    var E2 = b2 * a2 + w2 * _2;
    var A2 = Math.atan2(E2, Math.sqrt(C2 * C2 + T2 * T2));
    var L2 = Math.atan2(T2, C2);
    return new be((L2 * u + 540) % 360 - 180, A2 * u);
  }
  static getRhumbBearing(e4, t2) {
    var i2 = (t2.lon - e4.lon) * d;
    var s2 = Math.log(Math.tan(t2.lat * d / 2 + Math.PI / 4) / Math.tan(e4.lat * d / 2 + Math.PI / 4));
    if (Math.abs(i2) > Math.PI) {
      if (i2 > 0) {
        i2 = (2 * Math.PI - i2) * -1;
      } else {
        i2 = 2 * Math.PI + i2;
      }
    }
    return (Math.atan2(i2, s2) * u + 360) % 360;
  }
  getLonLatVisibilitySimple(e4, t2, i2) {
    const s2 = this.lonLatToCartesian(t2);
    const r2 = t2.height;
    const n2 = this.polarSize + r2;
    const o2 = Math.max(e4.length() - this.polarSize, 0);
    const a2 = s2.sub(e4);
    let l2;
    if (o2 > 0) {
      l2 = Math.sqrt((n2 + o2) ** 2 - n2 ** 2);
    } else {
      l2 = n2;
    }
    return l2 > a2.length() && (!i2 || i2.dot(a2.normalize()) > 0);
  }
}
const tt = new et(6378137, 6356752314245179e-9);
function it(e4, t2) {
  return e4 != void 0 ? e4 : t2;
}
function st(e4) {
  return e4 == null;
}
function rt(e4) {
  return e4 === void 0;
}
function nt(e4, t2) {
  return rt(e4) ? t2 : e4;
}
let ot = 0;
function at(e4) {
  let t2 = e4._openglobus_id;
  if (!t2) {
    t2 = e4._openglobus_id = ++ot;
  }
  return t2;
}
function lt(e4) {
  return typeof e4 === "string" || e4 instanceof String;
}
function ht(e4) {
  return e4.toString(16).padStart(2, "0");
}
function ct(e4) {
  let t2, i2, s2;
  if (e4 instanceof Array) {
    t2 = ht(e4[0]);
    i2 = ht(e4[1]);
    s2 = ht(e4[2]);
  } else {
    t2 = ht(e4.x);
    i2 = ht(e4.y);
    s2 = ht(e4.z);
  }
  return `#${t2}${i2}${s2}`;
}
function dt(e4, t2) {
  let i2 = Je[e4];
  if (i2) {
    e4 = i2;
  }
  if (e4[0] === "#") {
    let i3 = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    let s2 = e4.replace(i3, function(e5, t3, i4, s3) {
      return t3 + t3 + i4 + i4 + s3 + s3;
    });
    let r2 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(s2);
    if (r2) {
      return new $e(parseInt(r2[1], 16) / 255, parseInt(r2[2], 16) / 255, parseInt(r2[3], 16) / 255, st(t2) ? 1 : t2);
    } else {
      return new $e();
    }
  } else {
    if (st(t2)) {
      t2 = 1;
    }
    let i3 = e4.split(",");
    return new $e(parseInt(i3[0].split("(")[1]) / 255, parseInt(i3[1]) / 255, parseInt(i3[2]) / 255, !st(i3[3]) ? parseFloat(i3[3]) : t2);
  }
}
function ut(e4, t2) {
  let i2 = dt(e4, t2);
  return new Float32Array([i2.x, i2.y, i2.z, i2.w]);
}
function _t(e4) {
  let t2 = Je[e4];
  if (t2) {
    e4 = t2;
  }
  if (e4[0] === "#") {
    let t3 = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    let i2 = e4.replace(t3, function(e5, t4, i3, s3) {
      return t4 + t4 + i3 + i3 + s3 + s3;
    });
    let s2 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(i2);
    if (s2) {
      return new Ke(parseInt(s2[1], 16) / 255, parseInt(s2[2], 16) / 255, parseInt(s2[3], 16) / 255);
    } else {
      return new Ke();
    }
  } else {
    let t3 = e4.split(",");
    return new Ke(parseInt(t3[0].split("(")[1]) / 255, parseInt(t3[1]) / 255, parseInt(t3[2]) / 255);
  }
}
function ft(e4, t2) {
  return e4.replace(/{[^{}]+}/g, function(e5) {
    return t2[e5.replace(/[{}]+/g, "")] || "";
  });
}
function gt(e4, t2) {
  return e4.replace(/\$\{([^}]+)\}/g, (e5, i2) => (t2 == null ? void 0 : t2[i2.trim()]) ?? "");
}
function pt(e4, t2) {
  return ft(e4, t2);
}
function mt(e4) {
  let t2 = document.createElement("div");
  t2.innerHTML = e4;
  let i2 = [];
  for (let e5 = 0; e5 < t2.childNodes.length; e5++) {
    i2.push(t2.childNodes[e5]);
    t2.removeChild(t2.childNodes[e5]);
  }
  return i2;
}
function vt(e4, t2, i2, s2) {
  let r2 = document.getElementById(e4);
  if (!r2) {
    r2 = document.createElement("div");
    r2.id = e4;
    r2.classList.add("defaultText");
    document.body.appendChild(r2);
  }
  r2.innerHTML = t2;
  r2.style.left = `${i2}px`;
  r2.style.top = `${s2}px`;
}
function yt(e4) {
  return typeof e4 === "number";
}
function xt(e4, t2 = "") {
  return e4 ? e4.trim() : t2;
}
function bt(e4, t2) {
  if (e4) {
    if (yt(e4)) {
      return new Ke(e4, e4, e4);
    } else if (e4 instanceof Ke) {
      return e4.clone();
    } else if (e4 instanceof Array) {
      return Ke.fromVec(e4);
    } else if (e4 instanceof Qe) {
      return new Ke(e4.x, e4.y, 0);
    }
  } else if (t2) {
    return t2;
  }
  return new Ke();
}
function wt(e4, t2) {
  if (e4) {
    if (e4 instanceof $e) {
      return e4.clone();
    } else if (e4 instanceof Array) {
      return $e.fromVec(e4);
    }
  } else if (t2) {
    return t2;
  }
  return new $e();
}
function Ct(e4, t2) {
  if (e4) {
    if (lt(e4)) {
      return dt(e4);
    } else if (e4 instanceof Array) {
      return $e.fromVec(e4);
    } else if (e4 instanceof $e) {
      return e4.clone();
    }
  } else if (t2) {
    return t2;
  }
  return new $e(1, 1, 1, 1);
}
function Tt(e4, t2) {
  if (e4) {
    if (lt(e4)) {
      return _t(e4);
    } else if (e4 instanceof Array) {
      return Ke.fromVec(e4);
    } else if (e4 instanceof Ke) {
      return e4.clone();
    }
  } else if (t2) {
    return t2;
  }
  return new Ke(1, 1, 1);
}
function Et(e4, t2) {
  if (e4) {
    if (e4 instanceof Array) {
      return new Ye(At(e4[0]), At(e4[1]));
    } else if (e4 instanceof Ye) {
      return e4.clone();
    }
  } else if (t2) {
    return t2;
  }
  return new Ye();
}
function At(e4, t2) {
  if (e4) {
    if (e4 instanceof Array) {
      return new be(e4[0], e4[1], e4[2]);
    } else if (e4 instanceof be) {
      return e4.clone();
    }
  } else if (t2) {
    return t2;
  }
  return new be();
}
function Lt(e4, t2) {
  let i2 = 0, s2 = e4.length - 1;
  while (i2 <= s2) {
    let r2 = Math.floor((i2 + s2) * 0.5);
    if (Math.abs(e4[r2] - t2) < 1e-3) {
      return r2;
    } else if (e4[r2] < t2) {
      i2 = r2 + 1;
    } else {
      s2 = r2 - 1;
    }
  }
  return -1;
}
function Pt(e4, t2, i2) {
  let s2 = 0;
  let r2 = e4.length - 1;
  while (s2 <= r2) {
    let n2 = r2 + s2 >> 1;
    let o2 = i2(t2, e4[n2], n2);
    if (o2 > 0) {
      s2 = n2 + 1;
    } else if (o2 < 0) {
      r2 = n2 - 1;
    } else {
      return n2;
    }
  }
  return -s2 - 1;
}
function St(e4, t2, i2) {
  let s2 = Pt(e4, t2, i2);
  if (s2 < 0) {
    s2 = ~s2;
  }
  e4.splice(s2, 0, t2);
  return s2;
}
function Rt(e4, t2, i2, s2, r2) {
  let n2 = t2.sub(e4);
  let o2 = s2.sub(i2);
  let a2 = -n2.y;
  let l2 = +n2.x;
  let h2 = -(a2 * e4.x + l2 * e4.y);
  let c2 = -o2.y;
  let d2 = +o2.x;
  let u2 = -(c2 * i2.x + d2 * i2.y);
  let _2 = c2 * e4.x + d2 * e4.y + u2;
  let f2 = c2 * t2.x + d2 * t2.y + u2;
  let g2 = a2 * i2.x + l2 * i2.y + h2;
  let p2 = a2 * s2.x + l2 * s2.y + h2;
  if (r2 && (_2 * f2 > 0 || g2 * p2 > 0)) {
    return void 0;
  }
  let m2 = _2 / (_2 - f2);
  return new Qe(e4.x + m2 * n2.x, e4.y + m2 * n2.y);
}
function Mt(e4, t2, i2, s2, r2 = false) {
  let n2 = new be(t2.lon - e4.lon, t2.lat - e4.lat);
  let o2 = new be(s2.lon - i2.lon, s2.lat - i2.lat);
  let a2 = -n2.lat;
  let l2 = +n2.lon;
  let h2 = -(a2 * e4.lon + l2 * e4.lat);
  let c2 = -o2.lat;
  let d2 = +o2.lon;
  let u2 = -(c2 * i2.lon + d2 * i2.lat);
  let _2 = c2 * e4.lon + d2 * e4.lat + u2;
  let f2 = c2 * t2.lon + d2 * t2.lat + u2;
  let g2 = a2 * i2.lon + l2 * i2.lat + h2;
  let p2 = a2 * s2.lon + l2 * s2.lat + h2;
  if (r2 && (_2 * f2 > 0 || g2 * p2 > 0)) {
    return void 0;
  }
  let m2 = _2 / (_2 - f2);
  return new be(e4.lon + m2 * n2.lon, e4.lat + m2 * n2.lat);
}
function Bt(e4) {
  let t2 = {};
  if (e4.nodeType === 1) {
    if (e4.attributes.length > 0) {
      t2["@attributes"] = {};
      for (let i2 = 0; i2 < e4.attributes.length; i2++) {
        let s2 = e4.attributes.item(i2);
        t2["@attributes"][s2.nodeName] = s2.nodeValue;
      }
    }
  } else if (e4.nodeType === 3) {
    t2 = e4.nodeValue;
  }
  if (e4.hasChildNodes()) {
    for (let i2 = 0; i2 < e4.childNodes.length; i2++) {
      let s2 = e4.childNodes.item(i2);
      let r2 = s2.nodeName;
      if (typeof t2[r2] === "undefined") {
        t2[r2] = Bt(s2);
      } else {
        if (typeof t2[r2].push === "undefined") {
          let e5 = t2[r2];
          t2[r2] = [];
          t2[r2].push(e5);
        }
        t2[r2].push(Bt(s2));
      }
    }
  }
  return t2;
}
const kt = { string: function(e4) {
  return st(e4) ? e4 : e4.toString();
}, date: function(e4) {
  return st(e4) ? e4 : new Date(e4 * 1e3);
}, datetime: function(e4) {
  return st(e4) ? e4 : new Date(e4 * 1e3);
}, time: function(e4) {
  return st(e4) ? e4 : parseInt(e4);
}, integer: function(e4) {
  return st(e4) ? e4 : parseInt(e4);
}, float: function(e4) {
  return st(e4) ? e4 : parseFloat(e4);
}, boolean: function(e4) {
  if (e4 === null) {
    return e4;
  }
  if (typeof e4 === "boolean") {
    if (e4 === true) {
      return true;
    }
    return false;
  }
  if (typeof e4 === "string") {
    if (e4 === "") {
      return false;
    }
    e4 = e4.replace(/^\s+|\s+$/g, "");
    if (e4.toLowerCase() === "true" || e4.toLowerCase() === "yes") {
      return true;
    }
    e4 = e4.replace(/,/g, ".");
    e4 = e4.replace(/^\s*\-\s*/g, "-");
  }
  if (!isNaN(e4)) {
    return parseFloat(e4) !== 0;
  }
  return false;
} };
function It(e4, t2 = "") {
  let i2 = 1024;
  let s2 = atob(e4);
  let r2 = s2.length;
  let n2 = Math.ceil(r2 / i2);
  let o2 = new Array(n2);
  for (let e5 = 0; e5 < n2; ++e5) {
    let t3 = e5 * i2;
    let n3 = Math.min(t3 + i2, r2);
    let a2 = new Array(n3 - t3);
    for (let e6 = t3, i3 = 0; e6 < n3; ++i3, ++e6) {
      a2[i3] = s2[e6].charCodeAt(0);
    }
    o2[e5] = new Uint8Array(a2);
  }
  return new Blob(o2, { type: t2 });
}
function zt(e4) {
  let t2 = e4.split(";");
  let i2 = t2[0].split(":")[1];
  let s2 = t2[1].split(",")[1];
  return It(s2, i2);
}
function Dt(e4, t2, i2 = false) {
  let s2;
  let r2 = 0;
  return function() {
    const n2 = arguments;
    if (!r2) {
      e4.apply(null, n2);
      r2 = Date.now();
    } else {
      if (i2) {
        clearTimeout(s2);
      }
      s2 = setTimeout(() => {
        if (Date.now() - r2 >= t2) {
          e4.apply(null, n2);
          r2 = Date.now();
        }
      }, t2 - (Date.now() - r2));
    }
  };
}
function Ft(e4, t2, i2, s2, r2, n2, o2 = 0, a2 = 1, l2 = 0, h2 = 1) {
  return (i2 * (a2 - e4) * (h2 - t2) + s2 * (e4 - o2) * (h2 - t2) + r2 * (a2 - e4) * (t2 - l2) + n2 * (e4 - o2) * (t2 - l2)) / ((a2 - o2) * (h2 - l2));
}
function Nt(e4, t2, i2, s2, r2, n2) {
  return i2 * (1 - e4) * (1 - t2) + s2 * e4 * (1 - t2) + r2 * (1 - e4) * t2 + n2 * e4 * t2;
}
function Ot(e4, t2, i2) {
  let s2 = Math.sqrt(t2.length) - 1;
  let r2 = s2 + 1;
  let n2 = Math.sqrt(e4.length / 4);
  let o2 = n2 / s2;
  let a2 = 0, l2 = 0;
  for (let h2 = 0, c2 = 0, d2 = e4.length / 4; h2 < d2; h2++) {
    let d3 = e4[h2 * 4];
    let u2 = Math.floor(h2 / n2), _2 = h2 % n2;
    let f2 = Math.floor(_2 / s2), g2 = Math.floor(u2 / s2);
    let p2 = i2[g2][f2];
    let m2 = u2 % s2, v2 = _2 % s2;
    let y2 = (m2 + g2) * r2 + v2 + f2;
    p2[y2] = d3;
    if ((u2 + g2) % o2 === 0 && (_2 + f2) % o2 === 0) {
      t2[c2++] = d3;
    }
    if ((_2 + 1) % s2 === 0 && _2 !== n2 - 1) {
      a2 = e4[(h2 + 1) * 4];
      let n3 = (d3 + a2) * 0.5;
      y2 = (m2 + g2) * r2 + v2 + 1;
      p2[y2] = n3;
      if ((u2 + g2) % o2 === 0) {
        t2[c2++] = n3;
      }
      let l3 = (m2 + g2) * r2 + (v2 + 1) % s2;
      i2[g2][f2 + 1][l3] = n3;
    }
    if ((u2 + 1) % s2 === 0 && u2 !== n2 - 1) {
      l2 = e4[(h2 + n2) * 4];
      let a3 = (d3 + l2) * 0.5;
      y2 = (m2 + 1) * r2 + v2 + f2;
      p2[y2] = a3;
      if ((_2 + f2) % o2 === 0) {
        t2[c2++] = a3;
      }
      let u3 = (m2 + 1) % s2 * r2 + v2 + f2;
      i2[g2 + 1][f2][u3] = a3;
    }
    if ((_2 + 1) % s2 === 0 && _2 !== n2 - 1 && (u2 + 1) % s2 === 0 && u2 !== n2 - 1) {
      let o3 = e4[(h2 + n2 + 1) * 4];
      let u3 = (d3 + a2 + l2 + o3) * 0.25;
      y2 = (m2 + 1) * r2 + (v2 + 1);
      p2[y2] = u3;
      t2[c2++] = u3;
      let _3 = (m2 + 1) * r2;
      i2[g2][f2 + 1][_3] = u3;
      let x2 = s2;
      i2[g2 + 1][f2][x2] = u3;
      let b2 = 0;
      i2[g2 + 1][f2 + 1][b2] = u3;
    }
  }
}
function Ht(e4, t2) {
  let i2 = new e4.constructor(e4.length + t2.length);
  i2.set(e4, 0);
  i2.set(t2, e4.length);
  return i2;
}
function Vt(e4 = [], t2 = []) {
  if (ArrayBuffer.isView(e4)) {
    return Ht(e4, t2);
  } else {
    for (let i2 = 0; i2 < t2.length; i2++) {
      e4.push(t2[i2]);
    }
    return e4;
  }
}
function Ut(e4, t2 = Float32Array) {
  if (!ArrayBuffer.isView(e4)) {
    const i2 = new t2(e4.length);
    i2.set(e4, 0);
    return i2;
  } else {
    return e4;
  }
}
function Gt(e4) {
  if (ArrayBuffer.isView(e4)) {
    return Array.from(e4);
  } else {
    return e4;
  }
}
function Wt(e4, t2, i2, s2) {
  if (ArrayBuffer.isView(e4)) {
    if (t2 < 0) {
      i2 = Math.abs(t2);
      t2 += e4.length;
    }
    return jt(e4, t2, i2, s2);
  } else {
    let r2;
    if (t2 < 0) {
      r2 = e4.splice(t2);
    } else {
      r2 = e4.splice(t2, i2);
    }
    if (s2) {
      s2.result = r2;
    }
    return e4;
  }
}
function jt(e4, t2, i2, s2) {
  if (e4.length === 0) {
    return e4;
  }
  const r2 = e4.length - i2;
  const n2 = new e4.constructor(r2);
  n2.set(e4.subarray(0, t2));
  n2.set(e4.subarray(t2 + i2), t2);
  if (s2) {
    s2.result = e4.subarray(t2, t2 + i2);
  }
  return n2;
}
function Yt(e4, t2, i2, s2, r2) {
  const n2 = r2 + 1;
  const o2 = i2 + n2;
  const a2 = s2 + n2;
  let l2 = new Float64Array(n2 * n2 * 3);
  let h2 = 0;
  for (let r3 = i2; r3 < o2; r3++) {
    for (let i3 = s2; i3 < a2; i3++) {
      let s3 = 3 * (r3 * (t2 + 1) + i3);
      l2[h2++] = e4[s3];
      l2[h2++] = e4[s3 + 1];
      l2[h2++] = e4[s3 + 2];
    }
  }
  return l2;
}
function qt(e4, t2, i2, s2, r2) {
  const n2 = r2 + 1;
  const o2 = i2 + n2;
  const a2 = s2 + n2;
  let l2 = new Float32Array(n2 * n2 * 3);
  let h2 = 0;
  for (let r3 = i2; r3 < o2; r3++) {
    for (let i3 = s2; i3 < a2; i3++) {
      let s3 = 3 * (r3 * (t2 + 1) + i3);
      l2[h2++] = e4[s3];
      l2[h2++] = e4[s3 + 1];
      l2[h2++] = e4[s3 + 2];
    }
  }
  return l2;
}
function $t(e4, t2, i2, s2, r2, n2, o2, a2, l2, h2, c2, d2, u2) {
  const _2 = n2 + a2 + 1;
  const f2 = o2 + a2 + 1;
  r2 += 1;
  let g2 = 0, p2 = 0;
  for (let a3 = n2; a3 < _2; a3++) {
    for (let n3 = o2; n3 < f2; n3++) {
      let o3 = a3 * r2 + n3, _3 = 3 * o3;
      let f3 = e4[_3], m2 = e4[_3 + 1], v2 = e4[_3 + 2];
      if (!s2 || s2[o3] === 0) {
        if (f3 < d2.xmin) d2.xmin = f3;
        if (f3 > d2.xmax) d2.xmax = f3;
        if (m2 < d2.ymin) d2.ymin = m2;
        if (m2 > d2.ymax) d2.ymax = m2;
        if (v2 < d2.zmin) d2.zmin = v2;
        if (v2 > d2.zmax) d2.zmax = v2;
      } else {
        u2[p2] = 1;
      }
      p2++;
      l2[g2] = f3;
      c2[g2] = i2[_3];
      h2[g2++] = t2[_3];
      l2[g2] = m2;
      c2[g2] = i2[_3 + 1];
      h2[g2++] = t2[_3 + 1];
      l2[g2] = v2;
      c2[g2] = i2[_3 + 2];
      h2[g2++] = t2[_3 + 2];
    }
  }
}
function Xt(e4) {
  return e4.map((e5) => Array.isArray(e5) ? Xt(e5) : e5);
}
async function Zt(e4) {
  return new Promise((t2) => {
    const i2 = new Image();
    i2.addEventListener("load", () => {
      t2(i2);
    });
    i2.src = e4;
    i2.crossOrigin = "";
    return i2;
  });
}
function Kt(e4) {
  return e4.complete && e4.naturalHeight !== 0;
}
function Qt(e4) {
  if (e4 > 1e3) {
    return `${(e4 / 1e3).toFixed(2)} km`;
  } else if (e4 > 9) {
    return `${Math.round(e4)} m`;
  } else {
    return `${e4.toFixed(1)} m`;
  }
}
function Jt(e4) {
  if (e4 > 1e3) {
    let t2 = e4 - Math.floor(e4);
    if (t2 !== 0) {
      return [(e4 / 1e3).toFixed(2), "km"];
    }
    return [(e4 / 1e3).toFixed(0), "km"];
  } else if (e4 > 9) {
    return [Math.round(e4).toString(), "m"];
  } else {
    if (e4 <= 0.01) {
      return ["0", "m"];
    }
    return [e4.toFixed(1), "m"];
  }
}
function ei(e4) {
  let t2 = new URLSearchParams(location.search);
  let i2 = t2.get(e4);
  if (i2) {
    return Number(i2);
  }
}
function ti(e4, t2, i2, s2 = 256, r2 = tt) {
  let n2 = Ue(e4, t2, i2);
  let o2 = n2.getSouthWest().inverseMercator(), a2 = n2.getNorthEast().inverseMercator();
  let l2 = r2.getGreatCircleDistance(o2, new be(a2.lon, o2.lat)), h2 = r2.getGreatCircleDistance(o2, new be(o2.lon, a2.lat));
  return [l2 / s2, h2 / s2];
}
function ii(e4, t2 = -1) {
  if (t2 < 0) {
    return e4.toString();
  }
  const i2 = Math.pow(10, t2);
  return (Math.round(e4 * i2) / i2).toString();
}
const si = Object.freeze(Object.defineProperty({ __proto__: null, base64StringToBlog: zt, base64toBlob: It, binaryInsert: St, binarySearch: Pt, binarySearchFast: Lt, blerp: Ft, blerp2: Nt, castType: kt, cloneArray: Xt, concatArrays: Vt, concatTypedArrays: Ht, createColorRGB: Tt, createColorRGBA: Ct, createExtent: Et, createLonLat: At, createVector3: bt, createVector4: wt, defaultString: xt, distanceFormat: Qt, distanceFormatExt: Jt, extractElevationTiles: Ot, getDefault: it, getHTML: pt, getLinesIntersection2v: Rt, getLinesIntersectionLonLat: Mt, getMatrixSubArray32: qt, getMatrixSubArray64: Yt, getMatrixSubArrayBoundsExt: $t, getTileImageResolution: ti, getUrlParam: ei, htmlColorToFloat32Array: ut, htmlColorToRgb: _t, htmlColorToRgba: dt, isEmpty: st, isImageLoaded: Kt, isNumber: yt, isString: lt, isUndef: rt, isUndefExt: nt, loadImage: Zt, makeArray: Gt, makeArrayTyped: Ut, parseHTML: mt, print2d: vt, rgbToStringHTML: ct, spliceArray: Wt, spliceTypedArray: jt, stamp: at, stringTemplate: ft, stringTemplate2: gt, throttle: Dt, toFixedMax: ii, xmlToJson: Bt }, Symbol.toStringTag, { value: "Module" }));
const ri = 1e-3;
const ni = 1e3;
const oi = 60;
const ai = 1 / oi;
const li = 60;
const hi = 24;
const ci = 1 / hi;
const di = 3600;
const ui = 1 / di;
const _i = 12 * di;
const fi = 1440;
const gi = 1 / fi;
const pi = 86400;
const mi = 864e5;
const vi = 1 / mi;
const yi = 1 / pi;
const xi = 36525;
const bi = 365.25;
const wi = 1e-9;
const Ci = 24000005e-1;
const Ti = 2451545;
function Ei(e4) {
  return (e4 - Ti) / xi;
}
function Ai(e4, t2, i2) {
  let s2 = (t2 - 14) / 12 | 0;
  let r2 = e4 + 4800 + s2;
  return (1461 * r2 / 4 | 0) + (367 * (t2 - 2 - 12 * s2) / 12 | 0) - (3 * ((r2 + 100) / 100 | 0) / 4 | 0) + i2 - 32075;
}
function Li(e4) {
  let t2 = Ai(e4.getUTCFullYear(), e4.getUTCMonth() + 1, e4.getUTCDate());
  let i2 = e4.getUTCHours() - 12;
  if (i2 < 0) {
    i2 += 24;
  }
  let s2 = e4.getUTCSeconds() + i2 * di + e4.getUTCMinutes() * oi + e4.getUTCMilliseconds() * ri;
  if (s2 >= _i) {
    t2--;
  }
  let r2 = s2 * yi | 0;
  t2 += r2;
  s2 -= pi * r2;
  if (s2 < 0) {
    t2--;
    s2 += pi;
  }
  return t2 + s2 * yi;
}
function Pi(e4) {
  return Si(Li(e4));
}
function Si(e4) {
  let t2 = Yi;
  let i2 = Pt(t2, e4, function(e5, t3) {
    return e5 - t3.jd;
  });
  if (i2 < 0) {
    i2 = ~i2;
  }
  if (i2 >= t2.length) {
    i2 = t2.length - 1;
  }
  let s2 = t2[i2].leapSeconds;
  if (i2 !== 0) {
    if ((t2[i2].jd - e4) * pi > s2) {
      s2 = t2[i2 - 1].leapSeconds;
    }
  }
  return e4 + s2 * yi;
}
function Ri(e4) {
  let t2 = Yi;
  let i2 = Pt(t2, e4, function(e5, t3) {
    return e5 - t3.jd;
  });
  if (i2 < 0) {
    i2 = ~i2;
  }
  if (i2 >= t2.length) {
    return e4 - t2[i2 - 1].leapSeconds * yi;
  }
  if (i2 === 0) {
    return e4 - t2[0].leapSeconds * yi;
  }
  let s2 = (t2[i2].jd - e4) * pi;
  if (s2 === 0) {
    return e4 - t2[i2].leapSeconds * yi;
  }
  if (s2 <= 1) {
    return;
  }
  return e4 - t2[i2 - 1].leapSeconds * yi;
}
function Mi(e4) {
  let t2 = e4 | 0;
  let i2 = (e4 - t2) * pi;
  if (i2 >= _i) {
    t2++;
  }
  let s2 = t2 + 68569 | 0;
  let r2 = 4 * s2 / 146097 | 0;
  s2 = s2 - ((146097 * r2 + 3) / 4 | 0) | 0;
  let n2 = 4e3 * (s2 + 1) / 1461001 | 0;
  s2 = s2 - (1461 * n2 / 4 | 0) + 31 | 0;
  let o2 = 80 * s2 / 2447 | 0;
  let a2 = s2 - (2447 * o2 / 80 | 0) | 0;
  s2 = o2 / 11 | 0;
  let l2 = o2 + 2 - 12 * s2 | 0;
  let h2 = 100 * (r2 - 49) + n2 + s2 | 0;
  let c2 = i2 * ui | 0;
  let d2 = i2 - c2 * di;
  let u2 = d2 * ai | 0;
  d2 = d2 - u2 * oi;
  let _2 = d2 | 0;
  let f2 = (d2 - _2) * ni | 0;
  c2 += 12;
  if (c2 > 23) {
    c2 -= 24;
  }
  return new Date(Date.UTC(h2, l2 - 1, a2, c2, u2, _2, f2));
}
function Bi(e4) {
  let t2 = Ri(e4);
  if (!t2) {
    t2 = Ri(Ii(e4, -1));
    console.trace(`TAItoDate - can't convert ${e4.toString()} to utc.`);
  }
  return Mi(t2);
}
function ki(e4, t2) {
  return e4 + t2 * vi;
}
function Ii(e4, t2) {
  return e4 + t2 * yi;
}
function zi(e4, t2) {
  return e4 + t2 * ci;
}
function Di(e4, t2) {
  return e4 + t2 * fi;
}
function Fi(e4, t2) {
  return e4 + t2;
}
function Ni(e4) {
  let t2 = e4 - (e4 | 0);
  t2 *= pi;
  return (t2 - (t2 | 0)) * ni | 0;
}
function Oi(e4) {
  let t2 = e4 - (e4 | 0);
  return t2 * pi;
}
function Hi(e4) {
  let t2 = e4 | 0;
  let i2 = (e4 - t2) * pi;
  let s2 = i2 * ui | 0;
  let r2 = i2 - s2 * di;
  let n2 = r2 * ai | 0;
  r2 = r2 - n2 * oi;
  let o2 = r2 | 0;
  let a2 = (r2 - o2) * ni | 0;
  s2 += 12 + n2 / 60 + o2 / 3600 + a2 / 1e3;
  if (s2 > 23) {
    s2 -= 24;
  }
  return s2;
}
function Vi(e4) {
  let t2 = e4 - (e4 | 0);
  return t2 * fi | 0;
}
function Ui(e4) {
  return e4 | 0;
}
function Gi(e4) {
  return e4 * yi;
}
function Wi(e4) {
  return e4 * pi;
}
function ji(e4, t2) {
  return { jd: e4, leapSeconds: t2 };
}
const Yi = [ji(24413175e-1, 10), ji(24414995e-1, 11), ji(24416835e-1, 12), ji(24420485e-1, 13), ji(24424135e-1, 14), ji(24427785e-1, 15), ji(24431445e-1, 16), ji(24435095e-1, 17), ji(24438745e-1, 18), ji(24442395e-1, 19), ji(24447865e-1, 20), ji(24451515e-1, 21), ji(24455165e-1, 22), ji(24462475e-1, 23), ji(24471615e-1, 24), ji(24478925e-1, 25), ji(24482575e-1, 26), ji(24488045e-1, 27), ji(24491695e-1, 28), ji(24495345e-1, 29), ji(24500835e-1, 30), ji(24506305e-1, 31), ji(24511795e-1, 32), ji(24537365e-1, 33), ji(24548325e-1, 34), ji(24561095e-1, 35), ji(24572045e-1, 36)];
const qi = Si(Ti);
const $i = Object.freeze(Object.defineProperty({ __proto__: null, DAYS_PER_JULIAN_CENTURY: xi, DAYS_PER_JULIAN_YEAR: bi, DateToTAI: Pi, DateToUTC: Li, HOURS_PER_DAY: hi, J2000: Ti, J2000TAI: qi, MILLISECONDS_PER_DAY: mi, MILLISECONDS_PER_SECOND: ni, MINUTES_PER_DAY: fi, MINUTES_PER_HOUR: li, MODIFIED_JULIAN_DATE_DIFFERENCE: Ci, ONE_BY_HOURS_PER_DAY: ci, ONE_BY_MILLISECONDS_PER_DAY: vi, ONE_BY_MINUTES_PER_DAY: gi, ONE_BY_SECONDS_PER_DAY: yi, ONE_BY_SECONDS_PER_HOUR: ui, ONE_BY_SECONDS_PER_MINUTE: ai, PICOSECOND: wi, SECONDS_PER_12_HOURS: _i, SECONDS_PER_DAY: pi, SECONDS_PER_HOUR: di, SECONDS_PER_MILLISECOND: ri, SECONDS_PER_MINUTE: oi, T: Ei, TAItoDate: Bi, TAItoUTC: Ri, UTCtoDate: Mi, UTCtoTAI: Si, addDays: Fi, addHours: zi, addMilliseconds: ki, addMinutes: Di, addSeconds: Ii, daysToSeconds: Wi, getDayNumber: Ai, getDays: Ui, getHours: Hi, getMilliseconds: Ni, getMinutes: Vi, getSeconds: Oi, secondsToDays: Gi }, Symbol.toStringTag, { value: "Module" }));
class Xi {
  constructor(e4) {
    this.vertices = [new Ke(), new Ke(), new Ke(), new Ke(), new Ke(), new Ke(), new Ke(), new Ke()];
    if (e4) {
      this.setFromBoundsArr(e4);
    }
  }
  copy(e4) {
    for (let t2 = 0, i2 = this.vertices.length; t2 < i2; t2++) {
      this.vertices[t2].copy(e4.vertices[t2]);
    }
  }
  setFromBoundsArr(e4) {
    let t2 = e4[0], i2 = e4[3], s2 = e4[1], r2 = e4[4], n2 = e4[2], o2 = e4[5];
    let a2 = this.vertices;
    a2[0].set(t2, s2, n2);
    a2[1].set(i2, s2, n2);
    a2[2].set(i2, s2, o2);
    a2[3].set(t2, s2, o2);
    a2[4].set(t2, r2, n2);
    a2[5].set(i2, r2, n2);
    a2[6].set(i2, r2, o2);
    a2[7].set(t2, r2, o2);
  }
  setFromExtent(e4, t2) {
    this.setFromBoundsArr(t2.getCartesianBounds(e4));
  }
}
class Zi {
  constructor(e4 = 0, t2) {
    this.radius = e4;
    this.center = t2 ? t2.clone() : new Ke();
  }
  setFromBounds(e4) {
    let t2 = new Ke(e4[0], e4[1], e4[2]);
    this.center.set(t2.x + (e4[3] - t2.x) * 0.5, t2.y + (e4[3] - t2.y) * 0.5, t2.z + (e4[5] - t2.z) * 0.5);
    this.radius = this.center.distance(t2);
  }
  setFromExtent(e4, t2) {
    this.setFromBounds(t2.getCartesianBounds(e4));
  }
}
const Ki = Object.freeze(Object.defineProperty({ __proto__: null, Box: Xi, Sphere: Zi }, Symbol.toStringTag, { value: "Module" }));
function Qi(e4, t2) {
  return new Ji(e4, t2);
}
const _Ji = class _Ji {
  constructor(e4, t2) {
    this.__id = _Ji.__counter__++;
    this._eventNames = [];
    e4 && this.registerNames(e4);
    this._sender = t2 || this;
    this._stopPropagation = false;
    this._stampCache = {};
  }
  bindSender(e4) {
    this._sender = e4 || this;
  }
  registerNames(e4) {
    for (let t2 = 0; t2 < e4.length; t2++) {
      this[e4[t2]] = { active: true, handlers: [] };
      this._eventNames.push(e4[t2]);
    }
    return this;
  }
  _getStamp(e4, t2, i2) {
    return `${e4}_${t2}_${i2}`;
  }
  _stamp(e4, t2) {
    let i2 = at(t2);
    let s2 = this._getStamp(e4, this.__id, i2);
    if (!this._stampCache[s2]) {
      this._stampCache[s2] = i2;
      return true;
    }
    return false;
  }
  on(e4, t2, i2, s2 = 0) {
    if (this._stamp(e4, t2)) {
      if (this[e4]) {
        let r2 = t2.bind(i2 || this._sender);
        r2._openglobus_id = t2._openglobus_id;
        r2._openglobus_priority = s2;
        St(this[e4].handlers, r2, (e5, t3) => (t3._openglobus_priority || 0) - (e5._openglobus_priority || 0));
      }
    }
  }
  off(e4, t2) {
    if (t2) {
      let i2 = this._getStamp(e4, this.__id, t2._openglobus_id);
      if (t2._openglobus_id && this._stampCache[i2]) {
        let s2 = this[e4].handlers;
        let r2 = s2.length;
        let n2 = -1;
        while (r2--) {
          let e5 = s2[r2];
          if (e5._openglobus_id === t2._openglobus_id) {
            n2 = r2;
            break;
          }
        }
        if (n2 !== -1) {
          s2.splice(n2, 1);
          this._stampCache[i2] = void 0;
          delete this._stampCache[i2];
        }
      }
    }
  }
  dispatch(e4, ...t2) {
    let i2 = true;
    if (e4 && e4.active && !this._stopPropagation) {
      let s2 = e4.handlers.slice(0), r2 = s2.length;
      while (r2--) {
        if (s2[r2](...t2) === false) {
          i2 = false;
        }
      }
    }
    this._stopPropagation = false;
    return i2;
  }
  stopPropagation() {
    this._stopPropagation = true;
  }
  clear() {
    for (let e4 = 0; e4 < this._eventNames.length; e4++) {
      let t2 = this[this._eventNames[e4]];
      t2.handlers.length = 0;
      t2.handlers = [];
    }
    this._eventNames.length = 0;
    this._eventNames = [];
  }
};
_Ji.__counter__ = 0;
let Ji = _Ji;
const es = ["render"];
const _ts = class _ts {
  constructor(e4 = {}) {
    this.__id = _ts.__counter__++;
    this.events = Qi(es);
    this.model = e4.model || null;
    this.template = e4.template || "";
    this.parent = e4.parent || null;
    this._classList = e4.classList || [];
    this.el = null;
    if (e4.initRender) {
      this.render();
    }
  }
  on(e4, t2, i2, s2) {
    this.events.on(e4, t2, i2, s2);
  }
  off(e4, t2) {
    this.events.off(e4, t2);
  }
  static getHTML(e4, t2) {
    return ft(e4, t2);
  }
  static parseHTML(e4) {
    return mt(e4);
  }
  static insertAfter(e4, t2) {
    if (!Array.isArray(e4)) {
      e4 = [e4];
    }
    for (let i2 = 0; i2 < e4.length; i2++) {
      if (t2.parentNode) {
        t2.parentNode.insertBefore(e4[i2], t2.nextSibling);
      }
    }
    return e4;
  }
  static insertBefore(e4, t2) {
    if (!Array.isArray(e4)) {
      e4 = [e4];
    }
    for (let i2 = 0; i2 < e4.length; i2++) {
      if (t2.parentNode) {
        t2.parentNode.insertBefore(e4[i2], t2);
      }
    }
    return e4;
  }
  insertBefore(e4) {
    if (!this.el) {
      this.render();
    }
    if (this.el) {
      if (e4 instanceof HTMLElement && e4.parentNode) {
        _ts.insertBefore(this.el, e4);
      }
      if (e4 instanceof _ts && e4.el && e4.el.parentNode) {
        _ts.insertBefore(this.el, e4.el);
      }
    }
  }
  insertAfter(e4) {
    if (!this.el) {
      this.render();
    }
    if (this.el) {
      if (e4 instanceof HTMLElement && e4.parentNode) {
        _ts.insertAfter(this.el, e4);
      }
      if (e4 instanceof _ts && e4.el && e4.el.parentNode) {
        _ts.insertAfter(this.el, e4.el);
      }
    }
  }
  isEqual(e4) {
    return e4.__id === this.__id;
  }
  appendTo(e4, t2 = false, i2 = false) {
    if (e4) {
      if (!this.el) {
        this.beforeRender(e4);
        this.render();
      }
      if (this.el && this.el.parentNode) {
        this.el.parentNode.removeChild(this.el);
      }
      if (t2) {
        e4.innerHTML = "";
      }
      if (this.el) {
        if (i2) {
          if (e4.childNodes[0]) {
            _ts.insertBefore(this.el, e4.childNodes[0]);
          } else {
            e4.appendChild(this.el);
          }
        } else {
          e4.appendChild(this.el);
        }
      }
      this.afterRender(e4);
    }
    return this;
  }
  afterRender(e4) {
  }
  beforeRender(e4) {
  }
  stopPropagation() {
    this.events.stopPropagation();
  }
  renderTemplate(e4) {
    return _ts.parseHTML(_ts.getHTML(this.template, e4 || {}))[0];
  }
  render(e4) {
    this.el = this.renderTemplate(e4);
    for (let e5 = 0, t2 = this._classList.length; e5 < t2; e5++) {
      this.el.classList.add(this._classList[e5]);
    }
    this.events.dispatch(this.events.render, this);
    return this;
  }
  select(e4) {
    if (this.el) {
      return this.el.querySelector(e4);
    }
    return null;
  }
  selectRemove(e4) {
    if (this.el) {
      let t2 = this.select(e4);
      if (t2 && t2.parentNode) {
        t2.parentNode.removeChild(t2);
        return t2;
      }
    }
  }
  selectAll(e4, t2) {
    if (this.el) {
      const i2 = this.el.querySelectorAll(e4);
      if (t2) {
        for (let e5 = 0, s2 = i2.length; e5 < s2; e5++) {
          t2(i2[e5], e5);
        }
      }
      return i2;
    }
  }
  remove() {
    if (this.el && this.el.parentNode) {
      this.el.parentNode.removeChild(this.el);
    }
  }
};
_ts.__counter__ = 0;
let ts = _ts;
const is = `<div class="og-button" title="{title}">
       <div class="og-button-icon">{icon}</div>
       <div class="og-button-text">{text}</div>
    </div>`;
const ss = ["click", "mousedown", "mouseup", "touchstart", "touchend", "touchcancel"];
class rs extends ts {
  constructor(e4 = {}) {
    super({ template: ft(is, { icon: e4.icon || "", text: e4.text || "", title: e4.title || "" }), ...e4 });
    this._onMouseDown = (e5) => {
      e5.preventDefault();
      this.events.dispatch(this.events.mousedown, this, e5);
    };
    this._onMouseUp = (e5) => {
      e5.preventDefault();
      this.events.dispatch(this.events.mouseup, this, e5);
    };
    this._onTouchStart = (e5) => {
      e5.preventDefault();
      this.events.dispatch(this.events.touchstart, this, e5);
    };
    this._onTouchEnd = (e5) => {
      e5.preventDefault();
      this.events.dispatch(this.events.touchend, this, e5);
    };
    this._onTouchCancel = (e5) => {
      e5.preventDefault();
      this.events.dispatch(this.events.touchcancel, this, e5);
    };
    this._onMouseClick = (e5) => {
      this._mouseClickHandler(e5);
    };
    this.events = this.events.registerNames(ss);
    this.el = null;
    this.name = e4.name || "";
    this.$icon = null;
    this.$text = null;
  }
  render(e4) {
    super.render(e4);
    this.$icon = this.select(".og-button-icon");
    this.$text = this.select(".og-button-text");
    this.el.__og_button__ = this;
    this._initEvents();
    return this;
  }
  _initEvents() {
    if (this.el) {
      this.el.addEventListener("click", this._onMouseClick);
      this.el.addEventListener("mousedown", this._onMouseDown);
      this.el.addEventListener("mouseup", this._onMouseUp);
      this.el.addEventListener("touchstart", this._onTouchStart);
      this.el.addEventListener("touchend", this._onTouchEnd);
      this.el.addEventListener("touchcancel", this._onTouchCancel);
    }
  }
  _mouseClickHandler(e4) {
    e4.preventDefault();
    this.events.dispatch(this.events.click, this, e4);
  }
  remove() {
    this._clearEvents();
    super.remove();
  }
  _clearEvents() {
    this.el && this.el.removeEventListener("click", this._onMouseClick);
  }
}
const _ns = class _ns {
  constructor(e4 = {}) {
    this.__id = _ns.__counter__++;
    this._name = e4.name || `_control_${this.__id.toString()}`;
    this.planet = null;
    this._initialized = false;
    this.renderer = null;
    this.autoActivate = e4.autoActivate || false;
    this._active = false;
    this._deferredActive = true;
  }
  get name() {
    return this._name;
  }
  oninit() {
  }
  onadd() {
  }
  onremove() {
  }
  onactivate() {
  }
  ondeactivate() {
  }
  addTo(e4) {
    if (e4) {
      this.renderer = e4;
      e4.controls[this.name] = this;
      this.onadd && this.onadd();
      if (e4.isInitialized() && !this._initialized) {
        this._initialized = true;
        this.oninit && this.oninit();
        if (this.autoActivate) {
          this.activate();
        }
      }
    }
  }
  remove() {
    this.deactivate();
    this.onremove && this.onremove();
    let e4 = this.renderer, t2 = this.name;
    if (!e4) return;
    let i2 = e4.controls[t2];
    if (i2) {
      if (this.isEqual(i2)) {
        delete e4.controls[t2];
      }
    }
    this.renderer = null;
    this._active = false;
    this._initialized = false;
  }
  activate() {
    if (!this._active) {
      if (!this._initialized) {
        this._initialized = true;
        this.oninit && this.oninit();
      }
      if (this._deferredActive) {
        this._active = true;
        this.onactivate && this.onactivate();
      } else {
        this._deferredActive = true;
      }
    }
  }
  deactivate() {
    if (this._active) {
      this._active = false;
      this.ondeactivate && this.ondeactivate();
    } else if (!this._initialized) {
      this._deferredActive = false;
    }
  }
  isActive() {
    return this._active;
  }
  isEqual(e4) {
    return e4.__id === this.__id;
  }
};
_ns.__counter__ = 0;
let ns = _ns;
const os = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   viewBox="0 0 110.6 110.3"
   version="1.1"
   id="svg21"
   sodipodi:docname="aaa.svg"
   inkscape:version="0.92.3 (2405546, 2018-03-11)">
  <metadata
     id="metadata11">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <defs
     id="defs25" />
  <sodipodi:namedview
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1"
     objecttolerance="10"
     gridtolerance="10"
     guidetolerance="10"
     inkscape:pageopacity="0"
     inkscape:pageshadow="2"
     inkscape:window-width="1920"
     inkscape:window-height="1001"
     id="namedview23"
     showgrid="false"
     inkscape:zoom="9.4900968"
     inkscape:cx="28.376998"
     inkscape:cy="60.17054"
     inkscape:window-x="-9"
     inkscape:window-y="-9"
     inkscape:window-maximized="1"
     inkscape:current-layer="svg21" />
  <g
     id="Layer_2"
     data-name="Layer 2"
     transform="matrix(1,0,0,-1,0,110.3)">
    <g
       id="Слой_1"
       data-name="Слой 1">
      <g
         id="_Group_"
         data-name="&lt;Group&gt;">
        <g
           id="_Group_7"
           data-name="&lt;Group&gt;">
          <polygon
             id="_Path_7"
             data-name="&lt;Path&gt;"
             points="55.2,97.6 55.3,97.4 55.3,97.6 55.3,97.2 65.3,55.1 55.3,55.1 55.2,55.1 45.3,55.1 55.2,97.2 "
             style="fill:#ff2b45" />
          <polygon
             id="_Path_8"
             data-name="&lt;Path&gt;"
             points="55.3,12.7 55.3,12.9 55.2,12.7 55.2,13.1 45.3,55.1 55.2,55.1 55.3,55.1 65.3,55.1 55.3,13.1 "
             style="fill:#cecece;" />
        </g>
      </g>
    </g>
  </g>
</svg>`;
class as extends ns {
  constructor(e4 = {}) {
    super(e4);
    this._heading = 0;
    this._svg = null;
  }
  oninit() {
    let e4 = new rs({ classList: ["og-map-button", "og-compass-button"], icon: os });
    e4.appendTo(this.renderer.div);
    e4.events.on("click", this._onClick, this);
    this._svg = e4.select("svg");
    this.renderer.events.on("draw", this._draw, this);
  }
  _onClick() {
    const e4 = this.planet;
    let t2 = e4.getCartesianFromPixelTerrain(this.renderer.handler.getCenter());
    if (t2) {
      e4.flyCartesian(t2.normal().scaleTo(t2.length() + t2.distance(e4.camera.eye)), null, null, 0, null, null, () => {
        e4.camera.look(t2);
      });
    } else {
      e4.flyCartesian(e4.camera.eye);
    }
  }
  _draw() {
    this.setHeading(this.planet.camera.getHeading());
  }
  setHeading(e4) {
    if (this._heading !== e4) {
      this._heading = e4;
      this._svg.style.transform = `rotateZ(${-e4}deg)`;
    }
  }
}
const ls = `<svg className="svg-icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor; overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <path d="M777.856 280.192l-33.92-33.952-231.872 231.872-231.84-231.872-33.984 33.888 231.872 231.904-231.84 231.84 33.888 33.984 231.904-231.904 231.84 231.872 33.952-33.888-231.872-231.904z"/>
</svg>`;
const hs = ["resize", "focus", "visibility", "dragstart", "dragend"];
const cs = `<div class="og-ddialog" 
        style="display:{display}; resize:{resize}; width: {width}px; {height}; top: {top}px; left: {left}px; min-height: {minHeight}; max-height: {maxHeight}; min-width: {minWidth}; max-width: {maxWidth};">
       <div class="og-ddialog-header">
         <div class="og-ddialog-header__title">{title}</div>      
         <div class="og-ddialog-header__buttons"></div>      
        </div>
       <div class="og-ddialog-container"></div>
    </div>>`;
const _ds = class _ds extends ts {
  constructor(e4 = {}) {
    super({ template: ft(cs, { title: e4.title || "", display: it(e4.visible, true) ? "flex" : "none", resize: it(e4.resizable, true) ? "both" : "none", width: e4.width || 300, height: e4.height ? `height: ${e4.height || 200}px` : "", left: e4.left || 0, top: e4.top || 0, minHeight: e4.minHeight ? `${e4.minHeight}px` : "unset", maxHeight: e4.maxHeight ? `${e4.maxHeight}px` : "unset", minWidth: e4.minWidth ? `${e4.minWidth}px` : "unset", maxWidth: e4.maxWidth ? `${e4.maxWidth}px` : "unset" }), ...e4 });
    this._onCloseBtnClick = () => {
      this.close();
    };
    this._onMouseDownAll = () => {
      this.bringToFront();
    };
    this._onMouseDown = (e5) => {
      e5.preventDefault();
      this._startDragging();
      this._startPosX = e5.clientX;
      this._startPosY = e5.clientY;
      document.addEventListener("mousemove", this._onMouseMove);
      document.addEventListener("mouseup", this._onMouseUp);
    };
    this._onMouseMove = (e5) => {
      e5.preventDefault();
      let t2 = this._startPosX - e5.clientX;
      let i2 = this._startPosY - e5.clientY;
      this._startPosX = e5.clientX;
      this._startPosY = e5.clientY;
      this.setPosition(this.el.offsetLeft - t2, this.el.offsetTop - i2);
    };
    this._onMouseUp = () => {
      this._clearDragging();
      document.removeEventListener("mouseup", this._onMouseUp);
      document.removeEventListener("mousemove", this._onMouseMove);
    };
    this.events = this.events.registerNames(hs);
    this._startPosX = 0;
    this._startPosY = 0;
    this.$header = null;
    this.$title = null;
    this.$container = null;
    this.$buttons = null;
    this._closeBtn = new rs({ icon: ls, classList: ["og-button-size__20"] });
    this.useHide = e4.useHide || false;
    this._visibility = it(e4.visible, true);
    this._right = e4.right != void 0 ? e4.right : null;
  }
  setContainer(e4) {
    this.$container.innerHTML = e4;
  }
  get container() {
    return this.$container;
  }
  get width() {
    return this.el ? parseFloat(this.el.style.width) : 0;
  }
  get height() {
    return this.el ? parseFloat(this.el.style.height) : 0;
  }
  bringToFront() {
    this.el.style.zIndex = String(_ds.__zIndex__++);
  }
  render(e4) {
    super.render(e4);
    this.bringToFront();
    this.$header = this.select(".og-ddialog-header");
    this.$title = this.select(".og-ddialog-header__title");
    this.$container = this.select(".og-ddialog-container");
    this.$buttons = this.select(".og-ddialog-header__buttons");
    this._initEvents();
    this._initButtons();
    if (this._right != null) {
      this.el.style.visibility = "hidden";
      const e5 = new IntersectionObserver((e6, t2) => {
        e6.forEach((e7) => {
          if (e7.isIntersecting) {
            this.el.style.visibility = "visible";
            if (this.el.parentNode) {
              this.setPosition(this.el.parentNode.clientWidth - this.el.clientWidth - this._right);
              t2.disconnect();
            }
          }
        });
      });
      e5.observe(this.el);
    }
    return this;
  }
  show() {
    if (!this._visibility) {
      this._visibility = true;
      this.el.style.display = "flex";
      this.bringToFront();
      this.events.dispatch(this.events.visibility, true, this);
    }
  }
  hide() {
    if (this._visibility) {
      this._visibility = false;
      this.el.style.display = "none";
      this.events.dispatch(this.events.visibility, false, this);
    }
  }
  close() {
    if (this.useHide) {
      this.hide();
    } else {
      this.remove();
    }
  }
  setVisibility(e4) {
    if (e4) {
      this.show();
    } else {
      this.hide();
    }
  }
  getVisibility() {
    return this._visibility;
  }
  _initButtons() {
    this._closeBtn.events.on("click", this._onCloseBtnClick);
    this._closeBtn.appendTo(this.$buttons);
  }
  _initEvents() {
    this.$header.addEventListener("mousedown", this._onMouseDown);
    this.el.addEventListener("mousedown", this._onMouseDownAll);
  }
  setPosition(e4, t2) {
    if (e4 != void 0) {
      this.el.style.left = `${e4}px`;
    }
    if (t2 != void 0) {
      this.el.style.top = `${t2}px`;
    }
  }
  _startDragging() {
    if (!this.el.classList.contains("dragging")) {
      this.el.classList.add("dragging");
      this.events.dispatch(this.events.dragstart, this);
    }
  }
  _clearDragging() {
    if (this.el.classList.contains("dragging")) {
      this.events.dispatch(this.events.dragend, this);
      this.el.classList.remove("dragging");
    }
  }
  remove() {
    this._clearDragging();
    this._clearEvents();
    super.remove();
  }
  _clearEvents() {
    this._closeBtn.events.off("click", this._onCloseBtnClick);
    document.removeEventListener("mouseup", this._onMouseUp);
    document.removeEventListener("mousemove", this._onMouseMove);
    this.$header.removeEventListener("mousedown", this._onMouseDown);
    this.el.removeEventListener("mousedown", this._onMouseDownAll);
  }
};
_ds.__zIndex__ = 0;
let ds = _ds;
const us = ["change"];
class _s extends rs {
  constructor(e4) {
    super({ ...e4 });
    this._onMouseClick = (e5) => {
      if (!this.preventClick) {
        this._mouseClickHandler(e5);
        this.setActive(!this.isActive);
      }
    };
    this.events = this.events.registerNames(us);
    this._isActive = e4.isActive || false;
    this.preventClick = e4.preventClick || false;
  }
  setActive(e4, t2 = false) {
    if (e4 !== this._isActive) {
      this._isActive = e4;
      this._toggle();
      if (!t2) {
        this.events.dispatch(this.events.change, e4, this);
      }
    }
  }
  _toggle() {
    this.el && this.el.classList.toggle("og-button__active");
  }
  get isActive() {
    return this._isActive;
  }
  render(e4) {
    super.render(e4);
    if (this._isActive) {
      this._toggle();
    }
    return this;
  }
}
const fs = 3570;
const gs = 1e3;
const ps = 0;
const ms = 1;
const vs = 2;
const ys = 3;
const xs = 0;
const bs = 1;
const ws = 2;
const Cs = 3;
const Ts = 0;
const Es = 1;
const As = 2;
const Ls = [ws, Cs, xs, bs];
const Ps = [[-1, -1, ps, ms], [ms, -1, ys, -1], [vs, ys, -1, -1], [-1, ps, -1, vs]];
const Ss = [[vs, ys, ps, ms], [ms, ps, ys, vs], [vs, ys, ps, ms], [ms, ps, ys, vs]];
const Rs = [[0, 1, 0, 0], [1, 0, 0, 0], [0, 1, 0, 1], [1, 1, 1, 1]];
class Ms {
  constructor(e4, t2) {
    this.segment = e4;
    this.layer = t2;
    this.isReady = false;
    this.isLoading = false;
    this.texture = null;
    this.pickingMask = null;
    this.textureExists = false;
    this.appliedNodeId = 0;
    this.appliedNode = null;
    this.texOffset = [0, 0, 1, 1];
    this.loadingAttempts = 0;
    this._updateTexture = null;
    this._updatePickingMask = null;
    this.pickingReady = false;
  }
  abortLoading() {
    this.layer.abortMaterialLoading(this);
  }
  _createTexture(e4) {
    return this.layer._planet && this.layer.createTexture(e4, this.layer._internalFormat, this.isReady ? this.texture : null);
  }
  applyImage(e4) {
    if (this.segment.initialized) {
      this._updateTexture = null;
      this.texture = this._createTexture(e4);
      this.isReady = true;
      this.pickingReady = true;
      this.textureExists = true;
      this.isLoading = false;
      this.appliedNodeId = this.segment.node.nodeId;
      this.texOffset = [0, 0, 1, 1];
    }
  }
  applyTexture(e4, t2) {
    if (this.segment.initialized) {
      this.texture = e4;
      this._updateTexture = null;
      this.pickingMask = t2 || null;
      this._updatePickingMask = null;
      this.isReady = true;
      this.pickingReady = true;
      this.textureExists = true;
      this.isLoading = false;
      this.appliedNodeId = this.segment.node.nodeId;
      this.texOffset = [0, 0, 1, 1];
    }
  }
  textureNotExists() {
    if (this.segment.initialized) {
      this.pickingReady = true;
      this.isLoading = false;
      this.isReady = true;
      this.textureExists = false;
    }
  }
  clear() {
    this.loadingAttempts = 0;
    this.layer.clearMaterial(this);
  }
}
const Bs = 30;
const _ks = class _ks {
  constructor(e4, t2 = {}) {
    this.isVector = false;
    this.__id = _ks.__counter__++;
    this._iconSrc = t2.iconSrc || null;
    this.events = Qi(Is, this);
    this.name = e4 || "noname";
    this.properties = t2.properties || {};
    this.hideInLayerSwitcher = t2.hideInLayerSwitcher || false;
    this._hasImageryTiles = true;
    this._opacity = t2.opacity != void 0 ? t2.opacity : 1;
    this.minZoom = t2.minZoom || 0;
    this.maxZoom = t2.maxZoom != void 0 ? t2.maxZoom : 50;
    this._planet = null;
    this.isVector = false;
    this._attribution = t2.attribution || "";
    this._zIndex = t2.zIndex || 0;
    this._isBaseLayer = t2.isBaseLayer || false;
    this._defaultTextures = t2.defaultTextures || [null, null];
    this._visibility = t2.visibility !== void 0 ? t2.visibility : true;
    this._fading = t2.fading || false;
    this._fadingFactor = this._opacity / Bs;
    if (this._fading) {
      this._fadingOpacity = 0;
    } else {
      this._fadingOpacity = this._opacity;
    }
    this._height = t2.height || 0;
    this._extent = new Ye();
    this.createTexture = null;
    this._textureFilter = t2.textureFilter ? t2.textureFilter.trim().toUpperCase() : "MIPMAP";
    this._isSRGB = t2.isSRGB != void 0 ? t2.isSRGB : false;
    this._internalFormat = null;
    this._extentMerc = new Ye();
    this.setExtent(Et(t2.extent, new Ye(new be(-180, -90), new be(180, 90))));
    this._pickingColor = new Ke();
    this._pickingEnabled = t2.pickingEnabled !== void 0 ? t2.pickingEnabled : true;
    this._isPreloadDone = false;
    this._preLoadZoomLevels = t2.preLoadZoomLevels || [0, 1];
    this._ambient = null;
    this._diffuse = null;
    this._specular = null;
    if (t2.ambient) {
      let e5 = Tt(t2.ambient, new Ke(0.2, 0.2, 0.2));
      this._ambient = new Float32Array([e5.x, e5.y, e5.z]);
    }
    if (t2.diffuse) {
      let e5 = Tt(t2.diffuse, new Ke(0.8, 0.8, 0.8));
      this._diffuse = new Float32Array([e5.x, e5.y, e5.z]);
    }
    if (t2.specular) {
      let e5 = Tt(t2.specular, new Ke(3e-4, 3e-4, 3e-4));
      let i2 = t2.shininess || 20;
      this._specular = new Float32Array([e5.x, e5.y, e5.z, i2]);
    }
    this.nightTextureCoefficient = t2.nightTextureCoefficient || 1;
  }
  get iconSrc() {
    return this._iconSrc;
  }
  set iconSrc(e4) {
    this._iconSrc = e4;
  }
  set diffuse(e4) {
    if (e4) {
      let t2 = Tt(e4);
      this._diffuse = new Float32Array(t2.toArray());
    } else {
      this._diffuse = null;
    }
  }
  set ambient(e4) {
    if (e4) {
      let t2 = Tt(e4);
      this._ambient = new Float32Array(t2.toArray());
    } else {
      this._ambient = null;
    }
  }
  set specular(e4) {
    if (e4) {
      let t2 = Tt(e4);
      this._specular = new Float32Array([t2.x, t2.y, t2.y, this._specular ? this._specular[3] : 0]);
    } else {
      this._specular = null;
    }
  }
  set shininess(e4) {
    if (this._specular) {
      this._specular[3] = e4;
    }
  }
  static getTMS(e4, t2, i2) {
    return { x: e4, y: (1 << i2) - t2 - 1, z: i2 };
  }
  static getTileIndex(e4, t2, i2, s2) {
    return `${s2}::${e4}_${t2}_${i2}`;
  }
  get instanceName() {
    return "Layer";
  }
  get rendererEvents() {
    return this.events;
  }
  set opacity(e4) {
    if (e4 !== this._opacity) {
      if (this._fading) {
        if (e4 > this._opacity) {
          this._fadingFactor = (e4 - this._opacity) / Bs;
        } else if (e4 < this._opacity) {
          this._fadingFactor = (this._opacity - e4) / Bs;
        }
      } else {
        this._fadingOpacity = e4;
      }
      this._opacity = e4;
    }
  }
  set pickingEnabled(e4) {
    this._pickingEnabled = e4;
  }
  get pickingEnabled() {
    return this._pickingEnabled;
  }
  hasImageryTiles() {
    return this._hasImageryTiles;
  }
  getID() {
    return this.__id;
  }
  get id() {
    return this.__id;
  }
  get _id() {
    return this.__id;
  }
  isEqual(e4) {
    return e4.__id === this.__id;
  }
  _assignPlanet(e4) {
    this._planet = e4;
    e4._layers.push(this);
    if (e4.renderer && e4.renderer.isInitialized()) {
      if (this._isSRGB) {
        this._internalFormat = e4.renderer.handler.gl.SRGB8_ALPHA8;
      } else {
        this._internalFormat = e4.renderer.handler.gl.RGBA8;
      }
      this.createTexture = e4.renderer.handler.createTexture[this._textureFilter];
      this.events.on("visibilitychange", e4._onLayerVisibilityChanged, e4);
      if (this._isBaseLayer && this._visibility) {
        e4.setBaseLayer(this);
      }
      e4.events.dispatch(e4.events.layeradd, this);
      this.events.dispatch(this.events.add, e4);
      e4.updateVisibleLayers();
      this._bindPicking();
      if (this._visibility && this.hasImageryTiles()) {
        this._preLoad();
      }
    }
  }
  get isIdle() {
    return this._planet && this._planet._terrainCompletedActivated || false;
  }
  _bindPicking() {
    this._planet && this._planet.renderer && this._planet.renderer.assignPickingColor(this);
  }
  addTo(e4) {
    if (!this._planet) {
      this._assignPlanet(e4);
    }
  }
  remove() {
    let e4 = this._planet;
    if (e4) {
      for (let t2 = 0; t2 < e4._layers.length; t2++) {
        if (this.isEqual(e4._layers[t2])) {
          e4.renderer && e4.renderer.clearPickingColor(this);
          e4._layers.splice(t2, 1);
          e4.updateVisibleLayers();
          this.clear();
          e4.events.dispatch(e4.events.layerremove, this);
          this.events.dispatch(this.events.remove, e4);
          this._planet = null;
          this._internalFormat = null;
          this.createTexture = null;
          return this;
        }
      }
    }
    return this;
  }
  clear() {
    if (this._planet) {
      this._planet._clearLayerMaterial(this);
    }
  }
  get planet() {
    return this._planet;
  }
  setAttribution(e4) {
    if (this._attribution !== e4) {
      this._attribution = e4;
      this._planet && this._planet.updateAttributionsList();
    }
  }
  getAttribution() {
    return this._attribution;
  }
  setHeight(e4) {
    this._height = e4;
    this._planet && this._planet.updateVisibleLayers();
  }
  getHeight() {
    return this._height;
  }
  setZIndex(e4) {
    this._zIndex = e4;
    this._planet && this._planet.updateVisibleLayers();
  }
  getZIndex() {
    return this._zIndex;
  }
  bringToFront() {
    if (this._planet) {
      let e4 = this._planet.visibleTileLayers;
      let t2 = e4[e4.length - 1];
      if (!t2.isEqual(this)) {
        this.setZIndex(t2.getZIndex() + 1);
      }
    }
  }
  isBaseLayer() {
    return this._isBaseLayer;
  }
  setBaseLayer(e4) {
    this._isBaseLayer = e4;
    if (this._planet) {
      if (!e4 && this._planet.baseLayer && this.isEqual(this._planet.baseLayer)) {
        this._planet.baseLayer = null;
      }
      this._planet.updateVisibleLayers();
    }
  }
  setVisibility(e4) {
    if (e4 !== this._visibility) {
      this._visibility = e4;
      if (this._planet) {
        if (this._isBaseLayer && e4) {
          this._planet.setBaseLayer(this);
        }
        this._planet.updateVisibleLayers();
        if (e4 && !this._isPreloadDone && !this.isVector) {
          this._isPreloadDone = true;
          this._preLoad();
        }
      }
      this.events.dispatch(this.events.visibilitychange, this);
    }
  }
  _forceMaterialApply(e4) {
    let t2 = e4.materials, i2 = t2[this.__id];
    if (!i2) {
      i2 = t2[this.__id] = this.createMaterial(e4);
    }
    if (!i2.isReady) {
      this._planet._renderCompleted = false;
    }
    this.applyMaterial(i2, true);
  }
  clearMaterial(e4) {
  }
  loadMaterial(e4, t2 = false) {
  }
  applyMaterial(e4, t2 = false) {
    return [0, 0, 1, 1];
  }
  _preLoadRecursive(e4, t2) {
    if (e4.segment.tileZoom > t2) {
      return;
    }
    if (this._preLoadZoomLevels.includes(e4.segment.tileZoom)) {
      this._forceMaterialApply(e4.segment);
    }
    for (let i2 = 0, s2 = e4.nodes.length; i2 < s2; i2++) {
      if (e4.nodes[i2]) {
        this._preLoadRecursive(e4.nodes[i2], t2);
      }
    }
  }
  _preLoad() {
    if (this._planet && this._preLoadZoomLevels.length) {
      let e4 = this._planet, t2 = Math.max(...this._preLoadZoomLevels);
      for (let i2 = 0, s2 = e4.quadTreeStrategy.quadTreeList.length; i2 < s2; i2++) {
        this._preLoadRecursive(e4.quadTreeStrategy.quadTreeList[i2], t2);
      }
    }
  }
  getVisibility() {
    return this._visibility;
  }
  setExtent(e4) {
    let t2 = e4.southWest.clone(), i2 = e4.northEast.clone();
    if (t2.lat < We) {
      t2.lat = We;
    }
    if (i2.lat > Ge) {
      i2.lat = Ge;
    }
    this._extent = e4.clone();
    this._extentMerc = new Ye(t2.forwardMercator(), i2.forwardMercator());
    this._correctFullExtent();
  }
  getExtent() {
    return this._extent;
  }
  getExtentMerc() {
    return this._extentMerc;
  }
  flyExtent() {
    var _a2;
    (_a2 = this._planet) == null ? void 0 : _a2.flyExtent(this.getExtent());
  }
  viewExtent() {
    var _a2;
    (_a2 = this._planet) == null ? void 0 : _a2.viewExtent(this.getExtent());
  }
  _correctFullExtent() {
  }
  get opacity() {
    return this._opacity;
  }
  get screenOpacity() {
    return this._fading ? this._fadingOpacity : this._opacity;
  }
  _refreshFadingOpacity() {
    let e4 = this._planet;
    if (this._visibility && e4.getViewExtent().overlaps(this._extent) && e4.maxCurrZoom >= this.minZoom && e4.minCurrZoom <= this.maxZoom) {
      this._fadingOpacity += this._fadingFactor;
      if (this._fadingFactor > 0 && this._fadingOpacity > this._opacity || this._fadingFactor < 0 && this._fadingOpacity < this._opacity) {
        this._fadingOpacity = this._opacity;
      }
      return false;
    } else {
      this._fadingOpacity -= this._fadingFactor;
      if (this._fadingOpacity <= 0) {
        this._fadingOpacity = 0;
      }
      return false;
    }
  }
  createMaterial(e4) {
    return new Ms(e4, this);
  }
  redraw() {
    var _a2;
    (_a2 = this._planet) == null ? void 0 : _a2.quadTreeStrategy.clearLayerMaterial(this);
  }
  abortMaterialLoading(e4) {
  }
  abortLoading() {
  }
};
_ks.__counter__ = 0;
let ks = _ks;
const Is = ["visibilitychange", "add", "remove", "mousemove", "mouseenter", "mouseleave", "lclick", "rclick", "mclick", "ldblclick", "rdblclick", "mdblclick", "lup", "rup", "mup", "ldown", "rdown", "mdown", "lhold", "rhold", "mhold", "mousewheel", "touchmove", "touchstart", "touchend", "doubletouch", "touchleave", "touchenter"];
const zs = ["load", "loadend"];
const _Ds = class _Ds extends ks {
  constructor(e4, t2) {
    super(e4, t2);
    this.events = this.events.registerNames(zs);
    this.animated = t2.animated || false;
    this.minNativeZoom = t2.minNativeZoom || 0;
    this.maxNativeZoom = t2.maxNativeZoom || 100;
    this._counter = 0;
    this._pendingsQueue = [];
    this.drawTile = t2.drawTile;
    this._onLoadend_ = null;
  }
  addTo(e4) {
    this._onLoadend_ = this._onLoadend.bind(this);
    this.events.on("loadend", this._onLoadend_, this);
    return super.addTo(e4);
  }
  remove() {
    this.events.off("loadend", this._onLoadend_);
    this._onLoadend_ = null;
    return super.remove();
  }
  _onLoadend() {
    if (this._planet && this._planet._terrainCompletedActivated) {
      this._planet.events.dispatch(this._planet.events.layerloadend, this);
    }
  }
  get instanceName() {
    return "CanvasTiles";
  }
  get isIdle() {
    return super.isIdle && this._counter === 0;
  }
  abortLoading() {
    this._pendingsQueue.forEach((e4) => {
      this.abortMaterialLoading(e4);
    });
    this._pendingsQueue = [];
  }
  setVisibility(e4) {
    if (e4 !== this._visibility) {
      super.setVisibility(e4);
      if (!e4) {
        this.abortLoading();
      }
    }
  }
  loadMaterial(e4) {
    let t2 = e4.segment;
    if (this._isBaseLayer) {
      e4.texture = t2.getDefaultTexture();
    } else {
      e4.texture = t2.planet.transparentTexture;
    }
    if (this._planet.layerLock.isFree() || e4.segment.tileZoom < 2) {
      e4.isReady = false;
      e4.isLoading = true;
      if (_Ds.__requestsCounter >= _Ds.MAX_REQUESTS && this._counter) {
        this._pendingsQueue.push(e4);
      } else {
        this._exec(e4);
      }
    }
  }
  _exec(e4) {
    _Ds.__requestsCounter++;
    this._counter++;
    const t2 = this.events.load;
    if (t2.handlers.length) {
      this.events.dispatch(t2, e4);
    }
    requestAnimationFrame(() => {
      this.drawTile(e4, (t3) => {
        this._counter--;
        _Ds.__requestsCounter--;
        this._correctCounter();
        if (e4.isLoading) {
          e4.applyImage(t3);
        }
        this._dequeueRequest();
      });
    });
  }
  _correctCounter() {
    if (this._counter < 0) this._counter = 0;
    if (_Ds.__requestsCounter < 0) _Ds.__requestsCounter = 0;
  }
  abortMaterialLoading(e4) {
    if (e4.isLoading) {
      this._counter--;
      _Ds.__requestsCounter--;
      this._correctCounter();
      this._dequeueRequest();
    }
    e4.isLoading = false;
    e4.isReady = false;
  }
  _dequeueRequest() {
    if (this._pendingsQueue.length) {
      if (_Ds.__requestsCounter < _Ds.MAX_REQUESTS) {
        const e4 = this._whilePendings();
        if (e4) {
          this._exec(e4);
        }
      }
    } else if (this._counter === 0 && this._planet && this._planet._terrainCompletedActivated) {
      this.events.dispatch(this.events.loadend);
    }
  }
  _whilePendings() {
    while (this._pendingsQueue.length) {
      const e4 = this._pendingsQueue.pop();
      if (e4 && e4.segment && e4.segment.node) {
        if (e4.segment.initialized && e4.segment.node.getState() === Es) {
          return e4;
        }
        e4.isLoading = false;
      }
    }
    return null;
  }
  applyMaterial(e4) {
    if (e4.isReady) {
      if (e4.layer.animated) {
        requestAnimationFrame(() => {
          this.drawTile(e4, function(t2) {
            e4.applyImage(t2);
          });
        });
      }
      return e4.texOffset;
    } else if (e4.segment.tileZoom < this.minNativeZoom) {
      e4.textureNotExists();
    } else {
      let t2 = e4.segment;
      let i2 = t2.node, s2 = false;
      let r2 = e4.layer.maxNativeZoom;
      if (t2.passReady && !e4.isLoading && t2.tileZoom <= r2) {
        this.loadMaterial(e4);
      }
      let n2 = this._id;
      let o2 = e4;
      while (i2.parentNode) {
        i2 = i2.parentNode;
        o2 = i2.segment.materials[n2];
        if (o2 && o2.textureExists) {
          s2 = true;
          break;
        }
      }
      if (t2.passReady) {
        if (i2.segment.tileZoom === r2) {
          if (t2.tileZoom > r2) {
            e4.textureNotExists();
          }
        } else if (i2.segment.tileZoom < r2) {
          let i3 = t2.node;
          while (i3.segment.tileZoom > r2) {
            i3 = i3.parentNode;
          }
          let s3 = i3.segment.materials[n2];
          if (s3) {
            !s3.isLoading && !s3.isReady && this.loadMaterial(s3);
          } else {
            s3 = i3.segment.materials[e4.layer._id] = e4.layer.createMaterial(i3.segment);
            this.loadMaterial(s3);
          }
        }
      }
      if (s2) {
        if (e4.layer.animated) {
          requestAnimationFrame(() => {
            this.drawTile(e4, function(t3) {
              e4.applyImage(t3);
            });
          });
        }
        e4.appliedNodeId = i2.nodeId;
        e4.texture = o2.texture;
        let s3 = 1 / (2 << t2.tileZoom - i2.segment.tileZoom - 1);
        e4.texOffset[0] = t2.tileX * s3 - i2.segment.tileX;
        e4.texOffset[1] = t2.tileY * s3 - i2.segment.tileY;
        e4.texOffset[2] = s3;
        e4.texOffset[3] = s3;
      } else {
        e4.texture = t2.planet.transparentTexture;
        e4.texOffset[0] = 0;
        e4.texOffset[1] = 0;
        e4.texOffset[2] = 1;
        e4.texOffset[3] = 1;
      }
    }
    return e4.texOffset;
  }
  clearMaterial(e4) {
    if (e4.isReady) {
      e4.isReady = false;
      if (e4.textureExists && e4.texture && !e4.texture.default) {
        e4.segment.handler.gl.deleteTexture(e4.texture);
        e4.texture = null;
      }
    }
    this.abortMaterialLoading(e4);
    e4.isLoading = false;
    e4.textureExists = false;
    e4.layer = null;
    e4.segment = null;
  }
};
_Ds.MAX_REQUESTS = 20;
_Ds.__requestsCounter = 0;
let Ds = _Ds;
const Fs = `<?xml version="1.0" encoding="utf-8"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg fill="#000000" width="800px" height="800px" viewBox="-7.5 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg">
<title>lock</title>
<path d="M14.625 15.156h2.094c0.281 0 0.5 0.25 0.5 0.531v11c0 0.281-0.219 0.5-0.5 0.5h-16.219c-0.281 0-0.5-0.219-0.5-0.5v-11c0-0.281 0.219-0.531 0.5-0.531h2.031v-5.125c0-2.875 1.844-5.25 4.688-5.25h2.688c2.875 0 4.719 2.375 4.719 5.25v5.125zM5.188 15.156h6.813v-4.875c0-1.594-1.313-2.938-2.938-2.938h-0.969c-1.594 0-2.906 1.344-2.906 2.938v4.875zM7.156 24h2.906l-0.719-3.156c0.5-0.25 0.844-0.781 0.844-1.375 0-0.906-0.719-1.594-1.594-1.594s-1.563 0.688-1.563 1.594c0 0.594 0.344 1.125 0.844 1.375z"></path>
</svg>`;
const Ns = `<?xml version="1.0" encoding="iso-8859-1"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg fill="#000000" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
	 width="800px" height="800px" viewBox="0 0 932.179 932.179"
	 xml:space="preserve">
<g>
	<path d="M61.2,341.538c4.9,16.8,11.7,33,20.3,48.2l-24.5,30.9c-8,10.1-7.1,24.5,1.9,33.6l42.2,42.2c9.1,9.1,23.5,9.899,33.6,1.899
		l30.7-24.3c15.8,9.101,32.6,16.2,50.1,21.2l4.6,39.5c1.5,12.8,12.3,22.4,25.1,22.4h59.7c12.8,0,23.6-9.601,25.1-22.4l4.4-38.1
		c18.8-4.9,36.8-12.2,53.7-21.7l29.7,23.5c10.1,8,24.5,7.1,33.6-1.9l42.2-42.2c9.1-9.1,9.9-23.5,1.9-33.6l-23.1-29.3
		c9.6-16.601,17.1-34.3,22.1-52.8l35.6-4.1c12.801-1.5,22.4-12.3,22.4-25.1v-59.7c0-12.8-9.6-23.6-22.4-25.1l-35.1-4.1
		c-4.801-18.3-12-35.8-21.199-52.2l21.6-27.3c8-10.1,7.1-24.5-1.9-33.6l-42.1-42.1c-9.1-9.1-23.5-9.9-33.6-1.9l-26.5,21
		c-17.2-10.1-35.601-17.8-54.9-23l-4-34.3c-1.5-12.8-12.3-22.4-25.1-22.4h-59.7c-12.8,0-23.6,9.6-25.1,22.4l-4,34.3
		c-19.8,5.3-38.7,13.3-56.3,23.8l-27.5-21.8c-10.1-8-24.5-7.1-33.6,1.9l-42.2,42.2c-9.1,9.1-9.9,23.5-1.9,33.6l23,29.1
		c-9.2,16.6-16.2,34.3-20.8,52.7l-36.8,4.2c-12.8,1.5-22.4,12.3-22.4,25.1v59.7c0,12.8,9.6,23.6,22.4,25.1L61.2,341.538z
		 M277.5,180.038c54.4,0,98.7,44.3,98.7,98.7s-44.3,98.7-98.7,98.7c-54.399,0-98.7-44.3-98.7-98.7S223.1,180.038,277.5,180.038z"/>
	<path d="M867.699,356.238l-31.5-26.6c-9.699-8.2-24-7.8-33.199,0.9l-17.4,16.3c-14.699-7.1-30.299-12.1-46.4-15l-4.898-24
		c-2.5-12.4-14-21-26.602-20l-41.1,3.5c-12.6,1.1-22.5,11.4-22.9,24.1l-0.799,24.4c-15.801,5.7-30.701,13.5-44.301,23.3
		l-20.799-13.8c-10.602-7-24.701-5-32.9,4.7l-26.6,31.7c-8.201,9.7-7.801,24,0.898,33.2l18.201,19.399
		c-6.301,14.2-10.801,29.101-13.4,44.4l-26,5.3c-12.4,2.5-21,14-20,26.601l3.5,41.1c1.1,12.6,11.4,22.5,24.1,22.9l28.1,0.899
		c5.102,13.4,11.801,26.101,19.9,38l-15.699,23.7c-7,10.6-5,24.7,4.699,32.9l31.5,26.6c9.701,8.2,24,7.8,33.201-0.9l20.6-19.3
		c13.5,6.3,27.699,11,42.299,13.8l5.701,28.2c2.5,12.4,14,21,26.6,20l41.1-3.5c12.6-1.1,22.5-11.399,22.9-24.1l0.9-27.601
		c15-5.3,29.199-12.5,42.299-21.399l22.701,15c10.6,7,24.699,5,32.9-4.7l26.6-31.5c8.199-9.7,7.799-24-0.9-33.2l-18.301-19.399
		c6.701-14.2,11.602-29.2,14.4-44.601l25-5.1c12.4-2.5,21-14,20-26.601l-3.5-41.1c-1.1-12.6-11.4-22.5-24.1-22.9l-25.1-0.8
		c-5.201-14.6-12.201-28.399-20.9-41.2l13.699-20.6C879.4,378.638,877.4,364.438,867.699,356.238z M712.801,593.837
		c-44.4,3.801-83.602-29.3-87.301-73.699c-3.801-44.4,29.301-83.601,73.699-87.301c44.4-3.8,83.602,29.301,87.301,73.7
		C790.301,550.938,757.199,590.138,712.801,593.837z"/>
	<path d="M205,704.438c-12.6,1.3-22.3,11.899-22.4,24.6l-0.3,25.3c-0.2,12.7,9.2,23.5,21.8,25.101l18.6,2.399
		c3.1,11.301,7.5,22.101,13.2,32.301l-12,14.8c-8,9.899-7.4,24.1,1.5,33.2l17.7,18.1c8.9,9.1,23.1,10.1,33.2,2.3l14.899-11.5
		c10.5,6.2,21.601,11.101,33.2,14.5l2,19.2c1.3,12.6,11.9,22.3,24.6,22.4l25.301,0.3c12.699,0.2,23.5-9.2,25.1-21.8l2.3-18.2
		c12.601-3.101,24.601-7.8,36-14l14,11.3c9.9,8,24.101,7.4,33.201-1.5l18.1-17.7c9.1-8.899,10.1-23.1,2.301-33.2L496.6,818.438
		c6.6-11,11.701-22.7,15.201-35l16.6-1.7c12.6-1.3,22.299-11.9,22.4-24.6l0.299-25.301c0.201-12.699-9.199-23.5-21.799-25.1
		l-16.201-2.1c-3.1-12.2-7.699-24-13.699-35l10.1-12.4c8-9.9,7.4-24.1-1.5-33.2l-17.699-18.1c-8.9-9.101-23.102-10.101-33.201-2.3
		l-12.101,9.3c-11.399-6.9-23.6-12.2-36.399-15.8l-1.601-15.7c-1.3-12.601-11.899-22.3-24.6-22.4l-25.3-0.3
		c-12.7-0.2-23.5,9.2-25.101,21.8l-2,15.601c-13.199,3.399-25.899,8.6-37.699,15.399l-12.5-10.2c-9.9-8-24.101-7.399-33.201,1.5
		l-18.2,17.801c-9.1,8.899-10.1,23.1-2.3,33.199l10.7,13.801c-6.2,11-11.1,22.699-14.3,35L205,704.438z M368.3,675.837
		c36.3,0.4,65.399,30.301,65,66.601c-0.4,36.3-30.301,65.399-66.601,65c-36.3-0.4-65.399-30.3-65-66.601
		C302.1,704.538,332,675.438,368.3,675.837z"/>
</g>
</svg>`;
const Os = `<?xml version="1.0"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M 4 4 L 4 8 L 8 8 L 8 4 L 4 4 z M 10 4 L 10 8 L 14 8 L 14 4 L 10 4 z M 16 4 L 16 8 L 20 8 L 20 4 L 16 4 z M 4 10 L 4 14 L 8 14 L 8 10 L 4 10 z M 10 10 L 10 14 L 14 14 L 14 10 L 10 10 z M 16 10 L 16 14 L 20 14 L 20 10 L 16 10 z M 4 16 L 4 20 L 8 20 L 8 16 L 4 16 z M 10 16 L 10 20 L 14 20 L 14 16 L 10 16 z M 16 16 L 16 20 L 20 20 L 20 16 L 16 16 z"/>
</svg>`;
class Hs extends ns {
  constructor(e4 = {}) {
    if (!e4.name || e4.name === "") {
      e4.name = "DebugInfo";
    }
    super(e4);
    this.el = null;
    this._watch = e4.watch || [];
    this._toggleBtn = new _s({ classList: ["og-map-button", "og-debuginfo_button"], icon: Ns });
    this._dialog = new ds({ title: "Debug Info", visible: false, useHide: true, top: 120, left: 60, width: 480 });
    this._dialog.events.on("visibility", (e5) => {
      this._toggleBtn.setActive(e5);
    });
    this._canvasTiles = new Ds("Tile grid", { visibility: true, isBaseLayer: false, hideInLayerSwitcher: true, drawTile: function(e5, t2) {
      let i2 = document.createElement("canvas");
      let s2 = i2.getContext("2d");
      i2.width = 256;
      i2.height = 256;
      s2.clearRect(0, 0, i2.width, i2.height);
      s2.beginPath();
      s2.rect(0, 0, i2.width, i2.height);
      s2.lineWidth = 2;
      s2.strokeStyle = "black";
      s2.stroke();
      let r2;
      if (e5.segment.tileZoom > 14) {
        r2 = "26";
      } else {
        r2 = "32";
      }
      s2.fillStyle = "black";
      s2.font = "normal " + r2 + "px Verdana";
      s2.textAlign = "center";
      s2.fillText(e5.segment.tileX + "," + e5.segment.tileY + "," + e5.segment.tileZoom, i2.width / 2, i2.height / 2);
      t2(i2);
    } });
  }
  addWatches(e4) {
    for (let t2 = 0; t2 < e4.length; t2++) {
      this.addWatch(e4[t2]);
    }
  }
  addWatch(e4) {
    this._watch.push(e4);
    let t2 = document.createElement("div");
    t2.classList.add("og-watch-line");
    t2.innerHTML = `<div class="og-watch-label">${e4.label}</div><div class="og-watch-value"></div>`;
    e4.valEl = t2.querySelector(".og-watch-value");
    this.el.appendChild(t2);
  }
  oninit() {
    var _a2;
    this._toggleBtn.appendTo(this.renderer.div);
    this._dialog.appendTo(this.renderer.div);
    this._toggleBtn.events.on("change", (e5) => {
      this._dialog.setVisibility(e5);
    });
    this.el = document.createElement("div");
    this.el.className = "og-debug-info";
    let e4 = document.createElement("div");
    e4.classList.add("og-debuginfo_controls");
    this.el.appendChild(e4);
    let t2 = this._watch;
    this._watch = [];
    for (let e5 = 0; e5 < t2.length; e5++) {
      this.addWatch(t2[e5]);
    }
    (_a2 = this._dialog.container) == null ? void 0 : _a2.appendChild(this.el);
    this.renderer.events.on("draw", this._frame, this);
    let i2 = this.planet;
    if (i2) {
      this.addWatches([{ label: "Nodes count", frame: () => i2._renderedNodes.length }, { label: "Planet._fadingNodes", frame: () => i2._fadingNodes.size }, { label: "createdNodes", frame: () => i2._createdNodesCount }, { label: "indexesCache", frame: () => i2._indexesCacheToRemoveCounter }, { label: "distBeforeMemClear", frame: () => Math.round(i2._distBeforeMemClear) }, { label: "maxZoom/minZoom", frame: () => i2.maxCurrZoom + " / " + (i2 == null ? void 0 : i2.minCurrZoom) }, { label: "viewExtent", frame: () => i2.getViewExtent().toString() }, { label: "Mouse distance, m", frame: () => {
        let e5 = i2.getCartesianFromMouseTerrain();
        if (e5) {
          return i2.camera.eye.distance(e5).toFixed(3);
        }
        return "";
      } }, { label: "lodSize", frame: () => Math.round(i2.lodSize) }, { label: "deltaTime/FPS", frame: () => `<div style="width:70px"><div style="width:20px; float: left;">
                        ${Math.round(i2.renderer.handler.deltaTime)}
                        </div> <div style="float: left">
                        ${Math.round(1e3 / i2.renderer.handler.deltaTime)}
                        </div></div>` }, { label: "-------------------------" }, { label: "Pitch, deg", frame: () => (i2.camera.getPitch() * u).toFixed(2) }, { label: "Yaw, deg", frame: () => (i2.camera.getYaw() * u).toFixed(2) }, { label: "Roll, deg", frame: () => (i2.camera.getRoll() * u).toFixed(2) }, { label: "Lon, Lat", frame: () => `<div style="width:190px">${i2.camera._lonLat.lon.toFixed(7)}, ${i2.camera._lonLat.lon.toFixed(7)}</div>` }, { label: "height/alt, m", frame: () => `<div style="width:190px">${i2.camera._lonLat.height.toFixed(2) + " / " + i2.camera.getAltitude().toFixed(2)}</div>` }, { label: "cam.slope", frame: () => i2.camera.slope.toFixed(3) }, { label: "-------------------------" }, { label: "_renderCompleted / renderCompletedActivated", frame: () => `${i2._renderCompleted} / ${i2._renderCompletedActivated}` }, { label: "_terrainCompleted / terrainCompletedActivated", frame: () => `${i2._terrainCompleted} / ${i2._terrainCompletedActivated}` }, { label: "PlainWorker", frame: () => i2._plainSegmentWorker.pendingQueue.length }, { label: "TileLoader", frame: () => `${i2._tileLoader.loading} ${i2._tileLoader.queue.length}` }, { label: "TerrainLoader", frame: () => {
        if (i2.terrain && !i2.terrain.isEmpty) {
          return `${i2.terrain.loader.loading}  ${i2.terrain.loader.queue.length}`;
        }
        return "";
      } }, { label: "TerrainWorker", frame: () => i2._terrainWorker.pendingQueue.length }, { label: "NormalMapCreator", frame: () => i2._normalMapCreator.queueSize }, { label: "VectorTileCreator", frame: () => i2._vectorTileCreator.queueSize }]);
    }
    let s2 = new _s({ classList: ["og-debuginfo_controls-button"], icon: Fs, title: "Lock/Unlock quad tree" });
    s2.appendTo(e4);
    s2.events.on("change", (e5) => {
      if (e5) {
        i2.lockQuadTree();
      } else {
        i2.unlockQuadTree();
      }
    });
    let r2 = new _s({ classList: ["og-debuginfo_controls-button"], icon: Os, title: "Show/Hide grid" });
    r2.appendTo(e4);
    r2.events.on("change", (e5) => {
      if (e5) {
        this.planet.addLayer(this._canvasTiles);
      } else {
        this._canvasTiles.remove();
      }
    });
  }
  _frame() {
    this._watch.forEach((e4) => {
      if (e4.valEl) {
        e4.valEl.innerHTML = e4.frame ? String(e4.frame()) : "";
      }
    });
  }
}
const Vs = ["change"];
class Us {
  constructor(e4 = {}) {
    this._onChange = (e5, t2) => {
      if (e5) {
        t2.preventClick = true;
        for (let e6 = 0; e6 < this._buttons.length; e6++) {
          let i2 = this._buttons[e6];
          if (!i2.isEqual(t2)) {
            i2.setActive(false);
            i2.preventClick = false;
          }
        }
        this.events.dispatch(this.events.change, t2);
      }
    };
    this.events = Qi(Vs);
    this._buttons = e4.buttons || [];
    for (let e5 = 0; e5 < this._buttons.length; e5++) {
      this._bindButton(this._buttons[e5]);
    }
  }
  _bindButton(e4) {
    e4.events.on("change", this._onChange);
  }
  add(e4) {
    this._buttons.push(e4);
    this._bindButton(e4);
  }
  remove(e4) {
    for (let t2 = 0; t2 < this._buttons.length; t2++) {
      if (this._buttons[t2].isEqual(e4)) {
        this._buttons.splice(t2);
        e4.events.off("change", this._onChange);
        return;
      }
    }
  }
}
class Gs {
  constructor(e4 = 2, t2) {
    this._sourceId = 0;
    this._source = /* @__PURE__ */ new Map();
    this._pendingQueue = [];
    this._numWorkers = e4;
    this._workerQueue = [];
    if (t2) {
      this.setProgram(t2);
    }
  }
  check() {
    if (this._pendingQueue.length) {
      this.make(this._pendingQueue.pop());
    }
  }
  setProgram(e4) {
    if (lt(e4)) {
      let t2 = new Blob([e4], { type: "application/javascript" });
      for (let e5 = 0; e5 < this._numWorkers; e5++) {
        let e6 = new Worker(URL.createObjectURL(t2));
        e6.onmessage = (e7) => {
          this._onMessage(e7);
          this._workerQueue && this._workerQueue.unshift(e7.target);
          this.check();
        };
        this._workerQueue.push(e6);
      }
    } else {
      for (let t2 = 0; t2 < this._numWorkers; t2++) {
        let t3 = new e4();
        t3.onmessage = (e5) => {
          this._onMessage(e5);
          this._workerQueue && this._workerQueue.unshift(e5.target);
          this.check();
        };
        this._workerQueue.push(t3);
      }
    }
  }
  make(e4) {
  }
  _onMessage(e4) {
  }
  destroy() {
    for (let e4 = 0; e4 < this._workerQueue.length; e4++) {
      const t2 = this._workerQueue[e4];
      t2.onmessage = null;
      t2.terminate();
    }
    this._pendingQueue = null;
    this._workerQueue = null;
  }
  get pendingQueue() {
    return this._pendingQueue;
  }
}
const Ws = '(function() {\n  "use strict";\n  function r(r2, e, a) {\n    let f = a.length, o = e * f;\n    for (let e2 = 0; e2 < f; e2++) {\n      r2[o + e2] = a[e2];\n    }\n  }\n  self.onmessage = function(e) {\n    var a = e.data.labelData, f = a[0], o = a[1], t = a[2], n = a[3], l = a[4], A = a[5], i = a[6], u = a[7], b = a[8], s = a[9], w = a[10], y = a[11], F = a[12], g = a[13], c = a[14], d = a[15], p = a[16], x = a[17], h = a[18], v = a[19], C = a[20], m = a[21], k = a[22], z = a[23], D = a[24], H = a[25], I = a[26], L = a[27], M = a[28], P = a[29];\n    let j = new Float32Array(o * 12), q = new Float32Array(o * 24), B = new Float32Array(o * 24), E = new Float32Array(o * 18), G = new Float32Array(o * 18), J = new Float32Array(o * 6), K = new Float32Array(o * 18), N = new Float32Array(o * 24), O = new Float32Array(o * 6), Q = new Float32Array(o * 18), R = new Float32Array(o * 6), S = new Float32Array(o * 6), T = new Float32Array(o * 24), U = new Float32Array(o * 18);\n    for (let e2 = 0; e2 < o; e2++) {\n      if (t !== 0) {\n        r(j, e2, [0, 0, 0, -1, 1, -1, 1, -1, 1, 0, 0, 0]);\n      } else {\n        r(j, e2, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n      }\n      r(q, e2, [0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0]);\n      r(B, e2, [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0]);\n      var V = n, W = l, X = A, Y;\n      r(E, e2, [V, W, X, V, W, X, V, W, X, V, W, X, V, W, X, V, W, X]);\n      V = i;\n      W = u;\n      X = b;\n      r(G, e2, [V, W, X, V, W, X, V, W, X, V, W, X, V, W, X, V, W, X]);\n      V = s;\n      r(J, e2, [V, V, V, V, V, V]);\n      V = w;\n      W = y;\n      X = F;\n      r(K, e2, [V, W, X, V, W, X, V, W, X, V, W, X, V, W, X, V, W, X]);\n      V = g;\n      W = c;\n      X = d;\n      Y = p;\n      r(N, e2, [V, W, X, Y, V, W, X, Y, V, W, X, Y, V, W, X, Y, V, W, X, Y, V, W, X, Y]);\n      V = x;\n      r(O, e2, [V, V, V, V, V, V]);\n      V = h;\n      W = v;\n      X = C;\n      r(Q, e2, [V, W, X, V, W, X, V, W, X, V, W, X, V, W, X, V, W, X]);\n      V = m;\n      r(R, e2, [V, V, V, V, V, V]);\n      V = k;\n      r(S, e2, [V, V, V, V, V, V]);\n      V = z;\n      W = D;\n      X = H;\n      Y = I;\n      r(T, e2, [V, W, X, Y, V, W, X, Y, V, W, X, Y, V, W, X, Y, V, W, X, Y, V, W, X, Y]);\n      V = L / 255;\n      W = M / 255;\n      X = P / 255;\n      r(U, e2, [V, W, X, V, W, X, V, W, X, V, W, X, V, W, X, V, W, X]);\n    }\n    self.postMessage({ id: f, vertexArr: j, texCoordArr: q, gliphParamArr: B, positionHighArr: E, positionLowArr: G, sizeArr: J, offsetArr: K, rgbaArr: N, rotationArr: O, alignedAxisArr: Q, fontIndexArr: R, outlineArr: S, outlineColorArr: T, pickingColorArr: U }, [j.buffer, q.buffer, B.buffer, E.buffer, G.buffer, J.buffer, K.buffer, N.buffer, O.buffer, Q.buffer, R.buffer, S.buffer, T.buffer, U.buffer]);\n  };\n})();\n//# sourceMappingURL=LabelWorker.worker-DMq4IFdY.js.map\n';
const js = typeof self !== "undefined" && self.Blob && new Blob([Ws], { type: "text/javascript;charset=utf-8" });
function Ys(e4) {
  let t2;
  try {
    t2 = js && (self.URL || self.webkitURL).createObjectURL(js);
    if (!t2) throw "";
    const i2 = new Worker(t2, { name: e4 == null ? void 0 : e4.name });
    i2.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(t2);
    });
    return i2;
  } catch (t3) {
    return new Worker("data:text/javascript;charset=utf-8," + encodeURIComponent(Ws), { name: e4 == null ? void 0 : e4.name });
  } finally {
    t2 && (self.URL || self.webkitURL).revokeObjectURL(t2);
  }
}
const qs = -2;
const $s = -1;
class Xs extends Gs {
  constructor(e4 = 4) {
    super(e4, Ys);
  }
  _onMessage(e4) {
    let t2 = this._source.get(e4.data.id);
    if (t2.label._lockId === qs) {
      requestAnimationFrame(() => {
        this.make({ handler: t2.handler, label: t2.label });
      });
    } else {
      t2.handler.workerCallback(e4.data, t2.label);
    }
    this._source.delete(e4.data.id);
  }
  make(e4) {
    let t2 = e4.label, i2 = e4.handler;
    if (i2._entityCollection) {
      let i3 = t2.serializeWorkerData(this._sourceId);
      if (i3) {
        if (this._workerQueue.length) {
          let s2 = this._workerQueue.pop();
          this._source.set(this._sourceId, e4);
          t2._lockId = this._sourceId;
          this._sourceId++;
          s2.postMessage({ labelData: i3 }, [i3.buffer]);
        } else {
          this._pendingQueue.push(e4);
        }
      }
    }
  }
}
const _Zs = class _Zs {
  constructor(e4 = {}) {
    this.__id = _Zs.__counter__++;
    this._position = bt(e4.position);
    this._positionHigh = new Ke();
    this._positionLow = new Ke();
    Ke.doubleToTwoFloats(this._position, this._positionHigh, this._positionLow);
    this._rotation = e4.rotation || 0;
    this._color = Ct(e4.color);
    this._alignedAxis = bt(e4.alignedAxis);
    this._offset = bt(e4.offset);
    this._visibility = e4.visibility != void 0 ? e4.visibility : true;
    this._entity = null;
    this._handler = null;
    this._handlerIndex = -1;
    this._isReady = false;
    this._lockId = $s;
  }
  setPosition(e4, t2, i2) {
    this._position.x = e4;
    this._position.y = t2;
    this._position.z = i2;
    Ke.doubleToTwoFloats(this._position, this._positionHigh, this._positionLow);
    if (this._isReady && this._handler) {
      this._handler.setPositionArr(this._handlerIndex, this._positionHigh, this._positionLow);
    } else if (this._lockId !== $s) {
      this._lockId = qs;
    }
  }
  setPosition3v(e4) {
    this._position.x = e4.x;
    this._position.y = e4.y;
    this._position.z = e4.z;
    Ke.doubleToTwoFloats(e4, this._positionHigh, this._positionLow);
    if (this._isReady && this._handler) {
      this._handler.setPositionArr(this._handlerIndex, this._positionHigh, this._positionLow);
    } else if (this._lockId !== $s) {
      this._lockId = qs;
    }
  }
  getPosition() {
    return this._position;
  }
  setOffset(e4, t2, i2) {
    this._offset.x = e4;
    this._offset.y = t2;
    i2 != void 0 && (this._offset.z = i2);
    if (this._isReady && this._handler) {
      this._handler.setOffsetArr(this._handlerIndex, this._offset);
    } else if (this._lockId !== $s) {
      this._lockId = qs;
    }
  }
  setOffset3v(e4) {
    this.setOffset(e4.x, e4.y, e4.z);
  }
  getOffset() {
    return this._offset;
  }
  setRotation(e4) {
    if (e4 !== this._rotation) {
      this._rotation = e4;
      if (this._isReady && this._handler) {
        this._handler.setRotationArr(this._handlerIndex, e4);
      } else if (this._lockId !== $s) {
        this._lockId = qs;
      }
    }
  }
  getRotation() {
    return this._rotation;
  }
  setOpacity(e4) {
    if (e4 !== this._color.w) {
      e4 != void 0 && (this._color.w = e4);
      if (this._isReady && this._handler) {
        this._handler.setRgbaArr(this._handlerIndex, this._color);
      } else if (this._lockId !== $s) {
        this._lockId = qs;
      }
    }
  }
  setColor(e4, t2, i2, s2) {
    if (s2 !== this._color.w || e4 !== this._color.x || t2 !== this._color.y || this._color.z !== i2) {
      this._color.x = e4;
      this._color.y = t2;
      this._color.z = i2;
      s2 != void 0 && (this._color.w = s2);
      if (this._isReady && this._handler) {
        this._handler.setRgbaArr(this._handlerIndex, this._color);
      } else if (this._lockId !== $s) {
        this._lockId = qs;
      }
    }
  }
  setColor4v(e4) {
    this.setColor(e4.x, e4.y, e4.z, e4.w);
  }
  setColorHTML(e4) {
    this.setColor4v(dt(e4));
  }
  getColor() {
    return this._color;
  }
  setVisibility(e4) {
    if (e4 !== this._visibility) {
      this._visibility = e4;
      if (this._isReady && this._handler) {
        this._handler.setVisibility(this._handlerIndex, e4);
      } else if (this._lockId !== $s) {
        this._lockId = qs;
      }
    }
  }
  getVisibility() {
    return this._visibility;
  }
  setAlignedAxis(e4, t2, i2) {
    this._alignedAxis.x = e4;
    this._alignedAxis.y = t2;
    this._alignedAxis.z = i2;
    if (this._isReady && this._handler) {
      this._handler.setAlignedAxisArr(this._handlerIndex, this._alignedAxis);
    } else if (this._lockId !== $s) {
      this._lockId = qs;
    }
  }
  setAlignedAxis3v(e4) {
    this.setAlignedAxis(e4.x, e4.y, e4.z);
  }
  getAlignedAxis() {
    return this._alignedAxis;
  }
  remove() {
    this._entity = null;
    this._handler && this._handler.remove(this);
  }
  setPickingColor3v(e4) {
    if (this._isReady && this._handler) {
      this._handler.setPickingColorArr(this._handlerIndex, e4);
    } else if (this._lockId !== $s) {
      this._lockId = qs;
    }
  }
  serializeWorkerData(e4) {
    if (this._handler) {
      return new Float32Array([]);
    }
    return null;
  }
};
_Zs.__counter__ = 0;
let Zs = _Zs;
class Ks extends Zs {
  constructor(e4 = {}) {
    super(e4);
    this._handler = null;
    this._src = e4.src || null;
    this._image = e4.image || null;
    this._scale = 1;
    this._width = e4.width || (e4.size ? e4.size[0] : 30);
    this._height = e4.height || (e4.size ? e4.size[1] : 30);
  }
  setSrc(e4) {
    this._src = e4;
    let t2 = this._handler;
    if (t2 && e4 && e4.length) {
      let i2 = t2._entityCollection.renderNode;
      if (i2 && i2.renderer) {
        let s2 = i2.renderer.billboardsTextureAtlas;
        let r2 = this;
        s2.loadImage(e4, function(e5) {
          if (e5.__nodeIndex != void 0 && s2.get(e5.__nodeIndex)) {
            r2._image = e5;
            t2.setTexCoordArr(r2._handlerIndex, s2.get(r2._image.__nodeIndex).texCoords);
          } else {
            s2.addImage(e5);
            s2.createTexture();
            r2._image = e5;
            i2.updateBillboardsTexCoords();
          }
        });
      }
    }
  }
  getSrc() {
    return this._src;
  }
  setImage(e4) {
    this.setSrc(e4.src);
  }
  getImage() {
    return this._image;
  }
  setSize(e4, t2) {
    this._width = e4;
    this._height = t2;
    this._handler && this._handler.setSizeArr(this._handlerIndex, e4 * this._scale, t2 * this._scale);
  }
  getSize() {
    return { width: this._width, height: this._height };
  }
  setWidth(e4) {
    this.setSize(e4, this._height);
  }
  getWidth() {
    return this._width;
  }
  setHeight(e4) {
    this.setSize(this._width, e4);
  }
  getHeight() {
    return this._height;
  }
}
var Qs = ((e4) => {
  e4[e4["POINT"] = 1] = "POINT";
  e4[e4["LINESTRING"] = 2] = "LINESTRING";
  e4[e4["POLYGON"] = 3] = "POLYGON";
  e4[e4["MULTIPOLYGON"] = 4] = "MULTIPOLYGON";
  e4[e4["MULTILINESTRING"] = 5] = "MULTILINESTRING";
  return e4;
})(Qs || {});
const Js = { POINT: 1, LINESTRING: 2, POLYGON: 3, MULTIPOLYGON: 4, MULTILINESTRING: 5 };
const _er = class _er {
  constructor(e4 = {}) {
    this.__id = _er.__counter__++;
    this._entity = null;
    this._handler = null;
    this._handlerIndex = -1;
    this._polyVerticesHighMerc = [];
    this._polyVerticesLowMerc = [];
    this._polyVerticesLength = -1;
    this._polyIndexesLength = -1;
    this._polyVerticesHandlerIndex = -1;
    this._polyIndexesHandlerIndex = -1;
    this._lineVerticesHighMerc = [];
    this._lineVerticesLowMerc = [];
    this._lineVerticesLength = -1;
    this._lineOrdersLength = -1;
    this._lineIndexesLength = -1;
    this._lineColorsLength = -1;
    this._lineThicknessLength = -1;
    this._lineVerticesHandlerIndex = -1;
    this._lineOrdersHandlerIndex = -1;
    this._lineIndexesHandlerIndex = -1;
    this._lineThicknessHandlerIndex = -1;
    this._lineColorsHandlerIndex = -1;
    this._type = e4.type && _er.getType(e4.type) || 1;
    this._coordinates = e4.coordinates || [];
    this._extent = _er.getExtent({ type: e4.type || "POINT", coordinates: e4.coordinates || [] }, this._coordinates);
    e4.style = e4.style || {};
    this._style = { fillColor: Ct(e4.style.fillColor, new $e(0.19, 0.62, 0.85, 0.4)), lineColor: Ct(e4.style.lineColor, new $e(0.19, 0.62, 0.85, 1)), strokeColor: Ct(e4.style.strokeColor, new $e(1, 1, 1, 0.95)), lineWidth: e4.style.lineWidth || 3, strokeWidth: e4.style.strokeWidth || 0 };
    this._visibility = e4.visibility || true;
    this._pickingReady = false;
  }
  get id() {
    return this.__id;
  }
  get type() {
    return this._type;
  }
  static getType(e4) {
    return Js[e4.toUpperCase()];
  }
  static getExtent(e4, t2) {
    let i2 = new Ye(new be(180, 90), new be(-180, -90));
    let s2 = _er.getType(e4.type);
    if (s2 === 1) {
      let s3 = e4.coordinates[0], r2 = e4.coordinates[1];
      i2.southWest.lon = s3;
      i2.southWest.lat = r2;
      i2.northEast.lon = s3;
      i2.northEast.lat = r2;
      t2 && (t2[0] = s3) && (t2[1] = r2);
    } else if (s2 === 2) {
      let s3 = e4.coordinates;
      for (let e5 = 0; e5 < s3.length; e5++) {
        let r2 = s3[e5][0], n2 = s3[e5][1];
        if (r2 < i2.southWest.lon) i2.southWest.lon = r2;
        if (n2 < i2.southWest.lat) i2.southWest.lat = n2;
        if (r2 > i2.northEast.lon) i2.northEast.lon = r2;
        if (n2 > i2.northEast.lat) i2.northEast.lat = n2;
        t2 && (t2[e5] = [r2, n2]);
      }
    } else if (s2 === 3) {
      let s3 = e4.coordinates;
      for (let e5 = 0; e5 < s3.length; e5++) {
        let r2 = s3[e5];
        t2 && (t2[e5] = []);
        for (let s4 = 0; s4 < r2.length; s4++) {
          let n2 = r2[s4];
          let o2 = n2[0], a2 = n2[1];
          if (o2 < i2.southWest.lon) i2.southWest.lon = o2;
          if (a2 < i2.southWest.lat) i2.southWest.lat = a2;
          if (o2 > i2.northEast.lon) i2.northEast.lon = o2;
          if (a2 > i2.northEast.lat) i2.northEast.lat = a2;
          t2 && (t2[e5][s4] = [o2, a2]);
        }
      }
    } else if (s2 === 4) {
      let s3 = e4.coordinates;
      for (let e5 = 0; e5 < s3.length; e5++) {
        let r2 = s3[e5];
        t2 && (t2[e5] = []);
        for (let s4 = 0; s4 < r2.length; s4++) {
          let n2 = r2[s4];
          t2 && (t2[e5][s4] = []);
          for (let r3 = 0; r3 < n2.length; r3++) {
            let o2 = n2[r3];
            let a2 = o2[0], l2 = o2[1];
            if (a2 < i2.southWest.lon) i2.southWest.lon = a2;
            if (l2 < i2.southWest.lat) i2.southWest.lat = l2;
            if (a2 > i2.northEast.lon) i2.northEast.lon = a2;
            if (l2 > i2.northEast.lat) i2.northEast.lat = l2;
            t2 && (t2[e5][s4][r3] = [a2, l2]);
          }
        }
      }
    } else if (s2 === 5) {
      let s3 = e4.coordinates;
      for (let e5 = 0; e5 < s3.length; e5++) {
        let r2 = s3[e5];
        t2 && (t2[e5] = []);
        for (let s4 = 0; s4 < r2.length; s4++) {
          let n2 = r2[s4];
          let o2 = n2[0], a2 = n2[1];
          if (o2 < i2.southWest.lon) i2.southWest.lon = o2;
          if (a2 < i2.southWest.lat) i2.southWest.lat = a2;
          if (o2 > i2.northEast.lon) i2.northEast.lon = o2;
          if (a2 > i2.northEast.lat) i2.northEast.lat = a2;
          t2 && (t2[e5][s4] = [o2, a2]);
        }
      }
    } else {
      i2.southWest.lon = i2.southWest.lat = i2.northEast.lon = i2.northEast.lat = 0;
      t2 && (t2[0] = 0) && (t2[1] = 0);
    }
    return i2;
  }
  setGeometry(e4) {
    let t2 = this._handler;
    if (t2) {
      this.remove();
      this._type = _er.getType(e4.type || "Point");
      this._extent = _er.getExtent(e4, this._coordinates);
      t2.add(this);
    }
    return this;
  }
  setFillColor(e4, t2, i2, s2 = 1) {
    let r2 = this._style.fillColor;
    if (r2.w === 0 && s2 !== 0 || r2.w !== 0 && s2 === 0) {
      this._pickingReady = false;
    }
    r2.x = e4;
    r2.y = t2;
    r2.z = i2;
    r2.w = s2;
    this._handler && this._handler.setPolyColorArr(this, r2);
    return this;
  }
  overlaps(e4) {
    return this._extent.overlaps(e4);
  }
  setFillColor4v(e4) {
    return this.setFillColor(e4.x, e4.y, e4.z, e4.w);
  }
  setStrokeColor(e4, t2, i2, s2 = 1) {
    let r2 = this._style.strokeColor;
    if (r2.w === 0 && s2 !== 0 || r2.w !== 0 && s2 === 0) {
      this._pickingReady = false;
    }
    r2.x = e4;
    r2.y = t2;
    r2.z = i2;
    r2.w = s2;
    this._handler && this._handler.setLineStrokeColorArr(this, r2);
    return this;
  }
  setLineColor(e4, t2, i2, s2 = 1) {
    let r2 = this._style.lineColor;
    if (r2.w === 0 && s2 !== 0 || r2.w !== 0 && s2 === 0) {
      this._pickingReady = false;
    }
    r2.x = e4;
    r2.y = t2;
    r2.z = i2;
    r2.w = s2;
    this._handler && this._handler.setLineColorArr(this, r2);
    return this;
  }
  setStrokeColor4v(e4) {
    return this.setStrokeColor(e4.x, e4.y, e4.z, e4.w);
  }
  setLineColor4v(e4) {
    return this.setLineColor(e4.x, e4.y, e4.z, e4.w);
  }
  setStrokeOpacity(e4) {
    let t2 = this._style.strokeColor;
    t2.w = e4;
    return this.setStrokeColor(t2.x, t2.y, t2.z, e4);
  }
  setLineOpacity(e4) {
    let t2 = this._style.lineColor;
    t2.w = e4;
    return this.setLineColor(t2.x, t2.y, t2.z, e4);
  }
  setStrokeWidth(e4) {
    this._style.strokeWidth = e4;
    this._pickingReady = false;
    this._handler && this._handler.setLineStrokeArr(this, e4);
    return this;
  }
  bringToFront() {
    this._handler && this._handler.bringToFront(this);
    return this;
  }
  setLineWidth(e4) {
    this._style.lineWidth = e4;
    this._pickingReady = false;
    this._handler && this._handler.setLineThicknessArr(this, e4);
    return this;
  }
  setFillOpacity(e4) {
    let t2 = this._style.fillColor;
    if (t2.w === 0 && e4 !== 0 || t2.w !== 0 && e4 === 0) {
      this._pickingReady = false;
    }
    t2.w = e4;
    this._handler && this._handler.setPolyColorArr(this, t2);
    return this;
  }
  setVisibility(e4) {
    this._visibility = e4;
    this._handler && this._handler.setGeometryVisibility(this);
    return this;
  }
  getVisibility() {
    return this._visibility;
  }
  remove() {
    this._handler && this._handler.remove(this);
  }
  getExtent() {
    return this._extent.clone();
  }
  getType() {
    return this._type;
  }
};
_er.__counter__ = 0;
let er = _er;
class tr {
  constructor(e4 = 0, t2 = 0, i2 = 0) {
    this.a = e4;
    this.b = t2;
    this.c = i2;
  }
  static get(e4, t2) {
    return new tr(t2.y - e4.y, e4.x - t2.x, t2.x * e4.y - e4.x * t2.y);
  }
  static getParallel(e4, t2) {
    return new tr(e4.a, e4.b, -e4.a * t2.x - e4.b * t2.y);
  }
  static getIntersection(e4, t2) {
    let i2 = (t2.b * e4.c - e4.b * t2.c) / (e4.b * t2.a - t2.b * e4.a);
    return new Qe(i2, -(e4.c + e4.a * i2) / e4.b);
  }
  intersects(e4) {
    return tr.getIntersection(this, e4);
  }
}
class ir {
  constructor(e4, t2) {
    this.p0 = e4 || new Ke();
    this.p1 = t2 || new Ke();
  }
  getMagnitude() {
    return this.p0.distance(this.p1);
  }
  getSphereIntersection(e4) {
    let t2 = this.p0, i2 = this.p1;
    let s2 = e4.center.x, r2 = e4.center.y, n2 = e4.center.z;
    let o2 = t2.x, a2 = t2.y, l2 = t2.z;
    let h2 = i2.x - o2, c2 = i2.y - a2, d2 = i2.z - l2;
    let u2 = h2 * h2 + c2 * c2 + d2 * d2, _2 = 2 * (o2 * h2 + a2 * c2 + l2 * d2 - h2 * s2 - c2 * r2 - d2 * n2), f2 = o2 * o2 - 2 * o2 * s2 + s2 * s2 + a2 * a2 - 2 * a2 * r2 + r2 * r2 + l2 * l2 - 2 * l2 * n2 + n2 * n2 - e4.radius * e4.radius;
    let g2 = _2 * _2 - 4 * u2 * f2;
    if (g2 < 0) {
      return [];
    }
    let p2 = (-_2 - Math.sqrt(g2)) / (2 * u2);
    let m2 = new Ke(t2.x * (1 - p2) + p2 * i2.x, t2.y * (1 - p2) + p2 * i2.y, t2.z * (1 - p2) + p2 * i2.z);
    if (g2 == 0) {
      return [m2];
    }
    let v2 = (-_2 + Math.sqrt(g2)) / (2 * u2);
    let y2 = new Ke(t2.x * (1 - v2) + v2 * i2.x, t2.y * (1 - v2) + v2 * i2.y, t2.z * (1 - v2) + v2 * i2.z);
    if (Math.abs(p2 - 0.5) < Math.abs(v2 - 0.5)) {
      return [m2, y2];
    }
    return [y2, m2];
  }
  intersects(e4, t2, i2) {
    let s2 = this.p0.sub(e4.p0), r2 = e4.p1.sub(e4.p0);
    if (Math.abs(r2.x) < R && Math.abs(r2.y) < R && Math.abs(r2.z) < R) {
      return false;
    }
    let n2 = this.p1.sub(this.p0);
    if (Math.abs(n2.x) < R && Math.abs(n2.y) < R && Math.abs(n2.z) < R) {
      return false;
    }
    let o2 = s2.x * r2.x + s2.y * r2.y + s2.z * r2.z, a2 = r2.x * n2.x + r2.y * n2.y + r2.z * n2.z, l2 = s2.x * n2.x + s2.y * n2.y + s2.z * n2.z, h2 = r2.x * r2.x + r2.y * r2.y + r2.z * r2.z, c2 = n2.x * n2.x + n2.y * n2.y + n2.z * n2.z;
    let d2 = c2 * h2 - a2 * a2;
    if (Math.abs(d2) < R) {
      return false;
    }
    let u2 = o2 * a2 - l2 * h2;
    let _2 = u2 / d2;
    t2.x = this.p0.x + _2 * n2.x;
    t2.y = this.p0.y + _2 * n2.y;
    t2.z = this.p0.z + _2 * n2.z;
    if (i2) {
      let t3 = (o2 + a2 * _2) / h2;
      i2.x = e4.p0.x + t3 * r2.x;
      i2.y = e4.p0.y + t3 * r2.y;
      i2.z = e4.p0.z + t3 * r2.z;
    }
    return true;
  }
  getNearestDistancePoint(e4, t2) {
    let i2 = this.p0, s2 = this.p1;
    let r2 = this.getMagnitude();
    let n2 = ((e4.x - i2.x) * (s2.x - i2.x) + (e4.y - i2.y) * (s2.y - i2.y) + (e4.z - i2.z) * (s2.z - i2.z)) / (r2 * r2);
    t2.x = i2.x + n2 * (s2.x - i2.x);
    t2.y = i2.y + n2 * (s2.y - i2.y);
    t2.z = i2.z + n2 * (s2.z - i2.z);
    if (n2 < 0 || n2 > 1) {
      return false;
    }
    return true;
  }
}
const sr = 0;
const rr = 1;
const nr = 2;
class or {
  constructor(e4, t2) {
    this.p = e4 ? e4.clone() : new Ke();
    this.n = t2 ? t2.clone() : this.p.isZero() ? Ke.UP : this.p.getNormal();
  }
  setByPoints(e4, t2, i2) {
    let s2 = Ke.sub(t2, e4);
    let r2 = Ke.sub(i2, e4);
    this.n = s2.cross(r2);
    this.p.copy(e4);
    return this;
  }
  static fromPoints(e4, t2, i2) {
    return new or().setByPoints(e4, t2, i2);
  }
  set(e4, t2) {
    this.p.copy(e4);
    this.n.copy(t2);
  }
  getNormal() {
    return this.n.clone();
  }
  distance(e4) {
    let t2 = this.getProjection(e4);
    return e4.distance(t2);
  }
  getProjection(e4, t2) {
    return Ke.proj_b_to_plane(e4, this.n, t2);
  }
  getProjectionPoint(e4, t2) {
    let i2 = e4.sub(this.p), s2 = this.n, r2 = i2.dot(s2);
    if (t2) {
      t2.copy(s2.scale(r2));
    } else {
      t2 = s2.scale(r2);
    }
    return e4.sub(t2);
  }
  getIntersection(e4, t2, i2) {
    let s2 = e4.n.cross(t2.n);
    let r2 = s2.x >= 0 ? s2.x : -s2.x;
    let n2 = s2.y >= 0 ? s2.y : -s2.y;
    let o2 = s2.z >= 0 ? s2.z : -s2.z;
    if (r2 + n2 + o2 < E) {
      let i3 = t2.p.sub(e4.p);
      if (e4.n.dot(i3) == 0) {
        return rr;
      } else {
        return sr;
      }
    }
    let a2;
    if (r2 > n2) {
      if (r2 > o2) {
        a2 = 1;
      } else {
        a2 = 3;
      }
    } else {
      if (n2 > o2) {
        a2 = 2;
      } else {
        a2 = 3;
      }
    }
    let l2 = new Ke();
    let h2, c2;
    h2 = -e4.n.dot(e4.p);
    c2 = -t2.n.dot(t2.p);
    if (a2 === 1) {
      l2.x = 0;
      l2.y = (c2 * e4.n.z - h2 * t2.n.z) / s2.x;
      l2.z = (h2 * t2.n.y - c2 * e4.n.y) / s2.x;
    } else if (a2 === 2) {
      l2.x = (h2 * t2.n.z - c2 * e4.n.z) / s2.y;
      l2.y = 0;
      l2.z = (c2 * e4.n.x - h2 * t2.n.x) / s2.y;
    } else if (a2 === 3) {
      l2.x = (c2 * e4.n.y - h2 * t2.n.y) / s2.z;
      l2.y = (h2 * t2.n.x - c2 * e4.n.x) / s2.z;
      l2.z = 0;
    }
    i2.p0.copy(l2);
    i2.p1.copy(l2.add(s2));
    return nr;
  }
}
let ar = class e2 {
  constructor(e4 = Ke.ZERO, t2 = Ke.ZERO) {
    this.origin = e4;
    this.direction = t2;
  }
  static get OUTSIDE() {
    return 0;
  }
  static get INSIDE() {
    return 1;
  }
  static get INPLANE() {
    return 2;
  }
  static get AWAY() {
    return 3;
  }
  set(e4, t2) {
    this.origin = e4;
    this.direction = t2;
    return this;
  }
  getPoint(e4) {
    return Ke.add(this.origin, this.direction.scaleTo(e4));
  }
  hitTriangleRes(t2, i2, s2, r2) {
    let n2 = i2.sub(t2);
    let o2 = s2.sub(t2);
    let a2 = n2.cross(o2);
    let l2 = this.origin.sub(t2);
    let h2 = -a2.dot(l2);
    let c2 = a2.dot(this.direction);
    if (Math.abs(c2) < R) {
      if (h2 === 0) {
        r2.copy(this.origin);
        return e2.INPLANE;
      } else {
        return e2.OUTSIDE;
      }
    }
    let d2 = h2 / c2;
    r2.copy(this.origin.add(this.direction.scaleTo(d2)));
    if (d2 < 0) {
      return e2.AWAY;
    }
    let u2 = n2.dot(n2);
    let _2 = n2.dot(o2);
    let f2 = o2.dot(o2);
    let g2 = r2.sub(t2);
    let p2 = g2.dot(n2);
    let m2 = g2.dot(o2);
    let v2 = _2 * _2 - u2 * f2;
    let y2 = (_2 * m2 - f2 * p2) / v2;
    if (y2 < 0 || y2 > 1) {
      return e2.OUTSIDE;
    }
    let x2 = (_2 * p2 - u2 * m2) / v2;
    if (x2 < 0 || y2 + x2 > 1) {
      return e2.OUTSIDE;
    }
    return e2.INSIDE;
  }
  hitPlaneRes(t2, i2) {
    const s2 = this.direction.dot(t2.n);
    if (Math.abs(s2) < R) {
      return e2.OUTSIDE;
    }
    const r2 = t2.p.sub(this.origin).dot(t2.n) / s2;
    if (r2 < 0) {
      return e2.AWAY;
    }
    i2.copy(this.getPoint(r2));
    return e2.INSIDE;
  }
  hitSphere(e4) {
    const t2 = Ke.sub(this.origin, e4.center);
    const i2 = this.direction.dot(this.direction);
    const s2 = 2 * t2.dot(this.direction);
    const r2 = t2.dot(t2) - e4.radius * e4.radius;
    const n2 = s2 * s2 - 4 * i2 * r2;
    if (n2 < 0) {
      return null;
    }
    const o2 = Math.sqrt(n2);
    const a2 = (-s2 - o2) / (2 * i2);
    const l2 = (-s2 + o2) / (2 * i2);
    let h2 = a2;
    if (h2 < 0) h2 = l2;
    if (h2 < 0) return null;
    return Ke.add(this.origin, this.direction.scaleTo(h2));
  }
  hitBox(e4) {
  }
};
function lr(e4) {
  let t2 = e4.split("/");
  let i2 = t2[t2.length - 1];
  let s2 = t2[t2.length - 2];
  return `${s2 ? s2 + "/" : ""}${i2}`;
}
class hr {
  constructor() {
    this.objPositions = [];
    this.objTexcoords = [];
    this.objNormals = [];
    this.objVertexData = [this.objPositions, this.objTexcoords, this.objNormals];
    this.vertexData = [[], [], []];
    this._materialLibs = [];
    this.geometries = [];
    this.geometry = null;
    this.materials = {};
    this.material = {};
    this.object = "default";
    this.groups = ["default"];
    this._path = "";
    this.keywords = { v: (e4) => {
      this.objPositions.push(e4.map(parseFloat));
    }, vn: (e4) => {
      this.objNormals.push(e4.map(parseFloat));
    }, vt: (e4) => {
      this.objTexcoords.push([parseFloat(e4[0]), 1 - parseFloat(e4[1])]);
    }, f: (e4) => {
      this.setGeometry();
      const t2 = e4.length - 2;
      for (let i2 = 0; i2 < t2; ++i2) {
        this.addVertex(e4[0]);
        this.addVertex(e4[i2 + 1]);
        this.addVertex(e4[i2 + 2]);
      }
    }, s: () => {
    }, mtllib: (e4, t2) => {
      this._materialLibs.push(t2);
    }, usemtl: (e4, t2) => {
      this.newGeometry();
      this.setGeometry();
      if (this.geometry) {
        this.geometry.material = t2;
      }
    }, g: (e4) => {
      this.groups = e4;
      this.newGeometry();
    }, o: (e4, t2) => {
      this.object = t2;
      this.newGeometry();
    }, newmtl: (e4, t2) => {
      const i2 = {};
      this.material = i2;
      this.materials[t2] = i2;
    }, Ns: (e4, t2) => {
      this.material.shininess = parseFloat(t2);
    }, Ni: (e4, t2) => {
    }, Ka: (e4, t2) => {
      this.material.ambient = e4.map((e5) => parseFloat(e5));
    }, Kd: (e4, t2) => {
      this.material.diffuse = e4.map((e5) => parseFloat(e5));
    }, Ks: (e4, t2) => {
      this.material.specular = e4.map((e5) => parseFloat(e5));
    }, Ke: (e4, t2) => {
      this.material.color = e4.map((e5) => parseFloat(e5));
    }, illum: (e4, t2) => {
      this.material.illum = parseFloat(t2);
    }, d: (e4, t2) => {
      this.material.opacity = parseFloat(t2);
    }, Tr: (e4, t2) => {
      this.material.opacity = parseFloat(t2);
    }, Tf: (e4, t2) => {
    }, map_Ka: (e4, t2) => {
    }, map_Kd: (e4, t2) => {
      this.material.colorTexture = `${this._path}/${lr(t2)}`;
    }, map_Bump: (e4, t2) => {
      this.material.normalTexture = `${this._path}/${lr(t2)}`;
    }, map_Ns: (e4, t2) => {
      this.material.metallicRoughnessTexture = `${this._path}/${lr(t2)}`;
    } };
  }
  newGeometry() {
    if (this.geometry && this.geometry.data.vertices.length) {
      this.geometry = null;
    }
  }
  setGeometry() {
    if (!this.geometry) {
      const e4 = [];
      const t2 = [];
      const i2 = [];
      this.vertexData = [e4, t2, i2];
      this.geometry = { object: this.object, groups: this.groups, material: "", data: { vertices: e4, texCoords: t2, normals: i2 } };
      this.geometries.push(this.geometry);
    }
  }
  addVertex(e4) {
    let t2 = e4.split("/");
    for (let e5 = 0; e5 < t2.length; e5++) {
      let i2 = t2[e5];
      if (!i2) {
        continue;
      }
      let s2 = parseInt(i2) - 1;
      let r2 = this.vertexData[e5];
      let n2 = r2.length;
      let o2 = this.objVertexData[e5][s2];
      let a2 = o2.length;
      this.vertexData[e5].length = n2 + a2;
      for (let e6 = 0; e6 < a2; e6++) {
        r2[n2 + e6] = o2[e6];
      }
    }
  }
  _innerParser(e4, t2) {
    const i2 = /(\w*)(?: )*(.*)/;
    const s2 = e4.split("\n");
    for (let e5 = 0; e5 < s2.length; ++e5) {
      const r2 = s2[e5].trim();
      if (r2 === "" || r2.startsWith("#")) {
        continue;
      }
      const n2 = i2.exec(r2);
      if (!n2) {
        continue;
      }
      const [, o2, a2] = n2;
      const l2 = r2.split(/\s+/).slice(1);
      const h2 = this.keywords[o2];
      if (!h2) {
        console.warn(`Unknown keyword '${o2}' in '${t2}:${e5}'`);
        continue;
      }
      h2(l2, a2);
    }
  }
  get data() {
    return { geometries: this.geometries, materials: this.materials };
  }
  async load(e4) {
    this._path = e4.substring(0, e4.lastIndexOf("/"));
    const t2 = await fetch(e4);
    if (!t2.ok) {
      throw new Error(`Unable to load '${e4}'`);
    }
    const i2 = t2.body.getReader();
    const s2 = new TextDecoder();
    let { value: r2, done: n2 } = await i2.read();
    let o2 = "";
    while (!n2) {
      const t3 = s2.decode(r2, { stream: true });
      const a3 = (o2 + t3).split("\n");
      o2 = a3.pop();
      for (const t4 of a3) {
        this._innerParser(t4, e4);
      }
      ({ value: r2, done: n2 } = await i2.read());
    }
    if (o2) {
      this._innerParser(o2, e4);
    }
    this._cleanupGeometryArrays();
    let a2 = this._materialLibs.map((e5) => {
      e5 = `${this._path}/${e5}`;
      return fetch(e5).then((e6) => e6.text()).then((t3) => ({ text: t3, filename: e5 }));
    });
    await Promise.all(a2).then((e5) => {
      e5.forEach((e6) => this._innerParser(e6.text, e6.filename));
    });
    return this.data;
  }
  async _readAndParse(e4) {
    const t2 = e4.stream();
    const i2 = t2.getReader();
    const s2 = new TextDecoder();
    let { value: r2, done: n2 } = await i2.read();
    let o2 = "";
    while (!n2) {
      const t3 = s2.decode(r2, { stream: true });
      const a2 = (o2 + t3).split("\n");
      o2 = a2.pop();
      for (const t4 of a2) {
        this._innerParser(t4, e4.name);
      }
      ({ value: r2, done: n2 } = await i2.read());
    }
    if (o2) {
      this._innerParser(o2, e4.name);
    }
  }
  async readFile(e4, t2) {
    this._path = "";
    await this._readAndParse(e4);
    this._cleanupGeometryArrays();
    if (t2) {
      await this._readAndParse(t2);
    }
    return this.data;
  }
  _cleanupGeometryArrays() {
    for (const e4 of this.geometries) {
      e4.data = Object.fromEntries(Object.entries(e4.data).filter(([e5, t2]) => t2.length > 0));
    }
  }
}
function cr(e4) {
  if (e4 instanceof Array) {
    return new Float32Array(e4);
  } else if (typeof e4 === "string") {
    return ut(e4);
  }
  return new Float32Array([1, 1, 1, 1]);
}
function dr(e4) {
  let t2 = new Float32Array([1, 1, 1]);
  if (e4 instanceof Array) {
    t2[0] = e4[0];
    t2[1] = e4[1];
    t2[2] = e4[2];
  } else if (typeof e4 === "string") {
    let i2 = ut(e4);
    t2[0] = i2[0];
    t2[1] = i2[1];
    t2[2] = i2[2];
  }
  return t2;
}
class ur {
  constructor(e4 = {}) {
    this._name = e4.name || "noname";
    this._vertices = e4.vertices || [];
    this._numVertices = this._vertices.length / 3;
    this._texCoords = e4.texCoords || new Array(2 * this._numVertices);
    this.color = cr(e4.color);
    this.ambient = dr(e4.ambient);
    this.diffuse = dr(e4.diffuse);
    this.specular = dr(e4.specular);
    this.shininess = e4.shininess || 100;
    this.colorTexture = e4.colorTexture || "";
    this.normalTexture = e4.normalTexture || "";
    this.metallicRoughnessTexture = e4.metallicRoughnessTexture || "";
    if (e4.scale) {
      let t2 = e4.scale;
      let i2;
      if (typeof t2 === "number") {
        i2 = new Ke(t2, t2, t2);
      } else {
        i2 = t2;
      }
      ur.scale(this._vertices, i2);
    }
    if (e4.center) {
      ur.centering(this._vertices);
    }
    this.center = ur.getCenter(this._vertices);
    if (e4.indices) {
      this._indices = e4.indices;
      this._normals = e4.normals || [];
    } else {
      this._normals = e4.normals || ur.getNormals(this._vertices);
      this._indices = new Array(this._vertices.length / 3);
      for (let e5 = 0, t2 = this._indices.length; e5 < t2; e5++) {
        this._indices[e5] = e5;
      }
    }
  }
  static getCenter(e4) {
    let t2 = h, i2 = h, s2 = h, r2 = c, n2 = c, o2 = c;
    for (let a2 = 0, l2 = e4.length; a2 < l2; a2 += 3) {
      let l3 = e4[a2], h2 = e4[a2 + 1], c2 = e4[a2 + 2];
      if (l3 < t2) t2 = l3;
      if (h2 < i2) i2 = h2;
      if (c2 < s2) s2 = c2;
      if (l3 > r2) r2 = l3;
      if (h2 > n2) n2 = h2;
      if (c2 > o2) o2 = c2;
    }
    return new Ke(t2 + (r2 - t2) * 0.5, i2 + (n2 - i2) * 0.5, s2 + (o2 - s2) * 0.5);
  }
  static centering(e4) {
    let t2 = ur.getCenter(e4);
    for (let i2 = 0, s2 = e4.length; i2 < s2; i2 += 3) {
      e4[i2] -= t2.x;
      e4[i2 + 1] -= t2.y;
      e4[i2 + 2] -= t2.z;
    }
  }
  setMaterial(e4) {
    if (e4.ambient) {
      this.ambient = dr(e4.ambient);
    }
    if (e4.diffuse) {
      this.diffuse = dr(e4.diffuse);
    }
    if (e4.specular) {
      this.specular = dr(e4.specular);
    }
    if (e4.shininess !== void 0) {
      this.shininess = e4.shininess;
    }
    return this;
  }
  centering() {
    ur.centering(this._vertices);
    return this;
  }
  applyMat4(e4) {
    for (let t2 = 0, i2 = this._vertices.length; t2 < i2; t2 += 3) {
      let i3 = new Ke(this._vertices[t2], this._vertices[t2 + 1], this._vertices[t2 + 2]), s2 = new Ke(this._normals[t2], this._normals[t2 + 1], this._normals[t2 + 2]);
      i3 = e4.mulVec3(i3);
      s2 = e4.mulVec3(s2);
      this._vertices[t2] = i3.x;
      this._vertices[t2 + 1] = i3.y;
      this._vertices[t2 + 2] = i3.z;
      this._normals[t2] = s2.x;
      this._normals[t2 + 1] = s2.y;
      this._normals[t2 + 2] = s2.z;
    }
    return this;
  }
  scale(e4) {
    ur.scale(this._vertices, e4);
    return this;
  }
  translate(e4) {
    for (let t2 = 0, i2 = this._vertices.length; t2 < i2; t2 += 3) {
      this._vertices[t2] += e4.x;
      this._vertices[t2 + 1] += e4.y;
      this._vertices[t2 + 2] += e4.z;
    }
    return this;
  }
  get name() {
    return this._name;
  }
  get vertices() {
    return this._vertices;
  }
  get normals() {
    return this._normals;
  }
  get indices() {
    return this._indices;
  }
  get texCoords() {
    return this._texCoords;
  }
  get numVertices() {
    return this._numVertices;
  }
  static scale(e4, t2) {
    for (let i2 = 0; i2 < e4.length; i2 += 3) {
      e4[i2] *= t2.x;
      e4[i2 + 1] *= t2.y;
      e4[i2 + 2] *= t2.z;
    }
  }
  static centroid(e4) {
    let t2 = 1e3, i2 = 1e3, s2 = 1e3, r2 = -1e3, n2 = -1e3, o2 = -1e3;
    for (let a2 = 0; a2 < e4.length; a2 += 3) {
      let l2 = e4[a2], h2 = e4[a2 + 1], c2 = e4[a2 + 2];
      if (l2 < t2) t2 = l2;
      if (h2 < i2) i2 = h2;
      if (c2 < s2) s2 = c2;
      if (l2 > r2) r2 = l2;
      if (h2 > n2) n2 = h2;
      if (c2 > o2) o2 = c2;
    }
    return [t2 + (r2 - t2) * 0.5, i2 + (n2 - i2) * 0.5, s2 + (o2 - s2) * 0.5];
  }
  static translate(e4, t2) {
    for (let i2 = 0; i2 < e4.length; i2 += 3) {
      e4[i2] += t2[0];
      e4[i2 + 1] += t2[1];
      e4[i2 + 2] += t2[2];
    }
  }
  static getNormals(e4) {
    let t2 = new Array(e4.length);
    for (let i2 = 0; i2 < e4.length; i2 += 9) {
      let s2 = i2, r2 = i2 + 3, n2 = i2 + 6, o2 = e4[s2], a2 = e4[s2 + 1], l2 = e4[s2 + 2], h2 = e4[r2], c2 = e4[r2 + 1], d2 = e4[r2 + 2], u2 = e4[n2], _2 = e4[n2 + 1], f2 = e4[n2 + 2], g2 = h2 - o2, p2 = c2 - a2, m2 = d2 - l2, v2 = u2 - o2, y2 = _2 - a2, x2 = f2 - l2, b2 = p2 * x2 - m2 * y2, w2 = m2 * v2 - g2 * x2, C2 = g2 * y2 - p2 * v2;
      let T2 = Math.sqrt(b2 * b2 + w2 * w2 + C2 * C2);
      b2 /= T2;
      w2 /= T2;
      C2 /= T2;
      t2[s2] = b2;
      t2[s2 + 1] = w2;
      t2[s2 + 2] = C2;
      t2[r2] = b2;
      t2[r2 + 1] = w2;
      t2[r2 + 2] = C2;
      t2[n2] = b2;
      t2[n2 + 1] = w2;
      t2[n2 + 2] = C2;
    }
    return t2;
  }
  static createSphere(e4 = 16, t2 = 16, i2 = 1, s2 = 0, r2 = 0, n2 = 0) {
    let o2 = [], a2 = [], l2 = [];
    for (let a3 = 0; a3 <= t2; a3++) {
      let h2 = a3 * Math.PI / t2;
      let c2 = Math.sin(h2);
      let d2 = Math.cos(h2);
      for (let t3 = 0; t3 <= e4; t3++) {
        let a4 = t3 * 2 * Math.PI / e4;
        let h3 = Math.sin(a4);
        let u2 = Math.cos(a4);
        let _2 = u2 * c2 + s2;
        let f2 = d2 + r2;
        let g2 = h3 * c2 + n2;
        l2.push(_2);
        l2.push(f2);
        l2.push(g2);
        o2.push(i2 * _2);
        o2.push(i2 * f2);
        o2.push(i2 * g2);
      }
    }
    for (let i3 = 0; i3 < t2; i3++) {
      for (let t3 = 0; t3 < e4; t3++) {
        let s3 = i3 * (e4 + 1) + t3;
        let r3 = s3 + e4 + 1;
        a2.push(s3);
        a2.push(s3 + 1);
        a2.push(r3);
        a2.push(r3);
        a2.push(s3 + 1);
        a2.push(r3 + 1);
      }
    }
    return new ur({ vertices: o2, normals: l2, indices: a2 });
  }
  static createDisc(e4 = 1, t2 = 0, i2 = 8, s2 = true, r2 = 0, n2 = 0, o2 = 0, a2 = 0) {
    let l2 = [], h2 = [], c2 = [];
    let d2 = 0, u2 = Math.PI * 2;
    let _2 = s2 ? 1 : -1;
    let f2 = r2;
    for (let e5 = 1; e5 <= i2; e5++) {
      l2.push(n2, t2 * _2 + o2, a2);
      c2.push(0, _2, 0);
      r2++;
    }
    let g2 = r2;
    for (let s3 = 0; s3 <= i2; s3++) {
      let h3 = s3 / i2;
      let f3 = h3 * u2 + d2;
      let g3 = Math.cos(f3);
      let p2 = Math.sin(f3);
      l2.push(e4 * p2 + n2, t2 * _2 + o2, e4 * g3 + a2);
      c2.push(0, _2, 0);
      r2++;
    }
    for (let e5 = 0; e5 < i2; e5++) {
      let t3 = f2 + e5, i3 = g2 + e5;
      if (s2) {
        h2.push(i3, i3 + 1, t3);
      } else {
        h2.push(i3 + 1, i3, t3);
      }
    }
    return new ur({ vertices: l2, normals: c2, indices: h2 });
  }
  static getFrustumScaleByCameraAngles(e4, t2, i2) {
    return new Ke(2 * e4 * Math.tan(f * t2), 2 * e4 * Math.tan(f * i2), e4);
  }
  static getFrustumScaleByCameraAspectRatio(e4, t2, i2) {
    let s2 = _ * Math.atan(Math.tan(f * t2) / i2);
    return ur.getFrustumScaleByCameraAngles(e4, t2, s2);
  }
  static createFrustum(e4 = 1, t2 = 1, i2 = 1, s2 = 0, r2 = 0, n2 = 0) {
    t2 *= 0.5;
    i2 *= 0.5;
    return new ur({ vertices: [0 + s2, 0 + r2, 0 + n2, -1 * t2 + s2, 1 * i2 + r2, -1 * e4 + n2, 1 * t2 + s2, 1 * i2 + r2, -1 * e4 + n2, 0 + s2, 0 + r2, 0 + n2, 1 * t2 + s2, -1 * i2 + r2, -1 * e4 + n2, -1 * t2 + s2, -1 * i2 + r2, -1 * e4 + n2, 0 + s2, 0 + r2, 0 + n2, 1 * t2 + s2, 1 * i2 + r2, -1 * e4 + n2, 1 * t2 + s2, -1 * i2 + r2, -1 * e4 + n2, 0 + s2, 0 + r2, 0 + n2, -1 * t2 + s2, -1 * i2 + r2, -1 * e4 + n2, -1 * t2 + s2, 1 * i2 + r2, -1 * e4 + n2, 0 + s2, 0 + r2, 0 + n2, 1 * t2 + s2, 1 * i2 + r2, -1 * e4 + n2, -1 * t2 + s2, 1 * i2 + r2, -1 * e4 + n2, 0 + s2, 0 + r2, 0 + n2, -1 * t2 + s2, -1 * i2 + r2, -1 * e4 + n2, 1 * t2 + s2, -1 * i2 + r2, -1 * e4 + n2, 0 + s2, 0 + r2, 0 + n2, 1 * t2 + s2, -1 * i2 + r2, -1 * e4 + n2, 1 * t2 + s2, 1 * i2 + r2, -1 * e4 + n2, 0 + s2, 0 + r2, 0 + n2, -1 * t2 + s2, 1 * i2 + r2, -1 * e4 + n2, -1 * t2 + s2, -1 * i2 + r2, -1 * e4 + n2] });
  }
  static createCylinder(e4 = 1, t2 = 1, i2 = 1, s2 = 32, r2 = 1, n2 = true, o2 = true, a2 = 0, l2 = 0, h2 = 0) {
    let c2 = [], d2 = [], u2 = [];
    let _2 = 0, f2 = Math.PI * 2;
    let g2 = 0;
    let p2 = [];
    let m2 = new Ke();
    let v2 = (t2 - e4) / i2;
    for (let n3 = 0; n3 <= r2; n3++) {
      let o3 = [];
      let d3 = n3 / r2;
      let y2 = d3 * (t2 - e4) + e4;
      for (let e5 = 0; e5 <= s2; e5++) {
        let t3 = e5 / s2;
        let r3 = t3 * f2 + _2;
        let n4 = Math.sin(r3), p3 = Math.cos(r3);
        c2.push(y2 * n4 + a2, -d3 * i2 + i2 + l2, y2 * p3 + h2);
        m2.set(n4, v2, p3).normalize();
        u2.push(m2.x, m2.y, m2.z);
        o3.push(g2++);
      }
      p2.push(o3);
    }
    for (let e5 = 0; e5 < s2; e5++) {
      for (let t3 = 0; t3 < r2; t3++) {
        let i3 = p2[t3][e5], s3 = p2[t3 + 1][e5], r3 = p2[t3 + 1][e5 + 1], n3 = p2[t3][e5 + 1];
        d2.push(i3, s3, n3);
        d2.push(s3, r3, n3);
      }
    }
    if (e4 !== 0 && n2) {
      let t3 = ur.createDisc(e4, i2, s2, true, g2, a2, l2, h2);
      c2.push(...t3.vertices);
      u2.push(...t3.normals);
      d2.push(...t3.indices);
    }
    if (t2 !== 0 && o2) {
      let e5 = ur.createDisc(t2, 0, s2, false, g2 + (n2 ? 1 + 2 * s2 : 0), a2, l2, h2);
      c2.push(...e5.vertices);
      u2.push(...e5.normals);
      d2.push(...e5.indices);
    }
    return new ur({ vertices: c2, normals: u2, indices: d2 });
  }
  static createCube(e4 = 1, t2 = 1, i2 = 1, s2 = 0, r2 = 0, n2 = 0) {
    let o2 = e4 * 0.5 + s2, a2 = t2 * 0.5 + r2, l2 = i2 * 0.5 + n2;
    return new ur({ vertices: [-o2, -a2, l2, o2, -a2, -l2, o2, -a2, l2, -o2, -a2, l2, -o2, -a2, -l2, o2, -a2, -l2, -o2, a2, l2, o2, a2, l2, o2, a2, -l2, -o2, a2, l2, o2, a2, -l2, -o2, a2, -l2, -o2, -a2, l2, o2, -a2, l2, -o2, a2, l2, -o2, a2, l2, o2, -a2, l2, o2, a2, l2, -o2, -a2, -l2, -o2, a2, -l2, o2, -a2, -l2, -o2, a2, -l2, o2, a2, -l2, o2, -a2, -l2, o2, -a2, l2, o2, -a2, -l2, o2, a2, l2, o2, a2, l2, o2, -a2, -l2, o2, a2, -l2, -o2, -a2, l2, -o2, a2, l2, -o2, -a2, -l2, -o2, a2, l2, -o2, a2, -l2, -o2, -a2, -l2] });
  }
  static createPlane(e4 = 1, t2 = 1, i2 = 0, s2 = 0, r2 = 0) {
    let n2 = e4 * 0.5, o2 = s2, a2 = t2 * 0.5;
    return new ur({ vertices: [-n2 + i2, o2, a2 + r2, n2 + i2, o2, -a2 + r2, n2 + i2, o2, a2 + r2, -n2 + i2, o2, a2 + r2, -n2 + i2, o2, -a2 + r2, n2 + i2, o2, -a2 + r2, -n2 + i2, o2, a2 + r2, n2 + i2, o2, a2 + r2, n2 + i2, o2, -a2 + r2, -n2 + i2, o2, a2 + r2, n2 + i2, o2, -a2 + r2, -n2 + i2, o2, -a2 + r2] });
  }
  static createArrow(e4 = 0, t2 = 2.1, i2 = -15) {
    return new ur({ vertices: [0, t2, 0, 7, 0, 6, 0, 0, i2, 0, 0, e4, 7, 0, 6, 0, t2, 0, -7, 0, 6, 0, 0, e4, 0, t2, 0, -7, 0, 6, 0, t2, 0, 0, 0, i2, -7, 0, 6, 0, 0, i2, 0, 0, e4, 0, 0, e4, 0, 0, i2, 7, 0, 6] });
  }
  static async readFileObj(e4, t2, i2) {
    let s2 = new hr();
    const r2 = await s2.readFile(e4, t2);
    let n2 = r2.materials;
    return r2.geometries.map((e5) => {
      let t3 = n2[e5.material] || {};
      return new ur({ name: e5.object, vertices: e5.data.vertices, normals: e5.data.normals, texCoords: e5.data.texCoords, ambient: t3.ambient, diffuse: t3.diffuse, specular: t3.specular, shininess: t3.shininess, color: t3.color, colorTexture: i2 ? `${i2}/${t3.colorTexture}` : t3.colorTexture, normalTexture: i2 ? `${i2}/${t3.normalTexture}` : t3.normalTexture, metallicRoughnessTexture: i2 ? `${i2}/${t3.metallicRoughnessTexture}` : t3.metallicRoughnessTexture });
    });
  }
  static async loadObj(e4) {
    let t2 = new hr();
    const i2 = await t2.load(e4);
    let s2 = i2.materials;
    return i2.geometries.map((e5) => {
      let t3 = s2[e5.material] || {};
      return new ur({ name: e5.object, vertices: e5.data.vertices, normals: e5.data.normals, texCoords: e5.data.texCoords, ambient: t3.ambient, diffuse: t3.diffuse, specular: t3.specular, shininess: t3.shininess, color: t3.color, colorTexture: t3.colorTexture, normalTexture: t3.normalTexture, metallicRoughnessTexture: t3.metallicRoughnessTexture });
    });
  }
  merge(e4) {
    const t2 = this._vertices.length / 3;
    let i2 = this._vertices.length;
    this._vertices.length = i2 + e4._vertices.length;
    for (let t3 = 0; t3 < e4._vertices.length; t3++) {
      this._vertices[i2 + t3] = e4._vertices[t3];
    }
    i2 = this._normals.length;
    this._normals.length = i2 + e4._normals.length;
    for (let t3 = 0; t3 < e4._normals.length; t3++) {
      this._normals[i2 + t3] = e4._normals[t3];
    }
    i2 = this._texCoords.length;
    this._texCoords.length = i2 + e4._texCoords.length;
    for (let t3 = 0; t3 < e4._texCoords.length; t3++) {
      this._texCoords[i2 + t3] = e4._texCoords[t3];
    }
    i2 = this._indices.length;
    this._indices.length = i2 + e4._indices.length;
    for (let s2 = 0; s2 < e4._indices.length; s2++) {
      this._indices[i2 + s2] = e4._indices[s2] + t2;
    }
    this._numVertices = this._vertices.length / 3;
    return this;
  }
  static merge(e4, t2) {
    let i2 = new ur();
    let s2 = t2 ? t2 : e4.length;
    for (let t3 = 0; t3 < s2; t3++) {
      i2.merge(e4[t3]);
    }
    return i2;
  }
}
const _r = new Ke(0, 0, -1);
const _fr = class _fr {
  constructor(e4) {
    var _a2;
    this._handlerIndex = -1;
    this._tag = e4.tag || `tag_${_fr.__counter__++}`;
    this._entity = null;
    this._position = bt(e4.position);
    this._rtcPositionHigh = new Ke();
    this._rtcPositionLow = new Ke();
    this._scale = bt(e4.scale, new Ke(1, 1, 1));
    this._translate = bt(e4.translate, new Ke());
    this._localPosition = new Ke();
    this._color = Ct(e4.color, new $e(0.15, 0.15, 0.15, 1));
    this._handler = null;
    this._handlerIndex = -1;
    this._tagData = null;
    this._tagDataIndex = -1;
    let t2 = e4.object3d;
    if (!e4.object3d || ((_a2 = e4.object3d) == null ? void 0 : _a2.vertices.length) === 0) {
      t2 = new ur();
    }
    if (e4.objSrc) {
      this.setObjectSrc(e4.objSrc);
      this._objectSrc = e4.objSrc;
    }
    this._object3d = t2;
    this._visibility = e4.visibility != void 0 ? e4.visibility : true;
    this._children = [];
    this._direction = new Ke();
    this._qFrame = new Ze();
    this._qRot = Ze.IDENTITY;
  }
  get tag() {
    return this._tag;
  }
  getPosition() {
    return this._position;
  }
  get object3d() {
    return this._object3d;
  }
  get vertices() {
    return this._object3d.vertices;
  }
  get normals() {
    return this._object3d.normals;
  }
  get texCoords() {
    return this._object3d.texCoords;
  }
  get indices() {
    return this._object3d.indices;
  }
  setOpacity(e4) {
    this._color.w = e4;
    this.setColor(this._color.x, this._color.y, this._color.z, e4);
  }
  getOpacity() {
    return this._color.w;
  }
  setColor(e4, t2, i2, s2) {
    this._color.x = e4;
    this._color.y = t2;
    this._color.z = i2;
    s2 != void 0 && (this._color.w = s2);
    this._handler && this._handler.setRgbaArr(this._tagData, this._tagDataIndex, this._color);
  }
  setColor4v(e4) {
    this._color.x = e4.x;
    this._color.y = e4.y;
    this._color.z = e4.z;
    e4.w != void 0 && (this._color.w = e4.w);
    this._handler && this._handler.setRgbaArr(this._tagData, this._tagDataIndex, this._color);
  }
  setVisibility(e4) {
    this._visibility = e4;
    this._handler && this._handler.setVisibility(this._tagData, this._tagDataIndex, e4);
  }
  getVisibility() {
    return this._visibility;
  }
  setPosition(e4, t2, i2) {
    this._position.x = e4;
    this._position.y = t2;
    this._position.z = i2;
    this.updateRTCPosition();
    this.updateRotation();
  }
  updateRTCPosition() {
    if (this._handler) {
      this._handler.getRTCPosition(this._position, this._rtcPositionHigh, this._rtcPositionLow);
      this._handler.setRTCPositionArr(this._tagData, this._tagDataIndex, this._rtcPositionHigh, this._rtcPositionLow);
    }
  }
  setPosition3v(e4) {
    this.setPosition(e4.x, e4.y, e4.z);
  }
  setObject(e4) {
    this._object3d = e4;
  }
  setObjectSrc(e4) {
    this._objectSrc = e4;
    this._handler && this._handler.setObjectSrc(e4, this.tag);
  }
  setColorHTML(e4) {
    this.setColor4v(dt(e4));
  }
  setScale(e4) {
    this._scale.x = this._scale.y = this._scale.z = e4;
    this._handler && this._handler.setScaleArr(this._tagData, this._tagDataIndex, this._scale);
  }
  setScale3v(e4) {
    this._scale.copy(e4);
    this._handler && this._handler.setScaleArr(this._tagData, this._tagDataIndex, e4);
  }
  getScale() {
    return this._scale;
  }
  setTranslate3v(e4) {
    this._translate.copy(e4);
    this._handler && this._handler.setTranslateArr(this._tagData, this._tagDataIndex, e4);
  }
  getTranslate() {
    return this._translate.clone();
  }
  setLocalPosition3v(e4) {
    this._localPosition.copy(e4);
    this._handler && this._handler.setLocalPositionArr(this._tagData, this._tagDataIndex, e4);
  }
  getLocalPosition() {
    return this._localPosition.clone();
  }
  remove() {
    this._entity = null;
    this._handler && this._handler.remove(this);
  }
  setPickingColor3v(e4) {
    this._handler && this._handler.setPickingColorArr(this._tagData, this._tagDataIndex, e4);
  }
  setRotation(e4) {
    this._qRot.copy(e4);
    this._qRot.mulVec3Res(_r, this._direction).normalize();
    this.updateRotation();
  }
  getRotation() {
    return this._qRot;
  }
  updateRotation() {
    this._handler && this._handler.setQRotArr(this._tagData, this._tagDataIndex, this._qRot);
  }
  getDirection() {
    return this._direction.clone();
  }
};
_fr.__counter__ = 0;
let fr = _fr;
const gr = { RIGHT: 0, LEFT: 1, CENTER: 2 };
const pr = { left: gr.LEFT, right: gr.RIGHT, center: gr.CENTER };
class mr extends Zs {
  constructor(e4 = {}) {
    super(e4);
    this._handler = null;
    this._text = e4.text || "";
    this._face = xt(e4.face, "arial");
    this._size = e4.size || 24;
    this._outline = e4.outline != void 0 ? e4.outline : 0;
    this._outlineColor = Ct(e4.outlineColor, new $e(0, 0, 0, 1));
    this._align = e4.align ? pr[e4.align.trim().toLowerCase()] || gr.RIGHT : gr.RIGHT;
    this._fontIndex = 0;
    this._fontAtlas = null;
    this._isRTL = e4.isRTL || false;
    this._letterSpacing = e4.letterSpacing || 0;
  }
  setText(e4) {
    this._text = e4.toString();
    if (this._isReady && this._handler) {
      this._handler.setText(this._handlerIndex, e4, this._fontIndex, this._align, this._letterSpacing, this._isRTL);
    }
  }
  setLetterSpacing(e4) {
    this._letterSpacing = e4;
    if (this._isReady && this._handler) {
      this._handler.setText(this._handlerIndex, this._text, this._fontIndex, this._align, e4, this._isRTL);
    }
  }
  getLetterSpacing() {
    return this._letterSpacing;
  }
  setRtl(e4) {
    this._isRTL = e4;
    if (this._isReady && this._handler) {
      this._handler.setText(this._handlerIndex, this._text, this._fontIndex, this._align, this._letterSpacing, this._isRTL);
    }
  }
  getText() {
    return this._text;
  }
  setAlign(e4) {
    this._align = pr[e4.trim().toLowerCase()];
    if (this._isReady && this._handler) {
      this._handler.setText(this._handlerIndex, this._text, this._fontIndex, this._align, this._letterSpacing, this._isRTL);
    } else if (this._lockId !== $s) {
      this._lockId = qs;
    }
  }
  getAlign() {
    return this._align;
  }
  setFace(e4) {
    this._face = e4.trim();
    this.update();
  }
  getFace() {
    return this._face;
  }
  setSize(e4) {
    if (e4 !== this._size) {
      this._size = e4;
      if (this._isReady && this._handler) {
        this._handler.setSizeArr(this._handlerIndex, e4);
      } else if (this._lockId !== $s) {
        this._lockId = qs;
      }
    }
  }
  getSize() {
    return this._size;
  }
  setOutline(e4) {
    this._outline = e4;
    if (this._isReady && this._handler) {
      this._handler.setOutlineArr(this._handlerIndex, e4);
    } else if (this._lockId !== $s) {
      this._lockId = qs;
    }
  }
  getOutline() {
    return this._outline;
  }
  setOpacity(e4) {
    super.setOpacity(e4);
    this.setOutlineOpacity(e4);
  }
  setOutlineColor(e4, t2, i2, s2) {
    if (s2 !== this._outlineColor.w || e4 !== this._outlineColor.x || t2 !== this._outlineColor.y || i2 !== this._outlineColor.z) {
      this._outlineColor.x = e4;
      this._outlineColor.y = t2;
      this._outlineColor.z = i2;
      this._outlineColor.w = s2;
      if (this._isReady && this._handler) {
        this._handler.setOutlineColorArr(this._handlerIndex, this._outlineColor);
      } else if (this._lockId !== $s) {
        this._lockId = qs;
      }
    }
  }
  setOutlineColor4v(e4) {
    this.setOutlineColor(e4.x, e4.y, e4.z, e4.w);
  }
  setOutlineColorHTML(e4) {
    this.setOutlineColor4v(dt(e4));
  }
  getOutlineColor() {
    return this._outlineColor;
  }
  setOutlineOpacity(e4) {
    if (e4 !== this._outlineColor.w) {
      this._outlineColor.w = e4;
      if (this._isReady && this._handler) {
        this._handler.setOutlineColorArr(this._handlerIndex, this._outlineColor);
      } else if (this._lockId !== $s) {
        this._lockId = qs;
      }
    }
  }
  getOutlineOpacity() {
    return this._outlineColor.w;
  }
  async update() {
    if (this._fontAtlas) {
      const e4 = await this._fontAtlas.getFontIndex(this._face);
      this._applyFontIndex(e4);
    }
  }
  _applyFontIndex(e4) {
    this._fontIndex = e4;
    if (this._isReady && this._handler) {
      this._handler.setFontIndexArr(this._handlerIndex, this._fontIndex);
      this._handler.setText(this._handlerIndex, this._text, this._fontIndex, this._align, this._letterSpacing, this._isRTL);
    } else if (this._lockId !== $s) {
      this._lockId = qs;
    }
  }
  assignFontAtlas(e4) {
    if (!this._fontAtlas) {
      this._fontAtlas = e4;
    }
    this.update();
  }
  serializeWorkerData(e4) {
    if (this._handler) {
      return new Float32Array([e4, this._handler._maxLetters, this.getVisibility() ? 1 : 0, this._positionHigh.x, this._positionHigh.y, this._positionHigh.z, this._positionLow.x, this._positionLow.y, this._positionLow.z, this._size, this._offset.x, this._offset.y, this._offset.z, this._color.x, this._color.y, this._color.z, this._color.w, this._rotation, this._alignedAxis.x, this._alignedAxis.y, this._alignedAxis.z, this._fontIndex, this._outline, this._outlineColor.x, this._outlineColor.y, this._outlineColor.z, this._outlineColor.w, this._entity._pickingColor.x, this._entity._pickingColor.y, this._entity._pickingColor.z]);
    }
    return null;
  }
}
const vr = 0;
const yr = 1;
const xr = 2;
const _br = class _br {
  constructor(e4 = {}) {
    this.__id = _br.__counter__++;
    this.visibility = e4.visibility != void 0 ? e4.visibility : true;
    this.pointSize = e4.pointSize || 3;
    this.pickingScale = e4.pickingScale || 0;
    this._renderNode = null;
    this._entity = null;
    this._points = [];
    this._coordinatesData = [];
    this._colorData = [];
    this._pickingColorData = [];
    this._coordinatesBuffer = null;
    this._colorBuffer = null;
    this._pickingColorBuffer = null;
    this._handler = null;
    this._handlerIndex = -1;
    this._buffersUpdateCallbacks = [];
    this._buffersUpdateCallbacks[vr] = this._createCoordinatesBuffer;
    this._buffersUpdateCallbacks[yr] = this._createColorBuffer;
    this._buffersUpdateCallbacks[xr] = this._createPickingColorBuffer;
    this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
    if (e4.points) {
      this.setPoints(e4.points);
    }
  }
  clear() {
    this._points.length = 0;
    this._points = [];
    this._coordinatesData.length = 0;
    this._coordinatesData = [];
    this._colorData.length = 0;
    this._colorData = [];
    this._pickingColorData.length = 0;
    this._pickingColorData = [];
    this._deleteBuffers();
  }
  setVisibility(e4) {
    this.visibility = e4;
  }
  getVisibility() {
    return this.visibility;
  }
  setRenderNode(e4) {
    this._renderNode = e4;
    this._setPickingColors();
  }
  remove() {
    this._entity = null;
    this._handler && this._handler.remove(this);
  }
  setPoints(e4) {
    this.clear();
    for (let t2 = 0; t2 < e4.length; t2++) {
      let i2 = e4[t2];
      let s2 = new Ke(i2[0], i2[1], i2[2]), r2 = new $e(i2[3], i2[4], i2[5], i2[6] == void 0 ? 255 : i2[6]);
      this._coordinatesData.push(s2.x, s2.y, s2.z);
      this._colorData.push(r2.x / 255, r2.y / 255, r2.z / 255, r2.w / 255);
      let n2 = { _entity: this._entity, _pickingColor: new Ke(), _entityCollection: this._entity ? this._entity._entityCollection : null, index: t2, position: s2, color: r2, pointCloud: this, properties: i2[7] || {} };
      this._points.push(n2);
      if (this._renderNode && this._renderNode.renderer) {
        this._renderNode.renderer.assignPickingColor(n2);
        this._pickingColorData.push(n2._pickingColor.x / 255, n2._pickingColor.y / 255, n2._pickingColor.z / 255, 1);
      }
    }
    this._changedBuffers[vr] = true;
    this._changedBuffers[yr] = true;
    this._changedBuffers[xr] = true;
  }
  setPointPosition(e4, t2, i2, s2) {
    this._changedBuffers[vr] = true;
  }
  setPointColor(e4, t2, i2, s2, r2) {
    this._changedBuffers[yr] = true;
  }
  addPoints(e4) {
    this._changedBuffers[vr] = true;
    this._changedBuffers[yr] = true;
    this._changedBuffers[xr] = true;
  }
  addPoint(e4, t2) {
    this._changedBuffers[vr] = true;
    this._changedBuffers[yr] = true;
    this._changedBuffers[xr] = true;
  }
  getPoint(e4) {
    return this._points[e4];
  }
  removePoint(e4) {
    this._changedBuffers[vr] = true;
    this._changedBuffers[yr] = true;
    this._changedBuffers[xr] = true;
  }
  insertPoint(e4, t2) {
    this._changedBuffers[vr] = true;
    this._changedBuffers[yr] = true;
    this._changedBuffers[xr] = true;
  }
  draw() {
    if (this.visibility && this._coordinatesData.length) {
      this._update();
      let e4 = this._renderNode;
      let t2 = e4.renderer;
      let i2 = t2.handler.programs.pointCloud;
      let s2 = i2._program;
      let r2 = t2.handler.gl, n2 = s2.attributes, o2 = s2.uniforms;
      i2.activate();
      r2.uniformMatrix4fv(o2.projectionViewMatrix, false, t2.activeCamera.getProjectionViewMatrix());
      r2.uniform1f(o2.opacity, this._handler._entityCollection._fadingOpacity);
      r2.uniform1f(o2.pointSize, this.pointSize);
      r2.bindBuffer(r2.ARRAY_BUFFER, this._coordinatesBuffer);
      r2.vertexAttribPointer(n2.coordinates, this._coordinatesBuffer.itemSize, r2.FLOAT, false, 0, 0);
      r2.bindBuffer(r2.ARRAY_BUFFER, this._colorBuffer);
      r2.vertexAttribPointer(n2.colors, this._colorBuffer.itemSize, r2.FLOAT, false, 0, 0);
      r2.drawArrays(r2.POINTS, 0, this._coordinatesBuffer.numItems);
    }
  }
  drawPicking() {
    if (this.visibility && this._coordinatesData.length) {
      let e4 = this._renderNode;
      let t2 = e4.renderer;
      let i2 = t2.handler.programs.pointCloud;
      let s2 = i2._program;
      let r2 = t2.handler.gl, n2 = s2.attributes, o2 = s2.uniforms;
      i2.activate();
      r2.uniformMatrix4fv(o2.projectionViewMatrix, false, t2.activeCamera.getProjectionViewMatrix());
      r2.uniform1f(o2.opacity, this._handler._entityCollection._fadingOpacity);
      r2.uniform1f(o2.pointSize, this.pointSize + this.pickingScale);
      r2.bindBuffer(r2.ARRAY_BUFFER, this._coordinatesBuffer);
      r2.vertexAttribPointer(n2.coordinates, this._coordinatesBuffer.itemSize, r2.FLOAT, false, 0, 0);
      r2.bindBuffer(r2.ARRAY_BUFFER, this._pickingColorBuffer);
      r2.vertexAttribPointer(n2.colors, this._pickingColorBuffer.itemSize, r2.FLOAT, false, 0, 0);
      r2.drawArrays(r2.POINTS, 0, this._coordinatesBuffer.numItems);
    }
  }
  _update() {
    if (this._renderNode) {
      let e4 = this._changedBuffers.length;
      while (e4--) {
        if (this._changedBuffers[e4]) {
          this._buffersUpdateCallbacks[e4].call(this);
          this._changedBuffers[e4] = false;
        }
      }
    }
  }
  _deleteBuffers() {
    if (this._renderNode) {
      let e4 = this._renderNode.renderer, t2 = e4.handler.gl;
      t2.deleteBuffer(this._coordinatesBuffer);
      t2.deleteBuffer(this._colorBuffer);
      t2.deleteBuffer(this._pickingColorBuffer);
    }
    this._coordinatesBuffer = null;
    this._colorBuffer = null;
    this._pickingColorBuffer = null;
  }
  _createCoordinatesBuffer() {
    let e4 = this._renderNode.renderer.handler;
    e4.gl.deleteBuffer(this._coordinatesBuffer);
    this._coordinatesBuffer = e4.createArrayBuffer(new Float32Array(this._coordinatesData), 3, this._coordinatesData.length / 3);
  }
  _createColorBuffer() {
    let e4 = this._renderNode.renderer.handler;
    e4.gl.deleteBuffer(this._colorBuffer);
    this._colorBuffer = e4.createArrayBuffer(new Float32Array(this._colorData), 4, this._colorData.length / 4);
  }
  _createPickingColorBuffer() {
    let e4 = this._renderNode.renderer.handler;
    e4.gl.deleteBuffer(this._pickingColorBuffer);
    this._pickingColorBuffer = e4.createArrayBuffer(new Float32Array(this._pickingColorData), 4, this._pickingColorData.length / 4);
  }
  _setPickingColors() {
    if (this._renderNode && this._renderNode.renderer) {
      for (let e4 = 0; e4 < this._points.length; e4++) {
        let t2 = this._points[e4];
        t2._entity = this._entity;
        t2._entityCollection = this._entity._entityCollection;
        this._renderNode.renderer.assignPickingColor(t2);
        this._pickingColorData.push(t2._pickingColor.x / 255, t2._pickingColor.y / 255, t2._pickingColor.z / 255, 1);
      }
      this._changedBuffers[xr] = true;
    }
  }
};
_br.__counter__ = 0;
let br = _br;
const wr = 0;
const Cr = 1;
const Tr = 2;
const Er = "#0000FF";
const Ar = 0;
const Lr = 1;
const Pr = 2;
const Sr = 3;
const _Rr = class _Rr {
  constructor(e4 = {}) {
    this.__id = _Rr.__counter__++;
    this.__doubleToTwoFloats = Ke.doubleToTwoFloats;
    this.altitude = e4.altitude || 0;
    this.thickness = e4.thickness || 1.5;
    this._opacity = e4.opacity != void 0 ? e4.opacity : 1;
    this._defaultColor = ut(e4.color || Er, e4.opacity);
    this.visibility = e4.visibility != void 0 ? e4.visibility : true;
    this._closedLine = e4.isClosed || false;
    this._path3v = [];
    this._pathLengths = [];
    this._pathLonLat = [];
    this._pathLonLatMerc = [];
    this._pathColors = e4.pathColors ? Xt(e4.pathColors) : [];
    this._extent = new Ye();
    this._verticesHigh = [];
    this._verticesLow = [];
    this._orders = [];
    this._indexes = [];
    this._colors = [];
    this._verticesHighBuffer = null;
    this._verticesLowBuffer = null;
    this._ordersBuffer = null;
    this._indexesBuffer = null;
    this._colorsBuffer = null;
    this._pickingColor = [0, 0, 0];
    this._renderNode = null;
    this._entity = null;
    this._handler = null;
    this._handlerIndex = -1;
    this._buffersUpdateCallbacks = [];
    this._buffersUpdateCallbacks[wr] = this._createVerticesBuffer;
    this._buffersUpdateCallbacks[Cr] = this._createIndexBuffer;
    this._buffersUpdateCallbacks[Tr] = this._createColorsBuffer;
    this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
    let t2 = bt(e4.visibleSpherePosition).toArray();
    let i2 = e4.visibleSphereRadius || 0;
    this._visibleSphere = new Float32Array([...t2, i2]);
    if (e4.pathLonLat) {
      this.setPathLonLat(e4.pathLonLat);
    } else if (e4.path3v) {
      this.setPath3v(e4.path3v);
    }
    this._refresh();
  }
  __appendLineData3v(e4, t2, i2, s2, r2, n2, o2, a2, l2, h2, c2, d2, u2, _2) {
    var f2 = 0;
    var g2 = new Ke(), p2 = new Ke();
    if (u2) {
      u2.southWest.set(180, 90);
      u2.northEast.set(-180, -90);
    }
    if (a2.length > 0) {
      f2 = a2[a2.length - 5] + 9;
      a2.push(f2, f2);
    } else {
      a2.push(0, 0);
    }
    for (let A2 = 0, L2 = e4.length; A2 < L2; A2++) {
      var m2 = e4[A2], v2 = t2[A2];
      h2[A2] = [];
      d2[A2] = [];
      c2[A2] = [];
      if (m2.length === 0) {
        continue;
      }
      var y2 = f2;
      var x2;
      if (s2) {
        x2 = m2[m2.length - 1];
        if (x2 instanceof Array) {
          x2 = new Ke(x2[0], x2[1], x2[2]);
        }
      } else {
        var b2 = m2[0], w2 = m2[1] || b2;
        if (b2 instanceof Array) {
          b2 = new Ke(b2[0], b2[1], b2[2]);
        }
        if (w2 instanceof Array) {
          w2 = new Ke(w2[0], w2[1], w2[2]);
        }
        b2 = b2;
        w2 = w2;
        x2 = new Ke(b2.x + b2.x - w2.x, b2.y + b2.y - w2.y, b2.z + b2.z - w2.z);
      }
      let L3 = i2;
      if (v2 && v2[0]) {
        L3 = v2[0];
      }
      this.__doubleToTwoFloats(x2, g2, p2);
      r2.push(g2.x, g2.y, g2.z, g2.x, g2.y, g2.z, g2.x, g2.y, g2.z, g2.x, g2.y, g2.z);
      n2.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z, p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);
      let P2 = L3[Ar], S2 = L3[Lr], R2 = L3[Pr], M2 = L3[Sr] != void 0 ? L3[Sr] : 1;
      if (A2 > 0) {
        _2.push(P2, S2, R2, M2, P2, S2, R2, M2, P2, S2, R2, M2, P2, S2, R2, M2);
      }
      o2.push(1, -1, 2, -2);
      for (let e5 = 0, t3 = m2.length; e5 < t3; e5++) {
        var C2 = m2[e5];
        if (C2 instanceof Array) {
          C2 = new Ke(C2[0], C2[1], C2[2]);
        }
        c2[A2].push(C2);
        if (l2) {
          var T2 = l2.cartesianToLonLat(C2);
          h2[A2].push(T2);
          d2[A2].push(T2.forwardMercator());
          if (T2.lon < u2.southWest.lon) {
            u2.southWest.lon = T2.lon;
          }
          if (T2.lat < u2.southWest.lat) {
            u2.southWest.lat = T2.lat;
          }
          if (T2.lon > u2.northEast.lon) {
            u2.northEast.lon = T2.lon;
          }
          if (T2.lat > u2.northEast.lat) {
            u2.northEast.lat = T2.lat;
          }
        }
        if (v2 && v2[e5]) {
          L3 = v2[e5];
        }
        P2 = L3[Ar];
        S2 = L3[Lr];
        R2 = L3[Pr];
        M2 = L3[Sr] != void 0 ? L3[Sr] : 1;
        this.__doubleToTwoFloats(C2, g2, p2);
        r2.push(g2.x, g2.y, g2.z, g2.x, g2.y, g2.z, g2.x, g2.y, g2.z, g2.x, g2.y, g2.z);
        n2.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z, p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);
        _2.push(P2, S2, R2, M2, P2, S2, R2, M2, P2, S2, R2, M2, P2, S2, R2, M2);
        o2.push(1, -1, 2, -2);
        a2.push(f2++, f2++, f2++, f2++);
      }
      var E2;
      if (s2) {
        E2 = m2[0];
        if (E2 instanceof Array) {
          E2 = new Ke(E2[0], E2[1], E2[2]);
        }
        a2.push(y2, y2 + 1, y2 + 1, y2 + 1);
      } else {
        let e5 = m2[m2.length - 1], t3 = m2[m2.length - 2] || e5;
        if (e5 instanceof Array) {
          e5 = new Ke(e5[0], e5[1], e5[2]);
        } else {
          e5 = e5;
        }
        if (t3 instanceof Array) {
          t3 = new Ke(t3[0], t3[1], t3[2]);
        } else {
          t3 = t3;
        }
        E2 = new Ke(e5.x + e5.x - t3.x, e5.y + e5.y - t3.y, e5.z + e5.z - t3.z);
        a2.push(f2 - 1, f2 - 1, f2 - 1, f2 - 1);
      }
      if (v2 && v2[m2.length - 1]) {
        L3 = v2[m2.length - 1];
      }
      P2 = L3[Ar];
      S2 = L3[Lr];
      R2 = L3[Pr];
      M2 = L3[Sr] != void 0 ? L3[Sr] : 1;
      this.__doubleToTwoFloats(E2, g2, p2);
      r2.push(g2.x, g2.y, g2.z, g2.x, g2.y, g2.z, g2.x, g2.y, g2.z, g2.x, g2.y, g2.z);
      n2.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z, p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);
      _2.push(P2, S2, R2, M2, P2, S2, R2, M2, P2, S2, R2, M2, P2, S2, R2, M2);
      o2.push(1, -1, 2, -2);
      if (A2 < e4.length - 1 && e4[A2 + 1].length !== 0) {
        f2 += 8;
        a2.push(f2, f2);
      }
    }
  }
  __appendPoint3v(e4, t2, i2, s2, r2, n2, o2, a2, l2, h2, c2, d2, u2, _2) {
    var f2 = new Ke(), g2 = new Ke();
    var p2 = h2.length - 4, m2 = h2[p2 - 1] + 1;
    if (e4.length === 0) {
      e4.push([]);
      if (!i2[0]) {
        i2[0] = [];
      }
    } else if (!i2[e4.length - 1]) {
      i2[e4.length - 1] = [];
    }
    var v2 = e4[e4.length - 1], y2 = v2.length;
    v2.push(t2);
    let x2 = s2[Ar], b2 = s2[Lr], w2 = s2[Pr], C2 = s2[Sr] != void 0 ? s2[Sr] : 1, T2 = i2[e4.length - 1];
    if (T2[y2]) {
      T2[y2][Ar] = x2;
      T2[y2][Lr] = b2;
      T2[y2][Pr] = w2;
      T2[y2][Sr] = C2;
    } else {
      T2.push(s2);
    }
    if (y2 === 1) {
      var E2;
      if (r2) {
        E2 = v2[y2 - 1];
        if (E2 instanceof Array) {
          E2 = new Ke(E2[0], E2[1], E2[2]);
        }
      } else {
        let e6 = v2[0], t3 = v2[1] || e6;
        if (e6 instanceof Array) {
          e6 = new Ke(e6[0], e6[1], e6[2]);
        } else {
          e6 = e6;
        }
        if (t3 instanceof Array) {
          t3 = new Ke(t3[0], t3[1], t3[2]);
        } else {
          t3 = t3;
        }
        E2 = new Ke(e6.x + e6.x - t3.x, e6.y + e6.y - t3.y, e6.z + e6.z - t3.z);
      }
      this.__doubleToTwoFloats(E2, f2, g2);
      let e5 = n2.length - 3 * 12;
      n2[e5] = f2.x;
      n2[e5 + 1] = f2.y;
      n2[e5 + 2] = f2.z;
      n2[e5 + 3] = f2.x;
      n2[e5 + 4] = f2.y;
      n2[e5 + 5] = f2.z;
      n2[e5 + 6] = f2.x;
      n2[e5 + 7] = f2.y;
      n2[e5 + 8] = f2.z;
      n2[e5 + 9] = f2.x;
      n2[e5 + 10] = f2.y;
      n2[e5 + 11] = f2.z;
      o2[e5] = g2.x;
      o2[e5 + 1] = g2.y;
      o2[e5 + 2] = g2.z;
      o2[e5 + 3] = g2.x;
      o2[e5 + 4] = g2.y;
      o2[e5 + 5] = g2.z;
      o2[e5 + 6] = g2.x;
      o2[e5 + 7] = g2.y;
      o2[e5 + 8] = g2.z;
      o2[e5 + 9] = g2.x;
      o2[e5 + 10] = g2.y;
      o2[e5 + 11] = g2.z;
    }
    var A2 = m2;
    if (c2) {
      if (d2.length === 0) {
        d2.push([]);
      }
      if (u2.length === 0) {
        u2.push([]);
      }
      var L2 = d2[d2.length - 1], P2 = u2[u2.length - 1];
      let e5 = c2.cartesianToLonLat(t2);
      L2.push(e5);
      P2.push(e5.forwardMercator());
      if (e5.lon < _2.southWest.lon) {
        _2.southWest.lon = e5.lon;
      }
      if (e5.lat < _2.southWest.lat) {
        _2.southWest.lat = e5.lat;
      }
      if (e5.lon > _2.northEast.lon) {
        _2.northEast.lon = e5.lon;
      }
      if (e5.lat > _2.northEast.lat) {
        _2.northEast.lat = e5.lat;
      }
    }
    this.__doubleToTwoFloats(t2, f2, g2);
    let S2 = n2.length - 12;
    n2[S2] = f2.x;
    n2[S2 + 1] = f2.y;
    n2[S2 + 2] = f2.z;
    n2[S2 + 3] = f2.x;
    n2[S2 + 4] = f2.y;
    n2[S2 + 5] = f2.z;
    n2[S2 + 6] = f2.x;
    n2[S2 + 7] = f2.y;
    n2[S2 + 8] = f2.z;
    n2[S2 + 9] = f2.x;
    n2[S2 + 10] = f2.y;
    n2[S2 + 11] = f2.z;
    o2[S2] = g2.x;
    o2[S2 + 1] = g2.y;
    o2[S2 + 2] = g2.z;
    o2[S2 + 3] = g2.x;
    o2[S2 + 4] = g2.y;
    o2[S2 + 5] = g2.z;
    o2[S2 + 6] = g2.x;
    o2[S2 + 7] = g2.y;
    o2[S2 + 8] = g2.z;
    o2[S2 + 9] = g2.x;
    o2[S2 + 10] = g2.y;
    o2[S2 + 11] = g2.z;
    let R2 = a2.length - 16;
    a2[R2] = x2;
    a2[R2 + 1] = b2;
    a2[R2 + 2] = w2;
    a2[R2 + 3] = C2;
    a2[R2 + 4] = x2;
    a2[R2 + 5] = b2;
    a2[R2 + 6] = w2;
    a2[R2 + 7] = C2;
    a2[R2 + 8] = x2;
    a2[R2 + 9] = b2;
    a2[R2 + 10] = w2;
    a2[R2 + 11] = C2;
    a2[R2 + 12] = x2;
    a2[R2 + 13] = b2;
    a2[R2 + 14] = w2;
    a2[R2 + 15] = C2;
    h2[p2] = m2++;
    h2[p2 + 1] = m2++;
    h2[p2 + 2] = m2++;
    h2[p2 + 3] = m2++;
    var M2;
    if (r2) {
      M2 = v2[0];
      h2.push(A2, A2 + 1, A2 + 1, A2 + 1);
    } else {
      let e5 = v2[v2.length - 1], t3 = v2[v2.length - 2] || e5;
      M2 = new Ke(e5.x + e5.x - t3.x, e5.y + e5.y - t3.y, e5.z + e5.z - t3.z);
      h2.push(m2 - 1, m2 - 1, m2 - 1, m2 - 1);
    }
    this.__doubleToTwoFloats(M2, f2, g2);
    n2.push(f2.x, f2.y, f2.z, f2.x, f2.y, f2.z, f2.x, f2.y, f2.z, f2.x, f2.y, f2.z);
    o2.push(g2.x, g2.y, g2.z, g2.x, g2.y, g2.z, g2.x, g2.y, g2.z, g2.x, g2.y, g2.z);
    a2.push(x2, b2, w2, C2, x2, b2, w2, C2, x2, b2, w2, C2, x2, b2, w2, C2);
    l2.push(1, -1, 2, -2);
  }
  static setPathColors(e4, t2, i2, s2) {
    for (let a2 = 0, l2 = e4.length; a2 < l2; a2++) {
      var r2 = e4[a2], n2 = t2[a2];
      if (r2.length === 0) {
        continue;
      }
      let l3 = i2;
      if (n2 && n2[0]) {
        l3 = n2[0];
      }
      let h2 = l3[Ar], c2 = l3[Lr], d2 = l3[Pr], u2 = l3[Sr] != void 0 ? l3[Sr] : 1;
      if (a2 > 0) {
        s2.push(h2, c2, d2, u2, h2, c2, d2, u2, h2, c2, d2, u2, h2, c2, d2, u2);
      }
      for (let e5 = 0, t3 = r2.length; e5 < t3; e5++) {
        var o2 = r2[e5];
        if (o2 instanceof Array) {
          o2 = new be(o2[0], o2[1], o2[2]);
        }
        if (n2 && n2[e5]) {
          l3 = n2[e5];
        }
        h2 = l3[Ar];
        c2 = l3[Lr];
        d2 = l3[Pr];
        u2 = l3[Sr] != void 0 ? l3[Sr] : 1;
        s2.push(h2, c2, d2, u2, h2, c2, d2, u2, h2, c2, d2, u2, h2, c2, d2, u2);
      }
      if (n2 && n2[r2.length - 1]) {
        l3 = n2[r2.length - 1];
      }
      h2 = l3[Ar];
      c2 = l3[Lr];
      d2 = l3[Pr];
      u2 = l3[Sr] != void 0 ? l3[Sr] : 1;
      s2.push(h2, c2, d2, u2, h2, c2, d2, u2, h2, c2, d2, u2, h2, c2, d2, u2);
    }
  }
  __appendLineDataLonLat(e4, t2, i2, s2, r2, n2, o2, a2, l2, h2, c2, d2, u2, _2) {
    var f2 = 0;
    var g2 = new Ke(), p2 = new Ke();
    if (u2) {
      u2.southWest.set(180, 90);
      u2.northEast.set(-180, -90);
    }
    if (a2.length > 0) {
      f2 = a2[a2.length - 5] + 9;
      a2.push(f2);
    } else {
      a2.push(0);
    }
    for (let T2 = 0, E2 = e4.length; T2 < E2; T2++) {
      var m2 = e4[T2], v2 = t2[T2];
      h2[T2] = [];
      d2[T2] = [];
      c2[T2] = [];
      if (m2.length === 0) {
        continue;
      }
      var y2 = f2;
      var x2;
      if (s2) {
        let e5 = m2[m2.length - 1];
        if (e5 instanceof Array) {
          x2 = l2.lonLatToCartesian(new be(e5[0], e5[1], e5[2]));
        } else {
          x2 = l2.lonLatToCartesian(e5);
        }
      } else {
        let e5, t3;
        let i3 = m2[0];
        if (i3 instanceof Array) {
          e5 = l2.lonLatToCartesian(new be(i3[0], i3[1], i3[2]));
        } else {
          e5 = l2.lonLatToCartesian(i3);
        }
        i3 = m2[1];
        if (!i3) {
          i3 = m2[0];
        }
        if (i3 instanceof Array) {
          t3 = l2.lonLatToCartesian(new be(i3[0], i3[1], i3[2]));
        } else {
          t3 = l2.lonLatToCartesian(i3);
        }
        x2 = new Ke(e5.x + e5.x - t3.x, e5.y + e5.y - t3.y, e5.z + e5.z - t3.z);
      }
      let E3 = i2;
      if (v2 && v2[0]) {
        E3 = v2[0];
      }
      this.__doubleToTwoFloats(x2, g2, p2);
      r2.push(g2.x, g2.y, g2.z, g2.x, g2.y, g2.z, g2.x, g2.y, g2.z, g2.x, g2.y, g2.z);
      n2.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z, p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);
      let A2 = E3[Ar], L2 = E3[Lr], P2 = E3[Pr], S2 = E3[Sr] != void 0 ? E3[Sr] : 1;
      if (T2 > 0) {
        _2.push(A2, L2, P2, S2, A2, L2, P2, S2, A2, L2, P2, S2, A2, L2, P2, S2);
      }
      o2.push(1, -1, 2, -2);
      for (let e5 = 0, t3 = m2.length; e5 < t3; e5++) {
        var b2 = m2[e5];
        if (b2 instanceof Array) {
          b2 = new be(b2[0], b2[1], b2[2]);
        }
        if (v2 && v2[e5]) {
          E3 = v2[e5];
        }
        A2 = E3[Ar];
        L2 = E3[Lr];
        P2 = E3[Pr];
        S2 = E3[Sr] != void 0 ? E3[Sr] : 1;
        var w2 = l2.lonLatToCartesian(b2);
        h2[T2].push(w2);
        c2[T2].push(b2);
        d2[T2].push(b2.forwardMercator());
        this.__doubleToTwoFloats(w2, g2, p2);
        r2.push(g2.x, g2.y, g2.z, g2.x, g2.y, g2.z, g2.x, g2.y, g2.z, g2.x, g2.y, g2.z);
        n2.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z, p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);
        _2.push(A2, L2, P2, S2, A2, L2, P2, S2, A2, L2, P2, S2, A2, L2, P2, S2);
        o2.push(1, -1, 2, -2);
        a2.push(f2++, f2++, f2++, f2++);
        if (b2.lon < u2.southWest.lon) {
          u2.southWest.lon = b2.lon;
        }
        if (b2.lat < u2.southWest.lat) {
          u2.southWest.lat = b2.lat;
        }
        if (b2.lon > u2.northEast.lon) {
          u2.northEast.lon = b2.lon;
        }
        if (b2.lat > u2.northEast.lat) {
          u2.northEast.lat = b2.lat;
        }
      }
      var C2;
      if (s2) {
        let e5 = m2[0];
        if (e5 instanceof Array) {
          C2 = l2.lonLatToCartesian(new be(e5[0], e5[1], e5[2]));
        } else {
          C2 = l2.lonLatToCartesian(e5);
        }
        a2.push(y2, y2 + 1, y2 + 1, y2 + 1);
      } else {
        let e5, t3;
        let i3 = m2[m2.length - 1];
        if (i3 instanceof Array) {
          e5 = l2.lonLatToCartesian(new be(i3[0], i3[1], i3[2]));
        } else {
          e5 = l2.lonLatToCartesian(i3);
        }
        i3 = m2[m2.length - 2];
        if (!i3) {
          i3 = m2[0];
        }
        if (i3 instanceof Array) {
          t3 = l2.lonLatToCartesian(new be(i3[0], i3[1], i3[2]));
        } else {
          t3 = l2.lonLatToCartesian(i3);
        }
        C2 = new Ke(e5.x + e5.x - t3.x, e5.y + e5.y - t3.y, e5.z + e5.z - t3.z);
        a2.push(f2 - 1, f2 - 1, f2 - 1, f2 - 1);
      }
      if (v2 && v2[m2.length - 1]) {
        E3 = v2[m2.length - 1];
      }
      A2 = E3[Ar];
      L2 = E3[Lr];
      P2 = E3[Pr];
      S2 = E3[Sr] != void 0 ? E3[Sr] : 1;
      this.__doubleToTwoFloats(C2, g2, p2);
      r2.push(g2.x, g2.y, g2.z, g2.x, g2.y, g2.z, g2.x, g2.y, g2.z, g2.x, g2.y, g2.z);
      n2.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z, p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);
      _2.push(A2, L2, P2, S2, A2, L2, P2, S2, A2, L2, P2, S2, A2, L2, P2, S2);
      o2.push(1, -1, 2, -2);
      if (T2 < e4.length - 1 && e4[T2 + 1].length !== 0) {
        f2 += 8;
        a2.push(f2, f2);
      }
    }
  }
  _setEqualPath3v(e4) {
    var t2 = this._extent;
    t2.southWest.set(180, 90);
    t2.northEast.set(-180, -90);
    var i2 = new Ke(), s2 = new Ke();
    var r2 = this._verticesHigh, n2 = this._verticesLow, o2 = this._pathLonLat, a2 = this._pathLonLatMerc, l2 = 0;
    var h2 = this._renderNode.ellipsoid;
    for (let m2 = 0; m2 < e4.length; m2++) {
      var c2 = e4[m2];
      var d2;
      if (this._closedLine) {
        d2 = c2[c2.length - 1];
      } else {
        d2 = new Ke(c2[0].x + c2[0].x - c2[1].x, c2[0].y + c2[0].y - c2[1].y, c2[0].z + c2[0].z - c2[1].z);
      }
      this.__doubleToTwoFloats(d2, i2, s2);
      r2[l2] = i2.x;
      n2[l2++] = s2.x;
      r2[l2] = i2.y;
      n2[l2++] = s2.y;
      r2[l2] = i2.z;
      n2[l2++] = s2.z;
      r2[l2] = i2.x;
      n2[l2++] = s2.x;
      r2[l2] = i2.y;
      n2[l2++] = s2.y;
      r2[l2] = i2.z;
      n2[l2++] = s2.z;
      r2[l2] = i2.x;
      n2[l2++] = s2.x;
      r2[l2] = i2.y;
      n2[l2++] = s2.y;
      r2[l2] = i2.z;
      n2[l2++] = s2.z;
      r2[l2] = i2.x;
      n2[l2++] = s2.x;
      r2[l2] = i2.y;
      n2[l2++] = s2.y;
      r2[l2] = i2.z;
      n2[l2++] = s2.z;
      for (let e5 = 0; e5 < c2.length; e5++) {
        var u2 = c2[e5], _2 = this._path3v[m2][e5];
        _2.x = u2.x;
        _2.y = u2.y;
        _2.z = u2.z;
        if (h2) {
          var f2 = h2.cartesianToLonLat(u2);
          this._pathLonLat[m2][e5] = f2;
          o2[m2][e5] = f2;
          a2[m2][e5] = f2.forwardMercator();
          if (f2.lon < t2.southWest.lon) {
            t2.southWest.lon = f2.lon;
          }
          if (f2.lat < t2.southWest.lat) {
            t2.southWest.lat = f2.lat;
          }
          if (f2.lon > t2.northEast.lon) {
            t2.northEast.lon = f2.lon;
          }
          if (f2.lat > t2.northEast.lat) {
            t2.northEast.lat = f2.lat;
          }
        }
        this.__doubleToTwoFloats(u2, i2, s2);
        r2[l2] = i2.x;
        n2[l2++] = s2.x;
        r2[l2] = i2.y;
        n2[l2++] = s2.y;
        r2[l2] = i2.z;
        n2[l2++] = s2.z;
        r2[l2] = i2.x;
        n2[l2++] = s2.x;
        r2[l2] = i2.y;
        n2[l2++] = s2.y;
        r2[l2] = i2.z;
        n2[l2++] = s2.z;
        r2[l2] = i2.x;
        n2[l2++] = s2.x;
        r2[l2] = i2.y;
        n2[l2++] = s2.y;
        r2[l2] = i2.z;
        n2[l2++] = s2.z;
        r2[l2] = i2.x;
        n2[l2++] = s2.x;
        r2[l2] = i2.y;
        n2[l2++] = s2.y;
        r2[l2] = i2.z;
        n2[l2++] = s2.z;
      }
      var g2;
      if (this._closedLine) {
        g2 = c2[0];
      } else {
        var p2 = c2.length - 1;
        g2 = new Ke(c2[p2].x + c2[p2].x - c2[p2 - 1].x, c2[p2].y + c2[p2].y - c2[p2 - 1].y, c2[p2].z + c2[p2].z - c2[p2 - 1].z);
      }
      this.__doubleToTwoFloats(g2, i2, s2);
      r2[l2] = i2.x;
      n2[l2++] = s2.x;
      r2[l2] = i2.y;
      n2[l2++] = s2.y;
      r2[l2] = i2.z;
      n2[l2++] = s2.z;
      r2[l2] = i2.x;
      n2[l2++] = s2.x;
      r2[l2] = i2.y;
      n2[l2++] = s2.y;
      r2[l2] = i2.z;
      n2[l2++] = s2.z;
      r2[l2] = i2.x;
      n2[l2++] = s2.x;
      r2[l2] = i2.y;
      n2[l2++] = s2.y;
      r2[l2] = i2.z;
      n2[l2++] = s2.z;
      r2[l2] = i2.x;
      n2[l2++] = s2.x;
      r2[l2] = i2.y;
      n2[l2++] = s2.y;
      r2[l2] = i2.z;
      n2[l2++] = s2.z;
    }
  }
  _setEqualPathLonLat(e4) {
    var t2 = this._extent;
    t2.southWest.set(180, 90);
    t2.northEast.set(-180, -90);
    var i2 = new Ke(), s2 = new Ke();
    var r2 = this._verticesHigh, n2 = this._verticesLow, o2 = this._pathLonLat, a2 = this._pathLonLatMerc, l2 = this._path3v, h2 = 0;
    var c2 = this._renderNode.ellipsoid;
    for (let p2 = 0; p2 < e4.length; p2++) {
      var d2 = e4[p2];
      var u2;
      if (this._closedLine) {
        u2 = c2.lonLatToCartesian(d2[d2.length - 1]);
      } else {
        let e5 = c2.lonLatToCartesian(d2[0]), t3 = c2.lonLatToCartesian(d2[1]);
        u2 = new Ke(e5.x + e5.x - t3.x, e5.y + e5.y - t3.y, e5.z + e5.z - t3.z);
      }
      this.__doubleToTwoFloats(u2, i2, s2);
      r2[h2] = i2.x;
      n2[h2++] = s2.x;
      r2[h2] = i2.y;
      n2[h2++] = s2.y;
      r2[h2] = i2.z;
      n2[h2++] = s2.z;
      r2[h2] = i2.x;
      n2[h2++] = s2.x;
      r2[h2] = i2.y;
      n2[h2++] = s2.y;
      r2[h2] = i2.z;
      n2[h2++] = s2.z;
      r2[h2] = i2.x;
      n2[h2++] = s2.x;
      r2[h2] = i2.y;
      n2[h2++] = s2.y;
      r2[h2] = i2.z;
      n2[h2++] = s2.z;
      r2[h2] = i2.x;
      n2[h2++] = s2.x;
      r2[h2] = i2.y;
      n2[h2++] = s2.y;
      r2[h2] = i2.z;
      n2[h2++] = s2.z;
      for (let e5 = 0; e5 < d2.length; e5++) {
        var _2 = d2[e5];
        var f2 = c2.lonLatToCartesian(_2);
        l2[p2][e5] = f2;
        a2[p2][e5] = _2.forwardMercator();
        o2[p2][e5] = _2;
        this.__doubleToTwoFloats(f2, i2, s2);
        r2[h2] = i2.x;
        n2[h2++] = s2.x;
        r2[h2] = i2.y;
        n2[h2++] = s2.y;
        r2[h2] = i2.z;
        n2[h2++] = s2.z;
        r2[h2] = i2.x;
        n2[h2++] = s2.x;
        r2[h2] = i2.y;
        n2[h2++] = s2.y;
        r2[h2] = i2.z;
        n2[h2++] = s2.z;
        r2[h2] = i2.x;
        n2[h2++] = s2.x;
        r2[h2] = i2.y;
        n2[h2++] = s2.y;
        r2[h2] = i2.z;
        n2[h2++] = s2.z;
        r2[h2] = i2.x;
        n2[h2++] = s2.x;
        r2[h2] = i2.y;
        n2[h2++] = s2.y;
        r2[h2] = i2.z;
        n2[h2++] = s2.z;
        if (_2.lon < t2.southWest.lon) {
          t2.southWest.lon = _2.lon;
        }
        if (_2.lat < t2.southWest.lat) {
          t2.southWest.lat = _2.lat;
        }
        if (_2.lon > t2.northEast.lon) {
          t2.northEast.lon = _2.lon;
        }
        if (_2.lat > t2.northEast.lat) {
          t2.northEast.lat = _2.lat;
        }
      }
      var g2;
      if (this._closedLine) {
        g2 = c2.lonLatToCartesian(d2[0]);
      } else {
        let e5 = c2.lonLatToCartesian(d2[d2.length - 1]), t3 = c2.lonLatToCartesian(d2[d2.length - 2]);
        g2 = new Ke(e5.x + e5.x - t3.x, e5.y + e5.y - t3.y, e5.z + e5.z - t3.z);
      }
      this.__doubleToTwoFloats(g2, i2, s2);
      r2[h2] = i2.x;
      n2[h2++] = s2.x;
      r2[h2] = i2.y;
      n2[h2++] = s2.y;
      r2[h2] = i2.z;
      n2[h2++] = s2.z;
      r2[h2] = i2.x;
      n2[h2++] = s2.x;
      r2[h2] = i2.y;
      n2[h2++] = s2.y;
      r2[h2] = i2.z;
      n2[h2++] = s2.z;
      r2[h2] = i2.x;
      n2[h2++] = s2.x;
      r2[h2] = i2.y;
      n2[h2++] = s2.y;
      r2[h2] = i2.z;
      n2[h2++] = s2.z;
      r2[h2] = i2.x;
      n2[h2++] = s2.x;
      r2[h2] = i2.y;
      n2[h2++] = s2.y;
      r2[h2] = i2.z;
      n2[h2++] = s2.z;
    }
  }
  setPointLonLat(e4, t2, i2) {
    if (this._renderNode && this._renderNode.ellipsoid) {
      let a2 = this._pathLonLat, l2 = this._pathLonLatMerc;
      a2[i2][t2] = e4;
      l2[i2][t2] = e4.forwardMercator();
      var s2 = this._extent;
      s2.southWest.set(180, 90);
      s2.northEast.set(-180, -90);
      for (let e5 = 0; e5 < a2.length; e5++) {
        var r2 = a2[e5];
        for (let e6 = 0; e6 < r2.length; e6++) {
          var n2 = r2[e6].lon, o2 = r2[e6].lat;
          if (n2 > s2.northEast.lon) {
            s2.northEast.lon = n2;
          }
          if (o2 > s2.northEast.lat) {
            s2.northEast.lat = o2;
          }
          if (n2 < s2.southWest.lon) {
            s2.southWest.lon = n2;
          }
          if (o2 < s2.southWest.lat) {
            s2.southWest.lat = o2;
          }
        }
      }
      this.setPoint3v(this._renderNode.ellipsoid.lonLatToCartesian(e4), t2, i2, true);
    } else {
      let s3 = this._pathLonLat[i2];
      s3[t2].lon = e4.lon;
      s3[t2].lat = e4.lat;
      s3[t2].height = e4.height;
    }
  }
  setPoint3v(e4, t2 = 0, i2 = 0, s2 = false) {
    if (this._renderNode) {
      var r2 = new Ke(), n2 = new Ke();
      var o2 = this._verticesHigh, a2 = this._verticesLow, l2 = this._pathLonLat, h2 = this._pathLonLatMerc, c2 = 0, d2 = 0;
      d2 = this._pathLengths[i2] * 12 + 24 * i2;
      let x2 = this._path3v[i2];
      x2[t2].x = e4.x;
      x2[t2].y = e4.y;
      x2[t2].z = e4.z;
      let b2 = this._closedLine || x2.length === 1;
      if (t2 === 0 || t2 === 1) {
        var u2;
        if (b2) {
          u2 = x2[x2.length - 1];
        } else {
          u2 = new Ke(x2[0].x + x2[0].x - x2[1].x, x2[0].y + x2[0].y - x2[1].y, x2[0].z + x2[0].z - x2[1].z);
        }
        c2 = d2;
        this.__doubleToTwoFloats(u2, r2, n2);
        o2[c2] = r2.x;
        o2[c2 + 1] = r2.y;
        o2[c2 + 2] = r2.z;
        o2[c2 + 3] = r2.x;
        o2[c2 + 4] = r2.y;
        o2[c2 + 5] = r2.z;
        o2[c2 + 6] = r2.x;
        o2[c2 + 7] = r2.y;
        o2[c2 + 8] = r2.z;
        o2[c2 + 9] = r2.x;
        o2[c2 + 10] = r2.y;
        o2[c2 + 11] = r2.z;
        a2[c2] = n2.x;
        a2[c2 + 1] = n2.y;
        a2[c2 + 2] = n2.z;
        a2[c2 + 3] = n2.x;
        a2[c2 + 4] = n2.y;
        a2[c2 + 5] = n2.z;
        a2[c2 + 6] = n2.x;
        a2[c2 + 7] = n2.y;
        a2[c2 + 8] = n2.z;
        a2[c2 + 9] = n2.x;
        a2[c2 + 10] = n2.y;
        a2[c2 + 11] = n2.z;
      }
      if (!s2 && this._renderNode.ellipsoid) {
        var _2 = this._renderNode.ellipsoid.cartesianToLonLat(e4);
        l2[i2][t2] = _2;
        h2[i2][t2] = _2.forwardMercator();
        var f2 = this._extent;
        f2.southWest.set(180, 90);
        f2.northEast.set(-180, -90);
        for (let e5 = 0; e5 < l2.length; e5++) {
          var g2 = l2[e5];
          for (let e6 = 0; e6 < g2.length; e6++) {
            var p2 = g2[e6].lon, m2 = g2[e6].lat;
            if (p2 > f2.northEast.lon) {
              f2.northEast.lon = p2;
            }
            if (m2 > f2.northEast.lat) {
              f2.northEast.lat = m2;
            }
            if (p2 < f2.southWest.lon) {
              f2.southWest.lon = p2;
            }
            if (m2 < f2.southWest.lat) {
              f2.southWest.lat = m2;
            }
          }
        }
      }
      c2 = d2 + t2 * 12 + 12;
      this.__doubleToTwoFloats(e4, r2, n2);
      o2[c2] = r2.x;
      o2[c2 + 1] = r2.y;
      o2[c2 + 2] = r2.z;
      o2[c2 + 3] = r2.x;
      o2[c2 + 4] = r2.y;
      o2[c2 + 5] = r2.z;
      o2[c2 + 6] = r2.x;
      o2[c2 + 7] = r2.y;
      o2[c2 + 8] = r2.z;
      o2[c2 + 9] = r2.x;
      o2[c2 + 10] = r2.y;
      o2[c2 + 11] = r2.z;
      a2[c2] = n2.x;
      a2[c2 + 1] = n2.y;
      a2[c2 + 2] = n2.z;
      a2[c2 + 3] = n2.x;
      a2[c2 + 4] = n2.y;
      a2[c2 + 5] = n2.z;
      a2[c2 + 6] = n2.x;
      a2[c2 + 7] = n2.y;
      a2[c2 + 8] = n2.z;
      a2[c2 + 9] = n2.x;
      a2[c2 + 10] = n2.y;
      a2[c2 + 11] = n2.z;
      if (t2 === x2.length - 1 || t2 === x2.length - 2) {
        var v2;
        if (b2) {
          v2 = x2[0];
        } else {
          var y2 = x2.length - 1;
          v2 = new Ke(x2[y2].x + x2[y2].x - x2[y2 - 1].x, x2[y2].y + x2[y2].y - x2[y2 - 1].y, x2[y2].z + x2[y2].z - x2[y2 - 1].z);
        }
        c2 = d2 + x2.length * 12 + 12;
        this.__doubleToTwoFloats(v2, r2, n2);
        o2[c2] = r2.x;
        o2[c2 + 1] = r2.y;
        o2[c2 + 2] = r2.z;
        o2[c2 + 3] = r2.x;
        o2[c2 + 4] = r2.y;
        o2[c2 + 5] = r2.z;
        o2[c2 + 6] = r2.x;
        o2[c2 + 7] = r2.y;
        o2[c2 + 8] = r2.z;
        o2[c2 + 9] = r2.x;
        o2[c2 + 10] = r2.y;
        o2[c2 + 11] = r2.z;
        a2[c2] = n2.x;
        a2[c2 + 1] = n2.y;
        a2[c2 + 2] = n2.z;
        a2[c2 + 3] = n2.x;
        a2[c2 + 4] = n2.y;
        a2[c2 + 5] = n2.z;
        a2[c2 + 6] = n2.x;
        a2[c2 + 7] = n2.y;
        a2[c2 + 8] = n2.z;
        a2[c2 + 9] = n2.x;
        a2[c2 + 10] = n2.y;
        a2[c2 + 11] = n2.z;
      }
      this._changedBuffers[wr] = true;
    } else {
      let s3 = this._path3v[i2];
      s3[t2].x = e4.x;
      s3[t2].y = e4.y;
      s3[t2].z = e4.z;
    }
  }
  _resizePathLengths(e4 = 0) {
    this._pathLengths[0] = 0;
    for (let t2 = e4 + 1, i2 = this._path3v.length; t2 <= i2; t2++) {
      this._pathLengths[t2] = this._pathLengths[t2 - 1] + this._path3v[t2 - 1].length;
    }
  }
  removeSegment(e4) {
    this._path3v.splice(e4, 1);
    this.setPath3v([].concat(this._path3v));
  }
  removePoint(e4, t2 = 0) {
    this._path3v[t2].splice(e4, 1);
    if (this._path3v[t2].length === 0) {
      this._path3v.splice(t2, 1);
    }
    this.setPath3v([].concat(this._path3v));
  }
  insertPoint3v(e4, t2 = 0, i2, s2 = 0) {
    let r2 = [].concat(this._path3v), n2 = r2[s2];
    if (n2) {
      let o2 = [].concat(this._pathColors);
      n2.splice(t2, 0, e4);
      if (i2) {
        let e5 = o2[s2];
        if (!e5) {
          e5 = new Array(n2.length);
        }
        e5.splice(t2, 0, i2);
      }
      this.setPath3v(r2, o2);
    } else {
      this.addPoint3v(e4, s2);
    }
  }
  appendPoint3v(e4, t2, i2) {
    if (this._path3v.length === 0 || !this._renderNode) {
      this._pathColors.push([t2 || this._defaultColor]);
      this.addPoint3v(e4);
    } else {
      this._verticesHigh = Gt(this._verticesHigh);
      this._verticesLow = Gt(this._verticesLow);
      this._colors = Gt(this._colors);
      this._orders = Gt(this._orders);
      this._indexes = Gt(this._indexes);
      this.__appendPoint3v(this._path3v, e4, this._pathColors, t2 || this._defaultColor, this._closedLine, this._verticesHigh, this._verticesLow, this._colors, this._orders, this._indexes, !i2 ? this._renderNode.ellipsoid : null, this._pathLonLat, this._pathLonLatMerc, this._extent);
      this._pathLengths[this._path3v.length] += 1;
      this._changedBuffers[wr] = true;
      this._changedBuffers[Tr] = true;
      this._changedBuffers[Cr] = true;
    }
  }
  addPoint3v(e4, t2 = 0) {
    if (t2 >= this._path3v.length) {
      this._path3v.push([]);
    }
    this._path3v[t2].push(e4);
    this.setPath3v([].concat(this._path3v));
  }
  addPointLonLat(e4, t2 = 0) {
    if (t2 >= this._pathLonLat.length) {
      this._pathLonLat.push([]);
    }
    this._pathLonLat[t2].push(e4);
    this.setPathLonLat([].concat(this._pathLonLat));
  }
  clear() {
    this._clearData();
  }
  setPointColor(e4, t2 = 0, i2 = 0) {
    if (this._renderNode && t2 < this._path3v[i2].length) {
      let s2 = this._pathColors[i2];
      if (!s2) {
        if (this._path3v[i2] && t2 < this._path3v[i2].length) {
          this._pathColors[i2] = new Array(this._path3v[i2].length);
        } else {
          return;
        }
      }
      if (!s2[t2]) {
        s2[t2] = [e4[Ar], e4[Lr], e4[Pr], e4[Sr] || 1];
      } else {
        s2[t2][Ar] = e4[Ar];
        s2[t2][Lr] = e4[Lr];
        s2[t2][Pr] = e4[Pr];
        s2[t2][Sr] = e4[Sr] || 1;
      }
      let r2 = this._colors;
      let n2 = t2 * 16 + this._pathLengths[i2] * 16 + 32 * i2;
      r2[n2] = r2[n2 + 4] = r2[n2 + 8] = r2[n2 + 12] = e4[Ar];
      r2[n2 + 1] = r2[n2 + 5] = r2[n2 + 9] = r2[n2 + 13] = e4[Lr];
      r2[n2 + 2] = r2[n2 + 6] = r2[n2 + 10] = r2[n2 + 14] = e4[Pr];
      r2[n2 + 3] = r2[n2 + 7] = r2[n2 + 11] = r2[n2 + 15] = e4[Sr] || 1;
      this._changedBuffers[Tr] = true;
    } else {
      let s2 = this._pathColors[i2];
      s2[t2] = e4;
    }
  }
  setOpacity(e4) {
    this._opacity = e4;
  }
  getOpacity() {
    return this._opacity;
  }
  setAltitude(e4) {
    this.altitude = e4;
  }
  setThickness(e4) {
    this.thickness = e4;
  }
  getThickness() {
    return this.thickness;
  }
  setVisibility(e4) {
    this.visibility = e4;
  }
  getVisibility() {
    return this.visibility;
  }
  setRenderNode(e4) {
    if (e4) {
      this._renderNode = e4;
      if (this._pathLonLat.length) {
        this._createDataLonLat([].concat(this._pathLonLat));
      } else {
        this._createData3v([].concat(this._path3v));
      }
      this._refresh();
      if (e4.renderer && e4.renderer.isInitialized()) {
        this._update();
      }
    }
  }
  _clearData() {
    this._verticesHigh = null;
    this._verticesLow = null;
    this._orders = null;
    this._indexes = null;
    this._colors = null;
    this._verticesHigh = [];
    this._verticesLow = [];
    this._orders = [];
    this._indexes = [];
    this._colors = [];
    this._path3v.length = 0;
    this._pathLonLat.length = 0;
    this._pathLonLatMerc.length = 0;
    this._path3v = [];
    this._pathLonLat = [];
    this._pathLonLatMerc = [];
  }
  _createData3v(e4) {
    this._clearData();
    this.__appendLineData3v(e4, this._pathColors, this._defaultColor, this._closedLine, this._verticesHigh, this._verticesLow, this._orders, this._indexes, this._renderNode.ellipsoid, this._pathLonLat, this._path3v, this._pathLonLatMerc, this._extent, this._colors);
    this._resizePathLengths(0);
  }
  _createDataLonLat(e4) {
    this._clearData();
    this.__appendLineDataLonLat(e4, this._pathColors, this._defaultColor, this._closedLine, this._verticesHigh, this._verticesLow, this._orders, this._indexes, this._renderNode.ellipsoid, this._path3v, this._pathLonLat, this._pathLonLatMerc, this._extent, this._colors);
    this._resizePathLengths(0);
  }
  remove() {
    this._entity = null;
    this._pathColors.length = 0;
    this._pathColors = [];
    this._verticesHigh = null;
    this._verticesLow = null;
    this._orders = null;
    this._indexes = null;
    this._colors = null;
    this._verticesHigh = [];
    this._verticesLow = [];
    this._orders = [];
    this._indexes = [];
    this._colors = [];
    this._deleteBuffers();
    this._handler && this._handler.remove(this);
  }
  setPickingColor3v(e4) {
    this._pickingColor[0] = e4.x / 255;
    this._pickingColor[1] = e4.y / 255;
    this._pickingColor[2] = e4.z / 255;
  }
  getExtent() {
    return this._extent.clone();
  }
  getPath3v() {
    return this._path3v;
  }
  getPathLonLat() {
    return this._pathLonLat;
  }
  getPathColors() {
    return this._pathColors;
  }
  setPathColors(e4) {
    if (e4) {
      this._colors = [];
      this._pathColors = [].concat(e4);
      _Rr.setPathColors(this._pathLonLat, e4, this._defaultColor, this._colors);
      this._changedBuffers[Tr] = true;
    }
  }
  setColorHTML(e4) {
    this._defaultColor = ut(e4);
    let t2 = dt(e4), i2 = this._pathColors;
    for (let e5 = 0, s3 = i2.length; e5 < s3; e5++) {
      let s4 = i2[e5];
      for (let e6 = 0, i3 = s4.length; e6 < i3; e6++) {
        s4[e6][0] = t2.x;
        s4[e6][1] = t2.y;
        s4[e6][2] = t2.z;
        s4[e6][3] = t2.w;
      }
    }
    let s2 = this._colors;
    for (let e5 = 0, i3 = s2.length; e5 < i3; e5 += 4) {
      s2[e5] = t2.x;
      s2[e5 + 1] = t2.y;
      s2[e5 + 2] = t2.z;
      s2[e5 + 3] = t2.w;
    }
    this._changedBuffers[Tr] = true;
  }
  setPathLonLatFast(e4, t2) {
    this.setPathLonLat(e4, t2, true);
  }
  setPath3vFast(e4, t2) {
    this.setPath3v(e4, t2, true);
  }
  setPathLonLat(e4, t2, i2 = false) {
    if (t2) {
      this._pathColors = [].concat(t2);
    }
    if (this._renderNode && this._renderNode.ellipsoid) {
      if (i2) {
        this._setEqualPathLonLat(e4);
        this._changedBuffers[wr] = true;
        this._changedBuffers[Tr] = true;
      } else {
        this._createDataLonLat(e4);
        this._changedBuffers[wr] = true;
        this._changedBuffers[Cr] = true;
        this._changedBuffers[Tr] = true;
      }
    } else {
      this._pathLonLat = [].concat(e4);
    }
  }
  getSize(e4 = 0) {
    return this._path3v[e4].length;
  }
  setPath3v(e4, t2, i2 = false) {
    if (t2) {
      this._pathColors = [].concat(t2);
    }
    if (this._renderNode) {
      if (i2) {
        this._setEqualPath3v(e4);
        this._changedBuffers[wr] = true;
        this._changedBuffers[Tr] = true;
      } else {
        this._createData3v(e4);
        this._changedBuffers[wr] = true;
        this._changedBuffers[Cr] = true;
        this._changedBuffers[Tr] = true;
      }
    } else {
      this._path3v = [].concat(e4);
    }
  }
  draw() {
    if (this.visibility && this._path3v.length) {
      this._update();
      let e4 = this._renderNode;
      let t2 = e4.renderer;
      let i2 = t2.handler.programs.polyline_screen;
      let s2 = i2._program;
      let r2 = t2.handler.gl, n2 = s2.attributes, o2 = s2.uniforms;
      let a2 = this._handler._entityCollection;
      i2.activate();
      r2.disable(r2.CULL_FACE);
      r2.uniform1f(o2.depthOffset, a2.polygonOffsetUnits);
      r2.uniformMatrix4fv(o2.proj, false, t2.activeCamera.getProjectionMatrix());
      r2.uniformMatrix4fv(o2.view, false, t2.activeCamera.getViewMatrix());
      r2.uniform3fv(o2.rtcEyePositionHigh, this._handler._rtcEyePositionHigh);
      r2.uniform3fv(o2.rtcEyePositionLow, this._handler._rtcEyePositionLow);
      r2.uniform4fv(o2.visibleSphere, this._visibleSphere);
      r2.uniform2fv(o2.viewport, [t2.handler.canvas.width, t2.handler.canvas.height]);
      r2.uniform1f(o2.thickness, this.thickness * 0.5);
      r2.uniform1f(o2.opacity, this._opacity * a2._fadingOpacity);
      r2.bindBuffer(r2.ARRAY_BUFFER, this._colorsBuffer);
      r2.vertexAttribPointer(n2.color, this._colorsBuffer.itemSize, r2.FLOAT, false, 0, 0);
      let l2 = this._verticesHighBuffer;
      r2.bindBuffer(r2.ARRAY_BUFFER, l2);
      r2.vertexAttribPointer(n2.prevHigh, l2.itemSize, r2.FLOAT, false, 12, 0);
      r2.vertexAttribPointer(n2.currentHigh, l2.itemSize, r2.FLOAT, false, 12, 48);
      r2.vertexAttribPointer(n2.nextHigh, l2.itemSize, r2.FLOAT, false, 12, 96);
      l2 = this._verticesLowBuffer;
      r2.bindBuffer(r2.ARRAY_BUFFER, l2);
      r2.vertexAttribPointer(n2.prevLow, l2.itemSize, r2.FLOAT, false, 12, 0);
      r2.vertexAttribPointer(n2.currentLow, l2.itemSize, r2.FLOAT, false, 12, 48);
      r2.vertexAttribPointer(n2.nextLow, l2.itemSize, r2.FLOAT, false, 12, 96);
      r2.bindBuffer(r2.ARRAY_BUFFER, this._ordersBuffer);
      r2.vertexAttribPointer(n2.order, this._ordersBuffer.itemSize, r2.FLOAT, false, 4, 0);
      r2.bindBuffer(r2.ELEMENT_ARRAY_BUFFER, this._indexesBuffer);
      r2.drawElements(r2.TRIANGLE_STRIP, this._indexesBuffer.numItems, r2.UNSIGNED_INT, 0);
      r2.enable(r2.CULL_FACE);
    }
  }
  drawPicking() {
    if (this.visibility && this._path3v.length) {
      let e4 = this._renderNode;
      let t2 = e4.renderer;
      let i2 = t2.handler.programs.polyline_picking;
      let s2 = i2._program;
      let r2 = t2.handler.gl, n2 = s2.attributes, o2 = s2.uniforms;
      let a2 = this._handler._entityCollection;
      i2.activate();
      r2.disable(r2.CULL_FACE);
      r2.uniform1f(o2.depthOffset, a2.polygonOffsetUnits);
      r2.uniformMatrix4fv(o2.proj, false, t2.activeCamera.getProjectionMatrix());
      r2.uniformMatrix4fv(o2.view, false, t2.activeCamera.getViewMatrix());
      r2.uniform4fv(o2.color, [this._pickingColor[0], this._pickingColor[1], this._pickingColor[2], 1]);
      r2.uniform3fv(o2.rtcEyePositionHigh, this._handler._rtcEyePositionHigh);
      r2.uniform3fv(o2.rtcEyePositionLow, this._handler._rtcEyePositionLow);
      r2.uniform4fv(o2.visibleSphere, this._visibleSphere);
      r2.uniform2fv(o2.viewport, [t2.handler.canvas.width, t2.handler.canvas.height]);
      r2.uniform1f(o2.thickness, this.thickness * 0.5 * a2.pickingScale[0]);
      let l2 = this._verticesHighBuffer;
      r2.bindBuffer(r2.ARRAY_BUFFER, l2);
      r2.vertexAttribPointer(n2.prevHigh, l2.itemSize, r2.FLOAT, false, 12, 0);
      r2.vertexAttribPointer(n2.currentHigh, l2.itemSize, r2.FLOAT, false, 12, 48);
      r2.vertexAttribPointer(n2.nextHigh, l2.itemSize, r2.FLOAT, false, 12, 96);
      l2 = this._verticesLowBuffer;
      r2.bindBuffer(r2.ARRAY_BUFFER, l2);
      r2.vertexAttribPointer(n2.prevLow, l2.itemSize, r2.FLOAT, false, 12, 0);
      r2.vertexAttribPointer(n2.currentLow, l2.itemSize, r2.FLOAT, false, 12, 48);
      r2.vertexAttribPointer(n2.nextLow, l2.itemSize, r2.FLOAT, false, 12, 96);
      r2.bindBuffer(r2.ARRAY_BUFFER, this._ordersBuffer);
      r2.vertexAttribPointer(n2.order, this._ordersBuffer.itemSize, r2.FLOAT, false, 4, 0);
      r2.bindBuffer(r2.ELEMENT_ARRAY_BUFFER, this._indexesBuffer);
      r2.drawElements(r2.TRIANGLE_STRIP, this._indexesBuffer.numItems, r2.UNSIGNED_INT, 0);
      r2.enable(r2.CULL_FACE);
    }
  }
  _refresh() {
    let e4 = this._changedBuffers.length;
    while (e4--) {
      this._changedBuffers[e4] = true;
    }
  }
  _update() {
    if (this._renderNode) {
      let e4 = this._changedBuffers.length;
      while (e4--) {
        if (this._changedBuffers[e4]) {
          this._buffersUpdateCallbacks[e4].call(this);
          this._changedBuffers[e4] = false;
        }
      }
    }
  }
  _deleteBuffers() {
    if (this._renderNode) {
      let e4 = this._renderNode.renderer, t2 = e4.handler.gl;
      t2.deleteBuffer(this._verticesHighBuffer);
      t2.deleteBuffer(this._verticesLowBuffer);
      t2.deleteBuffer(this._ordersBuffer);
      t2.deleteBuffer(this._indexesBuffer);
      t2.deleteBuffer(this._colorsBuffer);
      this._verticesHighBuffer = null;
      this._verticesLowBuffer = null;
      this._ordersBuffer = null;
      this._indexesBuffer = null;
      this._colorsBuffer = null;
    }
  }
  _createVerticesBuffer() {
    let e4 = this._renderNode.renderer.handler;
    let t2 = this._verticesHigh.length / 3;
    if (!this._verticesHighBuffer || this._verticesHighBuffer.numItems !== t2) {
      e4.gl.deleteBuffer(this._verticesHighBuffer);
      e4.gl.deleteBuffer(this._verticesLowBuffer);
      this._verticesHighBuffer = e4.createStreamArrayBuffer(3, t2);
      this._verticesLowBuffer = e4.createStreamArrayBuffer(3, t2);
    }
    this._verticesHigh = Ut(this._verticesHigh);
    this._verticesLow = Ut(this._verticesLow);
    e4.setStreamArrayBuffer(this._verticesHighBuffer, this._verticesHigh);
    e4.setStreamArrayBuffer(this._verticesLowBuffer, this._verticesLow);
  }
  _createIndexBuffer() {
    let e4 = this._renderNode.renderer.handler;
    e4.gl.deleteBuffer(this._ordersBuffer);
    e4.gl.deleteBuffer(this._indexesBuffer);
    this._orders = Ut(this._orders);
    this._ordersBuffer = e4.createArrayBuffer(this._orders, 1, this._orders.length / 2);
    this._indexes = Ut(this._indexes, Uint32Array);
    this._indexesBuffer = e4.createElementArrayBuffer(this._indexes, 1, this._indexes.length);
  }
  _createColorsBuffer() {
    let e4 = this._renderNode.renderer.handler;
    e4.gl.deleteBuffer(this._colorsBuffer);
    this._colors = Ut(this._colors);
    this._colorsBuffer = e4.createArrayBuffer(new Float32Array(this._colors), 4, this._colors.length / 4);
  }
  setVisibleSphere(e4, t2) {
    if (this._handler) {
      this._visibleSphere[0] = e4.x - this._handler._relativeCenter.x;
      this._visibleSphere[1] = e4.y - this._handler._relativeCenter.y;
      this._visibleSphere[2] = e4.z - this._handler._relativeCenter.z;
    }
    this._visibleSphere[3] = t2;
  }
  updateRTCPosition() {
    if (this._handler && this._renderNode) {
      this._visibleSphere[0] = this._visibleSphere[0] - this._handler._relativeCenter.x;
      this._visibleSphere[1] = this._visibleSphere[1] - this._handler._relativeCenter.y;
      this._visibleSphere[2] = this._visibleSphere[2] - this._handler._relativeCenter.z;
      this._setEqualPath3v(this._path3v);
    }
    this._changedBuffers[wr] = true;
  }
};
_Rr.__counter__ = 0;
let Rr = _Rr;
const _Mr = class _Mr {
  constructor(e4 = {}) {
    this.__id = _Mr.__counter__++;
    this._thickness = e4.thickness || 2;
    this._startPosition = bt(e4.startPosition);
    this._startPositionHigh = new Ke();
    this._startPositionLow = new Ke();
    Ke.doubleToTwoFloats(this._startPosition, this._startPositionHigh, this._startPositionLow);
    this._endPosition = bt(e4.endPosition);
    this._endPositionHigh = new Ke();
    this._endPositionLow = new Ke();
    Ke.doubleToTwoFloats(this._endPosition, this._endPositionHigh, this._endPositionLow);
    this._startColor = Ct(e4.startColor);
    this._endColor = Ct(e4.endColor);
    this._visibility = e4.visibility != void 0 ? e4.visibility : true;
    this._entity = null;
    this._handler = null;
    this._handlerIndex = -1;
  }
  setStartPosition(e4, t2, i2) {
    this._startPosition.x = e4;
    this._startPosition.y = t2;
    this._startPosition.z = i2;
    Ke.doubleToTwoFloats(this._startPosition, this._startPositionHigh, this._startPositionLow);
    this._handler && this._handler.setStartPositionArr(this._handlerIndex, this._startPositionHigh, this._startPositionLow);
  }
  getLength() {
    return this._startPosition.distance(this._endPosition);
  }
  setStartPosition3v(e4) {
    this._startPosition.x = e4.x;
    this._startPosition.y = e4.y;
    this._startPosition.z = e4.z;
    Ke.doubleToTwoFloats(this._startPosition, this._startPositionHigh, this._startPositionLow);
    this._handler && this._handler.setStartPositionArr(this._handlerIndex, this._startPositionHigh, this._startPositionLow);
  }
  setEndPosition(e4, t2, i2) {
    this._endPosition.x = e4;
    this._endPosition.y = t2;
    this._endPosition.z = i2;
    Ke.doubleToTwoFloats(this._endPosition, this._endPositionHigh, this._endPositionLow);
    this._handler && this._handler.setEndPositionArr(this._handlerIndex, this._endPositionHigh, this._endPositionLow);
  }
  setEndPosition3v(e4) {
    this._endPosition.x = e4.x;
    this._endPosition.y = e4.y;
    this._endPosition.z = e4.z;
    Ke.doubleToTwoFloats(this._endPosition, this._endPositionHigh, this._endPositionLow);
    this._handler && this._handler.setEndPositionArr(this._handlerIndex, this._endPositionHigh, this._endPositionLow);
  }
  setThickness(e4) {
    this._thickness = e4;
    this._handler && this._handler.setThicknessArr(this._handlerIndex, e4);
  }
  setColors4v(e4, t2) {
    if (e4) {
      this._startColor.x = e4.x;
      this._startColor.y = e4.y;
      this._startColor.z = e4.z;
      this._startColor.w = e4.w;
    }
    if (t2) {
      this._endColor.x = t2.x;
      this._endColor.y = t2.y;
      this._endColor.z = t2.z;
      this._endColor.w = t2.w;
    }
    this._handler && this._handler.setRgbaArr(this._handlerIndex, this._startColor, this._endColor);
  }
  setColorsHTML(e4, t2) {
    if (e4) {
      this._startColor = dt(e4);
    }
    if (t2) {
      this._endColor = dt(t2);
    }
    this._handler && this._handler.setRgbaArr(this._handlerIndex, this._startColor, this._endColor);
  }
  getStartPosition() {
    return this._startPosition;
  }
  getEndPosition() {
    return this._endPosition;
  }
  setVisibility(e4) {
    this._visibility = e4;
    this._handler && this._handler.setVisibility(this._handlerIndex, e4);
  }
  getVisibility() {
    return this._visibility;
  }
  remove() {
    this._entity = null;
    this._handler && this._handler.remove(this);
  }
  setPickingColor3v(e4) {
    this._handler && this._handler.setPickingColorArr(this._handlerIndex, e4);
  }
};
_Mr.__counter__ = 0;
let Mr = _Mr;
let Br = new Ke(), kr = new Ke();
const _Ir = class _Ir {
  constructor(e4 = {}) {
    this.__id = _Ir.__counter__++;
    this.visibility = e4.visibility != void 0 ? e4.visibility : true;
    this.color = new Float32Array([1, 1, 1, 0.5]);
    if (e4.color) {
      let t2 = Ct(e4.color);
      this.setColor(t2.x, t2.y, t2.z, t2.w);
    }
    if (e4.opacity) {
      this.setOpacity(e4.opacity);
    }
    this._renderNode = null;
    this._entity = null;
    this._verticesHighBuffer = null;
    this._verticesLowBuffer = null;
    this._indexBuffer = null;
    this._verticesHigh = [];
    this._verticesLow = [];
    this._indexes = [];
    this._path = [];
    this._pickingColor = new Float32Array(4);
    this._gridSize = 1;
    this._handler = null;
    this._handlerIndex = -1;
    if (e4.path) {
      this.setPath(e4.path);
    }
  }
  setPickingColor3v(e4) {
    this._pickingColor[0] = e4.x / 255;
    this._pickingColor[1] = e4.y / 255;
    this._pickingColor[2] = e4.z / 255;
    this._pickingColor[3] = 1;
  }
  clear() {
    this._path.length = 0;
    this._path = [];
    this._verticesHigh.length = 0;
    this._verticesHigh = [];
    this._verticesLow.length = 0;
    this._verticesLow = [];
    this._indexes.length = 0;
    this._indexes = [];
    this._deleteBuffers();
  }
  setColor4v(e4) {
    this.setColor(e4.x, e4.y, e4.z, e4.w);
  }
  setColorHTML(e4) {
    this.setColor4v(dt(e4));
  }
  setColor(e4, t2, i2, s2) {
    s2 = s2 || this.color[3];
    this.color[0] = e4;
    this.color[1] = t2;
    this.color[2] = i2;
    this.color[3] = s2;
  }
  setOpacity(e4) {
    this.color[3] = e4 || 0;
  }
  setVisibility(e4) {
    this.visibility = e4;
  }
  getVisibility() {
    return this.visibility;
  }
  setRenderNode(e4) {
    this._renderNode = e4;
    this._createBuffers();
  }
  remove() {
    this._entity = null;
    this._handler && this._handler.remove(this);
  }
  draw() {
    if (this.visibility && this._verticesHigh.length) {
      let e4 = this._renderNode.renderer;
      let t2 = e4.handler.gl;
      let i2 = e4.handler.programs.strip, s2 = i2._program, r2 = s2.attributes, n2 = s2.uniforms;
      i2.activate();
      t2.disable(t2.CULL_FACE);
      t2.uniformMatrix4fv(n2.viewMatrix, false, e4.activeCamera.getViewMatrix());
      t2.uniformMatrix4fv(n2.projectionMatrix, false, e4.activeCamera.getProjectionMatrix());
      t2.uniform3fv(n2.eyePositionHigh, e4.activeCamera.eyeHigh);
      t2.uniform3fv(n2.eyePositionLow, e4.activeCamera.eyeLow);
      t2.uniform4fv(n2.uColor, this.color);
      t2.uniform1f(n2.uOpacity, this._entity._entityCollection._fadingOpacity);
      t2.bindBuffer(t2.ARRAY_BUFFER, this._verticesHighBuffer);
      t2.vertexAttribPointer(r2.aVertexPositionHigh, this._verticesHighBuffer.itemSize, t2.FLOAT, false, 0, 0);
      t2.bindBuffer(t2.ARRAY_BUFFER, this._verticesLowBuffer);
      t2.vertexAttribPointer(r2.aVertexPositionLow, this._verticesLowBuffer.itemSize, t2.FLOAT, false, 0, 0);
      t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
      t2.drawElements(e4.handler.gl.TRIANGLE_STRIP, this._indexBuffer.numItems, t2.UNSIGNED_INT, 0);
      t2.enable(t2.CULL_FACE);
    }
  }
  drawPicking() {
    if (this.visibility && this._verticesHigh.length) {
      let e4 = this._renderNode.renderer;
      let t2 = e4.handler.gl;
      let i2 = e4.handler.programs.strip, s2 = i2._program, r2 = s2.attributes, n2 = s2.uniforms;
      i2.activate();
      t2.disable(t2.CULL_FACE);
      t2.uniformMatrix4fv(n2.viewMatrix, false, e4.activeCamera.getViewMatrix());
      t2.uniformMatrix4fv(n2.projectionMatrix, false, e4.activeCamera.getProjectionMatrix());
      t2.uniform3fv(n2.eyePositionHigh, e4.activeCamera.eyeHigh);
      t2.uniform3fv(n2.eyePositionLow, e4.activeCamera.eyeLow);
      t2.uniform1f(n2.uOpacity, this._entity._entityCollection._fadingOpacity != 0 ? 1 : 0);
      t2.uniform4fv(n2.uColor, this._pickingColor);
      t2.bindBuffer(t2.ARRAY_BUFFER, this._verticesHighBuffer);
      t2.vertexAttribPointer(r2.aVertexPositionHigh, this._verticesHighBuffer.itemSize, t2.FLOAT, false, 0, 0);
      t2.bindBuffer(t2.ARRAY_BUFFER, this._verticesLowBuffer);
      t2.vertexAttribPointer(r2.aVertexPositionLow, this._verticesLowBuffer.itemSize, t2.FLOAT, false, 0, 0);
      t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
      t2.drawElements(e4.handler.gl.TRIANGLE_STRIP, this._indexBuffer.numItems, t2.UNSIGNED_INT, 0);
      t2.enable(t2.CULL_FACE);
    }
  }
  _deleteBuffers() {
    if (this._renderNode && this._renderNode.renderer) {
      let e4 = this._renderNode.renderer, t2 = e4.handler.gl;
      t2.deleteBuffer(this._indexBuffer);
      t2.deleteBuffer(this._verticesHighBuffer);
      t2.deleteBuffer(this._verticesLowBuffer);
    }
    this._verticesHighBuffer = null;
    this._verticesLowBuffer = null;
    this._indexBuffer = null;
  }
  _createBuffers() {
    if (this._renderNode && this._renderNode.renderer && this._renderNode.renderer.isInitialized()) {
      let e4 = this._renderNode.renderer.handler.gl;
      e4.deleteBuffer(this._indexBuffer);
      e4.deleteBuffer(this._verticesHighBuffer);
      e4.deleteBuffer(this._verticesLowBuffer);
      this._verticesHighBuffer = this._renderNode.renderer.handler.createArrayBuffer(new Float32Array(this._verticesHigh), 3, this._verticesHigh.length / 3);
      this._verticesLowBuffer = this._renderNode.renderer.handler.createArrayBuffer(new Float32Array(this._verticesLow), 3, this._verticesLow.length / 3);
      this._indexBuffer = this._renderNode.renderer.handler.createElementArrayBuffer(new Uint32Array(this._indexes), 1, this._indexes.length);
    }
  }
  addEdge3v(e4, t2) {
    let i2 = this._path.length;
    if (i2 === 0) {
      this._path.push([e4.clone(), t2.clone()]);
    } else {
      let s2 = this._path[i2 - 1][0], r2 = this._path[i2 - 1][1];
      this._path.push([e4.clone(), t2.clone()]);
      let n2 = this._verticesHigh, o2 = this._verticesLow;
      let a2 = this._gridSize, l2 = a2 + 1;
      let h2 = new Ke();
      let c2 = this._verticesHigh.length / 3, d2 = c2;
      let u2 = Math.abs(s2.sub(r2).normal().dot(e4.sub(s2).normal()));
      for (let i3 = 0; i3 < l2; i3++) {
        let _2 = i3 / a2;
        let f2 = s2.lerp(e4, _2), g2 = r2.lerp(t2, _2);
        for (let _3 = 0; _3 < l2; _3++) {
          let p2 = _3 / a2;
          let m2 = s2.lerp(r2, p2), v2 = e4.lerp(t2, p2);
          if (u2 !== 1) {
            new ir(f2, g2).intersects(new ir(m2, v2), h2);
          } else {
            h2 = v2;
          }
          d2 = c2 + i3 * l2 + _3;
          Ke.doubleToTwoFloats(h2, Br, kr);
          let y2 = d2 * 3;
          n2[y2] = Br.x;
          n2[y2 + 1] = Br.y;
          n2[y2 + 2] = Br.z;
          o2[y2] = kr.x;
          o2[y2 + 1] = kr.y;
          o2[y2 + 2] = kr.z;
          if (i3 < a2) {
            this._indexes.push(d2, d2 + l2);
          }
        }
        if (i3 < a2) {
          this._indexes.push(d2 + l2, d2 + 1);
        }
      }
      this._createBuffers();
    }
  }
  setEdge3v(e4, t2, i2) {
    if (i2 === this._path.length) {
      this.addEdge3v(e4, t2);
      return;
    }
    if (this._path[i2]) {
      this._path[i2][0] = e4;
      this._path[i2][1] = t2;
      if (this._path.length > 1) {
        let s2 = this._gridSize, r2 = s2 + 1;
        let n2 = r2 * r2;
        let o2 = new Ke();
        let a2 = this._verticesHigh, l2 = this._verticesLow;
        if (i2 === this._path.length - 1) {
          let h2 = this._path[i2 - 1][0], c2 = this._path[i2 - 1][1];
          let d2 = this._verticesHigh.length / 3 - n2, u2 = d2;
          let _2 = Math.abs(h2.sub(c2).normal().dot(e4.sub(h2).normal()));
          for (let i3 = 0; i3 < r2; i3++) {
            let n3 = i3 / s2;
            let f2 = h2.lerp(e4, n3), g2 = c2.lerp(t2, n3);
            for (let n4 = 0; n4 < r2; n4++) {
              let p2 = n4 / s2;
              let m2 = h2.lerp(c2, p2), v2 = e4.lerp(t2, p2);
              if (_2 !== 1) {
                new ir(f2, g2).intersects(new ir(m2, v2), o2);
              } else {
                o2 = v2;
              }
              u2 = d2 + i3 * r2 + n4;
              Ke.doubleToTwoFloats(o2, Br, kr);
              let y2 = u2 * 3;
              a2[y2] = Br.x;
              a2[y2 + 1] = Br.y;
              a2[y2 + 2] = Br.z;
              l2[y2] = kr.x;
              l2[y2 + 1] = kr.y;
              l2[y2 + 2] = kr.z;
            }
          }
        } else if (i2 === 0) {
          let i3 = 0;
          let n3 = e4, h2 = t2;
          e4 = this._path[1][0];
          t2 = this._path[1][1];
          for (let c2 = 0; c2 < r2; c2++) {
            let d2 = c2 / s2;
            let u2 = n3.lerp(e4, d2), _2 = h2.lerp(t2, d2);
            for (let d3 = 0; d3 < r2; d3++) {
              let f2 = d3 / s2;
              let g2 = n3.lerp(h2, f2), p2 = e4.lerp(t2, f2);
              new ir(u2, _2).intersects(new ir(g2, p2), o2);
              i3 = c2 * r2 + d3;
              Ke.doubleToTwoFloats(o2, Br, kr);
              let m2 = i3 * 3;
              a2[m2] = Br.x;
              a2[m2 + 1] = Br.y;
              a2[m2 + 2] = Br.z;
              l2[m2] = kr.x;
              l2[m2 + 1] = kr.y;
              l2[m2 + 2] = kr.z;
            }
          }
        } else if (i2 > 0 && i2 < this._path.length) {
          let h2 = this._path[i2 - 1][0], c2 = this._path[i2 - 1][1];
          let d2 = this._path[i2 + 1][0], u2 = this._path[i2 + 1][1];
          let _2 = i2 * n2, f2 = (i2 - 1) * n2, g2 = f2;
          for (let i3 = 0; i3 < r2; i3++) {
            let n3 = i3 / s2;
            let p2 = h2.lerp(e4, n3), m2 = t2.lerp(u2, n3), v2 = e4.lerp(d2, n3), y2 = c2.lerp(t2, n3);
            for (let n4 = 0; n4 < r2; n4++) {
              let x2 = n4 / s2;
              let b2 = h2.lerp(c2, x2), w2 = e4.lerp(t2, x2);
              new ir(p2, y2).intersects(new ir(b2, w2), o2);
              let C2 = i3 * r2 + n4;
              g2 = f2 + C2;
              Ke.doubleToTwoFloats(o2, Br, kr);
              let T2 = g2 * 3;
              a2[T2] = Br.x;
              a2[T2 + 1] = Br.y;
              a2[T2 + 2] = Br.z;
              l2[T2] = kr.x;
              l2[T2 + 1] = kr.y;
              l2[T2 + 2] = kr.z;
              let E2 = d2.lerp(u2, x2);
              w2 = e4.lerp(t2, x2);
              new ir(v2, m2).intersects(new ir(w2, E2), o2);
              g2 = _2 + C2;
              Ke.doubleToTwoFloats(o2, Br, kr);
              T2 = g2 * 3;
              a2[T2] = Br.x;
              a2[T2 + 1] = Br.y;
              a2[T2 + 2] = Br.z;
              l2[T2] = kr.x;
              l2[T2 + 1] = kr.y;
              l2[T2 + 2] = kr.z;
            }
          }
        }
        this._createBuffers();
      }
    } else {
      console.warn(`strip index ${i2} is out of range`);
    }
  }
  removeEdge(e4) {
    this._path.splice(e4, 1);
    this.setPath([].concat(this._path));
  }
  setGridSize(e4) {
    this._gridSize = e4;
    this.setPath([].concat(this._path));
  }
  getPath() {
    return this._path;
  }
  setPath(e4) {
    this._verticesHigh = [];
    this._verticesLow = [];
    this._indexes = [];
    this._path = [];
    for (let t2 = 0; t2 < e4.length; t2++) {
      let i2 = e4[t2][0], s2 = e4[t2][1];
      if (i2 instanceof Array) {
        i2 = new Ke(i2[0], i2[1], i2[2]);
      }
      if (s2 instanceof Array) {
        s2 = new Ke(s2[0], s2[1], s2[2]);
      }
      this.addEdge3v(i2, s2);
    }
  }
  insertEdge3v(e4, t2, i2) {
    if (i2 < this._path.length) {
      let s2 = [].concat(this._path);
      s2.splice(i2, 0, [e4, t2]);
      this.setPath(s2);
    } else if (i2 === this._path.length) {
      this.addEdge3v(e4, t2);
    }
  }
};
_Ir.__counter__ = 0;
let Ir = _Ir;
const _zr = class _zr {
  constructor(e4 = {}) {
    e4.properties = e4.properties || {};
    this.__id = _zr.__counter__++;
    this.properties = e4.properties || {};
    this.properties.name = this.properties.name != void 0 ? this.properties.name : "";
    this.childEntities = [];
    this.parent = null;
    this.forceGlobalPosition = e4.forceGlobalPosition || false;
    this.forceGlobalRotation = e4.forceGlobalRotation || false;
    this.forceGlobalScale = e4.forceGlobalScale || false;
    this._cartesian = bt(e4.cartesian);
    this._rootCartesian = new Ke();
    this._localPosition = bt(e4.localPosition);
    this._absoluteLocalPosition = new Ke();
    this._lonLat = At(e4.lonlat);
    this._lonLatMerc = new be();
    this._altitude = e4.altitude || 0;
    this._visibility = e4.visibility != void 0 ? e4.visibility : true;
    this._entityCollection = null;
    this._entityCollectionIndex = -1;
    this._layer = null;
    this._layerIndex = -1;
    this._pickingColor = new Ke(0, 0, 0);
    this._independentPicking = e4.independentPicking || false;
    this._relativePosition = e4.relativePosition || false;
    this._pitchRad = e4.pitch || 0;
    this._yawRad = e4.yaw || 0;
    this._rollRad = e4.roll || 0;
    this._scale = bt(e4.scale, new Ke(1, 1, 1));
    this._qFrame = Ze.IDENTITY;
    this._qRot = Ze.IDENTITY;
    this._absoluteQRot = Ze.IDENTITY;
    this._featureConstructorArray = { billboard: [Ks, this.setBillboard], label: [mr, this.setLabel], polyline: [Rr, this.setPolyline], pointCloud: [br, this.setPointCloud], geometry: [er, this.setGeometry], geoObject: [fr, this.setGeoObject], strip: [Ir, this.setStrip], ray: [Mr, this.setRay] };
    this.billboard = this._createOptionFeature("billboard", e4.billboard);
    this.label = this._createOptionFeature("label", e4.label);
    this.polyline = this._createOptionFeature("polyline", e4.polyline);
    this.ray = this._createOptionFeature("ray", e4.ray);
    this.pointCloud = this._createOptionFeature("pointCloud", e4.pointCloud);
    this.geometry = this._createOptionFeature("geometry", e4.geometry);
    this.geoObject = this._createOptionFeature("geoObject", e4.geoObject);
    this.strip = this._createOptionFeature("strip", e4.strip);
  }
  get rootEntity() {
    let e4 = this;
    while (e4) {
      if (!e4.parent) {
        return e4;
      }
      e4 = e4.parent;
    }
    return this;
  }
  set relativePosition(e4) {
    if (e4 !== this._relativePosition) {
      let t2 = this.getAbsoluteCartesian(), i2 = this.getAbsolutePitch(), s2 = this.getAbsoluteYaw(), r2 = this.getAbsoluteRoll();
      this._relativePosition = e4;
      if (this.parent) {
        this._rootCartesian.copy(this.parent._rootCartesian);
      }
      if (!e4) {
        this.setCartesian3v(t2);
        this.setPitch(i2);
        this.setYaw(s2);
        this.setRoll(r2);
      } else if (this.parent) {
        this.setAbsoluteCartesian3v(t2);
        this.setAbsolutePitch(i2);
        this.setAbsoluteYaw(s2);
        this.setAbsoluteRoll(r2);
      }
    }
  }
  get relativePosition() {
    return this._relativePosition;
  }
  get entityCollection() {
    return this._entityCollection;
  }
  get id() {
    return this.__id;
  }
  isEqual(e4) {
    return this.__id === e4.__id;
  }
  get layerIndex() {
    return this._layerIndex;
  }
  get instanceName() {
    return "Entity";
  }
  _createOptionFeature(e4, t2) {
    if (t2) {
      let i2 = this._featureConstructorArray[e4];
      return i2[1].call(this, new i2[0](t2));
    }
    return null;
  }
  getCollectionIndex() {
    return this._entityCollectionIndex;
  }
  addTo(e4, t2 = false) {
    e4.add(this, t2);
    return this;
  }
  remove() {
    this._layer && this._layer.removeEntity(this);
    this._entityCollection && this._entityCollection.removeEntity(this);
  }
  setVisibility(e4) {
    this._visibility = e4;
    this.billboard && this.billboard.setVisibility(e4);
    this.geoObject && this.geoObject.setVisibility(e4);
    this.label && this.label.setVisibility(e4);
    this.polyline && this.polyline.setVisibility(e4);
    this.ray && this.ray.setVisibility(e4);
    this.geometry && this.geometry.setVisibility(e4);
    for (let t2 = 0; t2 < this.childEntities.length; t2++) {
      this.childEntities[t2].setVisibility(e4);
    }
  }
  getVisibility() {
    return this._visibility;
  }
  setCartesian3v(e4) {
    this.setCartesian(e4.x, e4.y, e4.z);
  }
  getScale() {
    return this._scale;
  }
  setScale3v(e4) {
    this._scale.copy(e4);
    this.geoObject && this.geoObject.setScale3v(this._scale);
    for (let e5 = 0; e5 < this.childEntities.length; e5++) {
      let t2 = this.childEntities[e5];
      if (t2.forceGlobalScale) {
        t2.setScale3v(this._scale);
      } else {
        t2.setScale3v(this.childEntities[e5].getScale());
      }
    }
  }
  setScale(e4) {
    this._scale.set(e4, e4, e4);
    this.geoObject && this.geoObject.setScale(e4);
    for (let t2 = 0; t2 < this.childEntities.length; t2++) {
      let i2 = this.childEntities[t2];
      if (i2.forceGlobalScale) {
        i2.setScale(e4);
      } else {
        i2.setScale3v(this.childEntities[t2].getScale());
      }
    }
  }
  getAbsoluteRotation() {
    return this._absoluteQRot.clone();
  }
  getRotation() {
    return this._qRot;
  }
  setLook3v(e4) {
    let t2 = new Ze();
    let i2 = this.getAbsoluteCartesian();
    let s2;
    if (this._entityCollection) {
      let r2 = this._entityCollection.renderNode.ellipsoid.getSurfaceNormal3v(i2);
      s2 = t2.setLookRotation(e4.sub(i2), r2).conjugate();
    } else {
      s2 = t2.setLookRotation(e4.sub(i2), Ke.UP).conjugate();
    }
    this.setAbsoluteRotation(s2);
  }
  setLookLonLat(e4) {
    if (this._entityCollection) {
      let t2 = this._entityCollection.renderNode.ellipsoid.lonLatToCartesian(e4);
      this.setLook3v(t2);
    }
  }
  setAbsoluteRotation(e4) {
    this._absoluteQRot.copy(e4);
    this._updatePitchYawRoll();
  }
  setRotation(e4) {
  }
  setPitch(e4) {
    this._pitchRad = e4;
    this._updateAbsolutePosition();
  }
  setYaw(e4) {
    this._yawRad = e4;
    this._updateAbsolutePosition();
  }
  setRoll(e4) {
    this._rollRad = e4;
    this._updateAbsolutePosition();
  }
  getPitch() {
    return this._pitchRad;
  }
  getYaw() {
    return this._yawRad;
  }
  getRoll() {
    return this._rollRad;
  }
  setAbsolutePitch(e4) {
    if (this._relativePosition) {
      this._absoluteQRot.setPitchYawRoll(e4, this.getAbsoluteYaw(), this.getAbsoluteRoll(), this._qFrame);
      this._updatePitchYawRoll();
    } else {
      this.setPitch(e4);
    }
  }
  setAbsoluteYaw(e4) {
    if (this._relativePosition) {
      this._absoluteQRot.setPitchYawRoll(this.getAbsolutePitch(), e4, this.getAbsoluteRoll(), this._qFrame);
      this._updatePitchYawRoll();
    } else {
      this.setYaw(e4);
    }
  }
  setAbsoluteRoll(e4) {
    if (this._relativePosition) {
      this._absoluteQRot.setPitchYawRoll(this.getAbsolutePitch(), this.getAbsoluteYaw(), e4, this._qFrame);
      this._updatePitchYawRoll();
    } else {
      this.setRoll(e4);
    }
  }
  getAbsolutePitch() {
    if (this.parent && this._relativePosition) {
      return this._qFrame.conjugate().inverse().mul(this._absoluteQRot).getPitch();
    }
    return this._pitchRad;
  }
  getAbsoluteYaw() {
    if (this.parent && this._relativePosition) {
      return this._qFrame.conjugate().inverse().mul(this._absoluteQRot).getYaw();
    }
    return this._yawRad;
  }
  getAbsoluteRoll() {
    if (this.parent && this._relativePosition) {
      return this._qFrame.conjugate().inverse().mul(this._absoluteQRot).getRoll();
    }
    return this._rollRad;
  }
  _getScaleByDistance() {
    let e4 = 1;
    if (this._entityCollection) {
      let t2 = this._entityCollection.scaleByDistance;
      let i2 = 1;
      if (this._entityCollection.renderNode && this._entityCollection.renderNode.renderer) {
        i2 = this._entityCollection.renderNode.renderer.activeCamera.eye.distance(this._rootCartesian);
      }
      e4 = t2[2] * U(i2, t2[0], t2[1]) / t2[0];
    }
    return e4;
  }
  setAbsoluteCartesian(e4, t2, i2) {
    this.setAbsoluteCartesian3v(new Ke(e4, t2, i2));
  }
  setAbsoluteCartesian3v(e4) {
    let t2 = e4;
    if (this.parent && this._relativePosition) {
      let i2 = this._getScaleByDistance();
      t2 = e4.sub(this.parent.getAbsoluteCartesian()).scale(1 / i2);
      t2 = this.parent._absoluteQRot.conjugate().mulVec3(t2);
    }
    this.setCartesian3v(t2);
  }
  getAbsoluteCartesian() {
    if (this.parent && this._relativePosition) {
      let e4 = this._getScaleByDistance();
      return this._rootCartesian.add(this._absoluteLocalPosition.scaleTo(e4));
    }
    return this._cartesian.clone();
  }
  setCartesian(e4, t2, i2) {
    this._cartesian.set(e4, t2, i2);
    this._updateAbsolutePosition();
    for (let s2 = 0; s2 < this.childEntities.length; s2++) {
      let r2 = this.childEntities[s2];
      if (r2._relativePosition) {
        r2.setCartesian3v(r2.getCartesian());
      } else if (r2.forceGlobalPosition) {
        r2.setCartesian(e4, t2, i2);
      }
    }
    this._updateLonLat();
  }
  _updatePitchYawRoll() {
    if (this.parent) {
      this._qRot = this.parent._absoluteQRot.conjugate().mul(this._absoluteQRot);
      this._pitchRad = this._qRot.getPitch();
      this._yawRad = this._qRot.getYaw();
      this._rollRad = this._qRot.getRoll();
      if (this.geoObject) {
        this.geoObject.setRotation(this._absoluteQRot);
      }
      for (let e4 = 0; e4 < this.childEntities.length; e4++) {
        this.childEntities[e4]._updateAbsolutePosition();
      }
    }
  }
  _updateAbsolutePosition() {
    let e4 = this.parent;
    if (e4 && this._relativePosition) {
      this._qFrame.copy(e4._qFrame);
      this._rootCartesian.copy(e4._rootCartesian);
      this._qRot.setPitchYawRoll(this._pitchRad, this._yawRad, this._rollRad);
      e4._absoluteQRot.mulRes(this._qRot, this._absoluteQRot);
      let t2 = e4._absoluteQRot.mulVec3(this._cartesian.add(this._localPosition));
      e4._absoluteLocalPosition.addRes(t2, this._absoluteLocalPosition);
    } else {
      this._qFrame = Ze.IDENTITY;
      if (this._entityCollection && this._entityCollection.renderNode) {
        this._qFrame = this._entityCollection.renderNode.getFrameRotation(this._cartesian);
      }
      if (e4 && this.forceGlobalRotation) {
        this._qRot.setPitchYawRoll(e4._pitchRad, e4._yawRad, e4._rollRad, this._qFrame);
      } else {
        this._qRot.setPitchYawRoll(this._pitchRad, this._yawRad, this._rollRad, this._qFrame);
      }
      this._absoluteQRot.copy(this._qRot);
      this._rootCartesian.copy(this._cartesian);
      this._absoluteLocalPosition.copy(this._localPosition);
    }
    if (this.geoObject) {
      this.geoObject.setRotation(this._absoluteQRot);
      this.geoObject.setPosition3v(this._rootCartesian);
      this.geoObject.setLocalPosition3v(this._absoluteLocalPosition);
    }
    this.billboard && this.billboard.setPosition3v(this._rootCartesian);
    this.label && this.label.setPosition3v(this._rootCartesian);
    for (let e5 = 0, t2 = this.childEntities.length; e5 < t2; e5++) {
      this.childEntities[e5]._updateAbsolutePosition();
    }
    this._updateLonLat();
  }
  _setCartesian3vSilent(e4, t2 = false) {
    this._cartesian.copy(e4);
    this._updateAbsolutePosition();
    for (let e5 = 0; e5 < this.childEntities.length; e5++) {
      this.childEntities[e5].setCartesian(this._cartesian.x, this._cartesian.y, this._cartesian.z);
    }
    if (!t2) {
      this._updateLonLat();
    }
  }
  _updateLonLat() {
    let e4 = this._entityCollection;
    if (e4 && e4.renderNode && e4.renderNode.ellipsoid) {
      this._lonLat = e4.renderNode.ellipsoid.cartesianToLonLat(this.getAbsoluteCartesian());
      if (Math.abs(this._lonLat.lat) < Ge) {
        this._lonLatMerc = this._lonLat.forwardMercator();
      } else {
        this._lonLatMerc.lon = this._lonLatMerc.lat = 0;
      }
    }
  }
  getLonLat() {
    return this._lonLat.clone();
  }
  setLonLat(e4) {
    let t2 = this._lonLat;
    t2.lon = e4.lon;
    t2.lat = e4.lat;
    t2.height = e4.height;
    let i2 = this._entityCollection;
    if (i2 && i2.renderNode && i2.renderNode.ellipsoid) {
      if (Math.abs(t2.lat) < Ge) {
        this._lonLatMerc = t2.forwardMercator();
      }
      let e5 = new Ke();
      i2.renderNode.ellipsoid.lonLatToCartesianRes(t2, e5);
      this.setAbsoluteCartesian3v(e5);
    }
  }
  setLonLat2(e4, t2, i2) {
    let s2 = this._lonLat;
    s2.lon = e4;
    s2.lat = t2;
    s2.height = i2 != void 0 ? i2 : s2.height;
    let r2 = this._entityCollection;
    if (r2 && r2.renderNode && r2.renderNode.ellipsoid) {
      if (Math.abs(s2.lat) < Ge) {
        this._lonLatMerc = s2.forwardMercator();
      } else {
        this._lonLatMerc.lon = this._lonLatMerc.lat = this._lonLatMerc.height = 0;
      }
      let e5 = new Ke();
      r2.renderNode.ellipsoid.lonLatToCartesianRes(s2, e5);
      this.setAbsoluteCartesian3v(e5);
    }
  }
  setAltitude(e4) {
    this._altitude = e4;
  }
  getAltitude() {
    return this._altitude;
  }
  getCartesian() {
    return this._cartesian.clone();
  }
  setBillboard(e4) {
    if (this.billboard) {
      this.billboard.remove();
    }
    this.billboard = e4;
    this.billboard._entity = this;
    this.billboard.setPosition3v(this._cartesian);
    this.billboard.setVisibility(this._visibility);
    this._entityCollection && this._entityCollection.billboardHandler.add(e4);
    return e4;
  }
  setLabel(e4) {
    if (this.label) {
      this.label.remove();
    }
    this.label = e4;
    this.label._entity = this;
    this.label.setPosition3v(this._cartesian);
    this.label.setVisibility(this._visibility);
    this._entityCollection && this._entityCollection.labelHandler.add(e4);
    return e4;
  }
  setRay(e4) {
    if (this.ray) {
      this.ray.remove();
    }
    this.ray = e4;
    this.ray._entity = this;
    this.ray.setVisibility(this._visibility);
    this._entityCollection && this._entityCollection.rayHandler.add(e4);
    return e4;
  }
  setPolyline(e4) {
    if (this.polyline) {
      this.polyline.remove();
    }
    this.polyline = e4;
    this.polyline._entity = this;
    this.polyline.setVisibility(this._visibility);
    this._entityCollection && this._entityCollection.polylineHandler.add(e4);
    return e4;
  }
  setPointCloud(e4) {
    if (this.pointCloud) {
      this.pointCloud.remove();
    }
    this.pointCloud = e4;
    this.pointCloud._entity = this;
    this.pointCloud.setVisibility(this._visibility);
    this._entityCollection && this._entityCollection.pointCloudHandler.add(e4);
    return e4;
  }
  setGeometry(e4) {
    if (this.geometry) {
      this.geometry.remove();
    }
    this.geometry = e4;
    this.geometry._entity = this;
    this.geometry.setVisibility(this._visibility);
    let t2 = this._layer;
    if (this._layer) {
      this._layer.removeEntity(this);
    }
    t2 && t2.add(this);
    return e4;
  }
  setGeoObject(e4) {
    if (this.geoObject) {
      this.geoObject.remove();
    }
    this.geoObject = e4;
    this.geoObject._entity = this;
    this.geoObject.setPosition3v(this._cartesian);
    this.geoObject.setVisibility(this._visibility);
    this._entityCollection && this._entityCollection.geoObjectHandler.add(e4);
    return e4;
  }
  setStrip(e4) {
    if (this.strip) {
      this.strip.remove();
    }
    this.strip = e4;
    this.strip._entity = this;
    this.strip.setVisibility(this._visibility);
    this._entityCollection && this._entityCollection.stripHandler.add(e4);
    return e4;
  }
  get layer() {
    return this._layer;
  }
  get rendererEvents() {
    if (this._layer) {
      return this._layer.events;
    } else if (this._entityCollection) {
      return this._entityCollection.events;
    }
    return null;
  }
  appendChild(e4) {
    e4._entityCollection = this._entityCollection;
    if (!e4._independentPicking) {
      e4._pickingColor = this._pickingColor;
    }
    e4.parent = this;
    this.childEntities.push(e4);
    this._entityCollection && this._entityCollection.appendChildEntity(e4);
  }
  setPickingColor() {
    let e4 = this._pickingColor;
    this.billboard && this.billboard.setPickingColor3v(e4);
    this.label && this.label.setPickingColor3v(e4);
    this.polyline && this.polyline.setPickingColor3v(e4);
    this.ray && this.ray.setPickingColor3v(e4);
    this.strip && this.strip.setPickingColor3v(e4);
    this.geoObject && this.geoObject.setPickingColor3v(e4);
    for (let e5 = 0; e5 < this.childEntities.length; e5++) {
      this.childEntities[e5].setPickingColor();
    }
  }
  getExtent() {
    let e4;
    let t2 = this._lonLat;
    if (this.billboard || this.label) {
      e4 = new Ye(new be(t2.lon, t2.lat), new be(t2.lon, t2.lat));
    } else {
      e4 = new Ye(new be(180, 90), new be(-180, -90));
    }
    let i2 = e4.southWest, s2 = e4.northEast;
    if (this.polyline) {
      let e5 = this.polyline.getExtent();
      if (e5.southWest.lon < i2.lon) i2.lon = e5.southWest.lon;
      if (e5.southWest.lat < i2.lat) i2.lat = e5.southWest.lat;
      if (e5.northEast.lon > s2.lon) s2.lon = e5.northEast.lon;
      if (e5.northEast.lat > s2.lat) s2.lat = e5.northEast.lat;
    }
    if (this.geometry) {
      let e5 = this.geometry.getExtent();
      if (e5.southWest.lon < i2.lon) i2.lon = e5.southWest.lon;
      if (e5.southWest.lat < i2.lat) i2.lat = e5.southWest.lat;
      if (e5.northEast.lon > s2.lon) s2.lon = e5.northEast.lon;
      if (e5.northEast.lat > s2.lat) s2.lat = e5.northEast.lat;
    }
    for (let e5 = 0; e5 < this.childEntities.length; e5++) {
      let t3 = this.childEntities[e5].getExtent();
      if (t3.southWest.lon < i2.lon) i2.lon = t3.southWest.lon;
      if (t3.southWest.lat < i2.lat) i2.lat = t3.southWest.lat;
      if (t3.northEast.lon > s2.lon) s2.lon = t3.northEast.lon;
      if (t3.northEast.lat > s2.lat) s2.lat = t3.northEast.lat;
    }
    return e4;
  }
};
_zr.__counter__ = 0;
let zr = _zr;
const _Dr = class _Dr {
  constructor(e4) {
    this.__id = _Dr.__counter__++;
    this._name = e4 || `nonameNode:${this.__id}`;
    this.topNode = this;
    this._dictionary = {};
    this._dictionary[this._name] = this;
    this.childNodes = [];
    this.parentNode = null;
  }
  get name() {
    return this._name;
  }
  addNode(e4) {
    if (this.parentNode == null) {
      e4.topNode = this;
    } else {
      e4.topNode = this.topNode;
    }
    e4.parentNode = this;
    e4._dictionary = this.topNode._dictionary;
    this.childNodes.push(e4);
    this.topNode._dictionary[e4.name] = e4;
  }
  destroy() {
    for (let e4 = 0; e4 < this.childNodes.length; e4++) {
      this.childNodes[e4].destroy();
    }
    this._clear();
  }
  getNodeByName(e4) {
    return this._dictionary[e4];
  }
  _clear() {
    this.parentNode = null;
    this.topNode = this;
    this.childNodes.length = 0;
  }
  isEqual(e4) {
    return e4.__id === this.__id;
  }
};
_Dr.__counter__ = 0;
let Dr = _Dr;
class Fr extends Dr {
  constructor(e4) {
    super(e4);
    this.childNodes = [];
    this.renderer = null;
    this.drawMode = 0;
    this.show = true;
    this._isActive = true;
    this.lightEnabled = false;
    this._lightPosition = new Float32Array([100, 100, 100]);
    this._lightParams = new Float32Array(9);
    this._lightShininess = 100;
    this.entityCollections = [];
    this._entityCollectionsByDepthOrder = [];
    this._pickingId = -1;
  }
  getFrameRotation(e4) {
    return Ze.IDENTITY;
  }
  addNode(e4) {
    super.addNode(e4);
    this.renderer && e4.assign(this.renderer);
  }
  assign(e4) {
    this.renderer = e4;
    this._pickingId = e4.addPickingCallback(this, this._entityCollectionPickingCallback);
    this.initialize();
  }
  initialize() {
    if (this.renderer && this.renderer.isInitialized()) {
      for (let e4 = 0; e4 < this.entityCollections.length; e4++) {
        this.entityCollections[e4].bindRenderNode(this);
      }
      this.init();
    }
  }
  init() {
  }
  onremove() {
  }
  remove() {
    let e4 = this.renderer, t2 = this.name;
    if (e4) {
      if (e4.renderNodes[t2] && e4.renderNodes[t2].isEqual(this)) {
        e4.renderNodes[t2] = null;
        delete e4.renderNodes[t2];
      }
      for (let t3 = 0; t3 < e4._renderNodesArr.length; t3++) {
        if (e4._renderNodesArr[t3].isEqual(this)) {
          e4._renderNodesArr.splice(t3, 1);
          break;
        }
      }
      e4.removePickingCallback(this._pickingId);
      this._pickingId = -1;
      this.onremove && this.onremove();
    }
  }
  addEntityCollection(e4, t2) {
    if (!e4.renderNode) {
      e4.renderNode = this;
      if (!t2) {
        this.entityCollections.push(e4);
        this.updateEntityCollectionsDepthOrder();
      }
      this.ellipsoid && e4._updateGeodeticCoordinates(this.ellipsoid);
      e4.bindRenderNode(this);
      e4.events.dispatch(e4.events.add, this);
    }
  }
  removeEntityCollection(e4) {
    for (let t2 = 0; t2 < this.entityCollections.length; t2++) {
      if (this.entityCollections[t2].isEqual(e4)) {
        this.entityCollections.splice(t2, 1);
        this.updateEntityCollectionsDepthOrder();
        return;
      }
    }
  }
  updateEntityCollectionsDepthOrder() {
    let e4 = { 0: [] };
    for (const t2 of this.entityCollections) {
      if (t2.getVisibility()) {
        if (!e4[t2.depthOrder]) {
          e4[t2.depthOrder] = [];
        }
        e4[t2.depthOrder].push(t2);
      }
    }
    this._entityCollectionsByDepthOrder.length = 0;
    this._entityCollectionsByDepthOrder = [];
    this._entityCollectionsByDepthOrder = Object.keys(e4).sort((e5, t2) => Number(e5) - Number(t2)).map((t2) => e4[Number(t2)]);
  }
  addLight(e4) {
    e4.addTo(this);
    return this;
  }
  preDrawNode() {
    this._isActive && this._preDrawNodes();
  }
  drawNode() {
    this._isActive && this._drawNodes();
  }
  isActive() {
    return this._isActive;
  }
  setActive(e4) {
    this._isActive = e4;
    if (this.renderer) {
      if (this._isActive && this._pickingId === -1) {
        this._pickingId = this.renderer.addPickingCallback(this, this._entityCollectionPickingCallback);
      } else if (!this._isActive && this._pickingId !== -1) {
        this.renderer.removePickingCallback(this._pickingId);
        this._pickingId = -1;
      }
    }
    for (let t2 = 0; t2 < this.childNodes.length; t2++) {
      this.childNodes[t2].setActive(e4);
    }
  }
  setDrawMode(e4) {
    this.drawMode = e4;
    for (let t2 = 0; t2 < this.childNodes.length; t2++) {
      this.childNodes[t2].setDrawMode(e4);
    }
  }
  updateBillboardsTexCoords() {
    for (let e4 = 0; e4 < this.entityCollections.length; e4++) {
      this.entityCollections[e4].billboardHandler.refreshTexCoordsArr();
    }
  }
  frame() {
  }
  preFrame() {
  }
  _preDrawNodes() {
    for (let e4 = 0; e4 < this.childNodes.length; e4++) {
      if (this.childNodes[e4]._isActive) {
        this.childNodes[e4]._preDrawNodes();
      }
    }
    if (this.show) {
      this.preFrame();
      for (let e4 = 0; e4 < this._entityCollectionsByDepthOrder.length; e4++) {
        this.drawEntityCollections(this._entityCollectionsByDepthOrder[e4], e4);
      }
    }
  }
  _drawNodes() {
    for (let e4 = 0; e4 < this.childNodes.length; e4++) {
      if (this.childNodes[e4]._isActive) {
        this.childNodes[e4]._drawNodes();
      }
    }
    if (this.show) {
      this.frame();
    }
  }
  drawEntityCollections(e4, t2 = 0) {
    this.renderer.enqueueEntityCollectionsToDraw(e4, t2);
  }
  drawPickingEntityCollections(e4) {
    if (e4.length) {
      let t2 = e4.length;
      while (t2--) {
        e4[t2]._fadingOpacity && e4[t2].billboardHandler.drawPicking();
      }
      t2 = e4.length;
      while (t2--) {
        e4[t2]._fadingOpacity && e4[t2].geoObjectHandler.drawPicking();
      }
      t2 = e4.length;
      while (t2--) {
        e4[t2]._fadingOpacity && e4[t2].labelHandler.drawPicking();
      }
      t2 = e4.length;
      while (t2--) {
        e4[t2]._fadingOpacity && e4[t2].rayHandler.drawPicking();
      }
      t2 = e4.length;
      while (t2--) {
        e4[t2]._visibility && e4[t2].polylineHandler.drawPicking();
      }
      t2 = e4.length;
      while (t2--) {
        e4[t2]._visibility && e4[t2].stripHandler.drawPicking();
      }
    }
  }
  _entityCollectionPickingCallback() {
  }
}
class Nr {
  constructor() {
    this._container = document.createElement("div");
    this._container.classList.add("ogConsole");
    this._container.style.display = "none";
    if (document.body) {
      document.body.appendChild(this._container);
    }
    this._visibility = false;
  }
  getVisibility() {
    return this._visibility;
  }
  setVisibility(e4) {
    if (this._visibility != e4) {
      this._visibility = e4;
      if (this._visibility) {
        this.show();
      } else {
        this.hide();
      }
    }
  }
  show() {
    if (!this._container.parentNode) {
      if (document.body) {
        document.body.appendChild(this._container);
      }
    }
    this._container.style.display = "block";
    this._visibility = true;
  }
  hide() {
    this._container.style.display = "none";
    this._visibility = false;
  }
  logErr(e4) {
    let t2 = document.createElement("div");
    t2.classList.add("ogConsole-text");
    t2.classList.add("ogConsole-error");
    t2.innerHTML = "error: " + e4;
    console.trace(t2.innerHTML);
    this._container.appendChild(t2);
    this.show();
  }
  logWrn(e4) {
    let t2 = document.createElement("div");
    t2.classList.add("ogConsole-text");
    t2.classList.add("ogConsole-warning");
    t2.innerHTML = "warning: " + e4;
    console.trace(t2.innerHTML);
    this._container.appendChild(t2);
    this.show();
  }
  log(e4) {
    let t2 = document.createElement("div");
    t2.classList.add("ogConsole-text");
    t2.innerHTML = e4;
    console.trace(e4);
    this._container.appendChild(t2);
    this.show();
  }
}
const Or = new Nr();
let Hr = ["FLOAT", "DOUBLE", "BOOL", "INT", "UINT", "VEC2", "VEC3", "VEC4", "DVEC2", "DVEC3", "DVEC4", "BVEC2", "BVEC3", "BVEC4", "IVEC2", "IVEC3", "IVEC4", "UVEC2", "UVEC3", "UVEC4", "MAT2", "DMAT2", "MAT3", "DMAT3", "MAT4", "DMAT4", "MAT2X3", "MAT2X4", "MAT3X2", "MAT3X4", "MAT4X2", "MAT4X3", "DMAT2X3", "DMAT2X4", "DMAT3X2", "DMAT3X4", "DMAT4X2", "DMAT4X3", "SAMPLER1D", "SAMPLER2D", "SAMPLER3D", "SAMPLERCUBE", "SAMPLER2DSHADOW", "SAMPLER2DARRAY", "INTXX", "FLOATXX"];
const Vr = {};
for (let e4 = 0; e4 < Hr.length; e4++) {
  Vr[Hr[e4]] = e4;
}
const Ur = {};
for (let e4 = 0; e4 < Hr.length; e4++) {
  Ur[Hr[e4].toLowerCase()] = Vr[Hr[e4]];
}
const Gr = { u: [], a: [] };
Gr.u[Vr.MAT4] = function(e4, t2) {
  e4.gl.uniformMatrix4fv(t2._pName, false, t2.value);
};
Gr.u[Vr.MAT3] = function(e4, t2) {
  e4.gl.uniformMatrix3fv(t2._pName, false, t2.value);
};
Gr.u[Vr.FLOAT] = function(e4, t2) {
  e4.gl.uniform1f(t2._pName, t2.value);
};
Gr.u[Vr.INT] = function(e4, t2) {
  e4.gl.uniform1i(t2._pName, t2.value);
};
Gr.u[Vr.VEC2] = function(e4, t2) {
  e4.gl.uniform2fv(t2._pName, t2.value);
};
Gr.u[Vr.VEC3] = function(e4, t2) {
  e4.gl.uniform3fv(t2._pName, t2.value);
};
Gr.u[Vr.VEC4] = function(e4, t2) {
  e4.gl.uniform4fv(t2._pName, t2.value);
};
Gr.u[Vr.SAMPLER2D] = function(e4, t2) {
  let i2 = e4.gl;
  i2.activeTexture(i2.TEXTURE0 + e4._textureID);
  i2.bindTexture(i2.TEXTURE_2D, t2.value);
  i2.uniform1i(t2._pName, e4._textureID);
  e4._textureID++;
};
Gr.u[Vr.SAMPLERCUBE] = function(e4, t2) {
  let i2 = e4.gl;
  i2.activeTexture(i2.TEXTURE0 + e4._textureID);
  i2.bindTexture(i2.TEXTURE_CUBE_MAP, t2.value);
  i2.uniform1i(t2._pName, e4._textureID);
  e4._textureID++;
};
Gr.u[Vr.SAMPLER2DARRAY] = function(e4, t2) {
  let i2 = t2.value;
  let s2 = e4.gl, r2 = i2.length;
  let n2 = new Int32Array(r2);
  for (let t3 = 0; t3 < r2; t3++) {
    s2.activeTexture(s2.TEXTURE0 + e4._textureID + t3);
    s2.bindTexture(s2.TEXTURE_2D, i2[t3]);
    n2[t3] = t3;
  }
  s2.uniform1iv(t2._pName, n2);
};
Gr.u[Vr.INTXX] = function(e4, t2) {
  e4.gl.uniform1iv(t2._pName, t2.value);
};
Gr.u[Vr.FLOATXX] = function(e4, t2) {
  e4.gl.uniform1fv(t2._pName, t2.value);
};
Gr.a[Vr.FLOAT] = function(e4, t2) {
  e4.gl.vertexAttrib1f(t2._pName, t2.value);
};
Gr.a[Vr.VEC2] = function(e4, t2) {
  e4.gl.vertexAttrib2fv(t2._pName, t2.value);
};
Gr.a[Vr.VEC3] = function(e4, t2) {
  e4.gl.vertexAttrib3fv(t2._pName, t2.value);
};
const Wr = ["BYTE", "SHORT", "UNSIGNED_BYTE", "UNSIGNED_SHORT", "FLOAT", "HALF_FLOAT"];
function jr(e4, t2) {
  if (!t2) return e4;
  const i2 = e4.split("\n");
  const s2 = i2.findIndex((e5) => e5.startsWith("#version"));
  if (s2 !== -1) {
    i2.splice(s2 + 1, 0, "#define WEBGL2");
    return i2.join("\n");
  } else {
    return e4;
  }
}
class Yr {
  constructor(e4, t2) {
    this.name = e4;
    this._attributes = {};
    for (let e5 in t2.attributes) {
      if (typeof t2.attributes[e5] === "string" || typeof t2.attributes[e5] === "number") {
        this._attributes[e5] = { type: t2.attributes[e5] };
      } else {
        this._attributes[e5] = t2.attributes[e5];
      }
    }
    this._uniforms = {};
    for (let e5 in t2.uniforms) {
      if (typeof t2.uniforms[e5] === "string" || typeof t2.uniforms[e5] === "number") {
        this._uniforms[e5] = { type: t2.uniforms[e5] };
      } else {
        this._uniforms[e5] = t2.uniforms[e5];
      }
    }
    this.vertexShader = t2.vertexShader;
    this.fragmentShader = t2.fragmentShader;
    this.gl = null;
    this._variables = {};
    this._p = null;
    this._textureID = 0;
    this._attribArrays = [];
    this._attribDivisor = [];
    this.attributes = {};
    this.uniforms = {};
    this.vertexAttribDivisor = null;
    this.drawElementsInstanced = null;
  }
  static bindBuffer(e4, t2) {
    let i2 = e4.gl;
    if (i2) {
      i2.bindBuffer(i2.ARRAY_BUFFER, t2.value);
      i2.vertexAttribPointer(t2._pName, t2.value.itemSize, t2.itemType, t2.normalized, 0, 0);
    }
  }
  use() {
    this.gl && this.gl.useProgram(this._p);
  }
  set(e4) {
    this._textureID = 0;
    for (let t2 in e4) {
      this._variables[t2].value = e4[t2];
      this._variables[t2].func(this, this._variables[t2]);
    }
  }
  apply() {
    this._textureID = 0;
    let e4 = this._variables;
    for (let t2 in e4) {
      e4[t2].func(this, e4[t2]);
    }
  }
  drawIndexBuffer(e4, t2) {
    let i2 = this.gl;
    i2.bindBuffer(i2.ELEMENT_ARRAY_BUFFER, t2);
    i2.drawElements(e4, t2.numItems, i2.UNSIGNED_SHORT, 0);
  }
  drawArrays(e4, t2) {
    this.gl.drawArrays(e4, 0, t2);
  }
  _getShaderCompileStatus(e4, t2) {
    if (!this.gl) return false;
    const i2 = this.gl instanceof WebGL2RenderingContext;
    this.gl.shaderSource(e4, jr(t2, i2));
    this.gl.compileShader(e4);
    if (!this.gl.getShaderParameter(e4, this.gl.COMPILE_STATUS)) {
      Or.logErr(`Shader program "${this.name}":${this.gl.getShaderInfoLog(e4)}.`);
      return false;
    }
    return true;
  }
  _createVertexShader(e4) {
    if (!this.gl) return;
    let t2 = this.gl.createShader(this.gl.VERTEX_SHADER);
    if (t2 && this._getShaderCompileStatus(t2, e4)) {
      return t2;
    }
  }
  _createFragmentShader(e4) {
    if (!this.gl) return;
    let t2 = this.gl.createShader(this.gl.FRAGMENT_SHADER);
    if (t2 && this._getShaderCompileStatus(t2, e4)) {
      return t2;
    }
  }
  disableAttribArrays() {
    let e4 = this.gl;
    let t2 = this._attribArrays;
    for (let i2 = 0, s2 = t2.length; i2 < s2; i2++) {
      e4.disableVertexAttribArray(t2[i2]);
      this.vertexAttribDivisor(t2[i2], 0);
    }
  }
  enableAttribArrays() {
    let e4 = this.gl;
    let t2 = this._attribArrays;
    let i2 = this._attribDivisor;
    for (let s2 = 0, r2 = t2.length; s2 < r2; s2++) {
      e4.enableVertexAttribArray(t2[s2]);
      this.vertexAttribDivisor(t2[s2], i2[s2]);
    }
  }
  delete() {
    this.gl && this.gl.deleteProgram(this._p);
  }
  createProgram(e4) {
    this.gl = e4;
    this._p = this.gl.createProgram();
    if (!this._p) return;
    let t2 = this._createFragmentShader(this.fragmentShader);
    let i2 = this._createVertexShader(this.vertexShader);
    if (!t2 || !i2) return;
    e4.attachShader(this._p, t2);
    e4.attachShader(this._p, i2);
    e4.linkProgram(this._p);
    if (!this.drawElementsInstanced) {
      if (e4.drawElementsInstanced) {
        this.drawElementsInstanced = e4.drawElementsInstanced.bind(e4);
      } else {
        let t3 = e4.getExtension("ANGLE_instanced_arrays");
        if (t3) {
          this.drawElementsInstanced = t3.drawElementsInstancedANGLE.bind(t3);
        }
      }
    }
    if (!this.vertexAttribDivisor) {
      if (e4.vertexAttribDivisor) {
        this.vertexAttribDivisor = e4.vertexAttribDivisor.bind(e4);
      } else {
        let t3 = e4.getExtension("ANGLE_instanced_arrays");
        if (t3) {
          this.vertexAttribDivisor = t3.vertexAttribDivisorANGLE.bind(t3);
        }
      }
    }
    if (!e4.getProgramParameter(this._p, e4.LINK_STATUS)) {
      Or.logErr(`Shader program "${this.name}": initialization failed. ${e4.getProgramInfoLog(this._p)}.`);
      e4.deleteProgram(this._p);
      return;
    }
    this.use();
    for (let t3 in this._attributes) {
      this._variables[t3] = this._attributes[t3];
      this._attributes[t3].func = Yr.bindBuffer;
      let i3 = this._attributes[t3].itemType;
      let s2 = i3 ? i3.trim().toUpperCase() : "FLOAT";
      if (Wr.indexOf(s2) == -1) {
        Or.logErr(`Shader program "${this.name}": attribute '${t3}', item type '${this._attributes[t3].itemType}' not exists.`);
        this._attributes[t3].itemType = e4.FLOAT;
      } else {
        this._attributes[t3].itemType = e4[s2];
      }
      this._attributes[t3].normalized = this._attributes[t3].normalized || false;
      this._attributes[t3].divisor = this._attributes[t3].divisor || 0;
      this._p[t3] = e4.getAttribLocation(this._p, t3);
      if (this._p[t3] == void 0) {
        Or.logErr(`Shader program "${this.name}":  attribute '${t3}' not exists.`);
        e4.deleteProgram(this._p);
        return;
      }
      let r2 = this._attributes[t3].type;
      if (typeof r2 === "string") {
        r2 = Ur[r2.trim().toLowerCase()];
      }
      let n2 = this._attributes[t3].divisor;
      if (r2 === Vr.MAT4) {
        let e5 = this._p[t3];
        this._attribArrays.push(e5, e5 + 1, e5 + 2, e5 + 3);
        this._attribDivisor.push(n2, n2, n2, n2);
      } else {
        this._attribArrays.push(this._p[t3]);
        this._attribDivisor.push(n2);
      }
      e4.enableVertexAttribArray(this._p[t3]);
      this._attributes[t3]._pName = this._p[t3];
      this.attributes[t3] = this._p[t3];
    }
    for (let t3 in this._uniforms) {
      if (typeof this._uniforms[t3].type === "string") {
        let e5 = this._uniforms[t3].type;
        this._uniforms[t3].func = Gr.u[Ur[e5.trim().toLowerCase()]];
      } else {
        this._uniforms[t3].func = Gr.u[this._uniforms[t3].type];
      }
      this._variables[t3] = this._uniforms[t3];
      this._p[t3] = e4.getUniformLocation(this._p, t3);
      if (this._p[t3] == void 0) {
        Or.logErr(`Shader program "${this.name}": uniform '${t3}' not exists.`);
        e4.deleteProgram(this._p);
        return;
      }
      this._uniforms[t3]._pName = this._p[t3];
      this.uniforms[t3] = this._p[t3];
    }
    e4.detachShader(this._p, t2);
    e4.detachShader(this._p, i2);
    e4.deleteShader(t2);
    e4.deleteShader(i2);
  }
}
var qr = "precision highp float;\n\n#define EMPTY - 1.0\r\n#define RTL 1.0\n\nvec2 project(vec4 p, vec2 viewport) {\r\n    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;\r\n}\n\nmat2 rotate2d(float angle) {\r\n    return mat2(cos(angle), -sin(angle),\r\n    sin(angle), cos(angle));\r\n}\n\nattribute vec2 a_vertices;\r\nattribute vec3 a_positionsHigh;\r\nattribute vec3 a_positionsLow;\r\nattribute vec3 a_offset;\r\nattribute vec2 a_size;\r\nattribute float a_rotation;\r\nattribute vec4 a_rgba;\n\nvarying vec3 v_rgb;\n\nuniform mat4 viewMatrix;\r\nuniform mat4 projectionMatrix;\r\nuniform vec3 eyePositionHigh;\r\nuniform vec3 eyePositionLow;\r\nuniform vec3 uScaleByDistance;\r\nuniform float opacity;\r\nuniform float planetRadius;\r\nuniform vec2 viewport;\r\nuniform float depthOffset;\n\nconst vec3 ZERO3 = vec3(0.0);\r\n\nvoid main() {\n\n    vec3 a_positions = a_positionsHigh + a_positionsLow;\r\n    vec3 cameraPos = eyePositionHigh + eyePositionLow;\n\n    vec3 look = a_positions - cameraPos;\r\n    float lookDist = length(look);\r\n    v_rgb = a_rgba.rgb;\n\n    if (opacity * step(lookDist, sqrt(dot(cameraPos, cameraPos) - planetRadius) + sqrt(dot(a_positions, a_positions) - planetRadius)) == 0.0) {\r\n        return;\r\n    }\n\n    \n    \n\n    float scd = (1.0 - smoothstep(uScaleByDistance[0], uScaleByDistance[1], lookDist)) * (1.0 - step(uScaleByDistance[2], lookDist));\n\n    mat4 viewMatrixRTE = viewMatrix;\r\n    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 highDiff = a_positionsHigh - eyePositionHigh;\r\n    vec3 lowDiff = a_positionsLow - eyePositionLow;\r\n    vec4 posRTE = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);\r\n    vec4 projPos = projectionMatrix * posRTE;\n\n    float camSlope = dot(vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]), normalize(cameraPos));\r\n    if (camSlope > 0.5) {\r\n        float dist = dot(look, normalize(cameraPos));\r\n        projPos.z += dist * 0.02;\r\n    } else {\r\n        projPos.z += -(abs(projPos.z)) * 0.002;\r\n    }\n\n    projPos.z += depthOffset + a_offset.z;\n\n    vec2 screenPos = project(projPos, viewport);\n\n    vec2 v = screenPos + rotate2d(a_rotation) * (a_vertices * a_size * scd + a_offset.xy);\n\n    gl_Position = vec4((2.0 * v / viewport - 1.0) * projPos.w, projPos.z, projPos.w);\r\n}";
var $r = "precision highp float;\n\nvarying vec3 v_rgb;\n\nvoid main() {\r\n    gl_FragColor = vec4(v_rgb, 1.0);\r\n}";
var Xr = "precision highp float;\n\n#define EMPTY - 1.0\r\n#define RTL 1.0\n\nvec2 project(vec4 p, vec2 viewport) {\r\n    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;\r\n}\n\nmat2 rotate2d(float angle) {\r\n    return mat2(cos(angle), -sin(angle),\r\n    sin(angle), cos(angle));\r\n}\n\nattribute vec2 a_vertices;\r\nattribute vec2 a_texCoord;\r\nattribute vec3 a_positionsHigh;\r\nattribute vec3 a_positionsLow;\r\nattribute vec3 a_offset;\r\nattribute vec2 a_size;\r\nattribute float a_rotation;\r\nattribute vec4 a_rgba;\n\nvarying vec2 v_texCoords;\r\nvarying vec4 v_rgba;\n\nuniform mat4 viewMatrix;\r\nuniform mat4 projectionMatrix;\r\nuniform vec3 eyePositionHigh;\r\nuniform vec3 eyePositionLow;\r\nuniform vec3 uScaleByDistance;\r\nuniform float opacity;\r\nuniform float planetRadius;\r\nuniform vec2 viewport;\r\nuniform float depthOffset;\n\nconst vec3 ZERO3 = vec3(0.0);\n\nvoid main() {\n\n    vec3 a_positions = a_positionsHigh + a_positionsLow;\r\n    vec3 cameraPos = eyePositionHigh + eyePositionLow;\n\n    v_texCoords = a_texCoord;\r\n    vec3 look = a_positions - cameraPos;\r\n    float lookDist = length(look);\r\n    v_rgba = a_rgba;\n\n    if (opacity * step(lookDist, sqrt(dot(cameraPos, cameraPos) - planetRadius) + sqrt(dot(a_positions, a_positions) - planetRadius)) == 0.0) {\r\n        return;\r\n    }\n\n    \n    \n\n    float scd = (1.0 - smoothstep(uScaleByDistance[0], uScaleByDistance[1], lookDist)) * (1.0 - step(uScaleByDistance[2], lookDist));\n\n    mat4 viewMatrixRTE = viewMatrix;\r\n    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 highDiff = a_positionsHigh - eyePositionHigh;\r\n    vec3 lowDiff = a_positionsLow - eyePositionLow;\r\n    vec4 posRTE = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);\r\n    vec4 projPos = projectionMatrix * posRTE;\n\n    float camSlope = dot(vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]), normalize(cameraPos));\r\n    if (camSlope > 0.5) {\r\n        float dist = dot(look, normalize(cameraPos));\r\n        projPos.z += dist * 0.02;\r\n    } else {\r\n        projPos.z += -(abs(projPos.z)) * 0.002;\r\n    }\n\n    projPos.z += depthOffset + a_offset.z;\n\n    vec2 screenPos = project(projPos, viewport);\n\n    vec2 v = screenPos + rotate2d(a_rotation) * (a_vertices * a_size * scd + a_offset.xy);\n\n    gl_Position = vec4((2.0 * v / viewport - 1.0) * projPos.w, projPos.z, projPos.w);\r\n}";
var Zr = "precision highp float;\r\nuniform sampler2D u_texture;\r\nvarying vec2 v_texCoords;\r\nvarying vec4 v_rgba;\r\nvoid main () {\r\n    vec4 color = texture2D(u_texture, v_texCoords);\r\n    if(color.a < 0.1)\r\n    discard;\r\n    gl_FragColor = color * v_rgba;\r\n}";
function Kr() {
  return new Yr("billboardPicking", { uniforms: { viewport: "vec2", projectionMatrix: "mat4", viewMatrix: "mat4", eyePositionHigh: "vec3", eyePositionLow: "vec3", planetRadius: "float", uScaleByDistance: "vec3", opacity: "float", depthOffset: "float" }, attributes: { a_vertices: "vec2", a_positionsHigh: "vec3", a_positionsLow: "vec3", a_offset: "vec3", a_size: "vec2", a_rotation: "float", a_rgba: "vec4" }, vertexShader: qr, fragmentShader: $r });
}
function Qr() {
  return new Yr("billboard", { uniforms: { viewport: "vec2", u_texture: "sampler2d", projectionMatrix: "mat4", viewMatrix: "mat4", eyePositionHigh: "vec3", eyePositionLow: "vec3", planetRadius: "float", uScaleByDistance: "vec3", opacity: "float", depthOffset: "float" }, attributes: { a_vertices: "vec2", a_texCoord: "vec2", a_positionsHigh: "vec3", a_positionsLow: "vec3", a_offset: "vec3", a_size: "vec2", a_rotation: "float", a_rgba: "vec4" }, vertexShader: Xr, fragmentShader: Zr });
}
const Jr = 0;
const en = 1;
const tn = 2;
const sn = 3;
const rn = 4;
const nn = 5;
const on = 6;
const an = 7;
const _ln = class _ln {
  constructor(e4) {
    this.__id = _ln.__counter__++;
    this.pickingEnabled = true;
    this._entityCollection = e4;
    this._renderer = null;
    this._billboards = [];
    this._positionHighBuffer = null;
    this._positionLowBuffer = null;
    this._sizeBuffer = null;
    this._offsetBuffer = null;
    this._rgbaBuffer = null;
    this._rotationBuffer = null;
    this._texCoordBuffer = null;
    this._vertexBuffer = null;
    this._pickingColorBuffer = null;
    this._texCoordArr = new Float32Array([]);
    this._vertexArr = new Float32Array([]);
    this._positionHighArr = new Float32Array([]);
    this._positionLowArr = new Float32Array([]);
    this._sizeArr = new Float32Array([]);
    this._offsetArr = new Float32Array([]);
    this._rgbaArr = new Float32Array([]);
    this._rotationArr = new Float32Array([]);
    this._pickingColorArr = new Float32Array([]);
    this._buffersUpdateCallbacks = [];
    this._buffersUpdateCallbacks[Jr] = this.createPickingColorBuffer;
    this._buffersUpdateCallbacks[en] = this.createPositionBuffer;
    this._buffersUpdateCallbacks[tn] = this.createSizeBuffer;
    this._buffersUpdateCallbacks[sn] = this.createOffsetBuffer;
    this._buffersUpdateCallbacks[rn] = this.createRgbaBuffer;
    this._buffersUpdateCallbacks[nn] = this.createRotationBuffer;
    this._buffersUpdateCallbacks[on] = this.createTexCoordBuffer;
    this._buffersUpdateCallbacks[an] = this.createVertexBuffer;
    this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
  }
  isEqual(e4) {
    return e4 && e4.__id === this.__id;
  }
  static concArr(e4, t2) {
    for (let i2 = 0; i2 < t2.length; i2++) {
      e4.push(t2[i2]);
    }
  }
  initProgram() {
    if (this._renderer && this._renderer.handler) {
      if (!this._renderer.handler.programs.billboard) {
        this._renderer.handler.addProgram(Qr());
      }
      if (!this._renderer.handler.programs.billboardPicking) {
        this._renderer.handler.addProgram(Kr());
      }
    }
  }
  setRenderer(e4) {
    this._renderer = e4;
    this.initProgram();
  }
  refresh() {
    let e4 = this._changedBuffers.length;
    while (e4--) {
      this._changedBuffers[e4] = true;
    }
  }
  _removeBillboards() {
    let e4 = this._billboards.length;
    while (e4--) {
      let t2 = this._billboards[e4];
      t2._handlerIndex = -1;
      t2._handler = null;
      t2._isReady = false;
      t2._lockId = $s;
    }
    this._billboards.length = 0;
    this._billboards = [];
  }
  clear() {
    this._texCoordArr = null;
    this._vertexArr = null;
    this._positionHighArr = null;
    this._positionLowArr = null;
    this._sizeArr = null;
    this._offsetArr = null;
    this._rgbaArr = null;
    this._rotationArr = null;
    this._pickingColorArr = null;
    this._texCoordArr = new Float32Array([]);
    this._vertexArr = new Float32Array([]);
    this._positionHighArr = new Float32Array([]);
    this._positionLowArr = new Float32Array([]);
    this._sizeArr = new Float32Array([]);
    this._offsetArr = new Float32Array([]);
    this._rgbaArr = new Float32Array([]);
    this._rotationArr = new Float32Array([]);
    this._pickingColorArr = new Float32Array([]);
    this._removeBillboards();
    this._deleteBuffers();
    this.refresh();
  }
  _deleteBuffers() {
    if (this._renderer) {
      let e4 = this._renderer.handler.gl;
      e4.deleteBuffer(this._positionHighBuffer);
      e4.deleteBuffer(this._positionLowBuffer);
      e4.deleteBuffer(this._sizeBuffer);
      e4.deleteBuffer(this._offsetBuffer);
      e4.deleteBuffer(this._rgbaBuffer);
      e4.deleteBuffer(this._rotationBuffer);
      e4.deleteBuffer(this._vertexBuffer);
      e4.deleteBuffer(this._texCoordBuffer);
      e4.deleteBuffer(this._pickingColorBuffer);
    }
    this._positionHighBuffer = null;
    this._positionLowBuffer = null;
    this._sizeBuffer = null;
    this._offsetBuffer = null;
    this._rgbaBuffer = null;
    this._rotationBuffer = null;
    this._vertexBuffer = null;
    this._texCoordBuffer = null;
    this._pickingColorBuffer = null;
  }
  update() {
    if (this._renderer) {
      let e4 = this._changedBuffers.length;
      while (e4--) {
        if (this._changedBuffers[e4]) {
          this._buffersUpdateCallbacks[e4].call(this);
          this._changedBuffers[e4] = false;
        }
      }
    }
  }
  add(e4) {
    if (e4._handlerIndex == -1) {
      e4._isReady = true;
      e4._handler = this;
      e4._handlerIndex = this._billboards.length;
      this._billboards.push(e4);
    }
  }
  _displayPASS() {
    let e4 = this._renderer;
    let t2 = e4.handler;
    t2.programs.billboard.activate();
    let i2 = t2.programs.billboard._program;
    let s2 = i2.attributes, r2 = i2.uniforms;
    let n2 = t2.gl, o2 = this._entityCollection;
    n2.disable(n2.CULL_FACE);
    n2.uniform1f(r2.depthOffset, o2.polygonOffsetUnits);
    n2.uniform1i(r2.u_texture, 0);
    n2.uniformMatrix4fv(r2.viewMatrix, false, e4.activeCamera.getViewMatrix());
    n2.uniformMatrix4fv(r2.projectionMatrix, false, e4.activeCamera.getProjectionMatrix());
    n2.uniform3fv(r2.eyePositionHigh, e4.activeCamera.eyeHigh);
    n2.uniform3fv(r2.eyePositionLow, e4.activeCamera.eyeLow);
    n2.uniform3fv(r2.uScaleByDistance, o2.scaleByDistance);
    n2.uniform1f(r2.opacity, o2._fadingOpacity);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._texCoordBuffer);
    n2.vertexAttribPointer(s2.a_texCoord, this._texCoordBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._vertexBuffer);
    n2.vertexAttribPointer(s2.a_vertices, this._vertexBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._positionHighBuffer);
    n2.vertexAttribPointer(s2.a_positionsHigh, this._positionHighBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._positionLowBuffer);
    n2.vertexAttribPointer(s2.a_positionsLow, this._positionLowBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._rgbaBuffer);
    n2.vertexAttribPointer(s2.a_rgba, this._rgbaBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._sizeBuffer);
    n2.vertexAttribPointer(s2.a_size, this._sizeBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._offsetBuffer);
    n2.vertexAttribPointer(s2.a_offset, this._offsetBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.uniform1f(r2.planetRadius, o2.renderNode._planetRadius2 || 0);
    n2.uniform2fv(r2.viewport, [t2.canvas.clientWidth, t2.canvas.clientHeight]);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._rotationBuffer);
    n2.vertexAttribPointer(s2.a_rotation, this._rotationBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.drawArrays(n2.TRIANGLES, 0, this._vertexBuffer.numItems);
    n2.enable(n2.CULL_FACE);
  }
  _pickingPASS() {
    let e4 = this._renderer;
    let t2 = e4.handler;
    t2.programs.billboardPicking.activate();
    let i2 = t2.programs.billboardPicking._program;
    let s2 = i2.attributes, r2 = i2.uniforms;
    let n2 = t2.gl, o2 = this._entityCollection;
    n2.disable(n2.CULL_FACE);
    n2.uniform1f(r2.depthOffset, o2.polygonOffsetUnits);
    n2.uniformMatrix4fv(r2.viewMatrix, false, e4.activeCamera.getViewMatrix());
    n2.uniformMatrix4fv(r2.projectionMatrix, false, e4.activeCamera.getProjectionMatrix());
    n2.uniform3fv(r2.eyePositionHigh, e4.activeCamera.eyeHigh);
    n2.uniform3fv(r2.eyePositionLow, e4.activeCamera.eyeLow);
    n2.uniform3fv(r2.uScaleByDistance, o2.scaleByDistance);
    n2.uniform1f(r2.opacity, o2._fadingOpacity);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._vertexBuffer);
    n2.vertexAttribPointer(s2.a_vertices, this._vertexBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._positionHighBuffer);
    n2.vertexAttribPointer(s2.a_positionsHigh, this._positionHighBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._positionLowBuffer);
    n2.vertexAttribPointer(s2.a_positionsLow, this._positionLowBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._pickingColorBuffer);
    n2.vertexAttribPointer(s2.a_rgba, this._pickingColorBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._sizeBuffer);
    n2.vertexAttribPointer(s2.a_size, this._sizeBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._offsetBuffer);
    n2.vertexAttribPointer(s2.a_offset, this._offsetBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.uniform1f(r2.planetRadius, o2.renderNode._planetRadius2 || 0);
    n2.uniform2fv(r2.viewport, [t2.canvas.clientWidth, t2.canvas.clientHeight]);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._rotationBuffer);
    n2.vertexAttribPointer(s2.a_rotation, this._rotationBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.drawArrays(n2.TRIANGLES, 0, this._vertexBuffer.numItems);
    n2.enable(n2.CULL_FACE);
  }
  draw() {
    if (this._billboards.length) {
      this.update();
      this._displayPASS();
    }
  }
  drawPicking() {
    if (this._billboards.length && this.pickingEnabled) {
      this._pickingPASS();
    }
  }
  reindexBillboardsArray(e4) {
    let t2 = this._billboards;
    for (let i2 = e4; i2 < t2.length; i2++) {
      t2[i2]._handlerIndex = i2;
    }
  }
  _removeBillboard(e4) {
    let t2 = e4._handlerIndex;
    this._billboards.splice(t2, 1);
    let i2 = t2 * 24;
    this._rgbaArr = jt(this._rgbaArr, i2, 24);
    i2 = t2 * 18;
    this._positionHighArr = jt(this._positionHighArr, i2, 18);
    this._positionLowArr = jt(this._positionLowArr, i2, 18);
    this._offsetArr = jt(this._offsetArr, i2, 18);
    this._pickingColorArr = jt(this._pickingColorArr, i2, 18);
    i2 = t2 * 12;
    this._vertexArr = jt(this._vertexArr, i2, 12);
    this._sizeArr = jt(this._sizeArr, i2, 12);
    this._texCoordArr = jt(this._texCoordArr, i2, 12);
    i2 = t2 * 6;
    this._rotationArr = jt(this._rotationArr, i2, 6);
    this.reindexBillboardsArray(t2);
    this.refresh();
    e4._handlerIndex = -1;
    e4._handler = null;
    e4._isReady = false;
    e4._lockId = $s;
  }
  setAlignedAxisArr(e4, t2) {
  }
  remove(e4) {
    if (e4._handler) {
      if (e4._isReady && this.__id === e4._handler.__id) {
        this._removeBillboard(e4);
      } else {
        e4._handler = null;
      }
    }
  }
  setPositionArr(e4, t2, i2) {
    let s2 = e4 * 18;
    let r2 = this._positionHighArr, n2 = t2.x, o2 = t2.y, a2 = t2.z;
    r2[s2] = n2;
    r2[s2 + 1] = o2;
    r2[s2 + 2] = a2;
    r2[s2 + 3] = n2;
    r2[s2 + 4] = o2;
    r2[s2 + 5] = a2;
    r2[s2 + 6] = n2;
    r2[s2 + 7] = o2;
    r2[s2 + 8] = a2;
    r2[s2 + 9] = n2;
    r2[s2 + 10] = o2;
    r2[s2 + 11] = a2;
    r2[s2 + 12] = n2;
    r2[s2 + 13] = o2;
    r2[s2 + 14] = a2;
    r2[s2 + 15] = n2;
    r2[s2 + 16] = o2;
    r2[s2 + 17] = a2;
    r2 = this._positionLowArr;
    n2 = i2.x;
    o2 = i2.y;
    a2 = i2.z;
    r2[s2] = n2;
    r2[s2 + 1] = o2;
    r2[s2 + 2] = a2;
    r2[s2 + 3] = n2;
    r2[s2 + 4] = o2;
    r2[s2 + 5] = a2;
    r2[s2 + 6] = n2;
    r2[s2 + 7] = o2;
    r2[s2 + 8] = a2;
    r2[s2 + 9] = n2;
    r2[s2 + 10] = o2;
    r2[s2 + 11] = a2;
    r2[s2 + 12] = n2;
    r2[s2 + 13] = o2;
    r2[s2 + 14] = a2;
    r2[s2 + 15] = n2;
    r2[s2 + 16] = o2;
    r2[s2 + 17] = a2;
    this._changedBuffers[en] = true;
  }
  setPickingColorArr(e4, t2) {
    let i2 = e4 * 18;
    let s2 = this._pickingColorArr, r2 = t2.x / 255, n2 = t2.y / 255, o2 = t2.z / 255;
    s2[i2] = r2;
    s2[i2 + 1] = n2;
    s2[i2 + 2] = o2;
    s2[i2 + 3] = r2;
    s2[i2 + 4] = n2;
    s2[i2 + 5] = o2;
    s2[i2 + 6] = r2;
    s2[i2 + 7] = n2;
    s2[i2 + 8] = o2;
    s2[i2 + 9] = r2;
    s2[i2 + 10] = n2;
    s2[i2 + 11] = o2;
    s2[i2 + 12] = r2;
    s2[i2 + 13] = n2;
    s2[i2 + 14] = o2;
    s2[i2 + 15] = r2;
    s2[i2 + 16] = n2;
    s2[i2 + 17] = o2;
    this._changedBuffers[Jr] = true;
  }
  setSizeArr(e4, t2, i2) {
    let s2 = e4 * 12;
    let r2 = this._sizeArr, n2 = t2, o2 = i2;
    r2[s2] = n2;
    r2[s2 + 1] = o2;
    r2[s2 + 2] = n2;
    r2[s2 + 3] = o2;
    r2[s2 + 4] = n2;
    r2[s2 + 5] = o2;
    r2[s2 + 6] = n2;
    r2[s2 + 7] = o2;
    r2[s2 + 8] = n2;
    r2[s2 + 9] = o2;
    r2[s2 + 10] = n2;
    r2[s2 + 11] = o2;
    this._changedBuffers[tn] = true;
  }
  setOffsetArr(e4, t2) {
    let i2 = e4 * 18;
    let s2 = this._offsetArr, r2 = t2.x, n2 = t2.y, o2 = t2.z;
    s2[i2] = r2;
    s2[i2 + 1] = n2;
    s2[i2 + 2] = o2;
    s2[i2 + 3] = r2;
    s2[i2 + 4] = n2;
    s2[i2 + 5] = o2;
    s2[i2 + 6] = r2;
    s2[i2 + 7] = n2;
    s2[i2 + 8] = o2;
    s2[i2 + 9] = r2;
    s2[i2 + 10] = n2;
    s2[i2 + 11] = o2;
    s2[i2 + 12] = r2;
    s2[i2 + 13] = n2;
    s2[i2 + 14] = o2;
    s2[i2 + 15] = r2;
    s2[i2 + 16] = n2;
    s2[i2 + 17] = o2;
    this._changedBuffers[sn] = true;
  }
  setRgbaArr(e4, t2) {
    let i2 = e4 * 24;
    let s2 = this._rgbaArr, r2 = t2.x, n2 = t2.y, o2 = t2.z, a2 = t2.w;
    s2[i2] = r2;
    s2[i2 + 1] = n2;
    s2[i2 + 2] = o2;
    s2[i2 + 3] = a2;
    s2[i2 + 4] = r2;
    s2[i2 + 5] = n2;
    s2[i2 + 6] = o2;
    s2[i2 + 7] = a2;
    s2[i2 + 8] = r2;
    s2[i2 + 9] = n2;
    s2[i2 + 10] = o2;
    s2[i2 + 11] = a2;
    s2[i2 + 12] = r2;
    s2[i2 + 13] = n2;
    s2[i2 + 14] = o2;
    s2[i2 + 15] = a2;
    s2[i2 + 16] = r2;
    s2[i2 + 17] = n2;
    s2[i2 + 18] = o2;
    s2[i2 + 19] = a2;
    s2[i2 + 20] = r2;
    s2[i2 + 21] = n2;
    s2[i2 + 22] = o2;
    s2[i2 + 23] = a2;
    this._changedBuffers[rn] = true;
  }
  setRotationArr(e4, t2) {
    let i2 = e4 * 6;
    let s2 = this._rotationArr;
    s2[i2] = t2;
    s2[i2 + 1] = t2;
    s2[i2 + 2] = t2;
    s2[i2 + 3] = t2;
    s2[i2 + 4] = t2;
    s2[i2 + 5] = t2;
    this._changedBuffers[nn] = true;
  }
  setTexCoordArr(e4, t2) {
    let i2 = e4 * 12;
    let s2 = this._texCoordArr;
    s2[i2] = t2[0];
    s2[i2 + 1] = t2[1];
    s2[i2 + 2] = t2[2];
    s2[i2 + 3] = t2[3];
    s2[i2 + 4] = t2[4];
    s2[i2 + 5] = t2[5];
    s2[i2 + 6] = t2[6];
    s2[i2 + 7] = t2[7];
    s2[i2 + 8] = t2[8];
    s2[i2 + 9] = t2[9];
    s2[i2 + 10] = t2[10];
    s2[i2 + 11] = t2[11];
    this._changedBuffers[on] = true;
  }
  setVisibility(e4, t2) {
    let i2;
    if (t2) {
      i2 = [-0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5];
    } else {
      i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }
    this.setVertexArr(e4, i2);
  }
  setVertexArr(e4, t2) {
    let i2 = e4 * 12;
    let s2 = this._vertexArr;
    s2[i2] = t2[0];
    s2[i2 + 1] = t2[1];
    s2[i2 + 2] = t2[2];
    s2[i2 + 3] = t2[3];
    s2[i2 + 4] = t2[4];
    s2[i2 + 5] = t2[5];
    s2[i2 + 6] = t2[6];
    s2[i2 + 7] = t2[7];
    s2[i2 + 8] = t2[8];
    s2[i2 + 9] = t2[9];
    s2[i2 + 10] = t2[10];
    s2[i2 + 11] = t2[11];
    this._changedBuffers[an] = true;
  }
  createPositionBuffer() {
    let e4 = this._renderer.handler, t2 = this._positionHighArr.length / 3;
    if (!this._positionHighBuffer || this._positionHighBuffer.numItems !== t2) {
      e4.gl.deleteBuffer(this._positionHighBuffer);
      e4.gl.deleteBuffer(this._positionLowBuffer);
      this._positionHighBuffer = e4.createStreamArrayBuffer(3, t2);
      this._positionLowBuffer = e4.createStreamArrayBuffer(3, t2);
    }
    e4.setStreamArrayBuffer(this._positionHighBuffer, this._positionHighArr);
    e4.setStreamArrayBuffer(this._positionLowBuffer, this._positionLowArr);
  }
  createSizeBuffer() {
    let e4 = this._renderer.handler;
    e4.gl.deleteBuffer(this._sizeBuffer);
    this._sizeBuffer = e4.createArrayBuffer(this._sizeArr, 2, this._sizeArr.length / 2);
  }
  createOffsetBuffer() {
    let e4 = this._renderer.handler;
    e4.gl.deleteBuffer(this._offsetBuffer);
    this._offsetBuffer = e4.createArrayBuffer(this._offsetArr, 3, this._offsetArr.length / 3);
  }
  createRgbaBuffer() {
    let e4 = this._renderer.handler;
    e4.gl.deleteBuffer(this._rgbaBuffer);
    this._rgbaBuffer = e4.createArrayBuffer(this._rgbaArr, 4, this._rgbaArr.length / 4);
  }
  createRotationBuffer() {
    let e4 = this._renderer.handler;
    if (!this._rotationBuffer || this._rotationBuffer.numItems !== this._rotationArr.length) {
      e4.gl.deleteBuffer(this._rotationBuffer);
      this._rotationBuffer = e4.createStreamArrayBuffer(1, this._rotationArr.length);
    }
    e4.setStreamArrayBuffer(this._rotationBuffer, this._rotationArr);
  }
  createVertexBuffer() {
    let e4 = this._renderer.handler;
    e4.gl.deleteBuffer(this._vertexBuffer);
    this._vertexBuffer = e4.createArrayBuffer(this._vertexArr, 2, this._vertexArr.length / 2);
  }
  createTexCoordBuffer() {
    let e4 = this._renderer.handler;
    e4.gl.deleteBuffer(this._texCoordBuffer);
    this._texCoordBuffer = e4.createArrayBuffer(this._texCoordArr, 2, this._texCoordArr.length / 2);
  }
  createPickingColorBuffer() {
    let e4 = this._renderer.handler;
    e4.gl.deleteBuffer(this._pickingColorBuffer);
    this._pickingColorBuffer = e4.createArrayBuffer(this._pickingColorArr, 3, this._pickingColorArr.length / 3);
  }
  refreshTexCoordsArr() {
  }
};
_ln.__counter__ = 0;
let ln = _ln;
class hn extends ln {
  constructor(e4) {
    super(e4);
    this._billboards = [];
  }
  add(e4) {
    if (e4._handlerIndex == -1) {
      super.add(e4);
      this._addBillboardToArrays(e4);
      this.refresh();
      let t2 = e4.getSrc() || e4.getImage() && e4.getImage().src;
      if (t2) {
        e4.setSrc(t2);
      }
    }
  }
  _addBillboardToArrays(e4) {
    if (e4.getVisibility()) {
      this._vertexArr = Ht(this._vertexArr, [-0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5]);
    } else {
      this._vertexArr = Ht(this._vertexArr, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    }
    this._texCoordArr = Ht(this._texCoordArr, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    let t2 = e4._positionHigh.x, i2 = e4._positionHigh.y, s2 = e4._positionHigh.z, r2;
    this._positionHighArr = Ht(this._positionHighArr, [t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2]);
    t2 = e4._positionLow.x;
    i2 = e4._positionLow.y;
    s2 = e4._positionLow.z;
    this._positionLowArr = Ht(this._positionLowArr, [t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2]);
    t2 = e4._width;
    i2 = e4._height;
    this._sizeArr = Ht(this._sizeArr, [t2, i2, t2, i2, t2, i2, t2, i2, t2, i2, t2, i2]);
    t2 = e4._offset.x;
    i2 = e4._offset.y;
    s2 = e4._offset.z;
    this._offsetArr = Ht(this._offsetArr, [t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2]);
    t2 = e4._color.x;
    i2 = e4._color.y;
    s2 = e4._color.z;
    r2 = e4._color.w;
    this._rgbaArr = Ht(this._rgbaArr, [t2, i2, s2, r2, t2, i2, s2, r2, t2, i2, s2, r2, t2, i2, s2, r2, t2, i2, s2, r2, t2, i2, s2, r2]);
    t2 = e4._rotation;
    this._rotationArr = Ht(this._rotationArr, [t2, t2, t2, t2, t2, t2]);
    t2 = e4._entity._pickingColor.x / 255;
    i2 = e4._entity._pickingColor.y / 255;
    s2 = e4._entity._pickingColor.z / 255;
    this._pickingColorArr = Ht(this._pickingColorArr, [t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2]);
  }
  get billboards() {
    return this._billboards;
  }
  refreshTexCoordsArr() {
    let e4 = this._entityCollection;
    if (e4 && this._renderer) {
      let e5 = this._renderer.billboardsTextureAtlas;
      for (let t2 = 0; t2 < this._billboards.length; t2++) {
        let i2 = this._billboards[t2];
        let s2 = i2.getImage();
        if (s2) {
          let t3 = e5.get(s2.__nodeIndex);
          if (t3) {
            this.setTexCoordArr(i2._handlerIndex, t3.texCoords);
          }
        }
      }
    }
  }
}
var cn = "precision highp float;\n\nvec3 qRotate(vec4 q, vec3 v) {\r\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\r\n}\n\nattribute vec3 aVertexPosition;\r\nattribute vec3 aVertexNormal;\n\nattribute vec3 aRTCPositionHigh;\r\nattribute vec3 aRTCPositionLow;\n\nattribute vec4 aColor;\r\nattribute vec3 aScale;\r\nattribute vec3 aTranslate;\r\nattribute float aDispose;\r\nattribute float aUseTexture;\r\nattribute vec2 aTexCoord;\r\nattribute vec4 qRot;\r\nattribute vec3 aLocalPosition;\n\nuniform vec3 uScaleByDistance;\r\nuniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\n\nuniform vec3 eyePositionHigh;\r\nuniform vec3 eyePositionLow;\n\nuniform vec3 rtcEyePositionHigh;\r\nuniform vec3 rtcEyePositionLow;\n\nvarying vec3 cameraPosition;\r\nvarying vec3 vNormal;\r\nvarying vec3 v_vertex;\r\nvarying vec4 vColor;\r\nvarying float vDispose;\r\nvarying vec2 vTexCoords;\n\nvoid main(void) {\n\n    if (aDispose == 0.0) {\r\n        return;\r\n    }\n\n    vColor = aColor;\r\n    vTexCoords = aTexCoord;\n\n    mat4 viewMatrixRTE = viewMatrix;\r\n    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 highDiff = aRTCPositionHigh - rtcEyePositionHigh;\r\n    vec3 lowDiff = aRTCPositionLow - rtcEyePositionLow;\n\n    cameraPosition = eyePositionHigh + eyePositionLow;\n\n    highDiff = highDiff * step(1.0, length(highDiff));\n\n    vec4 positionInViewSpace = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);\n\n    float lookLength = length(positionInViewSpace.xyz);\n\n    vNormal = normalize(qRotate(qRot, aVertexNormal));\n\n    float scd = uScaleByDistance[2] * clamp(lookLength, uScaleByDistance[0], uScaleByDistance[1]) / uScaleByDistance[0];\r\n    vec3 vert = qRotate(qRot, scd * (aVertexPosition * aScale + aTranslate)) + scd * aLocalPosition;\n\n    gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff + lowDiff + vert, 1.0);\n\n    v_vertex = positionInViewSpace.xyz + vert;\r\n}";
var dn = "precision highp float;\n\nuniform vec3 sunPosition;\r\nuniform vec3 materialParams[3];\r\nuniform float materialShininess;\r\nuniform sampler2D uTexture;\r\nuniform float uUseTexture;\r\nuniform float useLighting;\n\nvarying vec3 cameraPosition;\r\nvarying vec3 v_vertex;\r\nvarying vec4 vColor;\r\nvarying vec3 vNormal;\r\nvarying vec2 vTexCoords;\n\nvoid main(void) {\n\n    vec3 lightWeighting = vec3(1.0);\n\n    if (useLighting != 0.0) {\r\n        vec3 normal = normalize(vNormal);\r\n        vec3 light_dir = normalize(sunPosition);\r\n        vec3 look_dir = normalize(cameraPosition - v_vertex);\n\n        float diffuse = max(dot(normal, light_dir), 0.0);\n\n        vec3 refl_dir = reflect(-light_dir, normal);\r\n        float refl = max(dot(refl_dir, look_dir), 0.0);\r\n        float specular = pow(refl, materialShininess) * step(1e-4, diffuse);\n\n        lightWeighting = vColor.rgb * materialParams[0]\r\n        + materialParams[1] * diffuse\r\n        + materialParams[2] * specular;\r\n    } else {\r\n        lightWeighting = vColor.rgb;\r\n    }\n\n    if (uUseTexture > 0.0) {\r\n        vec4 texColor = texture2D(uTexture, vTexCoords);\r\n        gl_FragColor = vec4(texColor.rgb * lightWeighting, texColor.a);\r\n    } else {\r\n        gl_FragColor = vec4(lightWeighting, vColor.a);\r\n    }\r\n}";
var un = "precision highp float;\n\nvec3 qRotate(vec4 q, vec3 v) {\r\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\r\n}\n\nattribute vec3 aVertexPosition;\r\nattribute vec3 aRTCPositionHigh;\r\nattribute vec3 aRTCPositionLow;\r\nattribute vec3 aPickingColor;\r\nattribute vec3 aScale;\r\nattribute vec3 aTranslate;\r\nattribute float aDispose;\r\nattribute vec4 qRot;\n\nattribute vec3 aLocalPosition;\n\nuniform vec3 rtcEyePositionHigh;\r\nuniform vec3 rtcEyePositionLow;\n\nuniform vec3 uScaleByDistance;\r\nuniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform vec3 pickingScale;\n\nvarying vec3 vColor;\n\nvoid main(void) {\n\n    if (aDispose == 0.0) {\r\n        return;\r\n    }\n\n    vColor = aPickingColor;\n\n    mat4 viewMatrixRTE = viewMatrix;\r\n    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 highDiff = aRTCPositionHigh - rtcEyePositionHigh;\r\n    vec3 lowDiff = aRTCPositionLow - rtcEyePositionLow;\n\n    highDiff = highDiff * step(1.0, length(highDiff));\n\n    vec4 positionInViewSpace = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);\n\n    float lookLength = length(positionInViewSpace.xyz);\n\n    float scd = uScaleByDistance[2] * clamp(lookLength, uScaleByDistance[0], uScaleByDistance[1]) / uScaleByDistance[0];\n\n    vec3 vert = qRotate(qRot, scd * pickingScale * (aVertexPosition * aScale + aTranslate)) + scd * aLocalPosition;\n\n    gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff + lowDiff + vert, 1.0);\r\n}";
var _n = "precision highp float;\r\nvarying vec3 vColor;\n\nvoid main() {\r\n    gl_FragColor = vec4(vColor, 1.0);\r\n}";
var fn = "#version 300 es\r\nprecision highp float;\n\nvec3 qRotate(vec4 q, vec3 v) {\r\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\r\n}\n\nin vec3 aVertexPosition;\r\nin vec3 aRTCPositionHigh;\r\nin vec3 aRTCPositionLow;\r\nin vec3 aScale;\r\nin vec3 aTranslate;\r\nin float aDispose;\r\nin vec4 qRot;\r\nin vec3 aLocalPosition;\n\nuniform vec3 rtcEyePositionHigh;\r\nuniform vec3 rtcEyePositionLow;\r\nuniform vec3 uScaleByDistance;\r\nuniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\n\nvoid main(void) {\n\n    if (aDispose == 0.0) {\r\n        return;\r\n    }\n\n    mat4 viewMatrixRTE = viewMatrix;\r\n    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 highDiff = aRTCPositionHigh - rtcEyePositionHigh;\r\n    vec3 lowDiff = aRTCPositionLow - rtcEyePositionLow;\n\n    highDiff = highDiff * step(1.0, length(highDiff));\n\n    vec4 positionInViewSpace = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);\n\n    float lookLength = length(positionInViewSpace.xyz);\n\n    float scd = uScaleByDistance[2] * clamp(lookLength, uScaleByDistance[0], uScaleByDistance[1]) / uScaleByDistance[0];\n\n    vec3 vert = qRotate(qRot, scd * (aVertexPosition * aScale + aTranslate)) + scd * aLocalPosition;\n\n    gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff + lowDiff + vert, 1.0);\r\n}";
var gn = "#version 300 es\r\nprecision highp float;\n\nuniform float frustumPickingColor;\n\nlayout (location = 0) out vec4 frustumColor;\r\nlayout (location = 1) out vec4 depthColor;\n\nvoid main() {\r\n    frustumColor = vec4(frustumPickingColor, frustumPickingColor, frustumPickingColor, 1.0);\r\n    depthColor = vec4(gl_FragCoord.z, gl_FragCoord.z, gl_FragCoord.z, 1.0);\r\n}";
const pn = () => new Yr("geo_object", { uniforms: { viewMatrix: "mat4", projectionMatrix: "mat4", uScaleByDistance: "vec3", eyePositionHigh: "vec3", eyePositionLow: "vec3", rtcEyePositionHigh: "vec3", rtcEyePositionLow: "vec3", sunPosition: "vec3", materialParams: "vec3", materialShininess: "float", uTexture: "sampler2d", uUseTexture: "float", useLighting: "float" }, attributes: { aVertexPosition: "vec3", aVertexNormal: "vec3", aTexCoord: "vec2", aLocalPosition: { type: "vec3", divisor: 1 }, aRTCPositionHigh: { type: "vec3", divisor: 1 }, aRTCPositionLow: { type: "vec3", divisor: 1 }, aColor: { type: "vec4", divisor: 1 }, aScale: { type: "vec3", divisor: 1 }, aTranslate: { type: "vec3", divisor: 1 }, aDispose: { type: "float", divisor: 1 }, qRot: { type: "vec4", divisor: 1 } }, vertexShader: cn, fragmentShader: dn });
const mn = () => new Yr("geo_object_picking", { uniforms: { viewMatrix: "mat4", projectionMatrix: "mat4", uScaleByDistance: "vec3", pickingScale: "vec3", rtcEyePositionHigh: "vec3", rtcEyePositionLow: "vec3" }, attributes: { aVertexPosition: "vec3", aRTCPositionHigh: { type: "vec3", divisor: 1 }, aRTCPositionLow: { type: "vec3", divisor: 1 }, aPickingColor: { type: "vec3", divisor: 1 }, aScale: { type: "vec3", divisor: 1 }, aTranslate: { type: "vec3", divisor: 1 }, aLocalPosition: { type: "vec3", divisor: 1 }, aDispose: { type: "float", divisor: 1 }, qRot: { type: "vec4", divisor: 1 } }, vertexShader: un, fragmentShader: _n });
const vn = () => new Yr("geo_object_depth", { uniforms: { viewMatrix: "mat4", projectionMatrix: "mat4", uScaleByDistance: "vec3", rtcEyePositionHigh: "vec3", rtcEyePositionLow: "vec3", frustumPickingColor: "float" }, attributes: { aVertexPosition: "vec3", aRTCPositionHigh: { type: "vec3", divisor: 1 }, aRTCPositionLow: { type: "vec3", divisor: 1 }, aScale: { type: "vec3", divisor: 1 }, aTranslate: { type: "vec3", divisor: 1 }, aDispose: { type: "float", divisor: 1 }, qRot: { type: "vec4", divisor: 1 }, aLocalPosition: { type: "vec3", divisor: 1 } }, vertexShader: fn, fragmentShader: gn });
const yn = 0;
const xn = 1;
const bn = 2;
const wn = 3;
const Cn = 4;
const Tn = 5;
const En = 6;
const An = 7;
const Ln = 8;
class Pn {
  constructor(e4) {
    this.isFree = true;
    this._geoObjectHandler = e4;
    this.geoObjects = [];
    this.numInstances = 0;
    this._colorTexture = null;
    this._colorTextureSrc = null;
    this._normalTexture = null;
    this._normalTextureSrc = null;
    this._metallicRoughnessTexture = null;
    this._metallicRoughnessTextureSrc = null;
    this._sizeArr = [];
    this._translateArr = [];
    this._vertexArr = [];
    this._rtcPositionHighArr = [];
    this._rtcPositionLowArr = [];
    this._qRotArr = [];
    this._rgbaArr = [];
    this._normalsArr = [];
    this._indicesArr = [];
    this._pickingColorArr = [];
    this._visibleArr = [];
    this._texCoordArr = [];
    this._localPositionArr = [];
    this._sizeBuffer = null;
    this._translateBuffer = null;
    this._vertexBuffer = null;
    this._rtcPositionHighBuffer = null;
    this._rtcPositionLowBuffer = null;
    this._qRotBuffer = null;
    this._rgbaBuffer = null;
    this._normalsBuffer = null;
    this._indicesBuffer = null;
    this._pickingColorBuffer = null;
    this._visibleBuffer = null;
    this._texCoordBuffer = null;
    this._localPositionBuffer = null;
    this._materialParams = new Float32Array(9);
    this._materialShininess = 0;
    this._buffersUpdateCallbacks = [];
    this._buffersUpdateCallbacks[Dn] = this.createPickingColorBuffer;
    this._buffersUpdateCallbacks[Bn] = this.createNormalsBuffer;
    this._buffersUpdateCallbacks[Mn] = this.createRgbaBuffer;
    this._buffersUpdateCallbacks[kn] = this.createIndicesBuffer;
    this._buffersUpdateCallbacks[Sn] = this.createVertexBuffer;
    this._buffersUpdateCallbacks[zn] = this.createSizeBuffer;
    this._buffersUpdateCallbacks[Fn] = this.createVisibleBuffer;
    this._buffersUpdateCallbacks[Nn] = this.createTexCoordBuffer;
    this._buffersUpdateCallbacks[In] = this.createQRotBuffer;
    this._buffersUpdateCallbacks[On] = this.createTranslateBuffer;
    this._buffersUpdateCallbacks[Rn] = this.createRTCPositionBuffer;
    this._buffersUpdateCallbacks[Hn] = this.createLocalPositionBuffer;
    this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
  }
  setMaterialAmbient(e4, t2, i2) {
    this._materialParams[yn] = e4;
    this._materialParams[xn] = t2;
    this._materialParams[bn] = i2;
  }
  setMaterialDiffuse(e4, t2, i2) {
    this._materialParams[wn] = e4;
    this._materialParams[Cn] = t2;
    this._materialParams[Tn] = i2;
  }
  setMaterialSpecular(e4, t2, i2) {
    this._materialParams[En] = e4;
    this._materialParams[An] = t2;
    this._materialParams[Ln] = i2;
  }
  setMaterialShininess(e4) {
    this._materialShininess = e4;
  }
  setMaterialParams(e4, t2, i2, s2) {
    this.setMaterialAmbient(e4[0], e4[1], e4[2]);
    this.setMaterialDiffuse(t2[0], t2[1], t2[2]);
    this.setMaterialSpecular(i2[0], i2[1], i2[2]);
    this.setMaterialShininess(s2);
  }
  drawOpaque(e4) {
    let t2 = e4.gl, i2 = e4.uniforms, s2 = e4.attributes;
    t2.bindBuffer(t2.ARRAY_BUFFER, this._qRotBuffer);
    t2.vertexAttribPointer(s2.qRot, this._qRotBuffer.itemSize, t2.FLOAT, false, 0, 0);
    t2.bindBuffer(t2.ARRAY_BUFFER, this._sizeBuffer);
    t2.vertexAttribPointer(s2.aScale, this._sizeBuffer.itemSize, t2.FLOAT, false, 0, 0);
    t2.bindBuffer(t2.ARRAY_BUFFER, this._translateBuffer);
    t2.vertexAttribPointer(s2.aTranslate, this._translateBuffer.itemSize, t2.FLOAT, false, 0, 0);
    t2.bindBuffer(t2.ARRAY_BUFFER, this._localPositionBuffer);
    t2.vertexAttribPointer(s2.aLocalPosition, this._localPositionBuffer.itemSize, t2.FLOAT, false, 0, 0);
    t2.bindBuffer(t2.ARRAY_BUFFER, this._visibleBuffer);
    t2.vertexAttribPointer(s2.aDispose, this._visibleBuffer.itemSize, t2.FLOAT, false, 0, 0);
    t2.uniform1f(i2.uUseTexture, this._colorTexture ? 1 : 0);
    t2.bindBuffer(t2.ARRAY_BUFFER, this._rgbaBuffer);
    t2.vertexAttribPointer(s2.aColor, this._rgbaBuffer.itemSize, t2.FLOAT, false, 0, 0);
    t2.uniform3fv(i2.materialParams, this._materialParams);
    t2.uniform1f(i2.materialShininess, this._materialShininess);
    this._drawElementsInstanced(e4);
  }
  drawTransparent(e4) {
    let t2 = e4.gl, i2 = e4.uniforms, s2 = e4.attributes;
    t2.bindBuffer(t2.ARRAY_BUFFER, this._qRotBuffer);
    t2.vertexAttribPointer(s2.qRot, this._qRotBuffer.itemSize, t2.FLOAT, false, 0, 0);
    t2.bindBuffer(t2.ARRAY_BUFFER, this._sizeBuffer);
    t2.vertexAttribPointer(s2.aScale, this._sizeBuffer.itemSize, t2.FLOAT, false, 0, 0);
    t2.bindBuffer(t2.ARRAY_BUFFER, this._translateBuffer);
    t2.vertexAttribPointer(s2.aTranslate, this._translateBuffer.itemSize, t2.FLOAT, false, 0, 0);
    t2.bindBuffer(t2.ARRAY_BUFFER, this._localPositionBuffer);
    t2.vertexAttribPointer(s2.aLocalPosition, this._localPositionBuffer.itemSize, t2.FLOAT, false, 0, 0);
    t2.bindBuffer(t2.ARRAY_BUFFER, this._visibleBuffer);
    t2.vertexAttribPointer(s2.aDispose, this._visibleBuffer.itemSize, t2.FLOAT, false, 0, 0);
    t2.uniform1f(i2.uUseTexture, this._colorTexture ? 1 : 0);
    t2.uniform3fv(i2.materialParams, this._materialParams);
    t2.uniform1f(i2.materialShininess, this._materialShininess);
    t2.bindBuffer(t2.ARRAY_BUFFER, this._rgbaBuffer);
    t2.vertexAttribPointer(s2.aColor, this._rgbaBuffer.itemSize, t2.FLOAT, false, 0, 0);
    this._drawElementsInstanced(e4);
  }
  _drawElementsInstanced(e4) {
    let t2 = e4.gl, i2 = e4.uniforms, s2 = e4.attributes;
    let r2 = this._geoObjectHandler._renderer;
    t2.bindBuffer(t2.ARRAY_BUFFER, this._rtcPositionHighBuffer);
    t2.vertexAttribPointer(s2.aRTCPositionHigh, this._rtcPositionHighBuffer.itemSize, t2.FLOAT, false, 0, 0);
    t2.bindBuffer(t2.ARRAY_BUFFER, this._rtcPositionLowBuffer);
    t2.vertexAttribPointer(s2.aRTCPositionLow, this._rtcPositionLowBuffer.itemSize, t2.FLOAT, false, 0, 0);
    t2.bindBuffer(t2.ARRAY_BUFFER, this._normalsBuffer);
    t2.vertexAttribPointer(s2.aVertexNormal, this._normalsBuffer.itemSize, t2.FLOAT, false, 0, 0);
    t2.bindBuffer(t2.ARRAY_BUFFER, this._vertexBuffer);
    t2.vertexAttribPointer(s2.aVertexPosition, this._vertexBuffer.itemSize, t2.FLOAT, false, 0, 0);
    t2.activeTexture(t2.TEXTURE0);
    t2.bindTexture(t2.TEXTURE_2D, this._colorTexture || r2.handler.defaultTexture);
    t2.uniform1i(i2.uTexture, 0);
    t2.bindBuffer(t2.ARRAY_BUFFER, this._texCoordBuffer);
    t2.vertexAttribPointer(s2.aTexCoord, this._texCoordBuffer.itemSize, t2.FLOAT, false, 0, 0);
    t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
    e4.drawElementsInstanced(t2.TRIANGLES, this._indicesBuffer.numItems, t2.UNSIGNED_INT, 0, this.numInstances);
  }
  createColorTexture(e4) {
    if (this._geoObjectHandler && this._geoObjectHandler._renderer) {
      let t2 = this._geoObjectHandler._renderer.handler;
      this._colorTexture = t2.createTextureDefault(e4, null, t2.gl.REPEAT);
    }
  }
  createNormalTexture(e4) {
    if (this._geoObjectHandler && this._geoObjectHandler._renderer) {
      let t2 = this._geoObjectHandler._renderer.handler;
      this._normalTexture = t2.createTextureDefault(e4, null, t2.gl.REPEAT);
    }
  }
  createMetallicRoughnessTexture(e4) {
    if (this._geoObjectHandler && this._geoObjectHandler._renderer) {
      let t2 = this._geoObjectHandler._renderer.handler;
      this._metallicRoughnessTexture = t2.createTextureDefault(e4, null, t2.gl.REPEAT);
    }
  }
  clear() {
    this.numInstances = 0;
    this.geoObjects = [];
    this._sizeArr = [];
    this._translateArr = [];
    this._vertexArr = [];
    this._rtcPositionHighArr = [];
    this._rtcPositionLowArr = [];
    this._qRotArr = [];
    this._rgbaArr = [];
    this._normalsArr = [];
    this._indicesArr = [];
    this._pickingColorArr = [];
    this._visibleArr = [];
    this._texCoordArr = [];
    this._localPositionArr = [];
    this._deleteBuffers();
    this.isFree = false;
  }
  _deleteBuffers() {
    if (this._geoObjectHandler && this._geoObjectHandler._renderer) {
      let e4 = this._geoObjectHandler._renderer.handler, t2 = e4.gl;
      e4.deleteTexture(this._colorTexture);
      e4.deleteTexture(this._normalTexture);
      e4.deleteTexture(this._metallicRoughnessTexture);
      this._colorTexture = null;
      this._normalTexture = null;
      this._metallicRoughnessTexture = null;
      t2.deleteBuffer(this._sizeBuffer);
      t2.deleteBuffer(this._translateBuffer);
      t2.deleteBuffer(this._vertexBuffer);
      t2.deleteBuffer(this._rtcPositionHighBuffer);
      t2.deleteBuffer(this._rtcPositionLowBuffer);
      t2.deleteBuffer(this._qRotBuffer);
      t2.deleteBuffer(this._rgbaBuffer);
      t2.deleteBuffer(this._normalsBuffer);
      t2.deleteBuffer(this._indicesBuffer);
      t2.deleteBuffer(this._pickingColorBuffer);
      t2.deleteBuffer(this._visibleBuffer);
      t2.deleteBuffer(this._texCoordBuffer);
      t2.deleteBuffer(this._localPositionBuffer);
    }
    this._sizeBuffer = null;
    this._translateBuffer = null;
    this._vertexBuffer = null;
    this._rtcPositionHighBuffer = null;
    this._rtcPositionLowBuffer = null;
    this._qRotBuffer = null;
    this._rgbaBuffer = null;
    this._normalsBuffer = null;
    this._indicesBuffer = null;
    this._pickingColorBuffer = null;
    this._visibleBuffer = null;
    this._texCoordBuffer = null;
    this._localPositionBuffer = null;
  }
  createVertexBuffer() {
    const e4 = this._geoObjectHandler._renderer.handler;
    e4.gl.deleteBuffer(this._vertexBuffer);
    this._vertexArr = Ut(this._vertexArr);
    this._vertexBuffer = e4.createArrayBuffer(this._vertexArr, 3, this._vertexArr.length / 3);
  }
  createVisibleBuffer() {
    const e4 = this._geoObjectHandler._renderer.handler, t2 = this._visibleArr.length;
    if (!this._visibleBuffer || this._visibleBuffer.numItems !== t2) {
      e4.gl.deleteBuffer(this._visibleBuffer);
      this._visibleBuffer = e4.createStreamArrayBuffer(1, t2);
    }
    this._visibleArr = Ut(this._visibleArr);
    e4.setStreamArrayBuffer(this._visibleBuffer, this._visibleArr);
  }
  createSizeBuffer() {
    let e4 = this._geoObjectHandler._renderer.handler, t2 = this._sizeArr.length / 3;
    if (!this._sizeBuffer || this._sizeBuffer.numItems !== t2) {
      e4.gl.deleteBuffer(this._sizeBuffer);
      this._sizeBuffer = e4.createStreamArrayBuffer(3, t2);
    }
    this._sizeArr = Ut(this._sizeArr);
    e4.setStreamArrayBuffer(this._sizeBuffer, this._sizeArr);
  }
  createTranslateBuffer() {
    let e4 = this._geoObjectHandler._renderer.handler, t2 = this._translateArr.length / 3;
    if (!this._translateBuffer || this._translateBuffer.numItems !== t2) {
      e4.gl.deleteBuffer(this._translateBuffer);
      this._translateBuffer = e4.createStreamArrayBuffer(3, t2);
    }
    this._translateArr = Ut(this._translateArr);
    e4.setStreamArrayBuffer(this._translateBuffer, this._translateArr);
  }
  createLocalPositionBuffer() {
    let e4 = this._geoObjectHandler._renderer.handler, t2 = this._localPositionArr.length / 3;
    if (!this._localPositionBuffer || this._localPositionBuffer.numItems !== t2) {
      e4.gl.deleteBuffer(this._localPositionBuffer);
      this._localPositionBuffer = e4.createStreamArrayBuffer(3, t2);
    }
    this._localPositionArr = Ut(this._localPositionArr);
    e4.setStreamArrayBuffer(this._localPositionBuffer, this._localPositionArr);
  }
  createTexCoordBuffer() {
    const e4 = this._geoObjectHandler._renderer.handler;
    e4.gl.deleteBuffer(this._texCoordBuffer);
    this._texCoordArr = Ut(this._texCoordArr);
    this._texCoordBuffer = e4.createArrayBuffer(this._texCoordArr, 2, this._texCoordArr.length / 2);
  }
  createRTCPositionBuffer() {
    let e4 = this._geoObjectHandler._renderer.handler, t2 = this._rtcPositionHighArr.length / 3;
    if (!this._rtcPositionHighBuffer || this._rtcPositionHighBuffer.numItems !== t2) {
      e4.gl.deleteBuffer(this._rtcPositionHighBuffer);
      e4.gl.deleteBuffer(this._rtcPositionLowBuffer);
      this._rtcPositionHighBuffer = e4.createStreamArrayBuffer(3, t2);
      this._rtcPositionLowBuffer = e4.createStreamArrayBuffer(3, t2);
    }
    this._rtcPositionHighArr = Ut(this._rtcPositionHighArr);
    this._rtcPositionLowArr = Ut(this._rtcPositionLowArr);
    e4.setStreamArrayBuffer(this._rtcPositionHighBuffer, this._rtcPositionHighArr);
    e4.setStreamArrayBuffer(this._rtcPositionLowBuffer, this._rtcPositionLowArr);
  }
  createRgbaBuffer() {
    let e4 = this._geoObjectHandler._renderer.handler, t2 = this._rgbaArr.length / 4;
    if (!this._rgbaBuffer || this._rgbaBuffer.numItems !== t2) {
      e4.gl.deleteBuffer(this._rgbaBuffer);
      this._rgbaBuffer = e4.createStreamArrayBuffer(4, t2);
    }
    this._rgbaArr = Ut(this._rgbaArr);
    e4.setStreamArrayBuffer(this._rgbaBuffer, this._rgbaArr);
  }
  createQRotBuffer() {
    let e4 = this._geoObjectHandler._renderer.handler, t2 = this._qRotArr.length / 4;
    if (!this._qRotBuffer || this._qRotBuffer.numItems !== t2) {
      e4.gl.deleteBuffer(this._qRotBuffer);
      this._qRotBuffer = e4.createStreamArrayBuffer(4, t2);
    }
    this._qRotArr = Ut(this._qRotArr);
    e4.setStreamArrayBuffer(this._qRotBuffer, this._qRotArr);
  }
  createNormalsBuffer() {
    const e4 = this._geoObjectHandler._renderer.handler;
    e4.gl.deleteBuffer(this._normalsBuffer);
    this._normalsArr = Ut(this._normalsArr);
    this._normalsBuffer = e4.createArrayBuffer(this._normalsArr, 3, this._normalsArr.length / 3);
  }
  createIndicesBuffer() {
    const e4 = this._geoObjectHandler._renderer.handler;
    e4.gl.deleteBuffer(this._indicesBuffer);
    this._indicesArr = Ut(this._indicesArr, Uint32Array);
    this._indicesBuffer = e4.createElementArrayBuffer(this._indicesArr, 1, this._indicesArr.length);
  }
  createPickingColorBuffer() {
    const e4 = this._geoObjectHandler._renderer.handler;
    e4.gl.deleteBuffer(this._pickingColorBuffer);
    this._pickingColorArr = Ut(this._pickingColorArr);
    this._pickingColorBuffer = e4.createArrayBuffer(this._pickingColorArr, 3, this._pickingColorArr.length / 3);
  }
  refresh() {
    let e4 = this._changedBuffers.length;
    while (e4--) {
      this._changedBuffers[e4] = true;
    }
  }
  update() {
    if (this._geoObjectHandler._renderer) {
      let e4 = this._changedBuffers.length;
      while (e4--) {
        if (this._changedBuffers[e4]) {
          this._buffersUpdateCallbacks[e4].call(this);
          this._changedBuffers[e4] = false;
        }
      }
      this.isFree = true;
    }
  }
}
const Sn = 0;
const Rn = 1;
const Mn = 2;
const Bn = 3;
const kn = 4;
const In = 5;
const zn = 6;
const Dn = 7;
const Fn = 8;
const Nn = 9;
const On = 10;
const Hn = 11;
function Vn(e4, t2 = 0, i2 = 0, s2 = 1, ...r2) {
  const n2 = t2 * i2;
  for (let t3 = n2, o2 = n2 + i2; t3 < o2; t3++) {
    e4[t3] = r2[t3 % s2];
  }
  return e4;
}
const _Un = class _Un {
  constructor(e4) {
    this.__id = _Un.__counter__++;
    this.pickingEnabled = true;
    this._entityCollection = e4;
    this._renderNode = null;
    this._renderer = null;
    this._geoObjects = [];
    this._instanceDataMap = /* @__PURE__ */ new Map();
    this._instanceDataMapValues = [];
    this._dataTagUpdateQueue = [];
    this._relativeCenter = new Ke();
    this._rtcEyePositionHigh = new Float32Array([0, 0, 0]);
    this._rtcEyePositionLow = new Float32Array([0, 0, 0]);
  }
  initProgram() {
    if (this._renderer) {
      if (!this._renderer.handler.programs.geo_object) {
        this._renderer.handler.addProgram(pn());
      }
      if (!this._renderer.handler.programs.geo_object_picking) {
        this._renderer.handler.addProgram(mn());
      }
      if (!this._renderer.handler.programs.geo_object_depth) {
        this._renderer.handler.addProgram(vn());
      }
    }
  }
  setRenderNode(e4) {
    this._renderNode = e4;
    this._renderer = e4.renderer;
    this.initProgram();
    for (let e5 = 0; e5 < this._instanceDataMapValues.length; e5++) {
      this._loadColorTexture(this._instanceDataMapValues[e5]);
      this._loadNormalTexture(this._instanceDataMapValues[e5]);
      this._loadMetallicRoughnessTexture(this._instanceDataMapValues[e5]);
    }
    for (let e5 = 0; e5 < this._geoObjects.length; e5++) {
      this._geoObjects[e5].updateRotation();
    }
    this.update();
  }
  setColorTextureTag(e4, t2) {
    const i2 = this._instanceDataMap.get(t2);
    if (i2) {
      i2._colorTextureSrc = e4;
      this._instanceDataMap.set(t2, i2);
      this._loadColorTexture(i2);
    }
  }
  setNormalTextureTag(e4, t2) {
    const i2 = this._instanceDataMap.get(t2);
    if (i2) {
      i2._normalTextureSrc = e4;
      this._instanceDataMap.set(t2, i2);
      this._loadNormalTexture(i2);
    }
  }
  setMetallicRoughnessTextureTag(e4, t2) {
    const i2 = this._instanceDataMap.get(t2);
    if (i2) {
      i2._metallicRoughnessTextureSrc = e4;
      this._instanceDataMap.set(t2, i2);
      this._loadMetallicRoughnessTexture(i2);
    }
  }
  setObjectSrc(e4, t2) {
    const i2 = this._instanceDataMap.get(t2);
    if (e4) {
      if (i2 && i2._objectSrc !== e4) {
        i2._objectSrc = e4;
        ur.loadObj(e4).then((e5) => {
          this._updateInstanceData(e5[0], t2);
        });
      }
    }
  }
  _updateInstanceData(e4, t2) {
    const i2 = this._instanceDataMap.get(t2);
    if (i2) {
      if (e4.vertices.length !== i2._vertexArr.length) {
        i2._vertexArr = e4.vertices;
        i2._changedBuffers[Sn] = true;
      }
      if (e4.normals.length !== i2._normalsArr.length) {
        i2._normalsArr = e4.normals;
        i2._changedBuffers[Bn] = true;
      }
      if (e4.indices.length !== i2._indicesArr.length) {
        i2._indicesArr = e4.indices;
        i2._changedBuffers[kn] = true;
      }
      if (e4.texCoords.length !== i2._texCoordArr.length) {
        i2._texCoordArr = e4.texCoords;
        i2._changedBuffers[Nn] = true;
      }
      i2._colorTextureSrc = e4.colorTexture;
      i2._normalTextureSrc = e4.normalTexture;
      i2._metallicRoughnessTexture = e4.metallicRoughnessTexture;
      this._loadColorTexture(i2);
      this._loadNormalTexture(i2);
      this._loadMetallicRoughnessTexture(i2);
      this._updateTag(i2);
      this._instanceDataMapValues = Array.from(this._instanceDataMap.values());
    }
  }
  _addGeoObjectToArray(e4) {
    const t2 = e4.tag;
    let i2 = this._instanceDataMap.get(t2);
    if (!i2) {
      i2 = new Pn(this);
      this._instanceDataMap.set(t2, i2);
      this._instanceDataMapValues = Array.from(this._instanceDataMap.values());
      i2._vertexArr = e4.vertices;
      i2._normalsArr = e4.normals;
      i2._indicesArr = e4.indices;
      i2._texCoordArr = e4.texCoords;
      i2._colorTextureSrc = e4.object3d.colorTexture;
      i2._normalTextureSrc = e4.object3d.normalTexture;
      i2._metallicRoughnessTextureSrc = e4.object3d.metallicRoughnessTexture;
      i2.setMaterialParams(e4.object3d.ambient, e4.object3d.diffuse, e4.object3d.specular, e4.object3d.shininess);
      this._loadColorTexture(i2);
      this._loadNormalTexture(i2);
      this._loadMetallicRoughnessTexture(i2);
    }
    e4._tagDataIndex = i2.numInstances++;
    e4._tagData = i2;
    i2.geoObjects.push(e4);
    let s2 = 3;
    i2._visibleArr = Vt(i2._visibleArr, Vn([], 0, 1, 1, e4.getVisibility() ? 1 : 0));
    this.getRTCPosition(e4.getPosition(), e4._rtcPositionHigh, e4._rtcPositionLow);
    let r2 = e4._rtcPositionHigh.x, n2 = e4._rtcPositionHigh.y, o2 = e4._rtcPositionHigh.z, a2;
    i2._rtcPositionHighArr = Vt(i2._rtcPositionHighArr, Vn([], 0, s2, s2, r2, n2, o2));
    r2 = e4._rtcPositionLow.x;
    n2 = e4._rtcPositionLow.y;
    o2 = e4._rtcPositionLow.z;
    i2._rtcPositionLowArr = Vt(i2._rtcPositionLowArr, Vn([], 0, s2, s2, r2, n2, o2));
    r2 = e4._entity._pickingColor.x / 255;
    n2 = e4._entity._pickingColor.y / 255;
    o2 = e4._entity._pickingColor.z / 255;
    i2._pickingColorArr = Vt(i2._pickingColorArr, Vn([], 0, s2, s2, r2, n2, o2));
    s2 = 4;
    r2 = e4._qRot.x;
    n2 = e4._qRot.y;
    o2 = e4._qRot.z;
    a2 = e4._qRot.w;
    i2._qRotArr = Vt(i2._qRotArr, Vn([], 0, s2, s2, r2, n2, o2, a2));
    r2 = e4._color.x;
    n2 = e4._color.y;
    o2 = e4._color.z;
    a2 = e4._color.w;
    i2._rgbaArr = Vt(i2._rgbaArr, Vn([], 0, s2, s2, r2, n2, o2, a2));
    s2 = 3;
    let l2 = e4.getScale();
    r2 = l2.x;
    n2 = l2.y;
    o2 = l2.z;
    i2._sizeArr = Vt(i2._sizeArr, Vn([], 0, s2, s2, r2, n2, o2));
    let h2 = e4.getTranslate();
    r2 = h2.x;
    n2 = h2.y;
    o2 = h2.z;
    i2._translateArr = Vt(i2._translateArr, Vn([], 0, s2, s2, r2, n2, o2));
    let c2 = e4.getLocalPosition();
    r2 = c2.x;
    n2 = c2.y;
    o2 = c2.z;
    i2._localPositionArr = Vt(i2._localPositionArr, Vn([], 0, s2, s2, r2, n2, o2));
  }
  _bindCommon() {
    let e4 = this._renderer, t2 = e4.handler.programs.geo_object, i2 = t2._program, s2 = i2.uniforms, r2 = e4.handler.gl, n2 = this._entityCollection;
    r2.uniform3fv(s2.uScaleByDistance, n2.scaleByDistance);
    r2.uniform1f(s2.useLighting, n2._useLighting);
    r2.uniform3fv(s2.eyePositionHigh, e4.activeCamera.eyeHigh);
    r2.uniform3fv(s2.eyePositionLow, e4.activeCamera.eyeLow);
    r2.uniform3fv(s2.rtcEyePositionHigh, this._rtcEyePositionHigh);
    r2.uniform3fv(s2.rtcEyePositionLow, this._rtcEyePositionLow);
    r2.uniformMatrix4fv(s2.projectionMatrix, false, e4.activeCamera.getProjectionMatrix());
    r2.uniformMatrix4fv(s2.viewMatrix, false, e4.activeCamera.getViewMatrix());
    r2.uniform3fv(s2.sunPosition, this._renderNode._lightPosition);
  }
  _displayOpaquePASS() {
    let e4 = this._renderer, t2 = e4.handler.programs.geo_object, i2 = t2._program;
    t2.activate();
    this._bindCommon();
    for (let e5 = 0; e5 < this._instanceDataMapValues.length; e5++) {
      let t3 = this._instanceDataMapValues[e5];
      t3.drawOpaque(i2);
    }
  }
  _displayTransparentPASS() {
    let e4 = this._renderer, t2 = e4.handler.programs.geo_object, i2 = t2._program;
    t2.activate();
    this._bindCommon();
    for (let e5 = 0; e5 < this._instanceDataMapValues.length; e5++) {
      this._instanceDataMapValues[e5].drawTransparent(i2);
    }
  }
  _depthPASS() {
    let e4 = this._renderer, t2 = e4.handler.programs.geo_object_depth, i2 = t2._program, s2 = i2.uniforms, r2 = i2.attributes, n2 = e4.handler.gl, o2 = this._entityCollection;
    let a2 = e4.activeCamera;
    t2.activate();
    n2.uniform3fv(s2.uScaleByDistance, o2.scaleByDistance);
    n2.uniform3fv(s2.rtcEyePositionHigh, this._rtcEyePositionHigh);
    n2.uniform3fv(s2.rtcEyePositionLow, this._rtcEyePositionLow);
    n2.uniformMatrix4fv(s2.projectionMatrix, false, e4.activeCamera.getProjectionMatrix());
    n2.uniformMatrix4fv(s2.viewMatrix, false, e4.activeCamera.getViewMatrix());
    n2.uniform1f(s2.frustumPickingColor, a2.frustumColorIndex);
    for (let e5 = 0; e5 < this._instanceDataMapValues.length; e5++) {
      let t3 = this._instanceDataMapValues[e5];
      n2.bindBuffer(n2.ARRAY_BUFFER, t3._qRotBuffer);
      n2.vertexAttribPointer(r2.qRot, t3._qRotBuffer.itemSize, n2.FLOAT, false, 0, 0);
      n2.bindBuffer(n2.ARRAY_BUFFER, t3._sizeBuffer);
      n2.vertexAttribPointer(r2.aScale, t3._sizeBuffer.itemSize, n2.FLOAT, false, 0, 0);
      n2.bindBuffer(n2.ARRAY_BUFFER, t3._translateBuffer);
      n2.vertexAttribPointer(r2.aTranslate, t3._translateBuffer.itemSize, n2.FLOAT, false, 0, 0);
      n2.bindBuffer(n2.ARRAY_BUFFER, t3._localPositionBuffer);
      n2.vertexAttribPointer(r2.aLocalPosition, t3._localPositionBuffer.itemSize, n2.FLOAT, false, 0, 0);
      n2.bindBuffer(n2.ARRAY_BUFFER, t3._rtcPositionHighBuffer);
      n2.vertexAttribPointer(r2.aRTCPositionHigh, t3._rtcPositionHighBuffer.itemSize, n2.FLOAT, false, 0, 0);
      n2.bindBuffer(n2.ARRAY_BUFFER, t3._rtcPositionLowBuffer);
      n2.vertexAttribPointer(r2.aRTCPositionLow, t3._rtcPositionLowBuffer.itemSize, n2.FLOAT, false, 0, 0);
      n2.bindBuffer(n2.ARRAY_BUFFER, t3._visibleBuffer);
      n2.vertexAttribPointer(r2.aDispose, t3._visibleBuffer.itemSize, n2.FLOAT, false, 0, 0);
      n2.bindBuffer(n2.ARRAY_BUFFER, t3._vertexBuffer);
      n2.vertexAttribPointer(r2.aVertexPosition, t3._vertexBuffer.itemSize, n2.FLOAT, false, 0, 0);
      n2.bindBuffer(n2.ELEMENT_ARRAY_BUFFER, t3._indicesBuffer);
      i2.drawElementsInstanced(n2.TRIANGLES, t3._indicesBuffer.numItems, n2.UNSIGNED_INT, 0, t3.numInstances);
    }
  }
  drawDepth() {
    if (this._geoObjects.length) {
      this._depthPASS();
    }
  }
  drawPicking() {
    if (this._geoObjects.length && this.pickingEnabled) {
      this._pickingPASS();
    }
  }
  _pickingPASS() {
    let e4 = this._renderer, t2 = e4.handler.programs.geo_object_picking, i2 = t2._program, s2 = i2.uniforms, r2 = i2.attributes, n2 = e4.handler.gl, o2 = this._entityCollection;
    t2.activate();
    n2.uniform3fv(s2.uScaleByDistance, o2.scaleByDistance);
    n2.uniform3fv(s2.pickingScale, o2.pickingScale);
    n2.uniform3fv(s2.rtcEyePositionHigh, this._rtcEyePositionHigh);
    n2.uniform3fv(s2.rtcEyePositionLow, this._rtcEyePositionLow);
    n2.uniformMatrix4fv(s2.projectionMatrix, false, e4.activeCamera.getProjectionMatrix());
    n2.uniformMatrix4fv(s2.viewMatrix, false, e4.activeCamera.getViewMatrix());
    for (let e5 = 0; e5 < this._instanceDataMapValues.length; e5++) {
      let t3 = this._instanceDataMapValues[e5];
      n2.bindBuffer(n2.ARRAY_BUFFER, t3._qRotBuffer);
      n2.vertexAttribPointer(r2.qRot, t3._qRotBuffer.itemSize, n2.FLOAT, false, 0, 0);
      n2.bindBuffer(n2.ARRAY_BUFFER, t3._sizeBuffer);
      n2.vertexAttribPointer(r2.aScale, t3._sizeBuffer.itemSize, n2.FLOAT, false, 0, 0);
      n2.bindBuffer(n2.ARRAY_BUFFER, t3._translateBuffer);
      n2.vertexAttribPointer(r2.aTranslate, t3._translateBuffer.itemSize, n2.FLOAT, false, 0, 0);
      n2.bindBuffer(n2.ARRAY_BUFFER, t3._localPositionBuffer);
      n2.vertexAttribPointer(r2.aLocalPosition, t3._localPositionBuffer.itemSize, n2.FLOAT, false, 0, 0);
      n2.bindBuffer(n2.ARRAY_BUFFER, t3._pickingColorBuffer);
      n2.vertexAttribPointer(r2.aPickingColor, t3._pickingColorBuffer.itemSize, n2.FLOAT, false, 0, 0);
      n2.bindBuffer(n2.ARRAY_BUFFER, t3._rtcPositionHighBuffer);
      n2.vertexAttribPointer(r2.aRTCPositionHigh, t3._rtcPositionHighBuffer.itemSize, n2.FLOAT, false, 0, 0);
      n2.bindBuffer(n2.ARRAY_BUFFER, t3._rtcPositionLowBuffer);
      n2.vertexAttribPointer(r2.aRTCPositionLow, t3._rtcPositionLowBuffer.itemSize, n2.FLOAT, false, 0, 0);
      n2.bindBuffer(n2.ARRAY_BUFFER, t3._visibleBuffer);
      n2.vertexAttribPointer(r2.aDispose, t3._visibleBuffer.itemSize, n2.FLOAT, false, 0, 0);
      n2.bindBuffer(n2.ARRAY_BUFFER, t3._vertexBuffer);
      n2.vertexAttribPointer(r2.aVertexPosition, t3._vertexBuffer.itemSize, n2.FLOAT, false, 0, 0);
      n2.bindBuffer(n2.ELEMENT_ARRAY_BUFFER, t3._indicesBuffer);
      i2.drawElementsInstanced(n2.TRIANGLES, t3._indicesBuffer.numItems, n2.UNSIGNED_INT, 0, t3.numInstances);
    }
  }
  async _loadColorTexture(e4) {
    if (this._renderer && e4._colorTextureSrc) {
      const t2 = await Zt(e4._colorTextureSrc);
      e4.createColorTexture(t2);
    }
  }
  async _loadNormalTexture(e4) {
    if (this._renderer && e4._normalTextureSrc) {
      const t2 = await Zt(e4._normalTextureSrc);
      e4.createNormalTexture(t2);
    }
  }
  async _loadMetallicRoughnessTexture(e4) {
    if (this._renderer && e4._metallicRoughnessTextureSrc) {
      const t2 = await Zt(e4._metallicRoughnessTextureSrc);
      e4.createMetallicRoughnessTexture(t2);
    }
  }
  setQRotArr(e4, t2, i2) {
    Vn(e4._qRotArr, t2, 4, 4, i2.x, i2.y, i2.z, i2.w);
    e4._changedBuffers[In] = true;
    this._updateTag(e4);
  }
  setVisibility(e4, t2, i2) {
    Vn(e4._visibleArr, t2, 1, 1, i2 ? 1 : 0);
    e4._changedBuffers[Fn] = true;
    this._updateTag(e4);
  }
  setRTCPositionArr(e4, t2, i2, s2) {
    Vn(e4._rtcPositionHighArr, t2, 3, 3, i2.x, i2.y, i2.z);
    Vn(e4._rtcPositionLowArr, t2, 3, 3, s2.x, s2.y, s2.z);
    e4._changedBuffers[Rn] = true;
    this._updateTag(e4);
  }
  setRgbaArr(e4, t2, i2) {
    Vn(e4._rgbaArr, t2, 4, 4, i2.x, i2.y, i2.z, i2.w);
    e4._changedBuffers[Mn] = true;
    this._updateTag(e4);
  }
  setPickingColorArr(e4, t2, i2) {
    Vn(e4._pickingColorArr, t2, 3, 3, i2.x / 255, i2.y / 255, i2.z / 255);
    e4._changedBuffers[Dn] = true;
    this._updateTag(e4);
  }
  setScaleArr(e4, t2, i2) {
    Vn(e4._sizeArr, t2, 3, 3, i2.x, i2.y, i2.z);
    e4._changedBuffers[zn] = true;
    this._updateTag(e4);
  }
  setTranslateArr(e4, t2, i2) {
    Vn(e4._translateArr, t2, 3, 3, i2.x, i2.y, i2.z);
    e4._changedBuffers[On] = true;
    this._updateTag(e4);
  }
  setLocalPositionArr(e4, t2, i2) {
    Vn(e4._localPositionArr, t2, 3, 3, i2.x, i2.y, i2.z);
    e4._changedBuffers[Hn] = true;
    this._updateTag(e4);
  }
  _updateTag(e4) {
    if (e4.isFree) {
      e4.isFree = false;
      this._dataTagUpdateQueue.push(e4);
    }
  }
  update() {
    for (let e4 = 0, t2 = this._dataTagUpdateQueue.length; e4 < t2; e4++) {
      this._dataTagUpdateQueue[e4].update();
    }
    this._dataTagUpdateQueue = [];
  }
  _removeAll() {
    let e4 = this._geoObjects.length;
    while (e4--) {
      const t2 = this._geoObjects[e4];
      t2._tagDataIndex = -1;
      t2._tagData = null;
      t2._handlerIndex = -1;
      t2._handler = null;
    }
    this._geoObjects.length = 0;
    this._geoObjects = [];
    for (let e5 = 0; e5 < this._instanceDataMapValues.length; e5++) {
      this._instanceDataMapValues[e5].clear();
    }
    this._instanceDataMap.clear();
    this._instanceDataMapValues = [];
  }
  clear() {
    this._removeAll();
  }
  getRTCPosition(e4, t2, i2) {
    let s2 = e4.sub(this._relativeCenter);
    Ke.doubleToTwoFloats(s2, t2, i2);
  }
  setRelativeCenter(e4) {
    this._relativeCenter.copy(e4);
    for (let e5 = 0; e5 < this._instanceDataMapValues.length; e5++) {
      let t2 = this._instanceDataMapValues[e5];
      let i2 = t2.geoObjects;
      for (let e6 = 0; e6 < i2.length; e6++) {
        i2[e6].updateRTCPosition();
      }
    }
  }
  _updateRTCEyePosition() {
    let e4 = this._renderer;
    if (e4.activeCamera.isFirstPass) {
      let t2 = e4.activeCamera.eye.sub(this._relativeCenter);
      Ke.doubleToTwoFloat32Array(t2, this._rtcEyePositionHigh, this._rtcEyePositionLow);
    }
  }
  draw() {
    if (this._geoObjects.length) {
      this._updateRTCEyePosition();
      this.update();
      this._displayOpaquePASS();
    }
  }
  drawTransparent() {
    if (this._geoObjects.length) {
      this._displayTransparentPASS();
    }
  }
  add(e4) {
    if (e4._handlerIndex === -1) {
      e4._handler = this;
      e4._handlerIndex = this._geoObjects.length;
      this._geoObjects.push(e4);
      this._addGeoObjectToArray(e4);
      e4.updateRotation();
      e4._tagData.refresh();
      this._updateTag(e4._tagData);
      e4.setObjectSrc(e4._objectSrc);
    }
  }
  remove(e4) {
    if (e4._handler && this.__id == e4._handler.__id) {
      this._removeGeoObject(e4);
    }
  }
  _clearDataTagQueue() {
    this._dataTagUpdateQueue = [];
  }
  _removeGeoObject(e4) {
    let t2 = e4._tagData;
    let i2 = e4.tag;
    t2.numInstances--;
    let s2 = false;
    if (t2.numInstances === 0) {
      t2.clear();
      this._instanceDataMap.delete(i2);
      this._instanceDataMapValues = [];
      this._clearDataTagQueue();
      s2 = true;
    }
    this._geoObjects.splice(e4._handlerIndex, 1);
    for (let t3 = e4._handlerIndex, i3 = this._geoObjects.length; t3 < i3; t3++) {
      let e5 = this._geoObjects[t3];
      e5._handlerIndex = e5._handlerIndex - 1;
    }
    let r2 = e4._tagDataIndex;
    t2.geoObjects.splice(r2, 1);
    for (let i3 = e4._tagDataIndex, s3 = t2.geoObjects.length; i3 < s3; i3++) {
      let e5 = t2.geoObjects[i3];
      e5._tagDataIndex = e5._tagDataIndex - 1;
    }
    t2._rgbaArr = Wt(t2._rgbaArr, r2 * 4, 4);
    t2._rtcPositionHighArr = Wt(t2._rtcPositionHighArr, r2 * 3, 3);
    t2._rtcPositionLowArr = Wt(t2._rtcPositionLowArr, r2 * 3, 3);
    t2._qRotArr = Wt(t2._qRotArr, r2 * 4, 4);
    t2._pickingColorArr = Wt(t2._pickingColorArr, r2 * 3, 3);
    t2._sizeArr = Wt(t2._sizeArr, r2 * 3, 3);
    t2._translateArr = Wt(t2._translateArr, r2 * 3, 3);
    t2._localPositionArr = Wt(t2._localPositionArr, r2 * 3, 3);
    t2._visibleArr = Wt(t2._visibleArr, r2, 1);
    e4._handlerIndex = -1;
    e4._handler = null;
    e4._tagDataIndex = -1;
    e4._tagData = null;
    if (!s2) {
      t2.refresh();
      this._updateTag(t2);
    }
  }
};
_Un.__counter__ = 0;
let Un = _Un;
var Gn = "#version 300 es\n\n#define EMPTY - 1.0\r\n#define RTL 1.0\n\nvec2 project(vec4 p, vec2 viewport) {\r\n    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;\r\n}\n\nmat2 rotate2d(float angle) {\r\n    return mat2(cos(angle), -sin(angle),\r\n    sin(angle), cos(angle));\r\n}\n\nin float a_outline;\r\nin vec4 a_gliphParam;\r\nin vec2 a_vertices;\r\nin vec4 a_texCoord;\r\nin vec3 a_positionsHigh;\r\nin vec3 a_positionsLow;\r\nin vec3 a_offset;\r\nin float a_size;\r\nin float a_rotation;\r\nin vec4 a_rgba;\r\nin float a_fontIndex;\n\nout vec2 v_uv;\r\nout vec4 v_rgba;\r\nflat out int v_fontIndex;\r\nout vec4 v_outlineColor;\r\nflat out float v_outline;\n\nuniform vec2 viewport;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 projectionMatrix;\r\nuniform vec3 eyePositionHigh;\r\nuniform vec3 eyePositionLow;\r\nuniform float planetRadius;\r\nuniform vec3 scaleByDistance;\r\nuniform float opacity;\r\nuniform float depthOffset;\n\nconst vec3 ZERO3 = vec3(0.0);\r\n\nvoid main() {\n\n    if (a_texCoord.w == EMPTY) {\r\n        gl_Position = vec4(0.0);\r\n        v_fontIndex = -1;\r\n        return;\r\n    }\n\n    vec3 a_positions = a_positionsHigh + a_positionsLow;\r\n    vec3 cameraPos = eyePositionHigh + eyePositionLow;\n\n    v_outline = a_outline;\n\n    v_fontIndex = int(a_fontIndex);\r\n    v_uv = a_texCoord.xy;\r\n    vec3 look = a_positions - cameraPos;\r\n    float lookDist = length(look);\r\n    v_rgba = a_rgba;\n\n    if (opacity * step(lookDist, sqrt(dot(cameraPos, cameraPos) - planetRadius) + sqrt(dot(a_positions, a_positions) - planetRadius)) == 0.0) {\r\n        return;\r\n    }\n\n    float scd = (1.0 - smoothstep(scaleByDistance[0], scaleByDistance[1], lookDist)) * (1.0 - step(scaleByDistance[2], lookDist));\n\n    v_rgba.a *= opacity;\n\n    mat4 viewMatrixRTE = viewMatrix;\r\n    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 highDiff = a_positionsHigh - eyePositionHigh;\r\n    vec3 lowDiff = a_positionsLow - eyePositionLow;\r\n    vec4 posRTE = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);\r\n    vec4 projPos = projectionMatrix * posRTE;\n\n    float camSlope = dot(vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]), normalize(cameraPos));\r\n    if (camSlope > 0.5) {\r\n        float dist = dot(look, normalize(cameraPos));\r\n        projPos.z += dist * 0.02;\r\n    } else {\r\n        projPos.z += -(abs(projPos.z)) * 0.002;\r\n    }\n\n    projPos.z += depthOffset + a_offset.z;\n\n    vec2 screenPos = project(projPos, viewport);\n\n    vec2 vert = a_vertices;\r\n    vec4 gp = a_gliphParam;\r\n    if (a_texCoord.w == RTL) {\r\n        vert.x = step(vert.x * 0.5 + 1.0, 1.0);\r\n        gp.x = -a_gliphParam.x;\r\n        gp.z = -(a_gliphParam.z + a_texCoord.z);\r\n    } else {\r\n        gp.z = a_gliphParam.z + a_texCoord.z;\r\n    }\n\n    vec2 v = screenPos + rotate2d(a_rotation) * ((vert * gp.xy + gp.zw) * a_size * scd + a_offset.xy);\n\n    gl_Position = vec4((2.0 * v / viewport - 1.0) * projPos.w, projPos.z, projPos.w);\r\n}";
var Wn = "#version 300 es\n\nuniform int isOutlinePass;\n\nprecision highp float;\n\nconst int MAX_SIZE = 11;\r\n\nuniform sampler2D fontTextureArr[MAX_SIZE];\r\nuniform vec4 sdfParamsArr[MAX_SIZE];\n\nflat in int v_fontIndex;\r\nin vec2 v_uv;\r\nin vec4 v_rgba;\n\nflat in float v_outline;\n\nin vec3 v_pickingColor;\n\nlayout (location = 0) out vec4 outScreen;\n\nfloat median(float r, float g, float b) {\r\n    return max(min(r, g), min(max(r, g), b));\r\n}\n\nfloat getDistance() {\r\n    vec3 msdf;\r\n    if (v_fontIndex == 0) {\r\n        msdf = texture(fontTextureArr[0], v_uv).rgb;\r\n    } else if (v_fontIndex == 1) {\r\n        msdf = texture(fontTextureArr[1], v_uv).rgb;\r\n    } else if (v_fontIndex == 2) {\r\n        msdf = texture(fontTextureArr[2], v_uv).rgb;\r\n    } else if (v_fontIndex == 3) {\r\n        msdf = texture(fontTextureArr[3], v_uv).rgb;\r\n    } else if (v_fontIndex == 4) {\r\n        msdf = texture(fontTextureArr[4], v_uv).rgb;\r\n    } else if (v_fontIndex == 5) {\r\n        msdf = texture(fontTextureArr[5], v_uv).rgb;\r\n    } else if (v_fontIndex == 6) {\r\n        msdf = texture(fontTextureArr[6], v_uv).rgb;\r\n    } else if (v_fontIndex == 7) {\r\n        msdf = texture(fontTextureArr[7], v_uv).rgb;\r\n    } else if (v_fontIndex == 8) {\r\n        msdf = texture(fontTextureArr[8], v_uv).rgb;\r\n    } else if (v_fontIndex == 9) {\r\n        msdf = texture(fontTextureArr[9], v_uv).rgb;\r\n    } else if (v_fontIndex == 10) {\r\n        msdf = texture(fontTextureArr[10], v_uv).rgb;\r\n    }\r\n    return median(msdf.r, msdf.g, msdf.b);\r\n}\n\nvoid main() {\n\n    if (v_fontIndex == -1) {\r\n        return;\r\n    }\n\n    vec4 sdfParams = sdfParamsArr[v_fontIndex];\r\n    float sd = getDistance();\r\n    vec2 dxdy = fwidth(v_uv) * sdfParams.xy;\n\n    if (isOutlinePass == 0) {\r\n        float dist = sd + min(0.001, 0.5 - 1.0 / sdfParams.w) - 0.5;\r\n        float opacity = clamp(dist * sdfParams.w / length(dxdy) + 0.5, 0.0, 1.0);\r\n        if (opacity <= 0.1) {\r\n            discard;\r\n        }\r\n        outScreen = vec4(v_rgba.rgb, opacity * v_rgba.a);\r\n    } else {\r\n        float dist = sd + min(v_outline, 0.5 - 1.0 / sdfParams.w) - 0.5;\r\n        float opacity = clamp(dist * sdfParams.w / length(dxdy) + 0.5, 0.0, 1.0);\r\n        if (opacity <= 0.1) {\r\n            discard;\r\n        }\r\n        outScreen = vec4(v_rgba.rgb, opacity * v_rgba.a);\r\n        \n    }\r\n}";
var jn = "#define EMPTY - 1.0\r\n#define RTL 1.0\n\nvec2 project(vec4 p, vec2 viewport) {\r\n    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;\r\n}\n\nmat2 rotate2d(float angle) {\r\n    return mat2(cos(angle), -sin(angle),\r\n    sin(angle), cos(angle));\r\n}\n\nattribute float a_outline;\r\nattribute vec4 a_gliphParam;\r\nattribute vec2 a_vertices;\r\nattribute vec4 a_texCoord;\r\nattribute vec3 a_positionsHigh;\r\nattribute vec3 a_positionsLow;\r\nattribute vec3 a_offset;\r\nattribute float a_size;\r\nattribute float a_rotation;\r\nattribute vec4 a_rgba;\r\nattribute float a_fontIndex;\n\nvarying float v_outline;\r\nvarying vec2 v_uv;\r\nvarying vec4 v_rgba;\r\nvarying float v_fontIndex;\n\nuniform vec2 viewport;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 projectionMatrix;\r\nuniform vec3 eyePositionHigh;\r\nuniform vec3 eyePositionLow;\r\nuniform float planetRadius;\r\nuniform vec3 scaleByDistance;\r\nuniform float opacity;\r\nuniform float depthOffset;\n\nconst vec3 ZERO3 = vec3(0.0);\n\nvoid main() {\n\n    if (a_texCoord.w == EMPTY) {\r\n        gl_Position = vec4(0.0);\r\n        v_fontIndex = -1.0;\r\n        return;\r\n    }\n\n    vec3 a_positions = a_positionsHigh + a_positionsLow;\r\n    vec3 cameraPos = eyePositionHigh + eyePositionLow;\n\n    v_outline = a_outline;\r\n    v_uv = vec2(a_texCoord.xy);\r\n    v_rgba = a_rgba;\r\n    v_fontIndex = a_fontIndex;\n\n    vec3 look = a_positions - cameraPos;\r\n    float lookDist = length(look);\n\n    if (opacity * step(lookDist, sqrt(dot(cameraPos, cameraPos) - planetRadius) + sqrt(dot(a_positions, a_positions) - planetRadius)) == 0.0) {\r\n        return;\r\n    }\n\n    float scd = (1.0 - smoothstep(scaleByDistance[0], scaleByDistance[1], lookDist)) * (1.0 - step(scaleByDistance[2], lookDist));\n\n    v_rgba.a *= opacity;\n\n    mat4 viewMatrixRTE = viewMatrix;\r\n    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 highDiff = a_positionsHigh - eyePositionHigh;\r\n    vec3 lowDiff = a_positionsLow - eyePositionLow;\r\n    vec4 posRTE = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);\r\n    vec4 projPos = projectionMatrix * posRTE;\n\n    float camSlope = dot(vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]), normalize(cameraPos));\r\n    if (camSlope > 0.5) {\r\n        float dist = dot(look, normalize(cameraPos));\r\n        projPos.z += dist * 0.02;\r\n    } else {\r\n        projPos.z += -(abs(projPos.z)) * 0.002;\r\n    }\n\n    projPos.z += depthOffset + a_offset.z;\n\n    vec2 screenPos = project(projPos, viewport);\n\n    vec2 vert = a_vertices;\r\n    vec4 gp = a_gliphParam;\r\n    if (a_texCoord.w == RTL) {\r\n        vert.x = step(vert.x * 0.5 + 1.0, 1.0);\r\n        gp.x = -a_gliphParam.x;\r\n        gp.z = -(a_gliphParam.z + a_texCoord.z);\r\n    } else {\r\n        gp.z = a_gliphParam.z + a_texCoord.z;\r\n    }\n\n    vec2 v = screenPos + rotate2d(a_rotation) * ((vert * gp.xy + gp.zw) * a_size * scd + a_offset.xy);\n\n    gl_Position = vec4((2.0 * v / viewport - 1.0) * projPos.w, projPos.z, projPos.w);\r\n}";
var Yn = "#extension GL_OES_standard_derivatives: enable\n\nprecision highp float;\r\nprecision highp int;\n\nconst int MAX_SIZE = 11;\r\n\nuniform sampler2D fontTextureArr[MAX_SIZE];\r\nuniform vec4 sdfParamsArr[MAX_SIZE];\r\nuniform int isOutlinePass;\n\nvarying float v_outline;\r\nvarying vec2 v_uv;\r\nvarying vec4 v_rgba;\r\nvarying float v_fontIndex;\n\nfloat fontIndex;\n\nfloat median(float r, float g, float b) {\r\n    return max(min(r, g), min(max(r, g), b));\r\n}\n\nfloat getDistance() {\r\n    vec3 msdf;\r\n    if (fontIndex >= 0.0 && fontIndex < 1.0) {\r\n        msdf = texture2D(fontTextureArr[0], v_uv).rgb;\r\n    } else if (fontIndex >= 1.0 && fontIndex < 2.0) {\r\n        msdf = texture2D(fontTextureArr[1], v_uv).rgb;\r\n    } else if (fontIndex >= 2.0 && fontIndex < 3.0) {\r\n        msdf = texture2D(fontTextureArr[2], v_uv).rgb;\r\n    } else if (fontIndex >= 3.0 && fontIndex < 4.0) {\r\n        msdf = texture2D(fontTextureArr[3], v_uv).rgb;\r\n    } else if (fontIndex >= 4.0 && fontIndex < 5.0) {\r\n        msdf = texture2D(fontTextureArr[4], v_uv).rgb;\r\n    } else if (fontIndex >= 5.0 && fontIndex < 6.0) {\r\n        msdf = texture2D(fontTextureArr[5], v_uv).rgb;\r\n    } else if (fontIndex >= 6.0 && fontIndex < 7.0) {\r\n        msdf = texture2D(fontTextureArr[6], v_uv).rgb;\r\n    } else if (fontIndex >= 7.0 && fontIndex < 8.0) {\r\n        msdf = texture2D(fontTextureArr[7], v_uv).rgb;\r\n    } else if (fontIndex >= 8.0 && fontIndex < 9.0) {\r\n        msdf = texture2D(fontTextureArr[8], v_uv).rgb;\r\n    } else if (fontIndex >= 9.0 && fontIndex < 10.0) {\r\n        msdf = texture2D(fontTextureArr[9], v_uv).rgb;\r\n    } else if (fontIndex >= 10.0 && fontIndex < 11.0) {\r\n        msdf = texture2D(fontTextureArr[10], v_uv).rgb;\r\n    }\r\n    return median(msdf.r, msdf.g, msdf.b);\r\n}\r\n\nvec4 getSDFParams() {\r\n    if (fontIndex >= 0.0 && fontIndex < 1.0) {\r\n        return sdfParamsArr[0];\r\n    } else if (fontIndex >= 1.0 && fontIndex < 2.0) {\r\n        return sdfParamsArr[1];\r\n    } else if (fontIndex >= 2.0 && fontIndex < 3.0) {\r\n        return sdfParamsArr[2];\r\n    } else if (fontIndex >= 3.0 && fontIndex < 4.0) {\r\n        return sdfParamsArr[3];\r\n    } else if (fontIndex >= 4.0 && fontIndex < 5.0) {\r\n        return sdfParamsArr[4];\r\n    } else if (fontIndex >= 5.0 && fontIndex < 6.0) {\r\n        return sdfParamsArr[5];\r\n    } else if (fontIndex >= 6.0 && fontIndex < 7.0) {\r\n        return sdfParamsArr[6];\r\n    } else if (fontIndex >= 7.0 && fontIndex < 8.0) {\r\n        return sdfParamsArr[7];\r\n    } else if (fontIndex >= 8.0 && fontIndex < 9.0) {\r\n        return sdfParamsArr[8];\r\n    } else if (fontIndex >= 9.0 && fontIndex < 10.0) {\r\n        return sdfParamsArr[9];\r\n    } else if (fontIndex >= 10.0 && fontIndex < 11.0) {\r\n        return sdfParamsArr[10];\r\n    }\r\n}\n\nvoid main() {\n\n    fontIndex = v_fontIndex + 0.1;\n\n    if (v_fontIndex < 0.0) {\r\n        return;\r\n    }\n\n    vec4 sdfParams = getSDFParams();\r\n    float sd = getDistance();\r\n    vec2 dxdy = fwidth(v_uv) * sdfParams.xy;\r\n    float dist = sd + min(0.001, 0.5 - 1.0 / sdfParams.w) - 0.5;\r\n    float opacity = clamp(dist * sdfParams.w / length(dxdy) + 0.5, 0.0, 1.0);\n\n    if (isOutlinePass == 0) {\r\n        \n    } else {\r\n        float strokeDist = sd + min(v_outline, 0.5 - 1.0 / sdfParams.w) - 0.5;\r\n        float strokeAlpha = v_rgba.a * clamp(strokeDist * sdfParams.w / length(dxdy) + 0.5, 0.0, 1.0);\r\n        if (strokeAlpha < 0.1) {\r\n            discard;\r\n        }\r\n        \n    }\r\n}";
var qn = "#define EMPTY - 1.0\r\n#define RTL 1.0\n\nvec2 project(vec4 p, vec2 viewport) {\r\n    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;\r\n}\n\nmat2 rotate2d(float angle) {\r\n    return mat2(cos(angle), -sin(angle),\r\n    sin(angle), cos(angle));\r\n}\n\nattribute vec4 a_gliphParam;\r\nattribute vec2 a_vertices;\r\nattribute vec4 a_texCoord;\r\nattribute vec3 a_positionsHigh;\r\nattribute vec3 a_positionsLow;\r\nattribute vec3 a_offset;\r\nattribute float a_size;\r\nattribute float a_rotation;\r\nattribute vec4 a_rgba;\n\nvarying vec4 v_rgba;\n\nuniform vec2 viewport;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 projectionMatrix;\r\nuniform vec3 eyePositionHigh;\r\nuniform vec3 eyePositionLow;\r\nuniform float planetRadius;\r\nuniform vec3 scaleByDistance;\r\nuniform float opacity;\r\nuniform float depthOffset;\n\nconst vec3 ZERO3 = vec3(0.0);\n\nvoid main() {\r\n    vec3 a_positions = a_positionsHigh + a_positionsLow;\r\n    vec3 cameraPos = eyePositionHigh + eyePositionLow;\r\n    v_rgba = a_rgba;\n\n    if (a_texCoord.w == EMPTY) {\r\n        v_rgba.a = 0.0;\r\n        gl_Position = vec4(0.0);\r\n        return;\r\n    }\n\n    vec3 look = a_positions - cameraPos;\r\n    float lookDist = length(look);\r\n    if (opacity * step(lookDist, sqrt(dot(cameraPos, cameraPos) - planetRadius) + sqrt(dot(a_positions, a_positions) - planetRadius)) == 0.0) {\r\n        return;\r\n    }\n\n    float scd = (1.0 - smoothstep(scaleByDistance[0], scaleByDistance[1], lookDist)) * (1.0 - step(scaleByDistance[2], lookDist));\n\n    v_rgba.a *= opacity;\n\n    mat4 viewMatrixRTE = viewMatrix;\r\n    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 highDiff = a_positionsHigh - eyePositionHigh;\r\n    vec3 lowDiff = a_positionsLow - eyePositionLow;\r\n    vec4 posRTE = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);\r\n    vec4 projPos = projectionMatrix * posRTE;\n\n    float camSlope = dot(vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]), normalize(cameraPos));\r\n    if (camSlope > 0.5) {\r\n        float dist = dot(look, normalize(cameraPos));\r\n        projPos.z += dist * 0.02;\r\n    } else {\r\n        projPos.z += -(abs(projPos.z)) * 0.002;\r\n    }\n\n    projPos.z += depthOffset + a_offset.z;\n\n    vec2 screenPos = project(projPos, viewport);\n\n    vec2 vert = a_vertices;\r\n    vec4 gp = a_gliphParam;\r\n    if (a_texCoord.w == RTL) {\r\n        vert.x = step(vert.x * 0.5 + 1.0, 1.0);\r\n        gp.x = -a_gliphParam.x;\r\n        gp.z = -(a_gliphParam.z + a_texCoord.z);\r\n    } else {\r\n        gp.z = a_gliphParam.z + a_texCoord.z;\r\n    }\n\n    vec2 v = screenPos + rotate2d(a_rotation) * ((vert * gp.xy + gp.zw) * a_size * scd + a_offset.xy);\n\n    gl_Position = vec4((2.0 * v / viewport - 1.0) * projPos.w, projPos.z, projPos.w);\r\n}";
var $n = "precision highp float;\n\nvarying vec4 v_rgba;\n\nvarying vec3 v_pickingColor;\n\nvoid main() {\n\n    vec4 color = v_rgba;\r\n    if (color.a < 0.05) {\r\n        return;\r\n    }\n\n    gl_FragColor = vec4(v_rgba.rgb, v_rgba.a);\r\n}";
function Xn() {
  return new Yr("label", { uniforms: { viewport: "vec2", fontTextureArr: "sampler2darray", sdfParamsArr: "vec4", projectionMatrix: "mat4", viewMatrix: "mat4", eyePositionHigh: "vec3", eyePositionLow: "vec3", planetRadius: "float", scaleByDistance: "vec3", opacity: "float", isOutlinePass: "int", depthOffset: "float" }, attributes: { a_outline: "float", a_gliphParam: "vec4", a_vertices: "vec2", a_texCoord: "vec4", a_positionsHigh: "vec3", a_positionsLow: "vec3", a_size: "float", a_rotation: "float", a_rgba: "vec4", a_offset: "vec3", a_fontIndex: "float" }, vertexShader: Gn, fragmentShader: Wn });
}
function Zn() {
  return new Yr("label", { uniforms: { viewport: "vec2", fontTextureArr: "sampler2darray", sdfParamsArr: "vec4", projectionMatrix: "mat4", viewMatrix: "mat4", eyePositionHigh: "vec3", eyePositionLow: "vec3", planetRadius: "float", scaleByDistance: "vec3", opacity: "float", isOutlinePass: "int", depthOffset: "float" }, attributes: { a_outline: "float", a_gliphParam: "vec4", a_vertices: "vec2", a_texCoord: "vec4", a_positionsHigh: "vec3", a_positionsLow: "vec3", a_size: "float", a_rotation: "float", a_rgba: "vec4", a_offset: "vec3", a_fontIndex: "float" }, vertexShader: jn, fragmentShader: Yn });
}
function Kn() {
  return new Yr("labelPicking", { uniforms: { viewport: "vec2", projectionMatrix: "mat4", viewMatrix: "mat4", eyePositionHigh: "vec3", eyePositionLow: "vec3", planetRadius: "float", scaleByDistance: "vec3", opacity: "float", depthOffset: "float" }, attributes: { a_gliphParam: "vec4", a_vertices: "vec2", a_texCoord: "vec4", a_positionsHigh: "vec3", a_positionsLow: "vec3", a_offset: "vec3", a_size: "float", a_rotation: "float", a_rgba: "vec4" }, vertexShader: qn, fragmentShader: $n });
}
const Qn = 0;
const Jn = 1;
const eo = 2;
const to = 3;
const io = 4;
const so = 5;
const ro = 6;
const no = 7;
const oo = 8;
const ao = 9;
const lo = 10;
const ho = -1;
const co = 1;
class uo extends ln {
  constructor(e4, t2 = 21) {
    super(e4);
    this._billboards = [];
    this._gliphParamBuffer = null;
    this._fontIndexBuffer = null;
    this._outlineBuffer = null;
    this._outlineColorBuffer = null;
    this._gliphParamArr = new Float32Array([]);
    this._fontIndexArr = new Float32Array([]);
    this._outlineArr = new Float32Array([]);
    this._outlineColorArr = new Float32Array([]);
    this._buffersUpdateCallbacks[oo] = this.createFontIndexBuffer;
    this._buffersUpdateCallbacks[ao] = this.createOutlineBuffer;
    this._buffersUpdateCallbacks[lo] = this.createOutlineColorBuffer;
    this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
    this._maxLetters = t2;
  }
  initProgram() {
    if (this._renderer && this._renderer.handler && this._renderer.handler.gl) {
      if (!this._renderer.handler.programs.label) {
        if (this._renderer.handler.gl.type === "webgl2") {
          this._renderer.handler.addProgram(Xn());
        } else {
          this._renderer.handler.addProgram(Zn());
        }
      }
      if (!this._renderer.handler.programs.labelPicking) {
        this._renderer.handler.addProgram(Kn());
      }
    }
  }
  get labels() {
    return this._billboards;
  }
  add(e4) {
    if (!e4._handler) {
      e4._handler = this;
      this.assignFontAtlas(e4);
      this.refresh();
    }
  }
  updateFonts() {
    let e4 = [...this._billboards];
    this._billboards = [];
    for (let t2 = 0; t2 < e4.length; t2++) {
      this.assignFontAtlas(e4[t2]);
    }
  }
  _addLabelToArrays(e4) {
    this._renderer && this._renderer.labelWorker.make({ handler: this, label: e4 });
  }
  assignFontAtlas(e4) {
    if (this._entityCollection && this._renderer) {
      e4.assignFontAtlas(this._renderer.fontAtlas);
      this._addLabelToArrays(e4);
    } else {
      this._billboards.push(e4);
    }
  }
  workerCallback(e4, t2) {
    if (t2._lockId !== $s && t2._handler && this.isEqual(t2._handler)) {
      t2._isReady = true;
      t2._lockId = $s;
      t2._handlerIndex = this._billboards.length;
      this._billboards.push(t2);
      this._vertexArr = Ht(this._vertexArr, e4.vertexArr);
      this._texCoordArr = Ht(this._texCoordArr, e4.texCoordArr);
      this._gliphParamArr = Ht(this._gliphParamArr, e4.gliphParamArr);
      this._positionHighArr = Ht(this._positionHighArr, e4.positionHighArr);
      this._positionLowArr = Ht(this._positionLowArr, e4.positionLowArr);
      this._sizeArr = Ht(this._sizeArr, e4.sizeArr);
      this._offsetArr = Ht(this._offsetArr, e4.offsetArr);
      this._rgbaArr = Ht(this._rgbaArr, e4.rgbaArr);
      this._rotationArr = Ht(this._rotationArr, e4.rotationArr);
      this._fontIndexArr = Ht(this._fontIndexArr, e4.fontIndexArr);
      this._outlineArr = Ht(this._outlineArr, e4.outlineArr);
      this._outlineColorArr = Ht(this._outlineColorArr, e4.outlineColorArr);
      this._pickingColorArr = Ht(this._pickingColorArr, e4.pickingColorArr);
      t2.update();
      this.refresh();
    }
  }
  clear() {
    this._texCoordArr = null;
    this._gliphParamArr = null;
    this._vertexArr = null;
    this._positionHighArr = null;
    this._positionLowArr = null;
    this._sizeArr = null;
    this._offsetArr = null;
    this._rgbaArr = null;
    this._rotationArr = null;
    this._fontIndexArr = null;
    this._outlineArr = null;
    this._outlineColorArr = null;
    this._texCoordArr = new Float32Array([]);
    this._gliphParamArr = new Float32Array([]);
    this._vertexArr = new Float32Array([]);
    this._positionHighArr = new Float32Array([]);
    this._positionLowArr = new Float32Array([]);
    this._sizeArr = new Float32Array([]);
    this._offsetArr = new Float32Array([]);
    this._rgbaArr = new Float32Array([]);
    this._rotationArr = new Float32Array([]);
    this._fontIndexArr = new Float32Array([]);
    this._outlineArr = new Float32Array([]);
    this._outlineColorArr = new Float32Array([]);
    this._removeBillboards();
    this._deleteBuffers();
    this.refresh();
  }
  _deleteBuffers() {
    if (this._renderer) {
      let e4 = this._renderer.handler.gl;
      e4.deleteBuffer(this._gliphParamBuffer);
      e4.deleteBuffer(this._sizeBuffer);
      e4.deleteBuffer(this._fontIndexBuffer);
      e4.deleteBuffer(this._texCoordBuffer);
      e4.deleteBuffer(this._outlineBuffer);
      e4.deleteBuffer(this._outlineColorBuffer);
      e4.deleteBuffer(this._positionHighBuffer);
      e4.deleteBuffer(this._positionLowBuffer);
      e4.deleteBuffer(this._sizeBuffer);
      e4.deleteBuffer(this._offsetBuffer);
      e4.deleteBuffer(this._rgbaBuffer);
      e4.deleteBuffer(this._rotationBuffer);
      e4.deleteBuffer(this._vertexBuffer);
      e4.deleteBuffer(this._texCoordBuffer);
      e4.deleteBuffer(this._pickingColorBuffer);
      this._gliphParamBuffer = null;
      this._sizeBuffer = null;
      this._fontIndexBuffer = null;
      this._texCoordBuffer = null;
      this._outlineBuffer = null;
      this._outlineColorBuffer = null;
      this._positionHighBuffer = null;
      this._positionLowBuffer = null;
      this._sizeBuffer = null;
      this._offsetBuffer = null;
      this._rgbaBuffer = null;
      this._rotationBuffer = null;
      this._vertexBuffer = null;
      this._texCoordBuffer = null;
      this._pickingColorBuffer = null;
    }
  }
  _displayPASS() {
    let e4 = this._renderer;
    let t2 = e4.handler;
    t2.programs.label.activate();
    let i2 = t2.programs.label._program;
    let s2 = i2.attributes, r2 = i2.uniforms;
    let n2 = t2.gl, o2 = this._entityCollection;
    n2.disable(n2.CULL_FACE);
    n2.uniform1iv(r2.fontTextureArr, e4.fontAtlas.samplerArr);
    n2.uniform4fv(r2.sdfParamsArr, e4.fontAtlas.sdfParamsArr);
    n2.uniformMatrix4fv(r2.viewMatrix, false, e4.activeCamera.getViewMatrix());
    n2.uniformMatrix4fv(r2.projectionMatrix, false, e4.activeCamera.getProjectionMatrix());
    n2.uniform3fv(r2.eyePositionHigh, e4.activeCamera.eyeHigh);
    n2.uniform3fv(r2.eyePositionLow, e4.activeCamera.eyeLow);
    n2.uniform3fv(r2.scaleByDistance, o2.scaleByDistance);
    n2.uniform1f(r2.opacity, o2._fadingOpacity);
    n2.uniform1f(r2.planetRadius, o2.renderNode._planetRadius2 || 0);
    n2.uniform2fv(r2.viewport, [t2.canvas.clientWidth, t2.canvas.clientHeight]);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._texCoordBuffer);
    n2.vertexAttribPointer(s2.a_texCoord, this._texCoordBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._gliphParamBuffer);
    n2.vertexAttribPointer(s2.a_gliphParam, this._gliphParamBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._vertexBuffer);
    n2.vertexAttribPointer(s2.a_vertices, this._vertexBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._positionHighBuffer);
    n2.vertexAttribPointer(s2.a_positionsHigh, this._positionHighBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._positionLowBuffer);
    n2.vertexAttribPointer(s2.a_positionsLow, this._positionLowBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._sizeBuffer);
    n2.vertexAttribPointer(s2.a_size, this._sizeBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._rotationBuffer);
    n2.vertexAttribPointer(s2.a_rotation, this._rotationBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._offsetBuffer);
    n2.vertexAttribPointer(s2.a_offset, this._offsetBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._fontIndexBuffer);
    n2.vertexAttribPointer(s2.a_fontIndex, this._fontIndexBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.uniform1i(r2.isOutlinePass, 1);
    n2.uniform1f(r2.depthOffset, o2.polygonOffsetUnits);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._outlineColorBuffer);
    n2.vertexAttribPointer(s2.a_rgba, this._outlineColorBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._outlineBuffer);
    n2.vertexAttribPointer(s2.a_outline, this._outlineBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.drawArrays(n2.TRIANGLES, 0, this._vertexBuffer.numItems);
    n2.depthFunc(n2.EQUAL);
    n2.uniform1i(r2.isOutlinePass, 0);
    n2.uniform1f(r2.depthOffset, o2.polygonOffsetUnits);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._rgbaBuffer);
    n2.vertexAttribPointer(s2.a_rgba, this._rgbaBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.drawArrays(n2.TRIANGLES, 0, this._vertexBuffer.numItems);
    n2.depthFunc(n2.LESS);
    n2.enable(n2.CULL_FACE);
  }
  _pickingPASS() {
    let e4 = this._renderer;
    let t2 = e4.handler;
    t2.programs.labelPicking.activate();
    let i2 = t2.programs.labelPicking._program;
    let s2 = i2.attributes, r2 = i2.uniforms;
    let n2 = t2.gl, o2 = this._entityCollection;
    let a2 = o2.renderNode;
    n2.disable(n2.CULL_FACE);
    n2.uniformMatrix4fv(r2.viewMatrix, false, e4.activeCamera.getViewMatrix());
    n2.uniformMatrix4fv(r2.projectionMatrix, false, e4.activeCamera.getProjectionMatrix());
    n2.uniform3fv(r2.eyePositionHigh, e4.activeCamera.eyeHigh);
    n2.uniform3fv(r2.eyePositionLow, e4.activeCamera.eyeLow);
    n2.uniform3fv(r2.scaleByDistance, o2.scaleByDistance);
    n2.uniform1f(r2.opacity, o2._fadingOpacity);
    n2.uniform1f(r2.planetRadius, a2._planetRadius2 || 0);
    n2.uniform2fv(r2.viewport, [t2.canvas.clientWidth, t2.canvas.clientHeight]);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._texCoordBuffer);
    n2.vertexAttribPointer(s2.a_texCoord, this._texCoordBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._gliphParamBuffer);
    n2.vertexAttribPointer(s2.a_gliphParam, this._gliphParamBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._vertexBuffer);
    n2.vertexAttribPointer(s2.a_vertices, this._vertexBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._positionHighBuffer);
    n2.vertexAttribPointer(s2.a_positionsHigh, this._positionHighBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._positionLowBuffer);
    n2.vertexAttribPointer(s2.a_positionsLow, this._positionLowBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._sizeBuffer);
    n2.vertexAttribPointer(s2.a_size, this._sizeBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._rotationBuffer);
    n2.vertexAttribPointer(s2.a_rotation, this._rotationBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._offsetBuffer);
    n2.vertexAttribPointer(s2.a_offset, this._offsetBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._pickingColorBuffer);
    n2.vertexAttribPointer(s2.a_rgba, this._pickingColorBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.uniform1f(r2.depthOffset, o2.polygonOffsetUnits);
    n2.drawArrays(n2.TRIANGLES, 0, this._vertexBuffer.numItems);
    n2.enable(n2.CULL_FACE);
  }
  _removeBillboard(e4) {
    let t2 = e4._handlerIndex;
    this._billboards.splice(t2, 1);
    let i2 = 24 * this._maxLetters;
    let s2 = t2 * i2;
    this._rgbaArr = jt(this._rgbaArr, s2, i2);
    this._outlineColorArr = jt(this._outlineColorArr, s2, i2);
    this._texCoordArr = jt(this._texCoordArr, s2, i2);
    this._gliphParamArr = jt(this._gliphParamArr, s2, i2);
    i2 = 18 * this._maxLetters;
    s2 = t2 * i2;
    this._positionHighArr = jt(this._positionHighArr, s2, i2);
    this._positionLowArr = jt(this._positionLowArr, s2, i2);
    this._offsetArr = jt(this._offsetArr, s2, i2);
    this._pickingColorArr = jt(this._pickingColorArr, s2, i2);
    i2 = 12 * this._maxLetters;
    s2 = t2 * i2;
    this._vertexArr = jt(this._vertexArr, s2, i2);
    i2 = 6 * this._maxLetters;
    s2 = t2 * i2;
    this._sizeArr = jt(this._sizeArr, s2, i2);
    this._rotationArr = jt(this._rotationArr, s2, i2);
    this._fontIndexArr = jt(this._fontIndexArr, s2, i2);
    this._outlineArr = jt(this._outlineArr, s2, i2);
    this.reindexBillboardsArray(t2);
    this.refresh();
    e4._handlerIndex = -1;
    e4._handler = null;
    e4._isReady = false;
  }
  setText(e4, t2, i2, s2, r2 = 0, n2 = false) {
    t2 = t2.normalize("NFKC");
    let o2 = this._renderer.fontAtlas.atlasesArr[i2];
    if (!o2) return;
    let a2 = e4 * 24 * this._maxLetters;
    let l2 = this._texCoordArr, h2 = this._gliphParamArr;
    let c2 = 0;
    let d2 = Math.min(this._maxLetters, t2.length);
    let u2 = 0;
    if (n2) {
      u2 = co;
    }
    let _2 = 0;
    let f2 = o2.kernings;
    for (c2 = 0; c2 < d2; c2++) {
      let e5 = a2 + c2 * 24;
      let i3 = t2[c2];
      let s3 = o2.get(i3.charCodeAt(0)) || o2.get(" ".charCodeAt(0));
      if (!s3) continue;
      let n3 = s3.texCoords;
      let d3 = s3.metrics;
      l2[e5] = n3[0];
      l2[e5 + 1] = n3[1];
      l2[e5 + 2] = _2;
      l2[e5 + 3] = u2;
      l2[e5 + 4] = n3[2];
      l2[e5 + 5] = n3[3];
      l2[e5 + 6] = _2;
      l2[e5 + 7] = u2;
      l2[e5 + 8] = n3[4];
      l2[e5 + 9] = n3[5];
      l2[e5 + 10] = _2;
      l2[e5 + 11] = u2;
      l2[e5 + 12] = n3[6];
      l2[e5 + 13] = n3[7];
      l2[e5 + 14] = _2;
      l2[e5 + 15] = u2;
      l2[e5 + 16] = n3[8];
      l2[e5 + 17] = n3[9];
      l2[e5 + 18] = _2;
      l2[e5 + 19] = u2;
      l2[e5 + 20] = n3[10];
      l2[e5 + 21] = n3[11];
      l2[e5 + 22] = _2;
      l2[e5 + 23] = u2;
      h2[e5] = d3.nWidth;
      h2[e5 + 1] = d3.nHeight;
      h2[e5 + 2] = d3.nXOffset;
      h2[e5 + 3] = d3.nYOffset;
      h2[e5 + 4] = d3.nWidth;
      h2[e5 + 5] = d3.nHeight;
      h2[e5 + 6] = d3.nXOffset;
      h2[e5 + 7] = d3.nYOffset;
      h2[e5 + 8] = d3.nWidth;
      h2[e5 + 9] = d3.nHeight;
      h2[e5 + 10] = d3.nXOffset;
      h2[e5 + 11] = d3.nYOffset;
      h2[e5 + 12] = d3.nWidth;
      h2[e5 + 13] = d3.nHeight;
      h2[e5 + 14] = d3.nXOffset;
      h2[e5 + 15] = d3.nYOffset;
      h2[e5 + 16] = d3.nWidth;
      h2[e5 + 17] = d3.nHeight;
      h2[e5 + 18] = d3.nXOffset;
      h2[e5 + 19] = d3.nYOffset;
      h2[e5 + 20] = d3.nWidth;
      h2[e5 + 21] = d3.nHeight;
      h2[e5 + 22] = d3.nXOffset;
      h2[e5 + 23] = d3.nYOffset;
      let g2 = f2[i3.charCodeAt(0)];
      if (g2 && t2[c2 + 1]) {
        let e6 = g2[t2[c2 + 1].charCodeAt(0)];
        if (e6) {
          _2 += d3.nAdvance + e6 + r2;
        } else {
          _2 += d3.nAdvance + r2;
        }
      } else {
        _2 += d3.nAdvance + r2;
      }
    }
    if (s2 === gr.CENTER) {
      _2 *= -0.5;
      for (c2 = 0; c2 < d2; c2++) {
        let e5 = a2 + c2 * 24;
        l2[e5 + 2] += _2;
        l2[e5 + 6] += _2;
        l2[e5 + 10] += _2;
        l2[e5 + 14] += _2;
        l2[e5 + 18] += _2;
        l2[e5 + 22] += _2;
      }
    }
    for (; c2 < this._maxLetters; c2++) {
      let e5 = a2 + c2 * 24;
      l2[e5 + 3] = ho;
      l2[e5 + 7] = ho;
      l2[e5 + 11] = ho;
      l2[e5 + 15] = ho;
      l2[e5 + 19] = ho;
      l2[e5 + 23] = ho;
    }
    this._changedBuffers[ro] = true;
  }
  setPositionArr(e4, t2, i2) {
    let s2 = e4 * 18 * this._maxLetters;
    let r2 = this._positionHighArr, n2 = t2.x, o2 = t2.y, a2 = t2.z, l2 = this._positionLowArr, h2 = i2.x, c2 = i2.y, d2 = i2.z;
    for (let e5 = 0; e5 < this._maxLetters; e5++) {
      let t3 = s2 + e5 * 18;
      r2[t3] = n2;
      r2[t3 + 1] = o2;
      r2[t3 + 2] = a2;
      r2[t3 + 3] = n2;
      r2[t3 + 4] = o2;
      r2[t3 + 5] = a2;
      r2[t3 + 6] = n2;
      r2[t3 + 7] = o2;
      r2[t3 + 8] = a2;
      r2[t3 + 9] = n2;
      r2[t3 + 10] = o2;
      r2[t3 + 11] = a2;
      r2[t3 + 12] = n2;
      r2[t3 + 13] = o2;
      r2[t3 + 14] = a2;
      r2[t3 + 15] = n2;
      r2[t3 + 16] = o2;
      r2[t3 + 17] = a2;
      l2[t3] = h2;
      l2[t3 + 1] = c2;
      l2[t3 + 2] = d2;
      l2[t3 + 3] = h2;
      l2[t3 + 4] = c2;
      l2[t3 + 5] = d2;
      l2[t3 + 6] = h2;
      l2[t3 + 7] = c2;
      l2[t3 + 8] = d2;
      l2[t3 + 9] = h2;
      l2[t3 + 10] = c2;
      l2[t3 + 11] = d2;
      l2[t3 + 12] = h2;
      l2[t3 + 13] = c2;
      l2[t3 + 14] = d2;
      l2[t3 + 15] = h2;
      l2[t3 + 16] = c2;
      l2[t3 + 17] = d2;
    }
    this._changedBuffers[Jn] = true;
  }
  setPickingColorArr(e4, t2) {
    let i2 = e4 * 18 * this._maxLetters;
    let s2 = this._pickingColorArr, r2 = t2.x / 255, n2 = t2.y / 255, o2 = t2.z / 255;
    for (let e5 = 0; e5 < this._maxLetters; e5++) {
      let t3 = i2 + e5 * 18;
      s2[t3] = r2;
      s2[t3 + 1] = n2;
      s2[t3 + 2] = o2;
      s2[t3 + 3] = r2;
      s2[t3 + 4] = n2;
      s2[t3 + 5] = o2;
      s2[t3 + 6] = r2;
      s2[t3 + 7] = n2;
      s2[t3 + 8] = o2;
      s2[t3 + 9] = r2;
      s2[t3 + 10] = n2;
      s2[t3 + 11] = o2;
      s2[t3 + 12] = r2;
      s2[t3 + 13] = n2;
      s2[t3 + 14] = o2;
      s2[t3 + 15] = r2;
      s2[t3 + 16] = n2;
      s2[t3 + 17] = o2;
    }
    this._changedBuffers[Qn] = true;
  }
  setSizeArr(e4, t2) {
    let i2 = e4 * 6 * this._maxLetters;
    let s2 = this._sizeArr;
    for (let e5 = 0; e5 < this._maxLetters; e5++) {
      let r2 = i2 + e5 * 6;
      s2[r2] = t2;
      s2[r2 + 1] = t2;
      s2[r2 + 2] = t2;
      s2[r2 + 3] = t2;
      s2[r2 + 4] = t2;
      s2[r2 + 5] = t2;
    }
    this._changedBuffers[eo] = true;
  }
  setOffsetArr(e4, t2) {
    let i2 = e4 * 18 * this._maxLetters;
    let s2 = this._offsetArr, r2 = t2.x, n2 = t2.y, o2 = t2.z;
    for (let e5 = 0; e5 < this._maxLetters; e5++) {
      let t3 = i2 + e5 * 18;
      s2[t3] = r2;
      s2[t3 + 1] = n2;
      s2[t3 + 2] = o2;
      s2[t3 + 3] = r2;
      s2[t3 + 4] = n2;
      s2[t3 + 5] = o2;
      s2[t3 + 6] = r2;
      s2[t3 + 7] = n2;
      s2[t3 + 8] = o2;
      s2[t3 + 9] = r2;
      s2[t3 + 10] = n2;
      s2[t3 + 11] = o2;
      s2[t3 + 12] = r2;
      s2[t3 + 13] = n2;
      s2[t3 + 14] = o2;
      s2[t3 + 15] = r2;
      s2[t3 + 16] = n2;
      s2[t3 + 17] = o2;
    }
    this._changedBuffers[to] = true;
  }
  setRgbaArr(e4, t2) {
    let i2 = e4 * 24 * this._maxLetters;
    let s2 = this._rgbaArr, r2 = t2.x, n2 = t2.y, o2 = t2.z, a2 = t2.w;
    for (let e5 = 0; e5 < this._maxLetters; e5++) {
      let t3 = i2 + e5 * 24;
      s2[t3] = r2;
      s2[t3 + 1] = n2;
      s2[t3 + 2] = o2;
      s2[t3 + 3] = a2;
      s2[t3 + 4] = r2;
      s2[t3 + 5] = n2;
      s2[t3 + 6] = o2;
      s2[t3 + 7] = a2;
      s2[t3 + 8] = r2;
      s2[t3 + 9] = n2;
      s2[t3 + 10] = o2;
      s2[t3 + 11] = a2;
      s2[t3 + 12] = r2;
      s2[t3 + 13] = n2;
      s2[t3 + 14] = o2;
      s2[t3 + 15] = a2;
      s2[t3 + 16] = r2;
      s2[t3 + 17] = n2;
      s2[t3 + 18] = o2;
      s2[t3 + 19] = a2;
      s2[t3 + 20] = r2;
      s2[t3 + 21] = n2;
      s2[t3 + 22] = o2;
      s2[t3 + 23] = a2;
    }
    this._changedBuffers[io] = true;
  }
  setOutlineColorArr(e4, t2) {
    let i2 = e4 * 24 * this._maxLetters;
    let s2 = this._outlineColorArr, r2 = t2.x, n2 = t2.y, o2 = t2.z, a2 = t2.w;
    for (let e5 = 0; e5 < this._maxLetters; e5++) {
      let t3 = i2 + e5 * 24;
      s2[t3] = r2;
      s2[t3 + 1] = n2;
      s2[t3 + 2] = o2;
      s2[t3 + 3] = a2;
      s2[t3 + 4] = r2;
      s2[t3 + 5] = n2;
      s2[t3 + 6] = o2;
      s2[t3 + 7] = a2;
      s2[t3 + 8] = r2;
      s2[t3 + 9] = n2;
      s2[t3 + 10] = o2;
      s2[t3 + 11] = a2;
      s2[t3 + 12] = r2;
      s2[t3 + 13] = n2;
      s2[t3 + 14] = o2;
      s2[t3 + 15] = a2;
      s2[t3 + 16] = r2;
      s2[t3 + 17] = n2;
      s2[t3 + 18] = o2;
      s2[t3 + 19] = a2;
      s2[t3 + 20] = r2;
      s2[t3 + 21] = n2;
      s2[t3 + 22] = o2;
      s2[t3 + 23] = a2;
    }
    this._changedBuffers[lo] = true;
  }
  setOutlineArr(e4, t2) {
    let i2 = e4 * 6 * this._maxLetters;
    let s2 = this._outlineArr;
    for (let e5 = 0; e5 < this._maxLetters; e5++) {
      let r2 = i2 + e5 * 6;
      s2[r2] = t2;
      s2[r2 + 1] = t2;
      s2[r2 + 2] = t2;
      s2[r2 + 3] = t2;
      s2[r2 + 4] = t2;
      s2[r2 + 5] = t2;
    }
    this._changedBuffers[ao] = true;
  }
  setRotationArr(e4, t2) {
    let i2 = e4 * 6 * this._maxLetters;
    let s2 = this._rotationArr;
    for (let e5 = 0; e5 < this._maxLetters; e5++) {
      let r2 = i2 + e5 * 6;
      s2[r2] = t2;
      s2[r2 + 1] = t2;
      s2[r2 + 2] = t2;
      s2[r2 + 3] = t2;
      s2[r2 + 4] = t2;
      s2[r2 + 5] = t2;
    }
    this._changedBuffers[so] = true;
  }
  setVisibility(e4, t2) {
    let i2;
    if (t2) {
      i2 = [0, 0, 0, -1, 1, -1, 1, -1, 1, 0, 0, 0];
    } else {
      i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }
    this.setVertexArr(e4, i2);
  }
  setVertexArr(e4, t2) {
    let i2 = e4 * 12 * this._maxLetters;
    let s2 = this._vertexArr;
    for (let e5 = 0; e5 < this._maxLetters; e5++) {
      let r2 = i2 + e5 * 12;
      s2[r2] = t2[0];
      s2[r2 + 1] = t2[1];
      s2[r2 + 2] = t2[2];
      s2[r2 + 3] = t2[3];
      s2[r2 + 4] = t2[4];
      s2[r2 + 5] = t2[5];
      s2[r2 + 6] = t2[6];
      s2[r2 + 7] = t2[7];
      s2[r2 + 8] = t2[8];
      s2[r2 + 9] = t2[9];
      s2[r2 + 10] = t2[10];
      s2[r2 + 11] = t2[11];
    }
    this._changedBuffers[no] = true;
  }
  setFontIndexArr(e4, t2) {
    let i2 = e4 * 6 * this._maxLetters;
    let s2 = this._fontIndexArr;
    for (let e5 = 0; e5 < this._maxLetters; e5++) {
      let r2 = i2 + e5 * 6;
      s2[r2] = t2;
      s2[r2 + 1] = t2;
      s2[r2 + 2] = t2;
      s2[r2 + 3] = t2;
      s2[r2 + 4] = t2;
      s2[r2 + 5] = t2;
    }
    this._changedBuffers[oo] = true;
  }
  createSizeBuffer() {
    let e4 = this._renderer.handler;
    e4.gl.deleteBuffer(this._sizeBuffer);
    this._sizeBuffer = e4.createArrayBuffer(this._sizeArr, 1, this._sizeArr.length);
  }
  createFontIndexBuffer() {
    let e4 = this._renderer.handler;
    e4.gl.deleteBuffer(this._fontIndexBuffer);
    this._fontIndexBuffer = e4.createArrayBuffer(this._fontIndexArr, 1, this._fontIndexArr.length);
  }
  createTexCoordBuffer() {
    let e4 = this._renderer.handler;
    e4.gl.deleteBuffer(this._texCoordBuffer);
    this._texCoordBuffer = e4.createArrayBuffer(this._texCoordArr, 4, this._texCoordArr.length / 4);
    e4.gl.deleteBuffer(this._gliphParamBuffer);
    this._gliphParamBuffer = e4.createArrayBuffer(this._gliphParamArr, 4, this._gliphParamArr.length / 4);
  }
  createOutlineBuffer() {
    let e4 = this._renderer.handler;
    e4.gl.deleteBuffer(this._outlineBuffer);
    this._outlineBuffer = e4.createArrayBuffer(this._outlineArr, 1, this._outlineArr.length);
  }
  createOutlineColorBuffer() {
    let e4 = this._renderer.handler;
    e4.gl.deleteBuffer(this._outlineColorBuffer);
    this._outlineColorBuffer = e4.createArrayBuffer(this._outlineColorArr, 4, this._outlineColorArr.length / 4);
  }
  setMaxLetters(e4) {
    this._maxLetters = e4;
  }
}
function _o() {
  return new Yr("pointCloud", { uniforms: { projectionViewMatrix: "mat4", opacity: "float", pointSize: "float" }, attributes: { coordinates: "vec3", colors: "vec3" }, vertexShader: `attribute vec3 coordinates;
            attribute vec4 colors;
            uniform mat4 projectionViewMatrix;
            uniform float opacity;
            uniform float pointSize;
            varying vec4 color;
            void main() {
                color = colors;
                color.a *= opacity;
                gl_Position = projectionViewMatrix * vec4(coordinates, 1.0);
                gl_PointSize = pointSize;
            }`, fragmentShader: `precision highp float;
            varying vec4 color;
            void main(void) {
                gl_FragColor = color;
            }` });
}
const _fo = class _fo {
  constructor(e4) {
    this.pickingEnabled = true;
    this.__id = _fo.__counter__++;
    this.pickingEnabled = true;
    this._entityCollection = e4;
    this._renderer = null;
    this._pointClouds = [];
  }
  _initProgram() {
    if (this._renderer && this._renderer.handler) {
      if (!this._renderer.handler.programs.pointCloud) {
        this._renderer.handler.addProgram(_o());
      }
    }
  }
  setRenderNode(e4) {
    this._renderer = e4.renderer;
    this._initProgram();
    for (let t2 = 0; t2 < this._pointClouds.length; t2++) {
      this._pointClouds[t2].setRenderNode(e4);
    }
  }
  add(e4) {
    if (e4._handlerIndex === -1) {
      e4._handler = this;
      e4._handlerIndex = this._pointClouds.length;
      this._pointClouds.push(e4);
      this._entityCollection && this._entityCollection.renderNode && e4.setRenderNode(this._entityCollection.renderNode);
    }
  }
  remove(e4) {
    let t2 = e4._handlerIndex;
    if (t2 !== -1) {
      e4._deleteBuffers();
      e4._handlerIndex = -1;
      e4._handler = null;
      this._pointClouds.splice(t2, 1);
      this._reindexPointCloudArray(t2);
    }
  }
  _reindexPointCloudArray(e4) {
    let t2 = this._pointClouds;
    for (let i2 = e4; i2 < t2.length; i2++) {
      t2[i2]._handlerIndex = i2;
    }
  }
  draw() {
    let e4 = this._pointClouds.length;
    while (e4--) {
      this._pointClouds[e4].draw();
    }
  }
  drawPicking() {
    if (this.pickingEnabled) {
      let e4 = this._pointClouds.length;
      while (e4--) {
        this._pointClouds[e4].drawPicking();
      }
    }
  }
  clear() {
    let e4 = this._pointClouds.length;
    while (e4--) {
      this._pointClouds[e4]._deleteBuffers();
      this._pointClouds[e4]._handler = null;
      this._pointClouds[e4]._handlerIndex = -1;
    }
    this._pointClouds.length = 0;
    this._pointClouds = [];
  }
};
_fo.__counter__ = 0;
let fo = _fo;
var go = "precision highp float;\n\nattribute vec3 prevHigh;\r\nattribute vec3 currentHigh;\r\nattribute vec3 nextHigh;\n\nattribute vec3 prevLow;\r\nattribute vec3 currentLow;\r\nattribute vec3 nextLow;\n\nattribute float order;\n\nattribute vec4 color;\n\nuniform float thickness;\r\nuniform mat4 proj;\r\nuniform mat4 view;\r\nuniform vec2 viewport;\r\nuniform vec3 rtcEyePositionHigh;\r\nuniform vec3 rtcEyePositionLow;\r\nuniform float opacity;\r\nuniform float depthOffset;\r\n\nvarying vec4 vColor;\r\nvarying vec3 vPos;\r\nvarying vec3 uCamPos;\n\nconst float NEAR = -1.0;\n\nvec2 getIntersection(vec2 start1, vec2 end1, vec2 start2, vec2 end2) {\r\n    vec2 dir = end2 - start2;\r\n    vec2 perp = vec2(-dir.y, dir.x);\r\n    float d2 = dot(perp, start2);\r\n    float seg = dot(perp, start1) - d2;\r\n    float prl = seg - dot(perp, end1) + d2;\r\n    if (prl > -1.0 && prl < 1.0) {\r\n        return start1;\r\n    }\r\n    float u = seg / prl;\r\n    return start1 + u * (end1 - start1);\r\n}\n\nvec2 project(vec4 p) {\r\n    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;\r\n}\n\nvoid main() {\n\n    uCamPos = rtcEyePositionHigh + rtcEyePositionLow;\r\n    vPos = currentHigh + currentLow;\n\n    vColor = vec4(color.rgb, color.a * opacity);\n\n    mat4 viewMatrixRTE = view;\r\n    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 highDiff, lowDiff;\n\n    highDiff = currentHigh - rtcEyePositionHigh;\r\n    highDiff = highDiff * step(1.0, length(highDiff));\r\n    lowDiff = currentLow - rtcEyePositionLow;\r\n    vec4 vCurrent = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);\n\n    highDiff = prevHigh - rtcEyePositionHigh;\r\n    highDiff = highDiff * step(1.0, length(highDiff));\r\n    lowDiff = prevLow - rtcEyePositionLow;\r\n    vec4 vPrev = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);\n\n    highDiff = nextHigh - rtcEyePositionHigh;\r\n    highDiff = highDiff * step(1.0, length(highDiff));\r\n    lowDiff = nextLow - rtcEyePositionLow;\r\n    vec4 vNext = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);\r\n\n    if (vCurrent.z > NEAR) {\r\n        if (vPrev.z < NEAR && abs(order) == 1.0) {\r\n            vCurrent = vPrev + (vCurrent - vPrev) * (NEAR - vPrev.z) / (vCurrent.z - vPrev.z);\r\n        } else if (vNext.z < NEAR && abs(order) == 2.0) {\r\n            vCurrent = vNext + (vCurrent - vNext) * (NEAR - vNext.z) / (vCurrent.z - vNext.z);\r\n        }\r\n    }\n\n    vec4 dCurrent = proj * vCurrent;\r\n    vec2 _next = project(proj * vNext);\r\n    vec2 _prev = project(proj * vPrev);\r\n    vec2 _current = project(dCurrent);\n\n    if (_prev == _current) {\r\n        if (_next == _current) {\r\n            _next = _current + vec2(1.0, 0.0);\r\n            _prev = _current - _next;\r\n        } else {\r\n            _prev = _current + normalize(_current - _next);\r\n        }\r\n    }\n\n    if (_next == _current) {\r\n        _next = _current + normalize(_current - _prev);\r\n    }\n\n    vec2 sNext = _next,\r\n    sCurrent = _current,\r\n    sPrev = _prev;\n\n    vec2 dirNext = normalize(sNext - sCurrent);\r\n    vec2 dirPrev = normalize(sPrev - sCurrent);\r\n    float dotNP = dot(dirNext, dirPrev);\n\n    vec2 normalNext = normalize(vec2(-dirNext.y, dirNext.x));\r\n    vec2 normalPrev = normalize(vec2(dirPrev.y, -dirPrev.x));\n\n    float d = thickness * sign(order);\n\n    vec2 m;\r\n    if (dotNP >= 0.99991) {\r\n        m = sCurrent - normalPrev * d;\r\n    } else {\r\n        m = getIntersection(sCurrent + normalPrev * d, sPrev + normalPrev * d,\r\n                            sCurrent + normalNext * d, sNext + normalNext * d);\n\n        if (dotNP > 0.5 && dot(dirNext + dirPrev, m - sCurrent) < 0.0) {\r\n            float occw = order * sign(dirNext.x * dirPrev.y - dirNext.y * dirPrev.x);\r\n            if (occw == -1.0) {\r\n                m = sCurrent + normalPrev * d;\r\n            } else if (occw == 1.0) {\r\n                m = sCurrent + normalNext * d;\r\n            } else if (occw == -2.0) {\r\n                m = sCurrent + normalNext * d;\r\n            } else if (occw == 2.0) {\r\n                m = sCurrent + normalPrev * d;\r\n            }\r\n        } else if (distance(sCurrent, m) > min(distance(sCurrent, sNext), distance(sCurrent, sPrev))) {\r\n            m = sCurrent + normalNext * d;\r\n        }\r\n    }\n\n    gl_Position = vec4((2.0 * m / viewport - 1.0) * dCurrent.w, dCurrent.z + depthOffset, dCurrent.w);\r\n}";
var po = "precision highp float;\n\nuniform vec4 visibleSphere;\n\nvarying vec3 uCamPos;\r\nvarying vec4 vColor;\r\nvarying vec3 vPos;\r\n\nvoid main() {\n\n    if (visibleSphere.w != 0.0) {\r\n        vec3 cam_dir = normalize(vPos - uCamPos);\r\n        vec3 sph_dir = normalize(vPos - visibleSphere.xyz);\r\n        if (dot(cam_dir, sph_dir) > 0.11) {\r\n            discard;\r\n        }\r\n    }\n\n    gl_FragColor = vec4(vColor.rgb, vColor.a);\r\n}";
var mo = "precision highp float;\n\nattribute vec3 prevHigh;\r\nattribute vec3 currentHigh;\r\nattribute vec3 nextHigh;\n\nattribute vec3 prevLow;\r\nattribute vec3 currentLow;\r\nattribute vec3 nextLow;\n\nattribute float order;\n\nuniform float thickness;\r\nuniform vec4 color;\r\nuniform mat4 proj;\r\nuniform mat4 view;\r\nuniform vec2 viewport;\r\nuniform vec3 rtcEyePositionHigh;\r\nuniform vec3 rtcEyePositionLow;\r\nuniform float depthOffset;\n\nvarying vec4 vColor;\r\nvarying vec3 vPos;\r\nvarying vec3 uCamPos;\r\n\nconst float NEAR = -1.0;\n\nvec2 getIntersection(vec2 start1, vec2 end1, vec2 start2, vec2 end2) {\r\n    vec2 dir = end2 - start2;\r\n    vec2 perp = vec2(-dir.y, dir.x);\r\n    float d2 = dot(perp, start2);\r\n    float seg = dot(perp, start1) - d2;\r\n    float prl = seg - dot(perp, end1) + d2;\r\n    if (prl > -1.0 && prl < 1.0) {\r\n        return start1;\r\n    }\r\n    float u = seg / prl;\r\n    return start1 + u * (end1 - start1);\r\n}\n\nvec2 project(vec4 p) {\r\n    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;\r\n}\n\nvoid main() {\n\n    uCamPos = rtcEyePositionHigh + rtcEyePositionLow;\r\n    vPos = currentHigh + currentLow;\r\n    vColor = color;\n\n    vec3 highDiff, lowDiff;\n\n    mat4 viewMatrixRTE = view;\r\n    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n    highDiff = currentHigh - rtcEyePositionHigh;\r\n    highDiff = highDiff * step(1.0, length(highDiff));\r\n    lowDiff = currentLow - rtcEyePositionLow;\r\n    vec4 vCurrent = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);\n\n    highDiff = prevHigh - rtcEyePositionHigh;\r\n    highDiff = highDiff * step(1.0, length(highDiff));\r\n    lowDiff = prevLow - rtcEyePositionLow;\r\n    vec4 vPrev = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);\n\n    highDiff = nextHigh - rtcEyePositionHigh;\r\n    highDiff = highDiff * step(1.0, length(highDiff));\r\n    lowDiff = nextLow - rtcEyePositionLow;\r\n    vec4 vNext = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);\r\n\n    if (vCurrent.z > NEAR) {\r\n        if (vPrev.z < NEAR && abs(order) == 1.0) {\r\n            vCurrent = vPrev + (vCurrent - vPrev) * (NEAR - vPrev.z) / (vCurrent.z - vPrev.z);\r\n        } else if (vNext.z < NEAR && abs(order) == 2.0) {\r\n            vCurrent = vNext + (vCurrent - vNext) * (NEAR - vNext.z) / (vCurrent.z - vNext.z);\r\n        }\r\n    }\n\n    vec4 dCurrent = proj * vCurrent;\r\n    vec2 _next = project(proj * vNext);\r\n    vec2 _prev = project(proj * vPrev);\r\n    vec2 _current = project(dCurrent);\r\n    if (_prev == _current) {\r\n        if (_next == _current) {\r\n            _next = _current + vec2(1.0, 0.0);\r\n            _prev = _current - _next;\r\n        } else {\r\n            _prev = _current + normalize(_current - _next);\r\n        }\r\n    }\r\n    if (_next == _current) {\r\n        _next = _current + normalize(_current - _prev);\r\n    }\n\n    vec2 sNext = _next,\r\n    sCurrent = _current,\r\n    sPrev = _prev;\n\n    vec2 dirNext = normalize(sNext - sCurrent);\r\n    vec2 dirPrev = normalize(sPrev - sCurrent);\r\n    float dotNP = dot(dirNext, dirPrev);\n\n    vec2 normalNext = normalize(vec2(-dirNext.y, dirNext.x));\r\n    vec2 normalPrev = normalize(vec2(dirPrev.y, -dirPrev.x));\n\n    float d = thickness * sign(order);\n\n    vec2 m;\r\n    if (dotNP >= 0.99991) {\r\n        m = sCurrent - normalPrev * d;\r\n    } else {\r\n        m = getIntersection(sCurrent + normalPrev * d, sPrev + normalPrev * d,\r\n                            sCurrent + normalNext * d, sNext + normalNext * d);\n\n        if (dotNP > 0.5 && dot(dirNext + dirPrev, m - sCurrent) < 0.0) {\r\n            float occw = order * sign(dirNext.x * dirPrev.y - dirNext.y * dirPrev.x);\r\n            if (occw == -1.0) {\r\n                m = sCurrent + normalPrev * d;\r\n            } else if (occw == 1.0) {\r\n                m = sCurrent + normalNext * d;\r\n            } else if (occw == -2.0) {\r\n                m = sCurrent + normalNext * d;\r\n            } else if (occw == 2.0) {\r\n                m = sCurrent + normalPrev * d;\r\n            }\r\n        }\r\n        else if (distance(sCurrent, m) > min(distance(sCurrent, sNext), distance(sCurrent, sPrev))) {\r\n            m = sCurrent + normalNext * d;\r\n        }\r\n    }\r\n    gl_Position = vec4((2.0 * m / viewport - 1.0) * dCurrent.w, dCurrent.z + depthOffset, dCurrent.w);\r\n}";
var vo = "precision highp float;\n\nuniform vec4 visibleSphere;\n\nvarying vec3 uCamPos;\r\nvarying vec4 vColor;\r\nvarying vec3 vPos;\n\nvoid main() {\r\n    if(visibleSphere.w != 0.0) {\r\n        vec3 cam_dir = normalize(vPos - uCamPos);\r\n        vec3 sph_dir = normalize(vPos - visibleSphere.xyz);\r\n        if( dot(cam_dir, sph_dir) > 0.11 ){\r\n            discard;\r\n        }\r\n    }\r\n    gl_FragColor = vec4(vColor.rgb, vColor.a);\r\n}";
function yo() {
  return new Yr("polyline_screen", { uniforms: { viewport: "vec2", proj: "mat4", view: "mat4", rtcEyePositionHigh: "vec3", rtcEyePositionLow: "vec3", thickness: "float", opacity: "float", depthOffset: "float", visibleSphere: "vec4" }, attributes: { prevHigh: "vec3", currentHigh: "vec3", nextHigh: "vec3", prevLow: "vec3", currentLow: "vec3", nextLow: "vec3", order: "float", color: "vec4" }, vertexShader: go, fragmentShader: po });
}
function xo() {
  return new Yr("polyline_picking", { uniforms: { viewport: "vec2", proj: "mat4", view: "mat4", rtcEyePositionHigh: "vec3", rtcEyePositionLow: "vec3", color: "vec4", thickness: "float", depthOffset: "float", visibleSphere: "vec4" }, attributes: { prevHigh: "vec3", currentHigh: "vec3", nextHigh: "vec3", prevLow: "vec3", currentLow: "vec3", nextLow: "vec3", order: "float" }, vertexShader: mo, fragmentShader: vo });
}
const _bo = class _bo {
  constructor(e4) {
    this.__id = _bo.__counter__++;
    this._entityCollection = e4;
    this._renderer = null;
    this._polylines = [];
    this.pickingEnabled = true;
    this._relativeCenter = new Ke();
    this._rtcEyePositionHigh = new Float32Array([0, 0, 0]);
    this._rtcEyePositionLow = new Float32Array([0, 0, 0]);
  }
  _initProgram() {
    if (this._renderer && this._renderer.handler) {
      if (!this._renderer.handler.programs.polyline_screen) {
        this._renderer.handler.addProgram(yo());
      }
      if (!this._renderer.handler.programs.polyline_picking) {
        this._renderer.handler.addProgram(xo());
      }
    }
  }
  setRenderNode(e4) {
    this._renderer = e4.renderer;
    this._initProgram();
    for (let t2 = 0; t2 < this._polylines.length; t2++) {
      this._polylines[t2].setRenderNode(e4);
    }
  }
  add(e4) {
    if (e4._handlerIndex === -1) {
      e4._handler = this;
      e4._handlerIndex = this._polylines.length;
      e4.__doubleToTwoFloats = this.getRTCPosition.bind(this);
      this._polylines.push(e4);
      if (this._entityCollection && this._entityCollection.renderNode) {
        e4.setRenderNode(this._entityCollection.renderNode);
        e4.updateRTCPosition();
      }
    }
  }
  remove(e4) {
    let t2 = e4._handlerIndex;
    if (t2 !== -1) {
      e4._deleteBuffers();
      e4._handlerIndex = -1;
      e4._handler = null;
      this._polylines.splice(t2, 1);
      this.reindexPolylineArray(t2);
    }
  }
  reindexPolylineArray(e4) {
    let t2 = this._polylines;
    for (let i2 = e4; i2 < t2.length; i2++) {
      t2[i2]._handlerIndex = i2;
    }
  }
  draw() {
    this._updateRTCEyePosition();
    let e4 = this._polylines.length;
    while (e4--) {
      this._polylines[e4].draw();
    }
  }
  drawPicking() {
    if (this.pickingEnabled) {
      let e4 = this._polylines.length;
      while (e4--) {
        this._polylines[e4].drawPicking();
      }
    }
  }
  clear() {
    let e4 = this._polylines.length;
    while (e4--) {
      this._polylines[e4]._deleteBuffers();
      this._polylines[e4]._handler = null;
      this._polylines[e4]._handlerIndex = -1;
    }
    this._polylines.length = 0;
    this._polylines = [];
  }
  getRTCPosition(e4, t2, i2) {
    let s2 = e4.sub(this._relativeCenter);
    Ke.doubleToTwoFloats(s2, t2, i2);
  }
  setRelativeCenter(e4) {
    this._relativeCenter.copy(e4);
    for (let e5 = 0; e5 < this._polylines.length; e5++) {
      this._polylines[e5].updateRTCPosition();
    }
  }
  _updateRTCEyePosition() {
    let e4 = this._renderer;
    if (e4.activeCamera.isFirstPass) {
      let t2 = e4.activeCamera.eye.sub(this._relativeCenter);
      Ke.doubleToTwoFloat32Array(t2, this._rtcEyePositionHigh, this._rtcEyePositionLow);
    }
  }
};
_bo.__counter__ = 0;
let bo = _bo;
var wo = "precision highp float;\n\nattribute vec4 a_rgba;\r\nattribute vec3 a_startPosHigh;\r\nattribute vec3 a_startPosLow;\r\nattribute vec3 a_endPosHigh;\r\nattribute vec3 a_endPosLow;\r\nattribute vec2 a_vertices;\r\nattribute float a_thickness;\n\nvarying vec4 v_rgba;\n\nuniform mat4 viewMatrix;\r\nuniform mat4 projectionMatrix;\r\nuniform vec3 eyePositionHigh;\r\nuniform vec3 eyePositionLow;\r\nuniform float resolution;\r\nuniform float uOpacity;\n\nvoid main() {\n\n    v_rgba = vec4(a_rgba.rgb, a_rgba.a * uOpacity);\n\n    vec3 v = (a_endPosHigh - a_startPosHigh) + (a_endPosLow - a_startPosLow);\n\n    vec3 look = (a_startPosHigh - eyePositionHigh) + (a_startPosLow - eyePositionLow) + v * a_vertices.y;\r\n    vec3 up = normalize(normalize(v));\r\n    vec3 right = normalize(cross(look,up));\n\n    float dist = dot(look, vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]));\r\n    float focalSize = 2.0 * dist * resolution;\r\n    vec3 vert = right * a_thickness * focalSize * a_vertices.x;\n\n    vec3 highDiff;\r\n    if(a_vertices.y == 0.0){\r\n        highDiff = a_startPosHigh - eyePositionHigh;\r\n        vert += a_startPosLow - eyePositionLow;\r\n    }else{\r\n        highDiff = a_endPosHigh - eyePositionHigh;\r\n        vert += a_endPosLow - eyePositionLow;\r\n    }\n\n    mat4 viewMatrixRTE = viewMatrix;\r\n    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n    \n    \n    \n    \n    \n\n    gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff * step(1.0, length(highDiff)) + vert, 1.0);\r\n}";
var Co = "precision highp float;\r\nvarying vec4 v_rgba;\r\nvoid main () {\r\n    gl_FragColor = v_rgba;\r\n}";
function To() {
  return new Yr("rayScreen", { uniforms: { projectionMatrix: "mat4", viewMatrix: "mat4", eyePositionHigh: "vec3", eyePositionLow: "vec3", resolution: "float", uOpacity: "float" }, attributes: { a_vertices: "vec2", a_startPosHigh: "vec3", a_startPosLow: "vec3", a_endPosHigh: "vec3", a_endPosLow: "vec3", a_thickness: "float", a_rgba: "vec4" }, vertexShader: wo, fragmentShader: Co });
}
const Eo = 0;
const Ao = 1;
const Lo = 2;
const Po = 3;
const So = 4;
const Ro = 5;
const _Mo = class _Mo {
  constructor(e4) {
    this.__id = _Mo.__counter__++;
    this.pickingEnabled = true;
    this._entityCollection = e4;
    this._renderer = null;
    this._rays = [];
    this._vertexBuffer = null;
    this._startPositionHighBuffer = null;
    this._startPositionLowBuffer = null;
    this._endPositionHighBuffer = null;
    this._endPositionLowBuffer = null;
    this._thicknessBuffer = null;
    this._rgbaBuffer = null;
    this._pickingColorBuffer = null;
    this._vertexArr = [];
    this._startPositionHighArr = [];
    this._startPositionLowArr = [];
    this._endPositionHighArr = [];
    this._endPositionLowArr = [];
    this._thicknessArr = [];
    this._rgbaArr = [];
    this._pickingColorArr = [];
    this._buffersUpdateCallbacks = [];
    this._buffersUpdateCallbacks[Ro] = this.createVertexBuffer;
    this._buffersUpdateCallbacks[Ao] = this.createStartPositionBuffer;
    this._buffersUpdateCallbacks[Lo] = this.createEndPositionBuffer;
    this._buffersUpdateCallbacks[So] = this.createThicknessBuffer;
    this._buffersUpdateCallbacks[Po] = this.createRgbaBuffer;
    this._buffersUpdateCallbacks[Eo] = this.createPickingColorBuffer;
    this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
  }
  static concArr(e4, t2) {
    for (let i2 = 0; i2 < t2.length; i2++) {
      e4.push(t2[i2]);
    }
  }
  initProgram() {
    if (this._renderer && this._renderer.handler) {
      if (!this._renderer.handler.programs.rayScreen) {
        this._renderer.handler.addProgram(To());
      }
    }
  }
  setRenderer(e4) {
    this._renderer = e4;
    this.initProgram();
  }
  refresh() {
    let e4 = this._changedBuffers.length;
    while (e4--) {
      this._changedBuffers[e4] = true;
    }
  }
  _removeRays() {
    let e4 = this._rays.length;
    while (e4--) {
      let t2 = this._rays[e4];
      t2._handlerIndex = -1;
      t2._handler = null;
    }
    this._rays.length = 0;
    this._rays = [];
  }
  clear() {
    this._vertexArr = null;
    this._startPositionHighArr = null;
    this._startPositionLowArr = null;
    this._endPositionHighArr = null;
    this._endPositionLowArr = null;
    this._thicknessArr = null;
    this._rgbaArr = null;
    this._vertexArr = new Float32Array([]);
    this._startPositionHighArr = new Float32Array([]);
    this._startPositionLowArr = new Float32Array([]);
    this._endPositionHighArr = new Float32Array([]);
    this._endPositionLowArr = new Float32Array([]);
    this._thicknessArr = new Float32Array([]);
    this._rgbaArr = new Float32Array([]);
    this._removeRays();
    this._deleteBuffers();
    this.refresh();
  }
  _deleteBuffers() {
    if (this._renderer) {
      let e4 = this._renderer.handler.gl;
      if (e4) {
        e4.deleteBuffer(this._startPositionHighBuffer);
        e4.deleteBuffer(this._startPositionLowBuffer);
        e4.deleteBuffer(this._endPositionHighBuffer);
        e4.deleteBuffer(this._endPositionLowBuffer);
        e4.deleteBuffer(this._thicknessBuffer);
        e4.deleteBuffer(this._rgbaBuffer);
        e4.deleteBuffer(this._vertexBuffer);
      }
      this._startPositionHighBuffer = null;
      this._startPositionLowBuffer = null;
      this._endPositionHighBuffer = null;
      this._endPositionLowBuffer = null;
      this._thicknessBuffer = null;
      this._rgbaBuffer = null;
      this._vertexBuffer = null;
    }
  }
  update() {
    if (this._renderer) {
      let e4 = this._changedBuffers.length;
      while (e4--) {
        if (this._changedBuffers[e4]) {
          this._buffersUpdateCallbacks[e4].call(this);
          this._changedBuffers[e4] = false;
        }
      }
    }
  }
  add(e4) {
    if (e4._handlerIndex == -1) {
      e4._handler = this;
      e4._handlerIndex = this._rays.length;
      this._rays.push(e4);
      this._addRayToArrays(e4);
      this.refresh();
    }
  }
  _addRayToArrays(e4) {
    if (e4.getVisibility()) {
      this._vertexArr = Vt(this._vertexArr, [-0.5, 1, -0.5, 0, 0.5, 0, 0.5, 0, 0.5, 1, -0.5, 1]);
    } else {
      this._vertexArr = Vt(this._vertexArr, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    }
    let t2 = e4._startPositionHigh.x, i2 = e4._startPositionHigh.y, s2 = e4._startPositionHigh.z;
    this._startPositionHighArr = Vt(this._startPositionHighArr, [t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2]);
    t2 = e4._startPositionLow.x;
    i2 = e4._startPositionLow.y;
    s2 = e4._startPositionLow.z;
    this._startPositionLowArr = Vt(this._startPositionLowArr, [t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2]);
    t2 = e4._endPositionHigh.x;
    i2 = e4._endPositionHigh.y;
    s2 = e4._endPositionHigh.z;
    this._endPositionHighArr = Vt(this._endPositionHighArr, [t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2]);
    t2 = e4._endPositionLow.x;
    i2 = e4._endPositionLow.y;
    s2 = e4._endPositionLow.z;
    this._endPositionLowArr = Vt(this._endPositionLowArr, [t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2]);
    t2 = e4._thickness;
    this._thicknessArr = Vt(this._thicknessArr, [t2, t2, t2, t2, t2, t2]);
    let r2 = e4._startColor.x, n2 = e4._startColor.y, o2 = e4._startColor.z, a2 = e4._startColor.w, l2 = e4._endColor.x, h2 = e4._endColor.y, c2 = e4._endColor.z, d2 = e4._endColor.w;
    this._rgbaArr = Vt(this._rgbaArr, [l2, h2, c2, d2, r2, n2, o2, a2, r2, n2, o2, a2, r2, n2, o2, a2, l2, h2, c2, d2, l2, h2, c2, d2]);
    t2 = e4._entity._pickingColor.x / 255;
    i2 = e4._entity._pickingColor.y / 255;
    s2 = e4._entity._pickingColor.z / 255;
    this._pickingColorArr = Vt(this._pickingColorArr, [t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2, t2, i2, s2]);
  }
  _displayPASS() {
    let e4 = this._renderer;
    let t2 = e4.handler;
    t2.programs.rayScreen.activate();
    let i2 = t2.programs.rayScreen._program;
    let s2 = i2.attributes, r2 = i2.uniforms;
    let n2 = t2.gl, o2 = this._entityCollection;
    n2.disable(n2.CULL_FACE);
    n2.uniform1f(r2.uOpacity, o2._fadingOpacity);
    n2.uniformMatrix4fv(r2.viewMatrix, false, e4.activeCamera.getViewMatrix());
    n2.uniformMatrix4fv(r2.projectionMatrix, false, e4.activeCamera.getProjectionMatrix());
    n2.uniform3fv(r2.eyePositionHigh, e4.activeCamera.eyeHigh);
    n2.uniform3fv(r2.eyePositionLow, e4.activeCamera.eyeLow);
    n2.uniform1f(r2.resolution, e4.activeCamera._tanViewAngle_hradOneByHeight);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._startPositionHighBuffer);
    n2.vertexAttribPointer(s2.a_startPosHigh, this._startPositionHighBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._startPositionLowBuffer);
    n2.vertexAttribPointer(s2.a_startPosLow, this._startPositionLowBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._endPositionHighBuffer);
    n2.vertexAttribPointer(s2.a_endPosHigh, this._endPositionHighBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._endPositionLowBuffer);
    n2.vertexAttribPointer(s2.a_endPosLow, this._endPositionLowBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._rgbaBuffer);
    n2.vertexAttribPointer(s2.a_rgba, this._rgbaBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._thicknessBuffer);
    n2.vertexAttribPointer(s2.a_thickness, this._thicknessBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.bindBuffer(n2.ARRAY_BUFFER, this._vertexBuffer);
    n2.vertexAttribPointer(s2.a_vertices, this._vertexBuffer.itemSize, n2.FLOAT, false, 0, 0);
    n2.drawArrays(n2.TRIANGLES, 0, this._vertexBuffer.numItems);
    n2.enable(n2.CULL_FACE);
  }
  _pickingPASS() {
  }
  draw() {
    if (this._rays.length) {
      this.update();
      this._displayPASS();
    }
  }
  drawPicking() {
    if (this._rays.length && this.pickingEnabled) {
      this._pickingPASS();
    }
  }
  reindexRaysArray(e4) {
    let t2 = this._rays;
    for (let i2 = e4; i2 < t2.length; i2++) {
      t2[i2]._handlerIndex = i2;
    }
  }
  _removeRay(e4) {
    let t2 = e4._handlerIndex;
    this._rays.splice(t2, 1);
    let i2 = t2 * 24;
    this._rgbaArr = Wt(this._rgbaArr, i2, 24);
    i2 = t2 * 18;
    this._startPositionHighArr = Wt(this._startPositionHighArr, i2, 18);
    this._startPositionLowArr = Wt(this._startPositionLowArr, i2, 18);
    this._endPositionHighArr = Wt(this._endPositionHighArr, i2, 18);
    this._endPositionLowArr = Wt(this._endPositionLowArr, i2, 18);
    this._pickingColorArr = Wt(this._pickingColorArr, i2, 18);
    i2 = t2 * 12;
    this._vertexArr = Wt(this._vertexArr, i2, 12);
    i2 = t2 * 6;
    this._thicknessArr = Wt(this._thicknessArr, i2, 6);
    this.reindexRaysArray(t2);
    this.refresh();
    e4._handlerIndex = -1;
    e4._handler = null;
  }
  remove(e4) {
    if (e4._handler && this.__id === e4._handler.__id) {
      this._removeRay(e4);
    }
  }
  setStartPositionArr(e4, t2, i2) {
    let s2 = e4 * 18;
    let r2 = this._startPositionHighArr, n2 = t2.x, o2 = t2.y, a2 = t2.z;
    r2[s2] = n2;
    r2[s2 + 1] = o2;
    r2[s2 + 2] = a2;
    r2[s2 + 3] = n2;
    r2[s2 + 4] = o2;
    r2[s2 + 5] = a2;
    r2[s2 + 6] = n2;
    r2[s2 + 7] = o2;
    r2[s2 + 8] = a2;
    r2[s2 + 9] = n2;
    r2[s2 + 10] = o2;
    r2[s2 + 11] = a2;
    r2[s2 + 12] = n2;
    r2[s2 + 13] = o2;
    r2[s2 + 14] = a2;
    r2[s2 + 15] = n2;
    r2[s2 + 16] = o2;
    r2[s2 + 17] = a2;
    r2 = this._startPositionLowArr;
    n2 = i2.x;
    o2 = i2.y;
    a2 = i2.z;
    r2[s2] = n2;
    r2[s2 + 1] = o2;
    r2[s2 + 2] = a2;
    r2[s2 + 3] = n2;
    r2[s2 + 4] = o2;
    r2[s2 + 5] = a2;
    r2[s2 + 6] = n2;
    r2[s2 + 7] = o2;
    r2[s2 + 8] = a2;
    r2[s2 + 9] = n2;
    r2[s2 + 10] = o2;
    r2[s2 + 11] = a2;
    r2[s2 + 12] = n2;
    r2[s2 + 13] = o2;
    r2[s2 + 14] = a2;
    r2[s2 + 15] = n2;
    r2[s2 + 16] = o2;
    r2[s2 + 17] = a2;
    this._changedBuffers[Ao] = true;
  }
  setEndPositionArr(e4, t2, i2) {
    let s2 = e4 * 18;
    let r2 = this._endPositionHighArr, n2 = t2.x, o2 = t2.y, a2 = t2.z;
    r2[s2] = n2;
    r2[s2 + 1] = o2;
    r2[s2 + 2] = a2;
    r2[s2 + 3] = n2;
    r2[s2 + 4] = o2;
    r2[s2 + 5] = a2;
    r2[s2 + 6] = n2;
    r2[s2 + 7] = o2;
    r2[s2 + 8] = a2;
    r2[s2 + 9] = n2;
    r2[s2 + 10] = o2;
    r2[s2 + 11] = a2;
    r2[s2 + 12] = n2;
    r2[s2 + 13] = o2;
    r2[s2 + 14] = a2;
    r2[s2 + 15] = n2;
    r2[s2 + 16] = o2;
    r2[s2 + 17] = a2;
    r2 = this._endPositionLowArr;
    n2 = i2.x;
    o2 = i2.y;
    a2 = i2.z;
    r2[s2] = n2;
    r2[s2 + 1] = o2;
    r2[s2 + 2] = a2;
    r2[s2 + 3] = n2;
    r2[s2 + 4] = o2;
    r2[s2 + 5] = a2;
    r2[s2 + 6] = n2;
    r2[s2 + 7] = o2;
    r2[s2 + 8] = a2;
    r2[s2 + 9] = n2;
    r2[s2 + 10] = o2;
    r2[s2 + 11] = a2;
    r2[s2 + 12] = n2;
    r2[s2 + 13] = o2;
    r2[s2 + 14] = a2;
    r2[s2 + 15] = n2;
    r2[s2 + 16] = o2;
    r2[s2 + 17] = a2;
    this._changedBuffers[Lo] = true;
  }
  setPickingColorArr(e4, t2) {
    let i2 = e4 * 18;
    let s2 = this._pickingColorArr, r2 = t2.x / 255, n2 = t2.y / 255, o2 = t2.z / 255;
    s2[i2] = r2;
    s2[i2 + 1] = n2;
    s2[i2 + 2] = o2;
    s2[i2 + 3] = r2;
    s2[i2 + 4] = n2;
    s2[i2 + 5] = o2;
    s2[i2 + 6] = r2;
    s2[i2 + 7] = n2;
    s2[i2 + 8] = o2;
    s2[i2 + 9] = r2;
    s2[i2 + 10] = n2;
    s2[i2 + 11] = o2;
    s2[i2 + 12] = r2;
    s2[i2 + 13] = n2;
    s2[i2 + 14] = o2;
    s2[i2 + 15] = r2;
    s2[i2 + 16] = n2;
    s2[i2 + 17] = o2;
    this._changedBuffers[Eo] = true;
  }
  setRgbaArr(e4, t2, i2) {
    let s2 = e4 * 24;
    let r2 = this._rgbaArr, n2 = t2.x, o2 = t2.y, a2 = t2.z, l2 = t2.w, h2 = i2.x, c2 = i2.y, d2 = i2.z, u2 = i2.w;
    r2[s2] = h2;
    r2[s2 + 1] = c2;
    r2[s2 + 2] = d2;
    r2[s2 + 3] = u2;
    r2[s2 + 4] = n2;
    r2[s2 + 5] = o2;
    r2[s2 + 6] = a2;
    r2[s2 + 7] = l2;
    r2[s2 + 8] = n2;
    r2[s2 + 9] = o2;
    r2[s2 + 10] = a2;
    r2[s2 + 11] = l2;
    r2[s2 + 12] = n2;
    r2[s2 + 13] = o2;
    r2[s2 + 14] = a2;
    r2[s2 + 15] = l2;
    r2[s2 + 16] = h2;
    r2[s2 + 17] = c2;
    r2[s2 + 18] = d2;
    r2[s2 + 19] = u2;
    r2[s2 + 20] = h2;
    r2[s2 + 21] = c2;
    r2[s2 + 22] = d2;
    r2[s2 + 23] = u2;
    this._changedBuffers[Po] = true;
  }
  setThicknessArr(e4, t2) {
    let i2 = e4 * 6;
    let s2 = this._thicknessArr;
    s2[i2] = t2;
    s2[i2 + 1] = t2;
    s2[i2 + 2] = t2;
    s2[i2 + 3] = t2;
    s2[i2 + 4] = t2;
    s2[i2 + 5] = t2;
    this._changedBuffers[So] = true;
  }
  setVisibility(e4, t2) {
    let i2;
    if (t2) {
      i2 = [-0.5, 1, -0.5, 0, 0.5, 0, 0.5, 0, 0.5, 1, -0.5, 1];
    } else {
      i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }
    this.setVertexArr(e4, i2);
  }
  setVertexArr(e4, t2) {
    let i2 = e4 * 12;
    let s2 = this._vertexArr;
    s2[i2] = t2[0];
    s2[i2 + 1] = t2[1];
    s2[i2 + 2] = t2[2];
    s2[i2 + 3] = t2[3];
    s2[i2 + 4] = t2[4];
    s2[i2 + 5] = t2[5];
    s2[i2 + 6] = t2[6];
    s2[i2 + 7] = t2[7];
    s2[i2 + 8] = t2[8];
    s2[i2 + 9] = t2[9];
    s2[i2 + 10] = t2[10];
    s2[i2 + 11] = t2[11];
    this._changedBuffers[Ro] = true;
  }
  createStartPositionBuffer() {
    let e4 = this._renderer.handler;
    e4.gl.deleteBuffer(this._startPositionHighBuffer);
    this._startPositionHighArr = Ut(this._startPositionHighArr);
    this._startPositionHighBuffer = e4.createArrayBuffer(this._startPositionHighArr, 3, this._startPositionHighArr.length / 3, e4.gl.DYNAMIC_DRAW);
    e4.gl.deleteBuffer(this._startPositionLowBuffer);
    this._startPositionLowArr = Ut(this._startPositionLowArr);
    this._startPositionLowBuffer = e4.createArrayBuffer(this._startPositionLowArr, 3, this._startPositionLowArr.length / 3, e4.gl.DYNAMIC_DRAW);
  }
  createEndPositionBuffer() {
    let e4 = this._renderer.handler;
    e4.gl.deleteBuffer(this._endPositionHighBuffer);
    this._endPositionHighArr = Ut(this._endPositionHighArr);
    this._endPositionHighBuffer = e4.createArrayBuffer(this._endPositionHighArr, 3, this._endPositionHighArr.length / 3, e4.gl.DYNAMIC_DRAW);
    e4.gl.deleteBuffer(this._endPositionLowBuffer);
    this._endPositionLowArr = Ut(this._endPositionLowArr);
    this._endPositionLowBuffer = e4.createArrayBuffer(this._endPositionLowArr, 3, this._endPositionLowArr.length / 3, e4.gl.DYNAMIC_DRAW);
  }
  createRgbaBuffer() {
    let e4 = this._renderer.handler;
    e4.gl.deleteBuffer(this._rgbaBuffer);
    this._rgbaArr = Ut(this._rgbaArr);
    this._rgbaBuffer = e4.createArrayBuffer(this._rgbaArr, 4, this._rgbaArr.length / 4);
  }
  createThicknessBuffer() {
    let e4 = this._renderer.handler;
    e4.gl.deleteBuffer(this._thicknessBuffer);
    this._thicknessArr = Ut(this._thicknessArr);
    this._thicknessBuffer = e4.createArrayBuffer(this._thicknessArr, 1, this._thicknessArr.length, e4.gl.DYNAMIC_DRAW);
  }
  createVertexBuffer() {
    let e4 = this._renderer.handler;
    e4.gl.deleteBuffer(this._vertexBuffer);
    this._vertexArr = Ut(this._vertexArr);
    this._vertexBuffer = e4.createArrayBuffer(this._vertexArr, 2, this._vertexArr.length / 2, e4.gl.DYNAMIC_DRAW);
  }
  createPickingColorBuffer() {
    let e4 = this._renderer.handler;
    e4.gl.deleteBuffer(this._pickingColorBuffer);
    this._pickingColorArr = Ut(this._pickingColorArr);
    this._pickingColorBuffer = e4.createArrayBuffer(this._pickingColorArr, 3, this._pickingColorArr.length / 3);
  }
};
_Mo.__counter__ = 0;
let Mo = _Mo;
const _Bo = class _Bo {
  constructor(e4) {
    this.__id = _Bo.__counter__++;
    this.pickingEnabled = true;
    this._entityCollection = e4;
    this._renderer = null;
    this._strips = [];
  }
  _initProgram() {
    if (this._renderer && this._renderer.handler) {
      !this._renderer.handler.programs.strip && this._renderer.handler.addProgram(new Yr("strip", { uniforms: { projectionMatrix: { type: "mat4" }, viewMatrix: { type: "mat4" }, eyePositionHigh: "vec3", eyePositionLow: "vec3", uColor: { type: "vec4" }, uOpacity: { type: "float" } }, attributes: { aVertexPositionHigh: { type: "vec3" }, aVertexPositionLow: { type: "vec3" } }, vertexShader: `attribute vec3 aVertexPositionHigh;
                        attribute vec3 aVertexPositionLow;
                        uniform mat4 projectionMatrix;
                        uniform mat4 viewMatrix;
                        uniform vec3 eyePositionHigh;
                        uniform vec3 eyePositionLow;
                        void main(void) {

                            vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                            vec3 lowDiff = aVertexPositionLow - eyePositionLow;

                            mat4 viewMatrixRTE = viewMatrix;
                            viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                            gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);
                        }`, fragmentShader: `precision highp float;
                        uniform vec4 uColor;
                        uniform float uOpacity;
                        void main(void) {
                            gl_FragColor = vec4(uColor.rgb, uColor.a * uOpacity);
                        }` }));
    }
  }
  setRenderNode(e4) {
    this._renderer = e4.renderer;
    this._initProgram();
    for (let t2 = 0; t2 < this._strips.length; t2++) {
      this._strips[t2].setRenderNode(e4);
    }
  }
  add(e4) {
    if (e4._handlerIndex === -1) {
      e4._handler = this;
      e4._handlerIndex = this._strips.length;
      this._strips.push(e4);
      this._entityCollection && this._entityCollection.renderNode && e4.setRenderNode(this._entityCollection.renderNode);
    }
  }
  remove(e4) {
    let t2 = e4._handlerIndex;
    if (t2 !== -1) {
      e4._deleteBuffers();
      e4._handlerIndex = -1;
      e4._handler = null;
      this._strips.splice(t2, 1);
      this.reindexStripArray(t2);
    }
  }
  reindexStripArray(e4) {
    let t2 = this._strips;
    for (let i2 = e4; i2 < t2.length; i2++) {
      t2[i2]._handlerIndex = i2;
    }
  }
  draw() {
    let e4 = this._strips.length;
    while (e4--) {
      this._strips[e4].draw();
    }
  }
  drawPicking() {
    if (this.pickingEnabled) {
      let e4 = this._strips.length;
      while (e4--) {
        this._strips[e4].drawPicking();
      }
    }
  }
  clear() {
    let e4 = this._strips.length;
    while (e4--) {
      this._strips[e4]._deleteBuffers();
      this._strips[e4]._handler = null;
      this._strips[e4]._handlerIndex = -1;
    }
    this._strips.length = 0;
    this._strips = [];
  }
};
_Bo.__counter__ = 0;
let Bo = _Bo;
const _ko = class _ko {
  constructor(e4 = {}) {
    this._onChangeRelativeCenter = (e5) => {
      this.geoObjectHandler.setRelativeCenter(e5);
      this.polylineHandler.setRelativeCenter(e5);
    };
    this.__id = _ko.__counter__++;
    this.renderNode = null;
    this._visibility = e4.visibility == void 0 ? true : e4.visibility;
    this.polygonOffsetUnits = e4.polygonOffsetUnits != void 0 ? e4.polygonOffsetUnits : 0;
    this.billboardHandler = new hn(this);
    this.labelHandler = new uo(this, e4.labelMaxLetters);
    this.polylineHandler = new bo(this);
    this.rayHandler = new Mo(this);
    this.pointCloudHandler = new fo(this);
    this.stripHandler = new Bo(this);
    this.geoObjectHandler = new Un(this);
    if (e4.pickingEnabled != void 0) {
      this.setPickingEnabled(e4.pickingEnabled);
    }
    this._entities = [];
    this.scaleByDistance = e4.scaleByDistance || [1, 1, 1];
    let t2 = new Float32Array([1, 1, 1]);
    if (e4.pickingScale !== void 0) {
      if (e4.pickingScale instanceof Array) {
        t2[0] = e4.pickingScale[0] || t2[0];
        t2[1] = e4.pickingScale[1] || t2[1];
        t2[2] = e4.pickingScale[2] || t2[2];
      } else if (typeof e4.pickingScale === "number") {
        t2[0] = e4.pickingScale;
        t2[1] = e4.pickingScale;
        t2[2] = e4.pickingScale;
      }
    }
    this._depthOrder = e4.depthOrder || 0;
    this.pickingScale = t2;
    this._opacity = e4.opacity == void 0 ? 1 : e4.opacity;
    this._fadingOpacity = this._opacity;
    this.events = this.rendererEvents = Qi(Io, this);
    this._useLighting = e4.useLighting != void 0 ? e4.useLighting ? 1 : 0 : 1;
    if (e4.entities) {
      this.addEntities(e4.entities);
    }
  }
  get depthOrder() {
    return this._depthOrder;
  }
  set depthOrder(e4) {
    this._depthOrder = e4;
    if (this.renderNode) {
      this.renderNode.updateEntityCollectionsDepthOrder();
    }
  }
  isEmpty() {
    return this._entities.length == 0;
  }
  get id() {
    return this.__id;
  }
  get useLighting() {
    return Boolean(this._useLighting);
  }
  set useLighting(e4) {
    this._useLighting = Number(e4);
  }
  isEqual(e4) {
    return e4 !== null && this.__id === e4.__id;
  }
  setVisibility(e4) {
    var _a2;
    this._visibility = e4;
    this._fadingOpacity = this._opacity * (e4 ? 1 : 0);
    (_a2 = this.renderNode) == null ? void 0 : _a2.updateEntityCollectionsDepthOrder();
    this.events.dispatch(this.events.visibilitychange, this);
  }
  getVisibility() {
    return this._visibility;
  }
  setOpacity(e4) {
    this._opacity = e4;
  }
  setPickingEnabled(e4) {
    this.billboardHandler.pickingEnabled = e4;
    this.labelHandler.pickingEnabled = e4;
    this.polylineHandler.pickingEnabled = e4;
    this.rayHandler.pickingEnabled = e4;
    this.pointCloudHandler.pickingEnabled = e4;
    this.stripHandler.pickingEnabled = e4;
    this.geoObjectHandler.pickingEnabled = e4;
  }
  getOpacity() {
    return this._opacity;
  }
  setScaleByDistance(e4, t2, i2) {
    this.scaleByDistance[0] = e4;
    this.scaleByDistance[1] = t2;
    this.scaleByDistance[2] = i2 || l;
  }
  appendChildEntity(e4) {
    this._addRecursively(e4);
  }
  _addRecursively(e4) {
    let t2 = this.renderNode;
    if (t2) {
      if (t2.ellipsoid && e4._cartesian.isZero()) {
        e4.setCartesian3v(t2.ellipsoid.lonLatToCartesian(e4._lonLat));
      }
    }
    this._setPickingColor(e4);
    e4._updateAbsolutePosition();
    e4.setScale3v(e4.getScale());
    e4.billboard && this.billboardHandler.add(e4.billboard);
    e4.label && this.labelHandler.add(e4.label);
    e4.polyline && this.polylineHandler.add(e4.polyline);
    e4.ray && this.rayHandler.add(e4.ray);
    e4.pointCloud && this.pointCloudHandler.add(e4.pointCloud);
    e4.strip && this.stripHandler.add(e4.strip);
    e4.geoObject && this.geoObjectHandler.add(e4.geoObject);
    this.events.dispatch(this.events.entityadd, e4);
    for (let t3 = 0; t3 < e4.childEntities.length; t3++) {
      e4.childEntities[t3]._entityCollection = this;
      e4.childEntities[t3]._entityCollectionIndex = e4._entityCollectionIndex;
      this._addRecursively(e4.childEntities[t3]);
    }
  }
  add(e4) {
    if (!e4._entityCollection) {
      e4._entityCollection = this;
      e4._entityCollectionIndex = this._entities.length;
      this._entities.push(e4);
      this._addRecursively(e4);
    }
    return this;
  }
  addEntities(e4) {
    for (let t2 = 0, i2 = e4.length; t2 < i2; t2++) {
      this.add(e4[t2]);
    }
    return this;
  }
  belongs(e4) {
    return this.isEqual(e4._entityCollection);
  }
  _removeRecursively(e4) {
    e4._entityCollection = null;
    e4._entityCollectionIndex = -1;
    e4.billboard && this.billboardHandler.remove(e4.billboard);
    e4.label && this.labelHandler.remove(e4.label);
    e4.polyline && this.polylineHandler.remove(e4.polyline);
    e4.ray && this.rayHandler.remove(e4.ray);
    e4.pointCloud && this.pointCloudHandler.remove(e4.pointCloud);
    e4.strip && this.stripHandler.remove(e4.strip);
    e4.geoObject && this.geoObjectHandler.remove(e4.geoObject);
    for (let t2 = 0; t2 < e4.childEntities.length; t2++) {
      this._removeRecursively(e4.childEntities[t2]);
    }
  }
  removeEntity(e4) {
    this._entities.splice(e4._entityCollectionIndex, 1);
    this.reindexEntitiesArray(e4._entityCollectionIndex);
    if (this.renderNode && this.renderNode.renderer) {
      this.renderNode.renderer.clearPickingColor(e4);
      e4._pickingColor.clear();
    }
    if (this.belongs(e4)) {
      this._removeRecursively(e4);
    }
    this.events.dispatch(this.events.entityremove, e4);
  }
  _removeEntitySilent(e4) {
    this._entities.splice(e4._entityCollectionIndex, 1);
    this.reindexEntitiesArray(e4._entityCollectionIndex);
    if (this.renderNode && this.renderNode.renderer) {
      this.renderNode.renderer.clearPickingColor(e4);
      e4._pickingColor.clear();
    }
    if (this.belongs(e4)) {
      this._removeRecursively(e4);
    }
  }
  createPickingColors(e4 = this._entities) {
    if (!(this.renderNode && this.renderNode.renderer)) return;
    for (let t2 = 0; t2 < e4.length; t2++) {
      let i2 = e4[t2];
      this._setPickingColor(i2);
      this.createPickingColors(i2.childEntities);
    }
  }
  _setPickingColor(e4) {
    if (this.renderNode && this.renderNode.renderer) {
      if (e4._independentPicking || !e4.parent) {
        this.renderNode.renderer.assignPickingColor(e4);
      } else {
        e4._pickingColor = e4.parent._pickingColor;
      }
      this.renderNode.renderer.assignPickingColor(e4);
      e4.setPickingColor();
    }
  }
  reindexEntitiesArray(e4) {
    let t2 = this._entities;
    for (let i2 = e4; i2 < t2.length; i2++) {
      t2[i2]._entityCollectionIndex = i2;
    }
  }
  addTo(e4, t2 = false) {
    if (!this.renderNode) {
      e4.addEntityCollection(this, t2);
    }
    return this;
  }
  bindRenderNode(e4) {
    if (e4.renderer && e4.renderer.isInitialized()) {
      this.billboardHandler.setRenderer(e4.renderer);
      this.labelHandler.setRenderer(e4.renderer);
      this.rayHandler.setRenderer(e4.renderer);
      this.geoObjectHandler.setRenderNode(e4);
      this.polylineHandler.setRenderNode(e4);
      this.pointCloudHandler.setRenderNode(e4);
      this.stripHandler.setRenderNode(e4);
      e4.renderer.events.on("changerelativecenter", this._onChangeRelativeCenter);
      this.updateBillboardsTextureAtlas();
      this.updateLabelsFontAtlas();
      this.createPickingColors();
    }
  }
  _updateGeodeticCoordinates(e4) {
    let t2 = this._entities;
    let i2 = t2.length;
    while (i2--) {
      let s2 = t2[i2];
      s2._lonLat && s2.setCartesian3v(e4.lonLatToCartesian(s2._lonLat));
    }
  }
  updateBillboardsTextureAtlas() {
    let e4 = this.billboardHandler.billboards;
    for (let t2 = 0; t2 < e4.length; t2++) {
      e4[t2].setSrc(e4[t2].getSrc());
    }
  }
  updateLabelsFontAtlas() {
    if (this.renderNode) {
      this.labelHandler.updateFonts();
    }
  }
  remove() {
    var _a2;
    if (this.renderNode) {
      this.renderNode.removeEntityCollection(this);
      (_a2 = this.renderNode.renderer) == null ? void 0 : _a2.events.off("changerelativecenter", this._onChangeRelativeCenter);
      this.renderNode = null;
      this.events.dispatch(this.events.remove, this);
    }
  }
  getEntities() {
    return [].concat(this._entities);
  }
  each(e4) {
    let t2 = this._entities.length;
    while (t2--) {
      let i2 = this._entities[t2];
      i2 && e4(i2);
    }
  }
  clear() {
    this.billboardHandler.clear();
    this.labelHandler.clear();
    this.polylineHandler.clear();
    this.rayHandler.clear();
    this.pointCloudHandler.clear();
    this.stripHandler.clear();
    this.geoObjectHandler.clear();
    let e4 = this._entities.length;
    while (e4--) {
      let t2 = this._entities[e4];
      if (this.renderNode && this.renderNode.renderer) {
        this.renderNode.renderer.clearPickingColor(t2);
        t2._pickingColor.clear();
      }
      this._clearEntity(t2);
    }
    this._entities.length = 0;
    this._entities = [];
  }
  _clearEntity(e4) {
    e4._entityCollection = null;
    e4._entityCollectionIndex = -1;
    for (let t2 = 0; t2 < e4.childEntities.length; t2++) {
      this._clearEntity(e4.childEntities[t2]);
    }
  }
};
_ko.__counter__ = 0;
let ko = _ko;
const Io = ["draw", "drawend", "add", "remove", "entityadd", "entityremove", "visibilitychange", "mousemove", "mouseenter", "mouseleave", "lclick", "rclick", "mclick", "ldblclick", "rdblclick", "mdblclick", "lup", "rup", "mup", "ldown", "rdown", "mdown", "lhold", "rhold", "mhold", "mousewheel", "touchmove", "touchstart", "touchend", "doubletouch", "touchleave", "touchenter"];
function zo(e4, t2) {
  if (e4 >= 0) {
    let i2 = Math.floor(e4 / 65536) * 65536;
    t2[0] = Math.fround(i2);
    t2[1] = Math.fround(e4 - i2);
  } else {
    let i2 = Math.floor(-e4 / 65536) * 65536;
    t2[0] = Math.fround(-i2);
    t2[1] = Math.fround(e4 + i2);
  }
  return t2;
}
function Do(e4, t2) {
  if (e4 >= 0) {
    let i2 = Math.floor(e4 / 65536) * 65536;
    t2.x = Math.fround(i2);
    t2.y = Math.fround(e4 - i2);
  } else {
    let i2 = Math.floor(-e4 / 65536) * 65536;
    t2.x = Math.fround(-i2);
    t2.y = Math.fround(e4 + i2);
  }
  return t2;
}
function Fo(e4, t2, i2) {
  i2 = i2 || 2;
  var s2 = t2 && t2.length, r2 = s2 ? t2[0] * i2 : e4.length, n2 = No(e4, 0, r2, i2, true), o2 = [];
  if (!n2) return o2;
  var a2, l2, h2, c2, d2, u2, _2;
  if (s2) n2 = jo(e4, t2, n2, i2);
  if (e4.length > 80 * i2) {
    a2 = h2 = e4[0];
    l2 = c2 = e4[1];
    for (let t3 = i2; t3 < r2; t3 += i2) {
      d2 = e4[t3];
      u2 = e4[t3 + 1];
      if (d2 < a2) a2 = d2;
      if (u2 < l2) l2 = u2;
      if (d2 > h2) h2 = d2;
      if (u2 > c2) c2 = u2;
    }
    _2 = Math.max(h2 - a2, c2 - l2);
  }
  Ho(n2, o2, i2, a2, l2, _2);
  return o2;
}
function No(e4, t2, i2, s2, r2) {
  var n2, o2;
  if (r2 === da(e4, t2, i2, s2) > 0) {
    for (n2 = t2; n2 < i2; n2 += s2) o2 = la(n2, e4[n2], e4[n2 + 1], o2);
  } else {
    for (n2 = i2 - s2; n2 >= t2; n2 -= s2) o2 = la(n2, e4[n2], e4[n2 + 1], o2);
  }
  if (o2 && ia(o2, o2.next)) {
    ha(o2);
    o2 = o2.next;
  }
  return o2;
}
function Oo(e4, t2) {
  if (!e4) return e4;
  if (!t2) t2 = e4;
  var i2 = e4, s2;
  do {
    s2 = false;
    if (!i2.steiner && (ia(i2, i2.next) || ta(i2.prev, i2, i2.next) === 0)) {
      ha(i2);
      i2 = t2 = i2.prev;
      if (i2 === i2.next) return null;
      s2 = true;
    } else {
      i2 = i2.next;
    }
  } while (s2 || i2 !== t2);
  return t2;
}
function Ho(e4, t2, i2, s2, r2, n2, o2) {
  if (!e4) return;
  if (!o2 && n2) Xo(e4, s2, r2, n2);
  var a2 = e4, l2, h2;
  while (e4.prev !== e4.next) {
    l2 = e4.prev;
    h2 = e4.next;
    if (n2 ? Uo(e4, s2, r2, n2) : Vo(e4)) {
      t2.push(l2.i / i2);
      t2.push(e4.i / i2);
      t2.push(h2.i / i2);
      ha(e4);
      e4 = h2.next;
      a2 = h2.next;
      continue;
    }
    e4 = h2;
    if (e4 === a2) {
      if (!o2) {
        Ho(Oo(e4), t2, i2, s2, r2, n2, 1);
      } else if (o2 === 1) {
        e4 = Go(e4, t2, i2);
        Ho(e4, t2, i2, s2, r2, n2, 2);
      } else if (o2 === 2) {
        Wo(e4, t2, i2, s2, r2, n2);
      }
      break;
    }
  }
}
function Vo(e4) {
  var t2 = e4.prev, i2 = e4, s2 = e4.next;
  if (ta(t2, i2, s2) >= 0) return false;
  var r2 = e4.next.next;
  while (r2 !== e4.prev) {
    if (Jo(t2.x, t2.y, i2.x, i2.y, s2.x, s2.y, r2.x, r2.y) && ta(r2.prev, r2, r2.next) >= 0) return false;
    r2 = r2.next;
  }
  return true;
}
function Uo(e4, t2, i2, s2) {
  var r2 = e4.prev, n2 = e4, o2 = e4.next;
  if (ta(r2, n2, o2) >= 0) return false;
  var a2 = r2.x < n2.x ? r2.x < o2.x ? r2.x : o2.x : n2.x < o2.x ? n2.x : o2.x, l2 = r2.y < n2.y ? r2.y < o2.y ? r2.y : o2.y : n2.y < o2.y ? n2.y : o2.y, h2 = r2.x > n2.x ? r2.x > o2.x ? r2.x : o2.x : n2.x > o2.x ? n2.x : o2.x, c2 = r2.y > n2.y ? r2.y > o2.y ? r2.y : o2.y : n2.y > o2.y ? n2.y : o2.y;
  var d2 = Ko(a2, l2, t2, i2, s2), u2 = Ko(h2, c2, t2, i2, s2);
  var _2 = e4.nextZ;
  while (_2 && _2.z <= u2) {
    if (_2 !== e4.prev && _2 !== e4.next && Jo(r2.x, r2.y, n2.x, n2.y, o2.x, o2.y, _2.x, _2.y) && ta(_2.prev, _2, _2.next) >= 0) return false;
    _2 = _2.nextZ;
  }
  _2 = e4.prevZ;
  while (_2 && _2.z >= d2) {
    if (_2 !== e4.prev && _2 !== e4.next && Jo(r2.x, r2.y, n2.x, n2.y, o2.x, o2.y, _2.x, _2.y) && ta(_2.prev, _2, _2.next) >= 0) return false;
    _2 = _2.prevZ;
  }
  return true;
}
function Go(e4, t2, i2) {
  var s2 = e4;
  do {
    var r2 = s2.prev, n2 = s2.next.next;
    if (!ia(r2, n2) && sa(r2, s2, s2.next, n2) && na(r2, n2) && na(n2, r2)) {
      t2.push(r2.i / i2);
      t2.push(s2.i / i2);
      t2.push(n2.i / i2);
      ha(s2);
      ha(s2.next);
      s2 = e4 = n2;
    }
    s2 = s2.next;
  } while (s2 !== e4);
  return s2;
}
function Wo(e4, t2, i2, s2, r2, n2) {
  var o2 = e4;
  do {
    var a2 = o2.next.next;
    while (a2 !== o2.prev) {
      if (o2.i !== a2.i && ea(o2, a2)) {
        var l2 = aa(o2, a2);
        o2 = Oo(o2, o2.next);
        l2 = Oo(l2, l2.next);
        Ho(o2, t2, i2, s2, r2, n2);
        Ho(l2, t2, i2, s2, r2, n2);
        return;
      }
      a2 = a2.next;
    }
    o2 = o2.next;
  } while (o2 !== e4);
}
function jo(e4, t2, i2, s2) {
  var r2 = [], n2, o2, a2, l2, h2;
  for (n2 = 0, o2 = t2.length; n2 < o2; n2++) {
    a2 = t2[n2] * s2;
    l2 = n2 < o2 - 1 ? t2[n2 + 1] * s2 : e4.length;
    h2 = No(e4, a2, l2, s2, false);
    if (h2 === h2.next) h2.steiner = true;
    r2.push(Qo(h2));
  }
  r2.sort(Yo);
  for (n2 = 0; n2 < r2.length; n2++) {
    qo(r2[n2], i2);
    i2 = Oo(i2, i2.next);
  }
  return i2;
}
function Yo(e4, t2) {
  return e4.x - t2.x;
}
function qo(e4, t2) {
  t2 = $o(e4, t2);
  if (t2) {
    var i2 = aa(t2, e4);
    Oo(i2, i2.next);
  }
}
function $o(e4, t2) {
  var i2 = t2, s2 = e4.x, r2 = e4.y, n2 = -Infinity, o2;
  do {
    if (r2 <= i2.y && r2 >= i2.next.y && i2.next.y !== i2.y) {
      var a2 = i2.x + (r2 - i2.y) * (i2.next.x - i2.x) / (i2.next.y - i2.y);
      if (a2 <= s2 && a2 > n2) {
        n2 = a2;
        if (a2 === s2) {
          if (r2 === i2.y) return i2;
          if (r2 === i2.next.y) return i2.next;
        }
        o2 = i2.x < i2.next.x ? i2 : i2.next;
      }
    }
    i2 = i2.next;
  } while (i2 !== t2);
  if (!o2) return null;
  if (s2 === n2) return o2.prev;
  var l2 = o2, h2 = o2.x, c2 = o2.y, d2 = Infinity, u2;
  i2 = o2.next;
  while (i2 !== l2) {
    if (s2 >= i2.x && i2.x >= h2 && s2 !== i2.x && Jo(r2 < c2 ? s2 : n2, r2, h2, c2, r2 < c2 ? n2 : s2, r2, i2.x, i2.y)) {
      u2 = Math.abs(r2 - i2.y) / (s2 - i2.x);
      if ((u2 < d2 || u2 === d2 && i2.x > o2.x) && na(i2, e4)) {
        o2 = i2;
        d2 = u2;
      }
    }
    i2 = i2.next;
  }
  return o2;
}
function Xo(e4, t2, i2, s2) {
  var r2 = e4;
  do {
    if (r2.z === null) r2.z = Ko(r2.x, r2.y, t2, i2, s2);
    r2.prevZ = r2.prev;
    r2.nextZ = r2.next;
    r2 = r2.next;
  } while (r2 !== e4);
  r2.prevZ.nextZ = null;
  r2.prevZ = null;
  Zo(r2);
}
function Zo(e4) {
  var t2, i2, s2, r2, n2, o2, a2, l2, h2 = 1;
  do {
    i2 = e4;
    e4 = null;
    n2 = null;
    o2 = 0;
    while (i2) {
      o2++;
      s2 = i2;
      a2 = 0;
      for (t2 = 0; t2 < h2; t2++) {
        a2++;
        s2 = s2.nextZ;
        if (!s2) break;
      }
      l2 = h2;
      while (a2 > 0 || l2 > 0 && s2) {
        if (a2 !== 0 && (l2 === 0 || !s2 || i2.z <= s2.z)) {
          r2 = i2;
          i2 = i2.nextZ;
          a2--;
        } else {
          r2 = s2;
          s2 = s2.nextZ;
          l2--;
        }
        if (n2) n2.nextZ = r2;
        else e4 = r2;
        r2.prevZ = n2;
        n2 = r2;
      }
      i2 = s2;
    }
    n2.nextZ = null;
    h2 *= 2;
  } while (o2 > 1);
  return e4;
}
function Ko(e4, t2, i2, s2, r2) {
  e4 = 32767 * (e4 - i2) / r2;
  t2 = 32767 * (t2 - s2) / r2;
  e4 = (e4 | e4 << 8) & 16711935;
  e4 = (e4 | e4 << 4) & 252645135;
  e4 = (e4 | e4 << 2) & 858993459;
  e4 = (e4 | e4 << 1) & 1431655765;
  t2 = (t2 | t2 << 8) & 16711935;
  t2 = (t2 | t2 << 4) & 252645135;
  t2 = (t2 | t2 << 2) & 858993459;
  t2 = (t2 | t2 << 1) & 1431655765;
  return e4 | t2 << 1;
}
function Qo(e4) {
  var t2 = e4, i2 = e4;
  do {
    if (t2.x < i2.x) i2 = t2;
    t2 = t2.next;
  } while (t2 !== e4);
  return i2;
}
function Jo(e4, t2, i2, s2, r2, n2, o2, a2) {
  return (r2 - o2) * (t2 - a2) - (e4 - o2) * (n2 - a2) >= 0 && (e4 - o2) * (s2 - a2) - (i2 - o2) * (t2 - a2) >= 0 && (i2 - o2) * (n2 - a2) - (r2 - o2) * (s2 - a2) >= 0;
}
function ea(e4, t2) {
  return e4.next.i !== t2.i && e4.prev.i !== t2.i && !ra(e4, t2) && na(e4, t2) && na(t2, e4) && oa(e4, t2);
}
function ta(e4, t2, i2) {
  return (t2.y - e4.y) * (i2.x - t2.x) - (t2.x - e4.x) * (i2.y - t2.y);
}
function ia(e4, t2) {
  return e4.x === t2.x && e4.y === t2.y;
}
function sa(e4, t2, i2, s2) {
  if (ia(e4, t2) && ia(i2, s2) || ia(e4, s2) && ia(i2, t2)) return true;
  return ta(e4, t2, i2) > 0 !== ta(e4, t2, s2) > 0 && ta(i2, s2, e4) > 0 !== ta(i2, s2, t2) > 0;
}
function ra(e4, t2) {
  var i2 = e4;
  do {
    if (i2.i !== e4.i && i2.next.i !== e4.i && i2.i !== t2.i && i2.next.i !== t2.i && sa(i2, i2.next, e4, t2)) return true;
    i2 = i2.next;
  } while (i2 !== e4);
  return false;
}
function na(e4, t2) {
  return ta(e4.prev, e4, e4.next) < 0 ? ta(e4, t2, e4.next) >= 0 && ta(e4, e4.prev, t2) >= 0 : ta(e4, t2, e4.prev) < 0 || ta(e4, e4.next, t2) < 0;
}
function oa(e4, t2) {
  var i2 = e4, s2 = false, r2 = (e4.x + t2.x) / 2, n2 = (e4.y + t2.y) / 2;
  do {
    if (i2.y > n2 !== i2.next.y > n2 && i2.next.y !== i2.y && r2 < (i2.next.x - i2.x) * (n2 - i2.y) / (i2.next.y - i2.y) + i2.x) s2 = !s2;
    i2 = i2.next;
  } while (i2 !== e4);
  return s2;
}
function aa(e4, t2) {
  var i2 = new ca(e4.i, e4.x, e4.y), s2 = new ca(t2.i, t2.x, t2.y), r2 = e4.next, n2 = t2.prev;
  e4.next = t2;
  t2.prev = e4;
  i2.next = r2;
  r2.prev = i2;
  s2.next = i2;
  i2.prev = s2;
  n2.next = s2;
  s2.prev = n2;
  return s2;
}
function la(e4, t2, i2, s2) {
  var r2 = new ca(e4, t2, i2);
  if (!s2) {
    r2.prev = r2;
    r2.next = r2;
  } else {
    r2.next = s2.next;
    r2.prev = s2;
    s2.next.prev = r2;
    s2.next = r2;
  }
  return r2;
}
function ha(e4) {
  e4.next.prev = e4.prev;
  e4.prev.next = e4.next;
  if (e4.prevZ) e4.prevZ.nextZ = e4.nextZ;
  if (e4.nextZ) e4.nextZ.prevZ = e4.prevZ;
}
function ca(e4, t2, i2) {
  this.i = e4;
  this.x = t2;
  this.y = i2;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function da(e4, t2, i2, s2) {
  var r2 = 0;
  for (let n2 = t2, o2 = i2 - s2; n2 < i2; n2 += s2) {
    r2 += (e4[o2] - e4[n2]) * (e4[n2 + 1] + e4[o2 + 1]);
    o2 = n2;
  }
  return r2;
}
function ua(e4) {
  var t2 = e4[0][0].length, i2 = { vertices: [], holes: [], dimensions: t2 }, s2 = 0;
  for (let r2 = 0; r2 < e4.length; r2++) {
    for (let s3 = 0; s3 < e4[r2].length; s3++) {
      for (let n2 = 0; n2 < t2; n2++) i2.vertices.push(e4[r2][s3][n2]);
    }
    if (r2 > 0) {
      s2 += e4[r2 - 1].length;
      i2.holes.push(s2);
    }
  }
  return i2;
}
const _a = 0;
const fa = 1;
const ga = 2;
const pa = 3;
const ma = 4;
const va = 5;
const ya = 6;
const xa = 7;
const ba = 8;
const wa = 9;
const Ca = 10;
const Ta = 11;
function Ea(e4, t2, i2) {
  let s2 = e4[0], r2 = e4[1];
  if (s2 >= 0) {
    let e5 = Math.floor(s2 / 65536) * 65536;
    t2.x = Math.fround(e5);
    i2.x = Math.fround(s2 - e5);
  } else {
    let e5 = Math.floor(-s2 / 65536) * 65536;
    t2.x = Math.fround(-e5);
    i2.x = Math.fround(s2 + e5);
  }
  if (r2 >= 0) {
    let e5 = Math.floor(r2 / 65536) * 65536;
    t2.y = Math.fround(e5);
    i2.y = Math.fround(r2 - e5);
  } else {
    let e5 = Math.floor(-r2 / 65536) * 65536;
    t2.y = Math.fround(-e5);
    i2.y = Math.fround(r2 + e5);
  }
}
let Aa = new Qe(), La = new Qe(), Pa = new Qe();
const _Sa = class _Sa {
  constructor(e4) {
    this.__id = _Sa.__counter__++;
    this._layer = e4;
    this._handler = null;
    this._geometries = [];
    this._updatedGeometryArr = [];
    this._updatedGeometry = {};
    this._removeGeometryExtentArr = [];
    this._removeGeometryExtents = {};
    this._polyVerticesHighMerc = [];
    this._polyVerticesLowMerc = [];
    this._polyColors = [];
    this._polyPickingColors = [];
    this._polyIndexes = [];
    this._lineVerticesHighMerc = [];
    this._lineVerticesLowMerc = [];
    this._lineOrders = [];
    this._lineIndexes = [];
    this._lineColors = [];
    this._linePickingColors = [];
    this._lineThickness = [];
    this._lineStrokes = [];
    this._lineStrokeColors = [];
    this._polyVerticesHighBufferMerc = null;
    this._polyVerticesLowBufferMerc = null;
    this._polyColorsBuffer = null;
    this._polyPickingColorsBuffer = null;
    this._polyIndexesBuffer = null;
    this._lineVerticesHighBufferMerc = null;
    this._lineVerticesLowBufferMerc = null;
    this._lineColorsBuffer = null;
    this._linePickingColorsBuffer = null;
    this._lineThicknessBuffer = null;
    this._lineStrokesBuffer = null;
    this._lineStrokeColorsBuffer = null;
    this._lineOrdersBuffer = null;
    this._lineIndexesBuffer = null;
    this._buffersUpdateCallbacks = [];
    this._buffersUpdateCallbacks[_a] = this.createPolyVerticesBuffer;
    this._buffersUpdateCallbacks[fa] = this.createPolyIndexesBuffer;
    this._buffersUpdateCallbacks[ga] = this.createPolyColorsBuffer;
    this._buffersUpdateCallbacks[pa] = this.createLineVerticesBuffer;
    this._buffersUpdateCallbacks[ma] = this.createLineIndexesBuffer;
    this._buffersUpdateCallbacks[va] = this.createLineOrdersBuffer;
    this._buffersUpdateCallbacks[ya] = this.createLineColorsBuffer;
    this._buffersUpdateCallbacks[xa] = this.createLineThicknessBuffer;
    this._buffersUpdateCallbacks[ba] = this.createLineStrokesBuffer;
    this._buffersUpdateCallbacks[wa] = this.createLineStrokeColorsBuffer;
    this._buffersUpdateCallbacks[Ca] = this.createPolyPickingColorsBuffer;
    this._buffersUpdateCallbacks[Ta] = this.createLinePickingColorsBuffer;
    this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
  }
  static appendLineData(e4, t2, i2, s2, r2, n2, o2, a2, l2, h2, c2, d2, u2, _2, f2, g2, p2, m2) {
    var v2 = 0;
    if (c2.length > 0) {
      v2 = c2[c2.length - 5] + 9;
      c2.push(v2, v2);
    } else {
      c2.push(0, 0);
    }
    var y2 = r2, x2 = [i2.x, i2.y, i2.z, i2.w], b2 = o2, w2 = [n2.x, n2.y, n2.z, n2.w], C2 = [s2.x, s2.y, s2.z, 1];
    for (let i3 = 0; i3 < e4.length; i3++) {
      var T2 = e4[i3];
      if (T2.length === 0) {
        continue;
      }
      let s3 = v2;
      let r3;
      if (t2) {
        r3 = T2[T2.length - 1];
      } else {
        let e5 = T2[0], t3 = T2[1];
        if (!t3) {
          t3 = e5;
        }
        r3 = [e5[0] + e5[0] - t3[0], e5[1] + e5[1] - t3[1]];
      }
      Ea(r3, Aa, La);
      a2.push(Aa.x, Aa.y, Aa.x, Aa.y, Aa.x, Aa.y, Aa.x, Aa.y);
      l2.push(La.x, La.y, La.x, La.y, La.x, La.y, La.x, La.y);
      p2.push(Aa.x, Aa.y, Aa.x, Aa.y, Aa.x, Aa.y, Aa.x, Aa.y);
      m2.push(La.x, La.y, La.x, La.y, La.x, La.y, La.x, La.y);
      h2.push(1, -1, 2, -2);
      _2.push(y2, y2, y2, y2);
      g2.push(b2, b2, b2, b2);
      d2.push(x2[0], x2[1], x2[2], x2[3], x2[0], x2[1], x2[2], x2[3], x2[0], x2[1], x2[2], x2[3], x2[0], x2[1], x2[2], x2[3]);
      f2.push(w2[0], w2[1], w2[2], w2[3], w2[0], w2[1], w2[2], w2[3], w2[0], w2[1], w2[2], w2[3], w2[0], w2[1], w2[2], w2[3]);
      u2.push(C2[0], C2[1], C2[2], C2[3], C2[0], C2[1], C2[2], C2[3], C2[0], C2[1], C2[2], C2[3], C2[0], C2[1], C2[2], C2[3]);
      for (let e5 = 0; e5 < T2.length; e5++) {
        let t3 = T2[e5];
        Ea(t3, Aa, La);
        a2.push(Aa.x, Aa.y, Aa.x, Aa.y, Aa.x, Aa.y, Aa.x, Aa.y);
        l2.push(La.x, La.y, La.x, La.y, La.x, La.y, La.x, La.y);
        p2.push(Aa.x, Aa.y, Aa.x, Aa.y, Aa.x, Aa.y, Aa.x, Aa.y);
        m2.push(La.x, La.y, La.x, La.y, La.x, La.y, La.x, La.y);
        h2.push(1, -1, 2, -2);
        _2.push(y2, y2, y2, y2);
        g2.push(b2, b2, b2, b2);
        d2.push(x2[0], x2[1], x2[2], x2[3], x2[0], x2[1], x2[2], x2[3], x2[0], x2[1], x2[2], x2[3], x2[0], x2[1], x2[2], x2[3]);
        f2.push(w2[0], w2[1], w2[2], w2[3], w2[0], w2[1], w2[2], w2[3], w2[0], w2[1], w2[2], w2[3], w2[0], w2[1], w2[2], w2[3]);
        u2.push(C2[0], C2[1], C2[2], C2[3], C2[0], C2[1], C2[2], C2[3], C2[0], C2[1], C2[2], C2[3], C2[0], C2[1], C2[2], C2[3]);
        c2.push(v2++, v2++, v2++, v2++);
      }
      let n3;
      if (t2) {
        n3 = T2[0];
        c2.push(s3, s3 + 1, s3 + 1, s3 + 1);
      } else {
        let e5 = T2[T2.length - 1], t3 = T2[T2.length - 2];
        if (!t3) {
          t3 = e5;
        }
        n3 = [e5[0] + e5[0] - t3[0], e5[1] + e5[1] - t3[1]];
        c2.push(v2 - 1, v2 - 1, v2 - 1, v2 - 1);
      }
      Ea(n3, Aa, La);
      a2.push(Aa.x, Aa.y, Aa.x, Aa.y, Aa.x, Aa.y, Aa.x, Aa.y);
      l2.push(La.x, La.y, La.x, La.y, La.x, La.y, La.x, La.y);
      p2.push(Aa.x, Aa.y, Aa.x, Aa.y, Aa.x, Aa.y, Aa.x, Aa.y);
      m2.push(La.x, La.y, La.x, La.y, La.x, La.y, La.x, La.y);
      h2.push(1, -1, 2, -2);
      _2.push(y2, y2, y2, y2);
      g2.push(b2, b2, b2, b2);
      d2.push(x2[0], x2[1], x2[2], x2[3], x2[0], x2[1], x2[2], x2[3], x2[0], x2[1], x2[2], x2[3], x2[0], x2[1], x2[2], x2[3]);
      f2.push(w2[0], w2[1], w2[2], w2[3], w2[0], w2[1], w2[2], w2[3], w2[0], w2[1], w2[2], w2[3], w2[0], w2[1], w2[2], w2[3]);
      u2.push(C2[0], C2[1], C2[2], C2[3], C2[0], C2[1], C2[2], C2[3], C2[0], C2[1], C2[2], C2[3], C2[0], C2[1], C2[2], C2[3]);
      if (i3 < e4.length - 1) {
        v2 += 8;
        c2.push(v2, v2);
      }
    }
  }
  assignHandler(e4) {
    this._handler = e4;
    this.refresh();
    if (e4.isInitialized()) {
      this.update();
    }
  }
  add(e4) {
    if (e4._handlerIndex === -1) {
      e4._handler = this;
      e4._handlerIndex = this._geometries.length;
      this._geometries.push(e4);
      let t2 = e4._entity._pickingColor.scaleTo(1 / 255);
      e4._polyVerticesHighMerc = [];
      e4._polyVerticesLowMerc = [];
      e4._lineVerticesHighMerc = [];
      e4._lineVerticesLowMerc = [];
      if (e4._coordinates[0].length) {
        if (e4.type === Qs.POLYGON) {
          let i2 = e4._coordinates;
          let s2 = [];
          for (let e5 = 0; e5 < i2.length; e5++) {
            s2[e5] = [];
            for (let t3 = 0; t3 < i2[e5].length; t3++) {
              s2[e5][t3] = [ze(i2[e5][t3][0]), De(i2[e5][t3][1])];
            }
          }
          let r2 = ua(s2);
          let n2 = Fo(r2.vertices, r2.holes, 2);
          e4._polyVerticesHandlerIndex = this._polyVerticesHighMerc.length;
          e4._polyIndexesHandlerIndex = this._polyIndexes.length;
          for (let t3 = 0; t3 < n2.length; t3++) {
            this._polyIndexes.push(n2[t3] + e4._polyVerticesHandlerIndex * 0.5);
          }
          let o2 = e4._style.fillColor;
          let a2 = [], l2 = [];
          for (let e5 = 0; e5 < r2.vertices.length * 0.5; e5++) {
            this._polyColors.push(o2.x, o2.y, o2.z, o2.w);
            this._polyPickingColors.push(t2.x, t2.y, t2.z, 1);
          }
          for (let e5 = 0; e5 < r2.vertices.length; e5++) {
            Do(r2.vertices[e5], Pa);
            a2[e5] = Pa.x;
            l2[e5] = Pa.y;
          }
          e4._polyVerticesHighMerc = a2;
          e4._polyVerticesLowMerc = l2;
          this._polyVerticesHighMerc.push.apply(this._polyVerticesHighMerc, a2);
          this._polyVerticesLowMerc.push.apply(this._polyVerticesLowMerc, l2);
          e4._polyVerticesLength = r2.vertices.length;
          e4._polyIndexesLength = n2.length;
          e4._lineVerticesHandlerIndex = this._lineVerticesHighMerc.length;
          e4._lineOrdersHandlerIndex = this._lineOrders.length;
          e4._lineIndexesHandlerIndex = this._lineIndexes.length;
          e4._lineColorsHandlerIndex = this._lineColors.length;
          e4._lineThicknessHandlerIndex = this._lineThickness.length;
          _Sa.appendLineData(s2, true, e4._style.lineColor, t2, e4._style.lineWidth, e4._style.strokeColor, e4._style.strokeWidth, this._lineVerticesHighMerc, this._lineVerticesLowMerc, this._lineOrders, this._lineIndexes, this._lineColors, this._linePickingColors, this._lineThickness, this._lineStrokeColors, this._lineStrokes, e4._lineVerticesHighMerc, e4._lineVerticesLowMerc);
          e4._lineVerticesLength = this._lineVerticesHighMerc.length - e4._lineVerticesHandlerIndex;
          e4._lineOrdersLength = this._lineOrders.length - e4._lineOrdersHandlerIndex;
          e4._lineIndexesLength = this._lineIndexes.length - e4._lineIndexesHandlerIndex;
          e4._lineColorsLength = this._lineColors.length - e4._lineColorsHandlerIndex;
          e4._lineThicknessLength = this._lineThickness.length - e4._lineThicknessHandlerIndex;
        } else if (e4.type === Qs.MULTIPOLYGON) {
          let i2 = e4._coordinates;
          let s2 = [], r2 = [];
          e4._lineVerticesHandlerIndex = this._lineVerticesHighMerc.length;
          e4._lineOrdersHandlerIndex = this._lineOrders.length;
          e4._lineIndexesHandlerIndex = this._lineIndexes.length;
          e4._lineColorsHandlerIndex = this._lineColors.length;
          e4._lineThicknessHandlerIndex = this._lineThickness.length;
          for (let n3 = 0; n3 < i2.length; n3++) {
            let o3 = i2[n3];
            let a3 = [];
            for (let e5 = 0; e5 < o3.length; e5++) {
              a3[e5] = [];
              for (let t3 = 0; t3 < i2[n3][e5].length; t3++) {
                a3[e5][t3] = [ze(o3[e5][t3][0]), De(o3[e5][t3][1])];
              }
            }
            let l2 = ua(a3);
            let h2 = Fo(l2.vertices, l2.holes, 2);
            for (let e5 = 0; e5 < h2.length; e5++) {
              r2.push(h2[e5] + s2.length * 0.5);
            }
            s2.push.apply(s2, l2.vertices);
            _Sa.appendLineData(a3, true, e4._style.lineColor, t2, e4._style.lineWidth, e4._style.strokeColor, e4._style.strokeWidth, this._lineVerticesHighMerc, this._lineVerticesLowMerc, this._lineOrders, this._lineIndexes, this._lineColors, this._linePickingColors, this._lineThickness, this._lineStrokeColors, this._lineStrokes, e4._lineVerticesHighMerc, e4._lineVerticesLowMerc);
          }
          e4._polyVerticesHandlerIndex = this._polyVerticesHighMerc.length;
          e4._polyIndexesHandlerIndex = this._polyIndexes.length;
          for (let t3 = 0; t3 < r2.length; t3++) {
            this._polyIndexes.push(r2[t3] + e4._polyVerticesHandlerIndex * 0.5);
          }
          let n2 = e4._style.fillColor;
          let o2 = [], a2 = [];
          for (let e5 = 0; e5 < s2.length * 0.5; e5++) {
            this._polyColors.push(n2.x, n2.y, n2.z, n2.w);
            this._polyPickingColors.push(t2.x, t2.y, t2.z, 1);
          }
          for (let e5 = 0; e5 < s2.length; e5++) {
            Do(s2[e5], Pa);
            o2[e5] = Pa.x;
            a2[e5] = Pa.y;
          }
          e4._polyVerticesHighMerc = o2;
          e4._polyVerticesLowMerc = a2;
          this._polyVerticesHighMerc.push.apply(this._polyVerticesHighMerc, o2);
          this._polyVerticesLowMerc.push.apply(this._polyVerticesLowMerc, a2);
          e4._polyVerticesLength = s2.length;
          e4._polyIndexesLength = r2.length;
          e4._lineVerticesLength = this._lineVerticesHighMerc.length - e4._lineVerticesHandlerIndex;
          e4._lineOrdersLength = this._lineOrders.length - e4._lineOrdersHandlerIndex;
          e4._lineIndexesLength = this._lineIndexes.length - e4._lineIndexesHandlerIndex;
          e4._lineColorsLength = this._lineColors.length - e4._lineColorsHandlerIndex;
          e4._lineThicknessLength = this._lineThickness.length - e4._lineThicknessHandlerIndex;
        } else if (e4.type === Qs.LINESTRING) {
          let i2 = e4._coordinates;
          let s2 = new Array(i2.length);
          for (let e5 = 0; e5 < i2.length; e5++) {
            s2[e5] = [ze(i2[e5][0]), De(i2[e5][1])];
          }
          e4._lineVerticesHandlerIndex = this._lineVerticesHighMerc.length;
          e4._lineOrdersHandlerIndex = this._lineOrders.length;
          e4._lineIndexesHandlerIndex = this._lineIndexes.length;
          e4._lineColorsHandlerIndex = this._lineColors.length;
          e4._lineThicknessHandlerIndex = this._lineThickness.length;
          _Sa.appendLineData([s2], false, e4._style.lineColor, t2, e4._style.lineWidth, e4._style.strokeColor, e4._style.strokeWidth, this._lineVerticesHighMerc, this._lineVerticesLowMerc, this._lineOrders, this._lineIndexes, this._lineColors, this._linePickingColors, this._lineThickness, this._lineStrokeColors, this._lineStrokes, e4._lineVerticesHighMerc, e4._lineVerticesLowMerc);
          e4._lineVerticesLength = this._lineVerticesHighMerc.length - e4._lineVerticesHandlerIndex;
          e4._lineOrdersLength = this._lineOrders.length - e4._lineOrdersHandlerIndex;
          e4._lineIndexesLength = this._lineIndexes.length - e4._lineIndexesHandlerIndex;
          e4._lineColorsLength = this._lineColors.length - e4._lineColorsHandlerIndex;
          e4._lineThicknessLength = this._lineThickness.length - e4._lineThicknessHandlerIndex;
        } else if (e4.type === Qs.MULTILINESTRING) {
          let i2 = e4._coordinates;
          let s2 = [];
          for (let e5 = 0; e5 < i2.length; e5++) {
            s2[e5] = [];
            for (let t3 = 0; t3 < i2[e5].length; t3++) {
              s2[e5][t3] = [ze(i2[e5][t3][0]), De(i2[e5][t3][1])];
            }
          }
          e4._lineVerticesHandlerIndex = this._lineVerticesHighMerc.length;
          e4._lineOrdersHandlerIndex = this._lineOrders.length;
          e4._lineIndexesHandlerIndex = this._lineIndexes.length;
          e4._lineColorsHandlerIndex = this._lineColors.length;
          e4._lineThicknessHandlerIndex = this._lineThickness.length;
          _Sa.appendLineData(s2, false, e4._style.lineColor, t2, e4._style.lineWidth, e4._style.strokeColor, e4._style.strokeWidth, this._lineVerticesHighMerc, this._lineVerticesLowMerc, this._lineOrders, this._lineIndexes, this._lineColors, this._linePickingColors, this._lineThickness, this._lineStrokeColors, this._lineStrokes, e4._lineVerticesHighMerc, e4._lineVerticesLowMerc);
          e4._lineVerticesLength = this._lineVerticesHighMerc.length - e4._lineVerticesHandlerIndex;
          e4._lineOrdersLength = this._lineOrders.length - e4._lineOrdersHandlerIndex;
          e4._lineIndexesLength = this._lineIndexes.length - e4._lineIndexesHandlerIndex;
          e4._lineColorsLength = this._lineColors.length - e4._lineColorsHandlerIndex;
          e4._lineThicknessLength = this._lineThickness.length - e4._lineThicknessHandlerIndex;
        }
      }
      this.setGeometryVisibility(e4);
      !this._updatedGeometry[e4.__id] && this._updatedGeometryArr.push(e4);
      this._updatedGeometry[e4.__id] = true;
      this.refresh();
    }
  }
  remove(e4) {
    const t2 = e4._handlerIndex;
    if (t2 !== -1) {
      this._geometries.splice(t2, 1);
      this._polyVerticesHighMerc.splice(e4._polyVerticesHandlerIndex, e4._polyVerticesLength);
      this._polyVerticesLowMerc.splice(e4._polyVerticesHandlerIndex, e4._polyVerticesLength);
      this._polyColors.splice(e4._polyVerticesHandlerIndex * 2, e4._polyVerticesLength * 2);
      this._polyPickingColors.splice(e4._polyVerticesHandlerIndex * 2, e4._polyVerticesLength * 2);
      this._polyIndexes.splice(e4._polyIndexesHandlerIndex, e4._polyIndexesLength);
      let i2 = e4._polyVerticesLength * 0.5;
      for (let t3 = e4._polyIndexesHandlerIndex; t3 < this._polyIndexes.length; t3++) {
        this._polyIndexes[t3] -= i2;
      }
      this._lineVerticesHighMerc.splice(e4._lineVerticesHandlerIndex, e4._lineVerticesLength);
      this._lineVerticesLowMerc.splice(e4._lineVerticesHandlerIndex, e4._lineVerticesLength);
      this._lineOrders.splice(e4._lineOrdersHandlerIndex, e4._lineOrdersLength);
      this._lineColors.splice(e4._lineColorsHandlerIndex, e4._lineColorsLength);
      this._linePickingColors.splice(e4._lineColorsHandlerIndex, e4._lineColorsLength);
      this._lineStrokeColors.splice(e4._lineColorsHandlerIndex, e4._lineColorsLength);
      this._lineThickness.splice(e4._lineThicknessHandlerIndex, e4._lineThicknessLength);
      this._lineStrokes.splice(e4._lineThicknessHandlerIndex, e4._lineThicknessLength);
      this._lineIndexes.splice(e4._lineIndexesHandlerIndex, e4._lineIndexesLength);
      i2 = e4._lineVerticesLength * 0.5;
      for (let t3 = e4._lineIndexesHandlerIndex; t3 < this._lineIndexes.length; t3++) {
        this._lineIndexes[t3] -= i2;
      }
      let s2 = this._geometries;
      for (let i3 = t2; i3 < s2.length; i3++) {
        let t3 = s2[i3];
        t3._handlerIndex = i3;
        t3._polyVerticesHandlerIndex -= e4._polyVerticesLength;
        t3._polyIndexesHandlerIndex -= e4._polyIndexesLength;
        t3._lineVerticesHandlerIndex -= e4._lineVerticesLength;
        t3._lineOrdersHandlerIndex -= e4._lineOrdersLength;
        t3._lineColorsHandlerIndex -= e4._lineColorsLength;
        t3._lineThicknessHandlerIndex -= e4._lineThicknessLength;
        t3._lineIndexesHandlerIndex -= e4._lineIndexesLength;
      }
      e4._pickingReady = false;
      e4._handler = null;
      e4._handlerIndex = -1;
      e4._polyVerticesHighMerc = [];
      e4._polyVerticesLowMerc = [];
      e4._polyVerticesLength = -1;
      e4._polyIndexesLength = -1;
      e4._polyVerticesHandlerIndex = -1;
      e4._polyIndexesHandlerIndex = -1;
      e4._lineVerticesHighMerc = [];
      e4._lineVerticesLowMerc = [];
      e4._lineVerticesLength = -1;
      e4._lineOrdersLength = -1;
      e4._lineIndexesLength = -1;
      e4._lineColorsLength = -1;
      e4._lineThicknessLength = -1;
      e4._lineVerticesHandlerIndex = -1;
      e4._lineOrdersHandlerIndex = -1;
      e4._lineIndexesHandlerIndex = -1;
      e4._lineThicknessHandlerIndex = -1;
      e4._lineColorsHandlerIndex = -1;
      !this._removeGeometryExtents[e4.__id] && this._removeGeometryExtentArr.push(e4.getExtent());
      this._removeGeometryExtents[e4.__id] = true;
      this.refresh();
    }
  }
  _refreshRecursevely(e4, t2) {
    if (t2.ready) {
      let i2 = this._layer._id;
      for (let s2 = 0; s2 < t2.nodes.length; s2++) {
        let r2 = t2.nodes[s2];
        if (e4.overlaps(r2.segment.getExtentLonLat())) {
          this._refreshRecursevely(e4, r2);
          let t3 = r2.segment.materials[i2];
          if (t3 && t3.isReady) {
            if (t3.segment.node.getState() !== Es) {
              t3.layer.clearMaterial(t3);
            } else {
              t3.pickingReady = t3.pickingReady && e4._pickingReady;
              t3.isReady = false;
              t3._updateTexture = t3.texture;
              t3._updatePickingMask = t3.pickingMask;
            }
            e4._pickingReady = true;
          }
        }
      }
    }
  }
  _refreshRecursevelyExt(e4, t2) {
    if (t2.ready) {
      let i2 = this._layer.__id;
      for (let s2 = 0; s2 < t2.nodes.length; s2++) {
        let r2 = t2.nodes[s2];
        if (e4.overlaps(r2.segment.getExtentLonLat())) {
          this._refreshRecursevelyExt(e4, r2);
          let t3 = r2.segment.materials[i2];
          if (t3 && t3.isReady) {
            t3.layer.clearMaterial(t3);
          }
        }
      }
    }
  }
  _refreshPlanetNode(e4) {
    let t2;
    let i2 = this._removeGeometryExtentArr;
    for (t2 = 0; t2 < i2.length; t2++) {
      this._refreshRecursevelyExt(i2[t2], e4);
    }
    let s2 = this._updatedGeometryArr;
    for (t2 = 0; t2 < s2.length; t2++) {
      this._refreshRecursevely(s2[t2], e4);
    }
  }
  _updatePlanet() {
    let e4 = this._layer._planet;
    if (e4) {
      let t2 = e4.quadTreeStrategy.quadTreeList;
      for (let e5 = 0; e5 < t2.length; e5++) {
        this._refreshPlanetNode(t2[e5]);
      }
    }
    this._updatedGeometryArr.length = 0;
    this._updatedGeometryArr = [];
    this._updatedGeometry = {};
    this._removeGeometryExtentArr.length = 0;
    this._removeGeometryExtentArr = [];
    this._removeGeometryExtents = {};
  }
  refresh() {
    let e4 = this._changedBuffers.length;
    while (e4--) {
      this._changedBuffers[e4] = true;
    }
  }
  update() {
    if (this._handler) {
      let e4 = false;
      let t2 = this._changedBuffers.length;
      while (t2--) {
        if (this._changedBuffers[t2]) {
          e4 = true;
          this._buffersUpdateCallbacks[t2].call(this);
          this._changedBuffers[t2] = false;
        }
      }
      e4 && this._updatePlanet();
    }
  }
  setGeometryVisibility(e4) {
    let t2 = e4.getVisibility() ? 1 : 0;
    let i2 = this._polyVerticesHighMerc, s2 = this._polyVerticesLowMerc;
    let r2 = e4._polyVerticesLength;
    let n2 = e4._polyVerticesHandlerIndex;
    for (let o2 = 0; o2 < r2; o2++) {
      i2[n2 + o2] = e4._polyVerticesHighMerc[o2] * t2;
      s2[n2 + o2] = e4._polyVerticesLowMerc[o2] * t2;
    }
    i2 = this._lineVerticesHighMerc;
    s2 = this._lineVerticesLowMerc;
    r2 = e4._lineVerticesLength;
    n2 = e4._lineVerticesHandlerIndex;
    for (let o2 = 0; o2 < r2; o2++) {
      i2[n2 + o2] = e4._lineVerticesHighMerc[o2] * t2;
      s2[n2 + o2] = e4._lineVerticesLowMerc[o2] * t2;
    }
    this._changedBuffers[_a] = true;
    this._changedBuffers[pa] = true;
    !this._updatedGeometry[e4.__id] && this._updatedGeometryArr.push(e4);
    this._updatedGeometry[e4.__id] = true;
  }
  setPolyColorArr(e4, t2) {
    let i2 = e4._polyVerticesHandlerIndex * 2, s2 = i2 + e4._polyVerticesLength * 2;
    let r2 = this._polyColors;
    for (let e5 = i2; e5 < s2; e5 += 4) {
      r2[e5] = t2.x;
      r2[e5 + 1] = t2.y;
      r2[e5 + 2] = t2.z;
      r2[e5 + 3] = t2.w;
    }
    this._changedBuffers[ga] = true;
    !this._updatedGeometry[e4.__id] && this._updatedGeometryArr.push(e4);
    this._updatedGeometry[e4.__id] = true;
  }
  setLineStrokeColorArr(e4, t2) {
    let i2 = e4._lineColorsHandlerIndex, s2 = i2 + e4._lineColorsLength;
    let r2 = this._lineStrokeColors;
    for (let e5 = i2; e5 < s2; e5 += 4) {
      r2[e5] = t2.x;
      r2[e5 + 1] = t2.y;
      r2[e5 + 2] = t2.z;
      r2[e5 + 3] = t2.w;
    }
    this._changedBuffers[wa] = true;
    !this._updatedGeometry[e4.__id] && this._updatedGeometryArr.push(e4);
    this._updatedGeometry[e4.__id] = true;
  }
  setLineColorArr(e4, t2) {
    let i2 = e4._lineColorsHandlerIndex, s2 = i2 + e4._lineColorsLength;
    let r2 = this._lineColors;
    for (let e5 = i2; e5 < s2; e5 += 4) {
      r2[e5] = t2.x;
      r2[e5 + 1] = t2.y;
      r2[e5 + 2] = t2.z;
      r2[e5 + 3] = t2.w;
    }
    this._changedBuffers[ya] = true;
    !this._updatedGeometry[e4.__id] && this._updatedGeometryArr.push(e4);
    this._updatedGeometry[e4.__id] = true;
  }
  setLineStrokeArr(e4, t2) {
  }
  setLineThicknessArr(e4, t2) {
    let i2 = e4._lineThicknessHandlerIndex, s2 = i2 + e4._lineThicknessLength;
    let r2 = this._lineThickness;
    for (let e5 = i2; e5 < s2; e5++) {
      r2[e5] = t2;
    }
    this._changedBuffers[xa] = true;
    !this._updatedGeometry[e4.__id] && this._updatedGeometryArr.push(e4);
    this._updatedGeometry[e4.__id] = true;
  }
  bringToFront(e4) {
    let t2 = this._polyIndexes.splice(e4._polyIndexesHandlerIndex, e4._polyIndexesLength);
    let i2 = this._lineIndexes.splice(e4._lineIndexesHandlerIndex, e4._lineIndexesLength);
    this._geometries.splice(e4._handlerIndex, 1);
    let s2 = this._geometries;
    for (let t3 = e4._handlerIndex; t3 < s2.length; t3++) {
      let i3 = s2[t3];
      i3._handlerIndex = t3;
      i3._polyIndexesHandlerIndex -= e4._polyIndexesLength;
      i3._lineIndexesHandlerIndex -= e4._lineIndexesLength;
    }
    e4._polyIndexesHandlerIndex = this._polyIndexes.length;
    e4._lineIndexesHandlerIndex = this._lineIndexes.length;
    e4._handlerIndex = this._geometries.length;
    this._geometries.push(e4);
    this._polyIndexes.push.apply(this._polyIndexes, t2);
    this._lineIndexes.push.apply(this._lineIndexes, i2);
    this._changedBuffers[fa] = true;
    this._changedBuffers[ma] = true;
    !this._updatedGeometry[e4.__id] && this._updatedGeometryArr.push(e4);
    this._updatedGeometry[e4.__id] = true;
  }
  createPolyVerticesBuffer() {
    let e4 = this._handler;
    e4.gl.deleteBuffer(this._polyVerticesHighBufferMerc);
    this._polyVerticesHighBufferMerc = e4.createArrayBuffer(new Float32Array(this._polyVerticesHighMerc), 2, this._polyVerticesHighMerc.length / 2);
    e4.gl.deleteBuffer(this._polyVerticesLowBufferMerc);
    this._polyVerticesLowBufferMerc = e4.createArrayBuffer(new Float32Array(this._polyVerticesLowMerc), 2, this._polyVerticesLowMerc.length / 2);
  }
  createPolyIndexesBuffer() {
    let e4 = this._handler;
    e4.gl.deleteBuffer(this._polyIndexesBuffer);
    this._polyIndexesBuffer = e4.createElementArrayBuffer(new Uint32Array(this._polyIndexes), 1, this._polyIndexes.length);
  }
  createPolyColorsBuffer() {
    let e4 = this._handler;
    e4.gl.deleteBuffer(this._polyColorsBuffer);
    this._polyColorsBuffer = e4.createArrayBuffer(new Float32Array(this._polyColors), 4, this._polyColors.length / 4);
  }
  createPolyPickingColorsBuffer() {
    let e4 = this._handler;
    e4.gl.deleteBuffer(this._polyPickingColorsBuffer);
    this._polyPickingColorsBuffer = e4.createArrayBuffer(new Float32Array(this._polyPickingColors), 4, this._polyPickingColors.length / 4);
  }
  createLineVerticesBuffer() {
    let e4 = this._handler;
    e4.gl.deleteBuffer(this._lineVerticesHighBufferMerc);
    this._lineVerticesHighBufferMerc = e4.createArrayBuffer(new Float32Array(this._lineVerticesHighMerc), 2, this._lineVerticesHighMerc.length / 2);
    e4.gl.deleteBuffer(this._lineVerticesLowBufferMerc);
    this._lineVerticesLowBufferMerc = e4.createArrayBuffer(new Float32Array(this._lineVerticesLowMerc), 2, this._lineVerticesLowMerc.length / 2);
  }
  createLineIndexesBuffer() {
    let e4 = this._handler;
    e4.gl.deleteBuffer(this._lineIndexesBuffer);
    this._lineIndexesBuffer = e4.createElementArrayBuffer(new Uint32Array(this._lineIndexes), 1, this._lineIndexes.length);
  }
  createLineOrdersBuffer() {
    let e4 = this._handler;
    e4.gl.deleteBuffer(this._lineOrdersBuffer);
    this._lineOrdersBuffer = e4.createArrayBuffer(new Float32Array(this._lineOrders), 1, this._lineOrders.length / 2);
  }
  createLineColorsBuffer() {
    let e4 = this._handler;
    e4.gl.deleteBuffer(this._lineColorsBuffer);
    this._lineColorsBuffer = e4.createArrayBuffer(new Float32Array(this._lineColors), 4, this._lineColors.length / 4);
  }
  createLinePickingColorsBuffer() {
    let e4 = this._handler;
    e4.gl.deleteBuffer(this._linePickingColorsBuffer);
    this._linePickingColorsBuffer = e4.createArrayBuffer(new Float32Array(this._linePickingColors), 4, this._linePickingColors.length / 4);
  }
  createLineThicknessBuffer() {
    let e4 = this._handler;
    e4.gl.deleteBuffer(this._lineThicknessBuffer);
    this._lineThicknessBuffer = e4.createArrayBuffer(new Float32Array(this._lineThickness), 1, this._lineThickness.length);
  }
  createLineStrokesBuffer() {
    let e4 = this._handler;
    e4.gl.deleteBuffer(this._lineStrokesBuffer);
    this._lineStrokesBuffer = e4.createArrayBuffer(new Float32Array(this._lineStrokes), 1, this._lineStrokes.length);
  }
  createLineStrokeColorsBuffer() {
    let e4 = this._handler;
    e4.gl.deleteBuffer(this._lineStrokeColorsBuffer);
    this._lineStrokeColorsBuffer = e4.createArrayBuffer(new Float32Array(this._lineStrokeColors), 4, this._lineStrokeColors.length / 4);
  }
  clear() {
    this._geometries = [];
    this._polyVerticesHighMerc = [];
    this._polyVerticesLowMerc = [];
    this._polyIndexes = [];
    this._polyColors = [];
    this._polyPickingColors = [];
    this._lineVerticesHighMerc = [];
    this._lineVerticesLowMerc = [];
    this._lineOrders = [];
    this._lineIndexes = [];
    this._lineColors = [];
    this._linePickingColors = [];
    this._lineThickness = [];
    this._lineStrokeColors = [];
    this._lineStrokes = [];
    this._deleteBuffers();
    this._polyVerticesHighBufferMerc = null;
    this._polyVerticesLowBufferMerc = null;
    this._polyIndexesBuffer = null;
    this._polyColorsBuffer = null;
    this._polyPickingColorsBuffer = null;
    this._lineVerticesHighBufferMerc = null;
    this._lineVerticesLowBufferMerc = null;
    this._lineIndexesBuffer = null;
    this._lineOrdersBuffer = null;
    this._lineColorsBuffer = null;
    this._linePickingColorsBuffer = null;
    this._lineThicknessBuffer = null;
    this._lineStrokeColorsBuffer = null;
    this._lineStrokesBuffer = null;
    this._updatedGeometryArr = [];
    this._updatedGeometry = {};
    this._removeGeometryExtentArr = [];
    this._removeGeometryExtents = {};
    this.refresh();
  }
  _deleteBuffers() {
    if (this._layer._planet && this._layer._planet.renderer) {
      let e4 = this._layer._planet.renderer.handler, t2 = e4.gl;
      if (t2) {
        t2.deleteBuffer(this._polyVerticesHighBufferMerc);
        t2.deleteBuffer(this._polyVerticesLowBufferMerc);
        t2.deleteBuffer(this._polyIndexesBuffer);
        t2.deleteBuffer(this._polyColorsBuffer);
        t2.deleteBuffer(this._polyPickingColorsBuffer);
        t2.deleteBuffer(this._lineVerticesHighBufferMerc);
        t2.deleteBuffer(this._lineVerticesLowBufferMerc);
        t2.deleteBuffer(this._lineIndexesBuffer);
        t2.deleteBuffer(this._lineOrdersBuffer);
        t2.deleteBuffer(this._lineColorsBuffer);
        t2.deleteBuffer(this._linePickingColorsBuffer);
        t2.deleteBuffer(this._lineThicknessBuffer);
        t2.deleteBuffer(this._lineStrokeColorsBuffer);
        t2.deleteBuffer(this._lineStrokesBuffer);
      }
    }
  }
};
_Sa.__counter__ = 0;
let Sa = _Sa;
function Ra(e4) {
  let t2 = [];
  for (let i2 = 0; i2 < e4.length; i2++) {
    let s2 = e4[i2];
    if (s2.instanceName === "Entity") {
      t2.push(s2);
    } else {
      t2.push(new zr(s2));
    }
  }
  return t2;
}
class Ma extends ks {
  constructor(e4, t2 = {}) {
    super(e4, t2);
    this.events = this.events.registerNames(Ba);
    this.isVector = true;
    this._hasImageryTiles = false;
    this.scaleByDistance = t2.scaleByDistance || [l, l, l];
    this._useLighting = t2.useLighting !== void 0 ? t2.useLighting : true;
    let i2 = new Float32Array([1, 1, 1]);
    if (t2.pickingScale !== void 0) {
      if (t2.pickingScale instanceof Array) {
        i2[0] = t2.pickingScale[0] || i2[0];
        i2[1] = t2.pickingScale[1] || i2[1];
        i2[2] = t2.pickingScale[2] || i2[2];
      } else if (typeof t2.pickingScale === "number") {
        i2[0] = t2.pickingScale;
        i2[1] = t2.pickingScale;
        i2[2] = t2.pickingScale;
      }
    }
    this.pickingScale = i2;
    this.async = t2.async !== void 0 ? t2.async : true;
    this.clampToGround = t2.clampToGround || false;
    this.relativeToGround = t2.relativeToGround || false;
    this._entities = Ra(t2.entities || []);
    this._labelMaxLetters = t2.labelMaxLetters || 24;
    this._stripEntityCollection = new ko({ pickingEnabled: this.pickingEnabled });
    this._bindEventsDefault(this._stripEntityCollection);
    this._polylineEntityCollection = new ko({ pickingEnabled: this.pickingEnabled });
    this._bindEventsDefault(this._polylineEntityCollection);
    this._geoObjectEntityCollection = new ko({ pickingEnabled: this.pickingEnabled, useLighting: this._useLighting });
    this._bindEventsDefault(this._geoObjectEntityCollection);
    this._geometryHandler = new Sa(this);
    this._nodeCapacity = t2.nodeCapacity || 60;
    this._entityCollectionsTreeStrategy = null;
    this.setEntities(this._entities);
    this.polygonOffsetUnits = t2.polygonOffsetUnits != void 0 ? t2.polygonOffsetUnits : 0;
    this.pickingEnabled = this._pickingEnabled;
    this._depthOrder = t2.depthOrder || 0;
  }
  get depthOrder() {
    return this._depthOrder;
  }
  set depthOrder(e4) {
    if (e4 !== this._depthOrder) {
      this._depthOrder = e4;
      this._planet && this._planet.updateVisibleLayers();
    }
  }
  get useLighting() {
    return this._useLighting;
  }
  set useLighting(e4) {
    if (e4 !== this._useLighting) {
      this._geoObjectEntityCollection.useLighting = e4;
      this._useLighting = e4;
    }
  }
  get labelMaxLetters() {
    return this._labelMaxLetters;
  }
  get instanceName() {
    return "Vector";
  }
  _bindPicking() {
    this._pickingColor.clear();
  }
  addTo(e4) {
    if (!this._planet) {
      this._assignPlanet(e4);
      this._geometryHandler.assignHandler(e4.renderer.handler);
      this._polylineEntityCollection.addTo(e4, true);
      this._stripEntityCollection.addTo(e4, true);
      this._geoObjectEntityCollection.addTo(e4, true);
      this._polylineEntityCollection._layer = this;
      this._stripEntityCollection._layer = this;
      this._geoObjectEntityCollection._layer = this;
      this.setEntities(this._entities);
    }
  }
  remove() {
    super.remove();
    this._polylineEntityCollection.remove();
    this._stripEntityCollection.remove();
    this._geoObjectEntityCollection.remove();
    this._polylineEntityCollection._layer = void 0;
    this._stripEntityCollection._layer = void 0;
    this._geoObjectEntityCollection._layer = void 0;
    return this;
  }
  getEntities() {
    return [].concat(this._entities);
  }
  add(e4, t2 = false) {
    if (!(e4._layer || e4._entityCollection)) {
      e4._layer = this;
      e4._layerIndex = this._entities.length;
      this._entities.push(e4);
      this._proceedEntity(e4, t2);
    }
    return this;
  }
  insert(e4, t2, i2 = false) {
    if (!(e4._layer || e4._entityCollection)) {
      e4._layer = this;
      e4._layerIndex = t2;
      this._entities.splice(t2, 0, e4);
      for (let e5 = t2 + 1, i3 = this._entities.length; e5 < i3; e5++) {
        this._entities[e5]._layerIndex = e5;
      }
      this._proceedEntity(e4, i2);
    }
    return this;
  }
  _proceedEntity(e4, t2 = false) {
    var _a2;
    let i2 = this._hasImageryTiles;
    let s2 = !(e4.strip || e4.polyline || e4.ray || e4.geoObject || e4.geometry);
    if (e4.strip) {
      this._stripEntityCollection.add(e4);
    }
    if (e4.polyline || e4.ray) {
      this._polylineEntityCollection.add(e4);
    }
    if (e4.geoObject || s2) {
      this._geoObjectEntityCollection.add(e4);
    }
    if (e4.geometry) {
      this._hasImageryTiles = true;
      if (this._planet) {
        this._planet.renderer.assignPickingColor(e4);
        this._geometryHandler.add(e4.geometry);
      }
    }
    if (this._planet) {
      if (e4.billboard || e4.label || e4.geoObject || s2) {
        if (e4._cartesian.isZero() && !e4._lonLat.isZero()) {
          e4._setCartesian3vSilent(this._planet.ellipsoid.lonLatToCartesian(e4._lonLat));
        } else {
          e4._lonLat = this._planet.ellipsoid.cartesianToLonLat(e4._cartesian);
          if (Math.abs(e4._lonLat.lat) < Ge) {
            e4._lonLatMerc = e4._lonLat.forwardMercator();
          } else {
            e4._lonLatMerc.lon = e4._lonLatMerc.lat = e4._lonLatMerc.height = 0;
          }
        }
      }
      if (e4.billboard || e4.label) {
        (_a2 = this._entityCollectionsTreeStrategy) == null ? void 0 : _a2.insertEntity(e4);
      }
    }
    if (this._planet && this._hasImageryTiles !== i2) {
      this._planet.updateVisibleLayers();
    }
    this.events.dispatch(this.events.entityadd, e4);
  }
  addEntities(e4, t2 = false) {
    let i2 = e4.length;
    while (i2--) {
      this.add(e4[i2], t2);
    }
    return this;
  }
  removeEntity(e4) {
    if (e4._layer && this.isEqual(e4._layer)) {
      this._entities.splice(e4._layerIndex, 1);
      this._reindexEntitiesArray(e4._layerIndex);
      e4._layer = null;
      e4._layerIndex = -1;
      if (e4._entityCollection) {
        e4._entityCollection._removeEntitySilent(e4);
        let t2 = e4._nodePtr;
        while (t2) {
          t2.count--;
          t2 = t2.parentNode;
        }
        if (e4._nodePtr && e4._nodePtr.count === 0 && e4._nodePtr.deferredEntities.length === 0) {
          e4._nodePtr.entityCollection = null;
        }
      } else if (e4._nodePtr && e4._nodePtr.deferredEntities.length) {
        let t2 = e4._nodePtr.deferredEntities;
        let i2 = t2.length;
        while (i2--) {
          if (t2[i2].id === e4.id) {
            t2.splice(i2, 1);
            let s2 = e4._nodePtr;
            while (s2) {
              s2.count--;
              s2 = s2.parentNode;
            }
            break;
          }
        }
      }
      if (this._planet && e4.geometry) {
        this._geometryHandler.remove(e4.geometry);
        this._planet.renderer.clearPickingColor(e4);
      }
      e4._nodePtr = void 0;
      this.events.dispatch(this.events.entityremove, e4);
    }
    return this;
  }
  set pickingEnabled(e4) {
    var _a2;
    this._pickingEnabled = e4;
    this._stripEntityCollection.setPickingEnabled(e4);
    this._polylineEntityCollection.setPickingEnabled(e4);
    this._geoObjectEntityCollection.setPickingEnabled(e4);
    (_a2 = this._entityCollectionsTreeStrategy) == null ? void 0 : _a2.setPickingEnabled(e4);
  }
  _reindexEntitiesArray(e4) {
    const t2 = this._entities;
    for (let i2 = e4; i2 < t2.length; i2++) {
      t2[i2]._layerIndex = i2;
    }
  }
  removeEntities(e4) {
    let t2 = e4.length;
    while (t2--) {
      this.removeEntity(e4[t2]);
    }
    return this;
  }
  clear() {
    var _a2;
    super.clear();
    let e4 = new Array(this._entities.length);
    for (let t3 = 0; t3 < e4.length; t3++) {
      e4[t3] = this._entities[t3];
    }
    let t2 = this._entities.length;
    while (t2--) {
      this._entities[t2].remove();
    }
    this._entities.length = 0;
    this._entities = [];
    for (let t3 = 0; t3 < e4.length; t3++) {
      this._entities[t3] = e4[t3];
    }
    (_a2 = this._entityCollectionsTreeStrategy) == null ? void 0 : _a2.dispose();
    this._entityCollectionsTreeStrategy = null;
    this._geometryHandler.clear();
  }
  each(e4) {
    let t2 = this._entities;
    let i2 = t2.length;
    while (i2--) {
      e4(t2[i2], i2);
    }
  }
  setEntities(e4) {
    let t2 = new Array(e4.length);
    for (let i3 = 0, s2 = e4.length; i3 < s2; i3++) {
      t2[i3] = e4[i3];
    }
    this.clear();
    this._entities = new Array(t2.length);
    let i2 = [];
    for (let e5 = 0; e5 < t2.length; e5++) {
      let s2 = t2[e5];
      s2._layer = this;
      s2._layerIndex = e5;
      let r2 = !(s2.strip || s2.polyline || s2.ray || s2.geoObject || s2.billboard || s2.label);
      if (s2.strip) {
        this._stripEntityCollection.add(s2);
      } else if (s2.polyline || s2.ray) {
        this._polylineEntityCollection.add(s2);
      } else if (s2.geoObject || r2) {
        this._geoObjectEntityCollection.add(s2);
      } else if (s2.billboard || s2.label) {
        i2.push(s2);
      }
      if (s2.geometry) {
        this._hasImageryTiles = true;
        if (this._planet) {
          this._planet.renderer.assignPickingColor(s2);
          this._geometryHandler.add(s2.geometry);
        }
      }
      this._entities[e5] = s2;
    }
    this._createEntityCollectionsTree(i2);
    return this;
  }
  _createEntityCollectionsTree(e4) {
    if (this._planet) {
      this._entityCollectionsTreeStrategy = this._planet.quadTreeStrategy.createEntitiCollectionsTreeStrategy(this, this._nodeCapacity);
      this._entityCollectionsTreeStrategy.insertEntities(e4);
    }
  }
  _bindEventsDefault(e4) {
    let t2 = this.events;
    e4.events.on("mousemove", (e5) => {
      t2.dispatch(t2.mousemove, e5);
    });
    e4.events.on("mouseenter", (e5) => {
      t2.dispatch(t2.mouseenter, e5);
    });
    e4.events.on("mouseleave", (e5) => {
      t2.dispatch(t2.mouseleave, e5);
    });
    e4.events.on("lclick", (e5) => {
      t2.dispatch(t2.lclick, e5);
    });
    e4.events.on("rclick", (e5) => {
      t2.dispatch(t2.rclick, e5);
    });
    e4.events.on("mclick", (e5) => {
      t2.dispatch(t2.mclick, e5);
    });
    e4.events.on("ldblclick", (e5) => {
      t2.dispatch(t2.ldblclick, e5);
    });
    e4.events.on("rdblclick", (e5) => {
      t2.dispatch(t2.rdblclick, e5);
    });
    e4.events.on("mdblclick", (e5) => {
      t2.dispatch(t2.mdblclick, e5);
    });
    e4.events.on("lup", (e5) => {
      t2.dispatch(t2.lup, e5);
    });
    e4.events.on("rup", (e5) => {
      t2.dispatch(t2.rup, e5);
    });
    e4.events.on("mup", (e5) => {
      t2.dispatch(t2.mup, e5);
    });
    e4.events.on("ldown", (e5) => {
      t2.dispatch(t2.ldown, e5);
    });
    e4.events.on("rdown", (e5) => {
      t2.dispatch(t2.rdown, e5);
    });
    e4.events.on("mdown", (e5) => {
      t2.dispatch(t2.mdown, e5);
    });
    e4.events.on("lhold", (e5) => {
      t2.dispatch(t2.lhold, e5);
    });
    e4.events.on("rhold", (e5) => {
      t2.dispatch(t2.rhold, e5);
    });
    e4.events.on("mhold", (e5) => {
      t2.dispatch(t2.mhold, e5);
    });
    e4.events.on("mousewheel", (e5) => {
      t2.dispatch(t2.mousewheel, e5);
    });
    e4.events.on("touchmove", (e5) => {
      t2.dispatch(t2.touchmove, e5);
    });
    e4.events.on("touchstart", (e5) => {
      t2.dispatch(t2.touchstart, e5);
    });
    e4.events.on("touchend", (e5) => {
      t2.dispatch(t2.touchend, e5);
    });
    e4.events.on("doubletouch", (e5) => {
      t2.dispatch(t2.doubletouch, e5);
    });
    e4.events.on("touchleave", (e5) => {
      t2.dispatch(t2.touchleave, e5);
    });
    e4.events.on("touchenter", (e5) => {
      t2.dispatch(t2.touchenter, e5);
    });
  }
  _collectStripCollectionPASS(e4) {
    let t2 = this._stripEntityCollection;
    t2._fadingOpacity = this._fadingOpacity;
    t2.scaleByDistance = this.scaleByDistance;
    t2.pickingScale = this.pickingScale;
    t2.polygonOffsetUnits = this.polygonOffsetUnits;
    e4.push(t2);
  }
  _collectPolylineCollectionPASS(e4) {
    let t2 = this._polylineEntityCollection;
    t2._fadingOpacity = this._fadingOpacity;
    t2.scaleByDistance = this.scaleByDistance;
    t2.pickingScale = this.pickingScale;
    t2.polygonOffsetUnits = this.polygonOffsetUnits;
    e4.push(t2);
    if (this.clampToGround || this.relativeToGround) {
      let e5 = Number(this.relativeToGround);
      const i2 = this._planet._renderedNodes;
      const s2 = this._planet.getViewExtent();
      let r2 = t2._entities;
      let n2 = r2.length;
      let o2 = new Ke();
      while (n2--) {
        let t3 = r2[n2].polyline;
        if (t3 && s2.overlaps(t3._extent)) {
          let s3 = t3._pathLonLatMerc, r3 = s3.length;
          while (r3--) {
            let n3 = s3[r3].length;
            while (n3--) {
              let a2 = s3[r3][n3], l2 = i2.length;
              while (l2--) {
                let s4 = i2[l2].segment;
                if (s4._extent.isInside(a2)) {
                  let i3 = t3._path3v[r3][n3];
                  s4.getTerrainPoint(i3, a2, o2);
                  let l3 = e5 && t3.altitude || 0;
                  if (l3) {
                    let e6 = this._planet.ellipsoid.getSurfaceNormal3v(o2);
                    t3.setPoint3v(o2.addA(e6.scale(l3)), n3, r3, true);
                  } else {
                    t3.setPoint3v(o2, n3, r3, true);
                  }
                  break;
                }
              }
            }
          }
        }
      }
    }
  }
  _collectGeoObjectCollectionPASS(e4) {
    let t2 = this._geoObjectEntityCollection;
    t2._fadingOpacity = this._fadingOpacity;
    t2.scaleByDistance = this.scaleByDistance;
    t2.pickingScale = this.pickingScale;
    t2.polygonOffsetUnits = this.polygonOffsetUnits;
    e4.push(t2);
  }
  collectVisibleCollections(e4) {
    let t2 = this._planet;
    if (this._fading && this._fadingOpacity > 0 || this.minZoom <= t2.maxCurrZoom && this.maxZoom >= t2.maxCurrZoom) {
      this._collectStripCollectionPASS(e4);
      this._collectPolylineCollectionPASS(e4);
      this._collectGeoObjectCollectionPASS(e4);
      if (this._entityCollectionsTreeStrategy) {
        this._entityCollectionsTreeStrategy.collectVisibleEntityCollections(e4);
      }
    }
  }
  loadMaterial(e4) {
    const t2 = e4.segment;
    if (this._isBaseLayer) {
      e4.texture = t2._isNorth ? t2.planet.solidTextureOne : t2.planet.solidTextureTwo;
    } else {
      e4.texture = t2.planet.transparentTexture;
    }
    if (this._planet.layerLock.isFree()) {
      e4.isReady = false;
      e4.isLoading = true;
      this._planet._vectorTileCreator.add(e4);
    }
  }
  abortMaterialLoading(e4) {
    e4.isLoading = false;
    e4.isReady = false;
  }
  applyMaterial(e4, t2 = false) {
    if (e4.isReady) {
      return [0, 0, 1, 1];
    } else {
      !e4.isLoading && this.loadMaterial(e4);
      const t3 = e4.segment;
      let i2 = t3.node, s2 = false;
      let r2 = this.__id;
      let n2 = e4;
      while (i2.parentNode) {
        if (n2 && n2.isReady) {
          s2 = true;
          break;
        }
        i2 = i2.parentNode;
        n2 = i2.segment.materials[r2];
      }
      if (s2) {
        e4.appliedNodeId = i2.nodeId;
        e4.texture = n2.texture;
        e4.pickingMask = n2.pickingMask;
        const s3 = 1 / (2 << t3.tileZoom - i2.segment.tileZoom - 1);
        return [t3.tileX * s3 - i2.segment.tileX, t3.tileY * s3 - i2.segment.tileY, s3, s3];
      } else {
        if (e4.textureExists && e4._updateTexture) {
          e4.texture = e4._updateTexture;
          e4.pickingMask = e4._updatePickingMask;
        } else {
          e4.texture = t3.planet.transparentTexture;
          e4.pickingMask = t3.planet.transparentTexture;
        }
        e4.pickingReady = true;
        return [0, 0, 1, 1];
      }
    }
  }
  clearMaterial(e4) {
    if (e4.isReady) {
      const t2 = e4.segment.handler.gl;
      e4.isReady = false;
      e4.pickingReady = false;
      let i2 = e4.texture;
      e4.texture = null;
      i2 && !i2.default && t2.deleteTexture(i2);
      i2 = e4.pickingMask;
      e4.pickingMask = null;
      i2 && !i2.default && t2.deleteTexture(i2);
      i2 = e4._updateTexture;
      e4._updateTexture = null;
      i2 && !i2.default && t2.deleteTexture(i2);
      i2 = e4._updatePickingMask;
      e4._updatePickingMask = null;
      i2 && !i2.default && t2.deleteTexture(i2);
    }
    this.abortMaterialLoading(e4);
    e4.isLoading = false;
    e4.textureExists = false;
  }
  update() {
    this._geometryHandler.update();
    this.events.dispatch(this.events.draw, this);
  }
}
const Ba = ["draw", "entityadd", "entityremove"];
const ka = ["change", "startpoint"];
const Ia = ur.createCylinder(1, 1, 2, 20, 1, true, false, 0, -0.5, 0);
const za = 200;
const Da = 0.3;
const Fa = "rgb(350, 350, 0)";
const Na = "rgb(0, 350, 50)";
const Oa = "rgb(0, 350, 50)";
const Ha = 3.5;
const Va = { scale: 0.5, instanced: true, tag: "corners", color: Fa, object3d: Ia };
const Ua = { scale: 0.4, instanced: true, tag: "centers", color: Na, object3d: Ia };
const Ga = { thickness: Ha, color: Oa };
class Wa extends Fr {
  constructor(e4) {
    super(e4.name);
    this._cornerDblClick = false;
    this._onChange = (e5) => {
      if (e5.geometryType === "POLYGON") {
        let t2 = this.getCoordinates();
        let i2 = new zr({ geometry: { type: e5.geometryType, coordinates: [t2], style: { fillColor: "rgba(0,146,247,0.2)" } } });
        this._geometryLayer.clear();
        this._geometryLayer.add(i2);
      }
    };
    this._onCornerMouseEnter = (e5) => {
      e5.renderer.handler.canvas.style.cursor = "pointer";
      this.hideGhostPointer();
    };
    this._onCornerMouseLeave = (e5) => {
      e5.renderer.handler.canvas.style.cursor = "default";
      this.showGhostPointer();
    };
    this._onCenterMouseEnter = (e5) => {
      e5.renderer.handler.canvas.style.cursor = "pointer";
      this.hideGhostPointer();
    };
    this._onCenterMouseLeave = (e5) => {
      e5.renderer.handler.canvas.style.cursor = "default";
      if (!(this._pickedCenter || this._pickedCorner)) {
        this.showGhostPointer();
      }
    };
    this._onLup = (e5) => {
      this._planet.renderer.controls.mouseNavigation.activate();
      if (this._pickedCorner || this._pickedCenter) {
        this.events.dispatch(this.events.change, this);
        this.setGhostPointerPosition(this._planet.getCartesianFromPixelTerrain(e5));
        this.showGhostPointer();
        this._pickedCorner = null;
        this._pickedCenter = null;
      }
    };
    this._onCornerLdown = (e5) => {
      this._pickedCorner = this._getLdown(e5);
    };
    this._onCenterLdown = (e5) => {
      this._pickedCenter = this._getLdown(e5);
    };
    this._onMouseMove = (e5) => {
      if (this._pickedCenter) {
        this._moveCenterPoint();
      } else if (this._pickedCorner) {
        this._moveCornerPoint(e5.pos);
      } else {
        this.setGhostPointerPosition(this._planet.getCartesianFromPixelTerrain(e5.pos));
      }
    };
    this._onCornerLdblclick = (e5) => {
      this._cornerDblClick = true;
      let t2 = this.getCoordinates();
      t2.splice(e5.pickingObject.layerIndex, 1);
      this.setCoordinates(t2);
    };
    this._onMouseDblClick = (e5) => {
      if (this._cornerDblClick) {
        this._cornerDblClick = false;
        return;
      }
      if (!this._showGhostPointer) {
        return;
      }
      let t2 = this._planet.getCartesianFromPixelTerrain(e5);
      if (t2) {
        this._addNew(t2);
        if (!this._isStartPoint && this._cornerLayer.getEntities().length > 2) {
          this._isStartPoint = true;
          this.events.dispatch(this.events.startpoint, this);
        }
        this.events.dispatch(this.events.change, this);
      }
    };
    this.events = Qi(ka);
    this._planet = null;
    this._initCoordinates = e4.coordinates || [];
    this._pickedCorner = null;
    this._pickedCenter = null;
    this._startPos = null;
    this._startClick = new Qe();
    this._geometryLayer = new Ma();
    this._cornerLayer = new Ma("corners", { pickingScale: 3, pickingEnabled: true, polygonOffsetUnits: -5, relativeToGround: true, scaleByDistance: [100, 4e6, 1] });
    this._centerLayer = new Ma("centers", { pickingScale: 3, pickingEnabled: true, polygonOffsetUnits: -5, relativeToGround: true, scaleByDistance: [100, 4e6, 1] });
    this._outlineLayer = new Ma("outline", { entities: [new zr({ polyline: { path3v: [], isClosed: false, ...Ga } })], pickingEnabled: false, polygonOffsetUnits: -5, relativeToGround: true });
    this._outlineLayer.getEntities()[0].polyline.altitude = Da;
    this._ghostCorner = new zr({ geoObject: Va });
    this._ghostOutlineLayer = new Ma("ghost-pointer", { pickingEnabled: false, polygonOffsetUnits: -5, relativeToGround: true, scaleByDistance: [100, 4e6, 1], opacity: 0.5 });
    this._showGhostPointer = false;
    this._isStartPoint = false;
    this._insertCornerIndex = -1;
  }
  get geometryType() {
    return "POLYGON";
  }
  getCoordinates() {
    let e4 = this._cornerLayer.getEntities();
    if (e4.length > 0) {
      return e4.map((e5) => {
        let t2 = e5.getLonLat();
        return [t2.lon, t2.lat, t2.height];
      });
    } else {
      return this._initCoordinates;
    }
  }
  bindPlanet(e4) {
    this._planet = e4;
  }
  init() {
    this._initEvents();
    this._initGhostLayerPointer();
    if (this._initCoordinates.length) {
      this.setCoordinates(this._initCoordinates);
    }
    this._planet.addLayer(this._outlineLayer);
    this._planet.addLayer(this._cornerLayer);
    this._planet.addLayer(this._centerLayer);
    this.showGhostPointer();
    this.startNewPoint();
    this._geometryLayer.addTo(this._planet);
    this.events.on("change", this._onChange, this);
  }
  onremove() {
    this._clearEvents();
    this.hideGhostPointer();
    this.stopNewPoint();
    this.clear();
    this._geometryLayer.remove();
  }
  clear() {
    this._geometryLayer.clear();
    let e4 = this._cornerLayer.getEntities();
    let t2 = e4.length;
    while (t2--) {
      e4[t2].remove();
    }
    let i2 = this._centerLayer.getEntities();
    t2 = i2.length;
    while (t2--) {
      i2[t2].remove();
    }
    let s2 = this._outlineLayer.getEntities();
    t2 = s2.length;
    while (t2--) {
      s2[t2].polyline.clear();
      if (t2 > 0) {
        s2[t2].remove();
      }
    }
    this._clearGhostPointer();
  }
  setCoordinates(e4) {
    this.clear();
    for (let t2 = 0; t2 < e4.length; t2++) {
      let i2 = e4[t2];
      let s2 = this._planet.ellipsoid.lonLatToCartesian(new be(i2[0], i2[1], i2[2]));
      this._appendCart(s2);
    }
    this.events.dispatch(this.events.change, this);
  }
  stopNewPoint() {
    if (this.renderer) {
      this.renderer.events.off("ldblclick", this._onMouseDblClick);
    }
  }
  startNewPoint() {
    this.renderer.events.on("ldblclick", this._onMouseDblClick, this);
  }
  showGhostPointer() {
    this._showGhostPointer = true;
    this._planet.addLayer(this._ghostOutlineLayer);
    this._insertCornerIndex = this._cornerLayer.getEntities().length;
  }
  hideGhostPointer() {
    this._showGhostPointer = false;
    this._ghostOutlineLayer.remove();
    this._insertCornerIndex = -1;
  }
  setGhostPointerPosition(e4) {
    if (e4) {
      this._ghostCorner.setCartesian3v(e4);
      this._updateGhostOutlinePointer(e4);
    }
  }
  _getLdown(e4) {
    this._planet.renderer.controls.mouseNavigation.deactivate();
    this._startClick.set(e4.x, e4.y);
    let t2 = e4.pickingObject.getCartesian();
    this._startPos = this._planet.getPixelFromCartesian(t2);
    return e4.pickingObject;
  }
  _initEvents() {
    this._cornerLayer.events.on("ldblclick", this._onCornerLdblclick, this);
    this._cornerLayer.events.on("ldown", this._onCornerLdown, this);
    this._centerLayer.events.on("ldown", this._onCenterLdown, this);
    this.renderer.events.on("lup", this._onLup, this);
    this.renderer.events.on("mousemove", this._onMouseMove, this);
    this._cornerLayer.events.on("mouseenter", this._onCornerMouseEnter, this);
    this._cornerLayer.events.on("mouseleave", this._onCornerMouseLeave, this);
    this._centerLayer.events.on("mouseenter", this._onCenterMouseEnter, this);
    this._centerLayer.events.on("mouseleave", this._onCenterMouseLeave, this);
  }
  _clearEvents() {
    this._cornerLayer.events.off("ldblclick", this._onCornerLdblclick);
    this._cornerLayer.events.off("ldown", this._onCornerLdown);
    this._centerLayer.events.off("ldown", this._onCenterLdown);
    this.renderer.events.off("lup", this._onLup);
    this.renderer.events.off("mousemove", this._onMouseMove);
    this._cornerLayer.events.off("mouseenter", this._onCornerMouseEnter);
    this._cornerLayer.events.off("mouseleave", this._onCornerMouseLeave);
    this._centerLayer.events.off("mouseenter", this._onCenterMouseEnter);
    this._centerLayer.events.off("mouseleave", this._onCenterMouseLeave);
  }
  _drawCorners() {
    let e4 = this._cornerLayer.getEntities();
    for (let t2 = 0; t2 < e4.length; t2++) {
      let i2 = e4[t2];
      this._checkTerrainCollision(i2);
    }
  }
  _drawCenters() {
    let e4 = this._centerLayer.getEntities();
    for (let t2 = 0; t2 < e4.length; t2++) {
      let i2 = e4[t2];
      this._checkTerrainCollision(i2);
    }
  }
  _drawGhostCorner() {
    if (this._showGhostPointer) {
      this._checkTerrainCollision(this._ghostCorner);
    }
  }
  frame() {
    this._drawCorners();
    this._drawCenters();
    this._drawGhostCorner();
  }
  _checkTerrainCollision(e4) {
    let t2 = new Ke();
    let i2 = this._planet._renderedNodes;
    for (let s2 = 0; s2 < i2.length; s2++) {
      let r2 = i2[s2].segment;
      if (r2 && r2._extentLonLat.isInside(e4.getLonLat())) {
        r2.getEntityTerrainPoint(e4, t2);
        e4.setCartesian3v(t2);
        break;
      }
    }
  }
  _moveCenterPoint() {
    let e4 = this.getCoordinates(), t2 = this._pickedCenter.layerIndex + 1, i2 = this._pickedCenter.getLonLat();
    let s2 = [i2.lon, i2.lat, i2.height];
    e4.splice(t2, 0, s2);
    this.setCoordinates(e4);
    this._pickedCenter = null;
    this._pickedCorner = this._cornerLayer.getEntities()[t2];
  }
  _addNew(e4) {
    if (this._insertCornerIndex === -1 || this._cornerLayer.getEntities().length < 2) {
      this._appendCart(e4);
    } else {
      let t2 = this.getCoordinates(), i2 = this._insertCornerIndex;
      let s2 = this._planet.ellipsoid.cartesianToLonLat(e4);
      let r2 = [s2.lon, s2.lat, s2.height];
      t2.splice(i2, 0, r2);
      this.clear();
      this.setCoordinates(t2);
    }
  }
  _appendCart(e4) {
    let t2 = this._cornerLayer.getEntities();
    let i2 = t2.length - 1;
    let s2 = t2[i2];
    let r2 = new zr({ geoObject: Va });
    r2.setCartesian3v(e4);
    r2.addTo(this._cornerLayer);
    this._checkTerrainCollision(r2);
    if (s2) {
      let e5 = t2[0].getCartesian(), i3 = s2.getCartesian();
      let n2 = r2.getCartesian().sub(i3), o2 = r2.getCartesian().sub(e5);
      let a2 = n2.length(), l2 = o2.length();
      n2.normalize();
      o2.normalize();
      let h2 = [], c2 = [];
      for (let t3 = 0; t3 <= za; t3++) {
        let s3 = n2.scaleTo(t3 * a2 / za).addA(i3);
        h2.push(s3);
        let r3 = o2.scaleTo(t3 * l2 / za).addA(e5);
        c2.push(r3);
      }
      this._outlineLayer.getEntities()[0].polyline.setPath3v([c2]);
      let d2 = new zr({ polyline: { path3v: [h2], isClosed: false, ...Ga } });
      d2.polyline.altitude = Da;
      this._outlineLayer.add(d2);
      let u2 = this._centerLayer.getEntities();
      let _2 = u2[u2.length - 1];
      let f2 = n2.scaleTo(a2 * 0.5).addA(i3), g2 = o2.scaleTo(l2 * 0.5).addA(e5);
      let p2 = new zr({ geoObject: Ua });
      p2.setCartesian3v(f2);
      p2.addTo(this._centerLayer);
      this._checkTerrainCollision(p2);
      _2.remove();
      _2.addTo(this._centerLayer);
      _2.setCartesian3v(g2);
    } else {
      let e5 = new zr({ geoObject: Ua });
      e5.addTo(this._centerLayer);
    }
  }
  _clearGhostPointer() {
    const e4 = this._ghostOutlineLayer;
    e4.getEntities()[0].polyline.clear();
    e4.getEntities()[1].polyline.clear();
  }
  _moveCornerPoint(e4) {
    let t2 = new Qe(e4.x, e4.y).sub(this._startClick), i2 = this._startPos.add(t2);
    let s2 = this._planet.getCartesianFromPixelTerrain(i2);
    if (s2) {
      this._pickedCorner.setCartesian3v(s2);
      let e5 = this._cornerLayer.getEntities();
      if (e5.length) {
        let t3 = this._pickedCorner.layerIndex;
        let i3 = e5.length;
        let s3 = e5[t3 === 0 ? i3 - 1 : t3 - 1].getCartesian(), r2 = e5[(t3 + 1) % i3].getCartesian();
        let n2 = this._pickedCorner.getCartesian().sub(s3), o2 = this._pickedCorner.getCartesian().sub(r2);
        let a2 = n2.length(), l2 = o2.length();
        n2.normalize();
        o2.normalize();
        let h2 = [], c2 = [];
        for (let e6 = 0; e6 <= za; e6++) {
          let t4 = n2.scaleTo(e6 * a2 / za).addA(s3);
          h2.push(t4);
          let i4 = o2.scaleTo(e6 * l2 / za).addA(r2);
          c2.push(i4);
        }
        let d2 = this._outlineLayer.getEntities();
        let u2 = d2[t3].polyline, _2 = d2[(t3 + 1) % i3].polyline;
        u2 == null ? void 0 : u2.setPath3v([h2]);
        _2 == null ? void 0 : _2.setPath3v([c2]);
        let f2 = this._centerLayer.getEntities();
        let g2 = f2[t3 === 0 ? i3 - 1 : t3 - 1], p2 = f2[t3];
        let m2 = n2.scaleTo(a2 * 0.5).addA(s3), v2 = o2.scaleTo(l2 * 0.5).addA(r2);
        g2.setCartesian3v(m2);
        this._checkTerrainCollision(g2);
        p2.setCartesian3v(v2);
        this._checkTerrainCollision(p2);
      }
    }
  }
  _updateGhostOutlinePointer(e4) {
    let t2 = this._cornerLayer.getEntities();
    let i2 = t2.length;
    if (i2 > 0) {
      let s2 = 0;
      let r2 = h;
      for (let n3 = 0; n3 < i2; n3++) {
        let i3 = t2[n3];
        let o3 = i3.getCartesian().distance(e4);
        if (o3 < r2) {
          r2 = o3;
          s2 = n3;
        }
      }
      let n2 = t2[s2].getCartesian(), o2 = t2[(s2 + 1) % i2].getCartesian(), a2 = t2[s2 === 0 ? i2 - 1 : s2 - 1].getCartesian();
      let l2 = a2.sub(n2).normalize(), c2 = o2.sub(n2).normalize(), d2 = e4.sub(n2).normalize();
      let u2 = l2.add(c2).normalize();
      let _2 = d2.cross(u2), f2 = l2.cross(c2);
      if (_2.dot(f2) > 0) {
        s2--;
        if (s2 < 0) {
          s2 = i2 - 1;
        }
      }
      let g2 = new Ke();
      for (let n3 = 0; n3 < i2; n3++) {
        let o3 = new ir(t2[n3].getCartesian(), t2[(n3 + 1) % i2].getCartesian());
        let a3 = o3.getNearestDistancePoint(e4, g2);
        if (a3) {
          let t3 = g2.distance(e4);
          if (t3 < r2) {
            r2 = t3;
            s2 = n3;
          }
        }
      }
      this._insertCornerIndex = (s2 + 1) % i2;
      let p2 = t2[s2 % i2].getCartesian(), m2 = t2[(s2 + 1) % i2].getCartesian();
      let v2 = this._ghostCorner.getCartesian().sub(p2), y2 = this._ghostCorner.getCartesian().sub(m2);
      let x2 = v2.length(), b2 = y2.length();
      v2.normalize();
      y2.normalize();
      let w2 = [], C2 = [];
      for (let e5 = 0; e5 <= za; e5++) {
        let t3 = v2.scaleTo(e5 * x2 / za).addA(p2);
        w2.push(t3);
        let i3 = y2.scaleTo(e5 * b2 / za).addA(m2);
        C2.push(i3);
      }
      let T2 = this._ghostOutlineLayer.getEntities();
      let E2 = T2[0].polyline, A2 = T2[1].polyline;
      E2 == null ? void 0 : E2.setPath3v([w2]);
      A2 == null ? void 0 : A2.setPath3v([C2]);
    }
  }
  _initGhostLayerPointer() {
    this._ghostOutlineLayer.setEntities([new zr({ polyline: { path3v: [], isClosed: false, ...Ga } }), new zr({ polyline: { path3v: [], isClosed: false, ...Ga } }), this._ghostCorner]);
    const e4 = this._ghostOutlineLayer;
    e4.getEntities()[0].polyline.altitude = e4.getEntities()[1].polyline.altitude = Da;
  }
}
class ja extends Wa {
  constructor(e4) {
    super(e4);
  }
  get geometryType() {
    return "LineString";
  }
  _addNew(e4) {
    this._appendCart(e4);
  }
  _appendCart(e4) {
    let t2 = this._cornerLayer.getEntities();
    let i2 = t2.length - 1;
    let s2 = t2[i2];
    let r2 = new zr({ geoObject: Va });
    r2.setCartesian3v(e4);
    r2.addTo(this._cornerLayer);
    this._checkTerrainCollision(r2);
    if (s2) {
      let e5 = s2.getCartesian();
      let t3 = r2.getCartesian().sub(e5);
      let i3 = t3.length();
      t3.normalize();
      let n2 = [];
      for (let s3 = 0; s3 <= za; s3++) {
        let r3 = t3.scaleTo(s3 * i3 / za).addA(e5);
        n2.push(r3);
      }
      let o2 = new zr({ polyline: { path3v: [n2], isClosed: false, ...Ga } });
      o2.polyline.altitude = Da;
      this._outlineLayer.add(o2);
      let a2 = t3.scaleTo(i3 * 0.5).addA(e5);
      let l2 = new zr({ geoObject: Ua });
      l2.setCartesian3v(a2);
      l2.addTo(this._centerLayer);
      this._checkTerrainCollision(l2);
    }
  }
  _clearGhostPointer() {
    this._ghostOutlineLayer.getEntities()[0].polyline.clear();
  }
  _moveCorner(e4, t2, i2) {
    let s2 = this._cornerLayer.getEntities();
    if (s2.length == 0) return;
    if (s2.length == 1) {
      e4 = t2 = i2 = 0;
    }
    let r2 = s2[e4].getCartesian();
    let n2 = this._pickedCorner.getCartesian().sub(r2);
    let o2 = n2.length();
    n2.normalize();
    let a2 = [];
    for (let e5 = 0; e5 <= za; e5++) {
      let t3 = n2.scaleTo(e5 * o2 / za).addA(r2);
      a2.push(t3);
    }
    let l2 = this._outlineLayer.getEntities();
    let h2 = l2[t2].polyline;
    h2 == null ? void 0 : h2.setPath3v([a2]);
    let c2 = this._centerLayer.getEntities();
    let d2 = c2[i2];
    if (d2) {
      let e5 = n2.scaleTo(o2 * 0.5).addA(r2);
      d2.setCartesian3v(e5);
      this._checkTerrainCollision(d2);
    }
  }
  _moveCornerPoint(e4) {
    let t2 = new Qe(e4.x, e4.y).sub(this._startClick), i2 = this._startPos.add(t2);
    let s2 = this._planet.getCartesianFromPixelTerrain(i2);
    if (s2) {
      this._pickedCorner.setCartesian3v(s2);
      let e5 = this._cornerLayer.getEntities();
      if (e5.length) {
        let t3 = this._pickedCorner.layerIndex;
        if (t3 === 0) {
          this._moveCorner(t3 + 1, t3 + 1, t3);
        } else if (t3 === e5.length - 1) {
          this._moveCorner(t3 - 1, t3, t3 - 1);
        } else {
          this._moveCorner(t3 + 1, t3 + 1, t3);
          this._moveCorner(t3 - 1, t3, t3 - 1);
        }
      }
    }
  }
  _updateGhostOutlinePointer(e4) {
    let t2 = this._cornerLayer.getEntities();
    let i2 = t2.length;
    if (i2 > 0) {
      let e5 = i2 - 1;
      this._insertCornerIndex = e5;
      let s2 = t2[e5].getCartesian();
      let r2 = this._ghostCorner.getCartesian().sub(s2);
      let n2 = r2.length();
      r2.normalize();
      let o2 = [];
      for (let e6 = 0; e6 <= za; e6++) {
        let t3 = r2.scaleTo(e6 * n2 / za).addA(s2);
        o2.push(t3);
      }
      let a2 = this._ghostOutlineLayer.getEntities();
      let l2 = a2[0].polyline;
      l2.setPath3v([o2]);
    }
  }
  _initGhostLayerPointer() {
    this._ghostOutlineLayer.setEntities([new zr({ polyline: { path3v: [], isClosed: false, ...Ga } }), this._ghostCorner]);
    this._ghostOutlineLayer.getEntities()[0].polyline.altitude = Da;
  }
}
class Ya extends ns {
  constructor(e4 = {}) {
    super(e4);
    this._drawingScene = new ja({ name: `drawingScene:${this.__id}` });
  }
  activatePolygonDrawing() {
    this.deactivate();
    this._drawingScene = new Wa({ name: `polygonDrawingScene:${this.__id}` });
    this.activate();
  }
  activateLineStringDrawing() {
    this.deactivate();
    this._drawingScene = new ja({ name: `linestringDrawingScene:${this.__id}` });
    this.activate();
  }
  oninit() {
  }
  onactivate() {
    this.planet && this._drawingScene.bindPlanet(this.planet);
    this.renderer && this.renderer.addNode(this._drawingScene);
  }
  ondeactivate() {
    this.renderer && this.renderer.removeNode(this._drawingScene);
  }
}
const qa = `<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 24.1.3, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg version="1.1" id="Layer_2" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 1024 1024" style="enable-background:new 0 0 1024 1024;" xml:space="preserve">
<g>
	<path d="M926.03,321.16c-16.02,0-31.11,3.94-44.48,10.79l-263.43-191.4c2.69-8.94,4.18-18.4,4.18-28.2
		c0-54.02-43.95-97.97-97.97-97.97c-54.03,0-97.98,43.95-97.98,97.97c0,9.81,1.49,19.27,4.18,28.21L155.75,340.18
		c-16.22-11.91-36.16-19.03-57.78-19.03C43.95,321.16,0,365.11,0,419.13c0,52.58,41.67,95.5,93.71,97.75l102.63,315.86
		c-24.28,17.85-40.13,46.52-40.13,78.9c0,54.02,43.95,97.98,97.98,97.98c37.54,0,70.18-21.25,86.62-52.34h367.26
		c16.44,31.08,49.08,52.34,86.63,52.34c54.03,0,97.98-43.95,97.98-97.98c0-32.46-15.94-61.21-40.33-79.05l104.11-320.4
		c39.15-12.84,67.54-49.68,67.54-93.07C1024,365.11,980.05,321.16,926.03,321.16z M828.05,911.65c0,8.5-3.3,16.19-8.55,22.09
		c-6.11,6.85-14.9,11.26-24.79,11.26c-13.65,0-25.37-8.26-30.52-20.02c-1.79-4.09-2.82-8.58-2.82-13.33
		c0-18.39,14.95-33.35,33.34-33.35c2.93,0,5.72,0.5,8.43,1.21c13.27,3.49,23.21,14.91,24.59,28.9
		C827.83,909.5,828.05,910.54,828.05,911.65z M790.48,813.89c-45.63,1.96-83.27,35.16-91.87,78.77H350.28
		c-8.62-43.69-46.38-76.93-92.11-78.79L155.59,498.19c24.41-17.84,40.36-46.59,40.36-79.06c0-8.9-1.3-17.49-3.53-25.7L468.57,192.8
		c15.84,11.01,35.05,17.52,55.76,17.52c20.71,0,39.92-6.5,55.76-17.52l256.56,186.4c-5.48,12.21-8.59,25.7-8.59,39.93
		c0,41.02,25.36,76.17,61.21,90.75L790.48,813.89z M254.19,945c-10.11,0-19.07-4.62-25.19-11.75c-5.01-5.84-8.15-13.32-8.15-21.6
		c0-0.91,0.2-1.76,0.27-2.66c1.14-14.18,11.08-25.8,24.43-29.41c2.78-0.75,5.64-1.28,8.65-1.28c18.38,0,33.33,14.96,33.33,33.35
		c0,4.74-1.03,9.24-2.82,13.33C279.55,936.74,267.83,945,254.19,945z M64.88,421.49c-0.06-0.79-0.24-1.55-0.24-2.35
		c0-16.41,11.93-30.01,27.55-32.76c1.89-0.33,3.8-0.58,5.78-0.58c11.94,0,22.35,6.36,28.24,15.81c3.18,5.11,5.11,11.09,5.11,17.53
		c0,15.47-10.63,28.39-24.94,32.14c-2.7,0.71-5.48,1.2-8.4,1.2C80.4,452.47,66.11,438.76,64.88,421.49z M549.41,90.62
		c5.07,5.85,8.25,13.39,8.25,21.72c0,7.32-2.44,14.03-6.45,19.54c-6.07,8.33-15.82,13.81-26.88,13.81
		c-11.07,0-20.83-5.48-26.89-13.81c-4.01-5.51-6.45-12.22-6.45-19.54c0-8.33,3.17-15.86,8.24-21.71
		c6.12-7.07,15.04-11.64,25.1-11.64C534.38,79,543.29,83.57,549.41,90.62z M959.36,419.13c0,11.94-6.36,22.35-15.82,28.24
		c-5.1,3.18-11.07,5.1-17.52,5.1c-6.08,0-11.71-1.76-16.62-4.61c-9.71-5.64-16.33-15.94-16.64-27.89c-0.01-0.29-0.09-0.56-0.09-0.85
		c0-11.75,6.14-22.05,15.36-28c5.2-3.35,11.35-5.35,17.99-5.35C944.41,385.78,959.36,400.75,959.36,419.13z"/>
</g>
</svg>`;
const $a = `<?xml version="1.0" encoding="utf-8"?><!-- License: MIT. Made by Esri: https://github.com/Esri/calcite-ui-icons -->
    <svg width="800px" height="800px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21 6h.046l-5.25 9h-.944L10 9.455V7H7v2.926L1.862 18H0v3h3v-2.926L8.138 10h1.01L14 15.545V18h3v-3h-.046l5.25-9H24V3h-3zM8 8h1v1H8zM2 20H1v-1h1zm14-3h-1v-1h1zm7-13v1h-1V4z"/></svg>`;
const Xa = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M4 0l16 12.279-6.951 1.17 4.325 8.817-3.596 1.734-4.35-8.879-5.428 4.702z"/></svg>`;
class Za extends ns {
  constructor(e4 = {}) {
    super({ name: "DrawingSwitcher", ...e4 });
    this.drawingControl = new Ya();
  }
  oninit() {
    this.planet.addControl(this.drawingControl);
    this._createMenu();
  }
  onactivate() {
    this.drawingControl.activate();
  }
  ondeactivate() {
    this.drawingControl.deactivate();
  }
  _createMenu() {
    let e4 = new _s({ classList: ["og-map-button", "og-drawing-default_button"], icon: Xa, name: "default", isActive: true });
    let t2 = new _s({ classList: ["og-map-button", "og-drawing-polygon_button"], icon: qa, name: "polygon" });
    let i2 = new _s({ classList: ["og-map-button", "og-drawing-linestring_button"], icon: $a, name: "linestring" });
    let s2 = new Us({ buttons: [e4, t2, i2] });
    s2.events.on("change", (e5) => {
      this.drawingControl.deactivate();
      switch (e5.name) {
        case "polygon":
          this.drawingControl.activatePolygonDrawing();
          break;
        case "linestring":
          this.drawingControl.activateLineStringDrawing();
          break;
      }
    });
    e4.appendTo(this.renderer.div);
    t2.appendTo(this.renderer.div);
    i2.appendTo(this.renderer.div);
  }
}
const Ka = 0;
const Qa = 1;
const Ja = 2;
const el = { ell: Ka, msl: Qa, gnd: Ja };
const tl = 1e3;
const il = 1 / tl;
const sl = 0.3048;
const rl = 1 / sl;
const nl = 3.6;
const ol = 1 / nl;
const al = 3.28084;
const ll = sl * il;
const hl = 1 / ll;
const cl = 0;
const dl = 1;
const ul = 2;
const _l = 3;
const fl = 4;
const gl = 5;
const pl = 6;
const ml = 7;
const vl = "--";
const yl = ["m", "km", "ft", "s", "h", "m/s", "km/h", "ft/s"];
const xl = [0, 2, 0, 0, 0, 0, 0, 0];
let bl = [];
bl[cl] = [];
bl[cl][cl] = (e4) => e4;
bl[cl][dl] = (e4) => e4 * il;
bl[cl][ul] = (e4) => e4 * rl;
bl[ul] = [];
bl[ul][cl] = (e4) => e4 * sl;
bl[ul][dl] = (e4) => e4 * ll;
bl[ul][ul] = (e4) => e4;
bl[dl] = [];
bl[dl][cl] = (e4) => e4 * tl;
bl[dl][dl] = (e4) => e4;
bl[dl][ul] = (e4) => e4 * hl;
bl[gl] = [];
bl[gl][gl] = (e4) => e4;
bl[gl][pl] = (e4) => e4 * nl;
bl[gl][ml] = (e4) => e4 * al;
bl[pl] = [];
bl[pl][gl] = (e4) => e4 * ol;
bl[pl][pl] = (e4) => e4;
function wl(e4, t2, i2) {
  return bl[e4][t2](i2);
}
function Cl(e4, t2, i2, s2, r2) {
  if (e4) {
    return wl(t2, i2, s2).toFixed(r2 || xl[i2]);
  }
  return vl;
}
function Tl(e4) {
  return yl[e4];
}
const El = Object.freeze(Object.defineProperty({ __proto__: null, ELL: Ka, GND: Ja, MSL: Qa, _tenth: xl, convert: wl, convertExt: Cl, ft: ul, fts: ml, h: fl, heightMode: el, km: dl, kmh: pl, m: cl, ms: gl, s: _l, toString: Tl }, Symbol.toStringTag, { value: "Module" }));
const Al = `<div class="og-lat-side"></div><div class="og-lat-val"></div>
    <div class="og-lon-side"></div><div class="og-lon-val"></div>
    <div class="og-height"></div>
    <div class="og-units-height"></div>`;
const Ll = `<div class="og-lat-side"></div><div class="og-lat-val"></div>
    <div class="og-lon-side"></div><div class="og-lon-val"></div>
    <div class="og-height"></div>
    <div class="og-units-height"></div>`;
const Pl = '<svg width="12" height="12"><g><path stroke-width="1" stroke-opacity="1" d="M6 0L6 12M0 6L12 6" stroke="#337ab7"></path></g></svg>';
const Sl = [Al, Ll];
class Rl extends ns {
  constructor(e4 = {}) {
    super(e4);
    this._type = e4.type || 0;
    this._TYPE_FUNC = [this._SHOW_DECIMAL, this._SHOW_DEGREE];
    this._showFn = null;
    this._el = null;
    this._latSideEl = null;
    this._lonSideEl = null;
    this._latValEl = null;
    this._lonValEl = null;
    this._heightEl = null;
    this._altUnitVal = e4.altitudeUnit || "m";
    this._heightModeVal = e4.heightMode || "ell";
    this._altUnit = El[this._altUnitVal];
    this._heightMode = el[this._heightModeVal];
    this._lonLat = null;
    this._centerMode = false;
  }
  _SHOW_DECIMAL(e4) {
    if (e4) {
      let t2 = e4.lat, i2 = e4.lon;
      if (t2 >= 0) {
        this._latSideEl.innerHTML = "N";
      } else {
        this._latSideEl.innerHTML = "S";
      }
      if (i2 >= 0) {
        this._lonSideEl.innerHTML = "E";
      } else {
        this._lonSideEl.innerHTML = "W";
      }
      this._latValEl.innerHTML = Math.abs(t2).toFixed(7) + "°";
      this._lonValEl.innerHTML = Math.abs(i2).toFixed(7) + "°";
    }
  }
  _SHOW_DEGREE(e4) {
    if (e4) {
      let t2 = e4.lat, i2 = e4.lon;
      if (t2 >= 0) {
        this._latSideEl.innerHTML = "N";
      } else {
        this._latSideEl.innerHTML = "S";
      }
      if (i2 >= 0) {
        this._lonSideEl.innerHTML = "E";
      } else {
        this._lonSideEl.innerHTML = "W";
      }
      let s2 = 0;
      let r2 = t2 < 0 ? Math.ceil(t2) : Math.floor(t2);
      let n2 = Math.floor(s2 = Math.abs(t2 - r2) * 60);
      let o2 = Math.floor((s2 - n2) * 6e3) / 100;
      this._latValEl.innerHTML = Math.abs(r2) + "°" + n2 + "'" + o2.toFixed(0) + '"';
      r2 = i2 < 0 ? Math.ceil(i2) : Math.floor(i2);
      n2 = Math.floor(s2 = Math.abs(i2 - r2) * 60);
      o2 = Math.floor((s2 - n2) * 6e3) / 100;
      this._lonValEl.innerHTML = Math.abs(r2) + "°" + n2 + "'" + o2.toFixed(0) + '"';
    }
  }
  _createCenterEl() {
    let e4 = document.createElement("div");
    e4.className = "og-center-icon";
    e4.innerHTML = Pl;
    return e4;
  }
  _updateUnits() {
    this._heightMode = el[this._heightModeVal];
    this._altUnit = El[this._altUnitVal];
    this._el.querySelector(".og-units-height").innerHTML = Tl(this._altUnit);
    this._showHeight();
  }
  _refreshCoordinates() {
    if (this._type >= this._TYPE_FUNC.length) {
      this._type = 0;
    }
    let e4 = this._el;
    e4.innerHTML = Sl[this._type];
    this._latSideEl = e4.querySelector(".og-lat-side");
    this._lonSideEl = e4.querySelector(".og-lon-side");
    this._latValEl = e4.querySelector(".og-lat-val");
    this._lonValEl = e4.querySelector(".og-lon-val");
    this._heightEl = e4.querySelector(".og-height");
    this._showFn = this._TYPE_FUNC[this._type];
    this._showFn(this._lonLat);
  }
  oninit() {
    this._el = document.createElement("div");
    this._el.classList.add("og-coordinates");
    this.renderer.div.appendChild(this._el);
    this._el.addEventListener("click", () => {
      this._type++;
      this._refreshCoordinates();
      this._updateUnits();
      this._showHeight();
    });
    if (this._centerMode) {
      this.renderer.div.appendChild(this._createCenterEl());
      this.planet.camera.events.on("moveend", this._grabCoordinates, this);
      this.planet.camera.events.on("moveend", Dt(() => this._showHeight(), 400, true), this);
    } else {
      this.renderer.events.on("mousemove", this._grabCoordinates, this);
      this.renderer.events.on("mousestop", Dt(() => this._showHeight(), 400, true), this);
    }
    this._refreshCoordinates();
    this._updateUnits();
  }
  _grabCoordinates(e4) {
    let t2 = e4.pos;
    let i2;
    let s2 = this.renderer;
    if (this._centerMode) {
      i2 = s2.handler.getCenter();
    } else {
      i2 = t2;
    }
    this._lonLat = this.planet.getLonLatFromPixelTerrain(i2) || null;
    this._showFn(this._lonLat);
  }
  async _showHeight() {
    if (this._lonLat && this.planet) {
      let e4 = 0;
      this._heightEl.style.opacity = "0.7";
      if (this._heightMode === el.ell) {
        e4 = await this.planet.getHeightAboveELL(this._lonLat);
        e4 = Number(Cl(true, cl, this._altUnit, e4));
      } else if (this._heightMode === el.msl) {
        e4 = await this.planet.getHeightDefault(this._lonLat);
        e4 = Number(Cl(true, cl, this._altUnit, e4));
      }
      this._heightEl.style.opacity = "1.0";
      this._heightEl.innerHTML = e4.toString();
    }
  }
}
const Ml = ["loadend"];
class Bl extends ks {
  constructor(e4, t2 = {}) {
    super(e4, t2);
    this.events = this.events.registerNames(Ml);
    this._projType = 0;
    this._frameWidth = 256;
    this._frameHeight = 256;
    this._sourceReady = false;
    this._sourceTexture = null;
    this._materialTexture = null;
    this._gridBufferLow = null;
    this._gridBufferHigh = null;
    this._extentWgs84ParamsHigh = new Float32Array(4);
    this._extentWgs84ParamsLow = new Float32Array(4);
    this._extentMercParamsHigh = new Float32Array(4);
    this._extentMercParamsLow = new Float32Array(4);
    this._refreshFrame = true;
    this._frameCreated = false;
    this._sourceCreated = false;
    this._animate = false;
    this._ready = false;
    this._creationProceeding = false;
    this._isRendering = false;
    this._extentWgs84 = new Ye();
    this._cornersWgs84 = [];
    this._cornersMerc = [];
    this._isFullExtent = t2.fullExtent ? 1 : 0;
    this.rendering = this._renderingProjType0.bind(this);
    this._onLoadend_ = null;
    t2.corners && this.setCorners(t2.corners);
  }
  get isIdle() {
    return super.isIdle && this._ready;
  }
  addTo(e4) {
    this._onLoadend_ = this._onLoadend.bind(this);
    this.events.on("loadend", this._onLoadend_, this);
    return super.addTo(e4);
  }
  _onLoadend() {
    if (this._planet) {
      this._planet.events.dispatch(this._planet.events.layerloadend, this);
    }
  }
  remove() {
    this.events.off("loadend", this._onLoadend_);
    this._onLoadend_ = null;
    return super.remove();
  }
  get instanceName() {
    return "BaseGeoImage";
  }
  getCornersLonLat() {
    let e4 = this._cornersWgs84;
    return [new be(e4[0].lon, e4[0].lat), new be(e4[1].lon, e4[1].lat), new be(e4[2].lon, e4[2].lat), new be(e4[3].lon, e4[3].lat)];
  }
  getCorners() {
    let e4 = this._cornersWgs84;
    return [[e4[0].lon, e4[0].lat], [e4[1].lon, e4[1].lat], [e4[2].lon, e4[2].lat], [e4[3].lon, e4[3].lat]];
  }
  setCorners(e4) {
    this.setCornersLonLat(be.join(e4));
  }
  setCornersLonLat(e4) {
    this._refreshFrame = true;
    this._cornersWgs84 = [e4[0].clone(), e4[1].clone(), e4[2].clone(), e4[3].clone()];
    for (let e5 = 0; e5 < this._cornersWgs84.length; e5++) {
      if (this._cornersWgs84[e5].lat >= 89.9) {
        this._cornersWgs84[e5].lat = 89.9;
      }
      if (this._cornersWgs84[e5].lat <= -89.9) {
        this._cornersWgs84[e5].lat = -89.9;
      }
    }
    this._extent.setByCoordinates(this._cornersWgs84);
    let t2 = this._extent;
    if (t2.southWest.lat > Ge || t2.northEast.lat < We) {
      this._projType = 0;
      this.rendering = this._renderingProjType0;
    } else {
      this._projType = 1;
      this.rendering = this._renderingProjType1;
    }
    if (this._ready && !this._creationProceeding) {
      this._planet._geoImageCreator.add(this);
    }
  }
  _createFrame() {
    this._extentWgs84 = this._extent.clone();
    this._cornersMerc = [this._cornersWgs84[0].forwardMercatorEPS01(), this._cornersWgs84[1].forwardMercatorEPS01(), this._cornersWgs84[2].forwardMercatorEPS01(), this._cornersWgs84[3].forwardMercatorEPS01()];
    this._extentMerc = new Ye(this._extentWgs84.southWest.forwardMercatorEPS01(), this._extentWgs84.northEast.forwardMercatorEPS01());
    let e4 = new Float32Array(2);
    if (this._projType === 0) {
      zo(this._extentWgs84.southWest.lon, e4);
      this._extentWgs84ParamsHigh[0] = e4[0];
      this._extentWgs84ParamsLow[0] = e4[1];
      zo(this._extentWgs84.southWest.lat, e4);
      this._extentWgs84ParamsHigh[1] = e4[0];
      this._extentWgs84ParamsLow[1] = e4[1];
      this._extentWgs84ParamsHigh[2] = 2 / this._extentWgs84.getWidth();
      this._extentWgs84ParamsHigh[3] = 2 / this._extentWgs84.getHeight();
    } else {
      zo(this._extentMerc.southWest.lon, e4);
      this._extentMercParamsHigh[0] = e4[0];
      this._extentMercParamsLow[0] = e4[1];
      zo(this._extentMerc.southWest.lat, e4);
      this._extentMercParamsHigh[1] = e4[0];
      this._extentMercParamsLow[1] = e4[1];
      this._extentMercParamsHigh[2] = 2 / this._extentMerc.getWidth();
      this._extentMercParamsHigh[3] = 2 / this._extentMerc.getHeight();
    }
    if (this._planet) {
      let e5 = this._planet, t2 = e5.renderer.handler, i2 = t2.gl;
      i2.deleteTexture(this._materialTexture);
      this._materialTexture = t2.createEmptyTexture_l(this._frameWidth, this._frameHeight);
      let s2 = this._planet._geoImageCreator.createGridBuffer(this._cornersWgs84, this._projType === 1);
      this._gridBufferHigh = s2[0];
      this._gridBufferLow = s2[1];
      this._refreshFrame = false;
    }
  }
  abortMaterialLoading(e4) {
    this._creationProceeding = false;
    e4.isLoading = false;
    e4.isReady = false;
  }
  clear() {
    let e4 = this._planet;
    if (e4) {
      let t2 = e4.renderer.handler.gl;
      this._creationProceeding && e4._geoImageCreator.remove(this);
      e4._clearLayerMaterial(this);
      if (t2) {
        t2.deleteBuffer(this._gridBufferHigh);
        t2.deleteBuffer(this._gridBufferLow);
        t2.deleteTexture(this._sourceTexture);
        this._materialTexture && !this._materialTexture.default && t2.deleteTexture(this._materialTexture);
      }
    }
    this._sourceTexture = null;
    this._materialTexture = null;
    this._gridBufferHigh = null;
    this._gridBufferLow = null;
    this._refreshFrame = true;
    this._sourceCreated = false;
    this._ready = false;
    this._creationProceeding = false;
  }
  setVisibility(e4) {
    if (e4 !== this._visibility) {
      super.setVisibility(e4);
      if (this._planet && this._sourceReady) {
        if (e4) {
          this._planet._geoImageCreator.add(this);
        } else {
          this._planet._geoImageCreator.remove(this);
        }
      }
    }
  }
  clearMaterial(e4) {
    e4.texture = null;
    e4.isLoading = false;
    e4.isReady = false;
  }
  applyMaterial(e4) {
    let t2 = e4.segment;
    if (this._ready) {
      e4.applyTexture(this._materialTexture);
    } else {
      e4.texture = this._planet.transparentTexture;
      !this._creationProceeding && this.loadMaterial(e4);
    }
    let i2, s2;
    if (this._projType === 0) {
      i2 = this._extentWgs84;
      s2 = t2._extent;
    } else {
      i2 = this._extentMerc;
      s2 = t2.getExtentMerc();
    }
    let r2 = i2.northEast.lon - i2.southWest.lon;
    let n2 = i2.northEast.lat - i2.southWest.lat;
    let o2 = (s2.southWest.lon - i2.southWest.lon) / r2;
    let a2 = (i2.northEast.lat - s2.northEast.lat) / n2;
    let l2 = (s2.northEast.lon - s2.southWest.lon) / r2;
    let h2 = (s2.northEast.lat - s2.southWest.lat) / n2;
    return [o2, a2, l2, h2];
  }
  get getFrameWidth() {
    return this._frameWidth;
  }
  get getFrameHeight() {
    return this._frameHeight;
  }
  _createSourceTexture() {
  }
  _renderingProjType1() {
    let e4 = this._planet, t2 = e4.renderer.handler, i2 = t2.gl, s2 = e4._geoImageCreator;
    this._refreshFrame && this._createFrame();
    this._createSourceTexture();
    let r2 = s2._framebuffer;
    r2.setSize(this._frameWidth, this._frameHeight);
    r2.activate();
    t2.programs.geoImageTransform.activate();
    let n2 = t2.programs.geoImageTransform._program;
    let o2 = n2.attributes, a2 = n2.uniforms;
    i2.disable(i2.CULL_FACE);
    r2.bindOutputTexture(this._materialTexture);
    i2.clearColor(0, 0, 0, 0);
    i2.clear(i2.COLOR_BUFFER_BIT);
    i2.uniform1i(a2.isFullExtent, this._isFullExtent);
    i2.bindBuffer(i2.ARRAY_BUFFER, s2._texCoordsBuffer);
    i2.vertexAttribPointer(o2.texCoords, 2, i2.UNSIGNED_SHORT, true, 0, 0);
    i2.bindBuffer(i2.ARRAY_BUFFER, this._gridBufferHigh);
    i2.vertexAttribPointer(o2.cornersHigh, this._gridBufferHigh.itemSize, i2.FLOAT, false, 0, 0);
    i2.bindBuffer(i2.ARRAY_BUFFER, this._gridBufferLow);
    i2.vertexAttribPointer(o2.cornersLow, this._gridBufferLow.itemSize, i2.FLOAT, false, 0, 0);
    i2.uniform4fv(a2.extentParamsHigh, this._extentMercParamsHigh);
    i2.uniform4fv(a2.extentParamsLow, this._extentMercParamsLow);
    i2.activeTexture(i2.TEXTURE0);
    i2.bindTexture(i2.TEXTURE_2D, this._sourceTexture);
    i2.uniform1i(a2.sourceTexture, 0);
    i2.bindBuffer(i2.ELEMENT_ARRAY_BUFFER, s2._indexBuffer);
    i2.drawElements(i2.TRIANGLE_STRIP, s2._indexBuffer.numItems, i2.UNSIGNED_INT, 0);
    r2.deactivate();
    i2.enable(i2.CULL_FACE);
    this._ready = true;
    this._creationProceeding = false;
  }
  _renderingProjType0() {
    let e4 = this._planet, t2 = e4.renderer.handler, i2 = t2.gl, s2 = e4._geoImageCreator;
    this._refreshFrame && this._createFrame();
    this._createSourceTexture();
    let r2 = s2._framebuffer;
    r2.setSize(this._frameWidth, this._frameHeight);
    r2.activate();
    t2.programs.geoImageTransform.activate();
    let n2 = t2.programs.geoImageTransform._program;
    let o2 = n2.attributes, a2 = n2.uniforms;
    i2.disable(i2.CULL_FACE);
    r2.bindOutputTexture(this._materialTexture);
    i2.clearColor(0, 0, 0, 0);
    i2.clear(i2.COLOR_BUFFER_BIT);
    i2.bindBuffer(i2.ARRAY_BUFFER, s2._texCoordsBuffer);
    i2.vertexAttribPointer(o2.texCoords, 2, i2.UNSIGNED_SHORT, true, 0, 0);
    i2.bindBuffer(i2.ARRAY_BUFFER, this._gridBufferHigh);
    i2.vertexAttribPointer(o2.cornersHigh, this._gridBufferHigh.itemSize, i2.FLOAT, false, 0, 0);
    i2.bindBuffer(i2.ARRAY_BUFFER, this._gridBufferLow);
    i2.vertexAttribPointer(o2.cornersLow, this._gridBufferLow.itemSize, i2.FLOAT, false, 0, 0);
    i2.uniform4fv(a2.extentParamsHigh, this._extentWgs84ParamsHigh);
    i2.uniform4fv(a2.extentParamsLow, this._extentWgs84ParamsLow);
    i2.activeTexture(i2.TEXTURE0);
    i2.bindTexture(i2.TEXTURE_2D, this._sourceTexture);
    i2.uniform1i(a2.sourceTexture, 0);
    i2.bindBuffer(i2.ELEMENT_ARRAY_BUFFER, s2._indexBuffer);
    i2.drawElements(i2.TRIANGLE_STRIP, s2._indexBuffer.numItems, i2.UNSIGNED_INT, 0);
    r2.deactivate();
    i2.enable(i2.CULL_FACE);
    this._ready = true;
    this._creationProceeding = false;
  }
}
const kl = `<?xml version="1.0" encoding="UTF-8" standalone="no"?> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M16 13l6.964 4.062-2.973.85 2.125 3.681-1.732 1-2.125-3.68-2.223 2.15L16 13zm-2-7h2v2h5a1 1 0 0 1 1 1v4h-2v-3H10v10h4v2H9a1 1 0 0 1-1-1v-5H6v-2h2V9a1 1 0 0 1 1-1h5V6zM4 14v2H2v-2h2zm0-4v2H2v-2h2zm0-4v2H2V6h2zm0-4v2H2V2h2zm4 0v2H6V2h2zm4 0v2h-2V2h2zm4 0v2h-2V2h2z" fill="#000"/></svg>`;
class Il extends ns {
  constructor(e4 = {}) {
    super(e4);
    this._cornerIndex = -1;
    this._catchCorner = false;
    this._toggleBtn = new _s({ classList: ["og-map-button", "og-geoimagegrag_button"], icon: kl });
  }
  oninit() {
    this._toggleBtn.appendTo(this.renderer.div);
    this.planet.events.on("layeradd", (e4) => {
      if (this.isActive()) {
        this._bindLayer(e4);
      }
    }, this);
    this._toggleBtn.events.on("change", (e4) => {
      if (e4) {
        this.activate();
      } else {
        this.deactivate();
      }
    });
  }
  onactivate() {
    super.onactivate();
    const e4 = this.planet;
    for (let t2 = 0; t2 < e4.layers.length; t2++) {
      this._bindLayer(e4.layers[t2]);
    }
  }
  ondeactivate() {
    super.ondeactivate();
    const e4 = this.planet;
    for (let t2 = 0; t2 < e4.layers.length; t2++) {
      this._unbindLayer(e4.layers[t2]);
    }
  }
  _bindLayer(e4) {
    if (e4 instanceof Bl) {
      e4.events.on("mousemove", this._onMouseMove, this);
      e4.events.on("mouseleave", this._onMouseLeave, this);
      e4.events.on("ldown", this._onLDown, this);
      e4.events.on("lup", this._onLUp, this);
    }
  }
  _unbindLayer(e4) {
    if (e4 instanceof Bl) {
      e4.events.off("mousemove", this._onMouseMove);
      e4.events.off("mouseleave", this._onMouseLeave);
      e4.events.off("ldown", this._onLDown);
      e4.events.off("lup", this._onLUp);
    }
  }
  _onLUp(e4) {
    this._catchCorner = false;
    e4.renderer.controls.mouseNavigation.activate();
  }
  _onLDown(e4) {
    if (this._cornerIndex !== -1) {
      this._catchCorner = true;
      e4.renderer.controls.mouseNavigation.deactivate();
    }
  }
  _onMouseLeave() {
    document.body.style.cursor = "auto";
  }
  _onMouseMove(e4) {
    let t2 = e4.pickingObject;
    const i2 = this.planet;
    if (this._catchCorner) {
      let s2 = t2.getCornersLonLat();
      s2[this._cornerIndex] = i2.getLonLatFromPixelTerrain(e4);
      t2.setCornersLonLat(s2);
    } else {
      this._cornerIndex = -1;
      for (let s2 = 0; s2 < t2._cornersWgs84.length; s2++) {
        let r2 = i2.getLonLatFromPixelTerrain(e4);
        if (r2 && i2.ellipsoid.getGreatCircleDistance(t2._cornersWgs84[s2], r2) / i2.getDistanceFromPixel(e4) <= 0.05) {
          this._cornerIndex = s2;
          document.body.style.cursor = "move";
          break;
        } else {
          document.body.style.cursor = "auto";
        }
      }
    }
  }
}
const zl = { MB_LEFT: 0, MB_RIGHT: 2, MB_MIDDLE: 1, KEY_CTRL: 17, KEY_ALT: 18, KEY_SHIFT: 16, KEY_SPACE: 32, KEY_PGUP: 33, KEY_PGDN: 34, KEY_LEFT: 37, KEY_UP: 38, KEY_RIGHT: 39, KEY_DOWN: 40, KEY_PRINTSCREEN: 44, KEY_EQUALS: 61, KEY_A: 65, KEY_C: 67, KEY_D: 68, KEY_E: 69, KEY_F: 70, KEY_H: 72, KEY_I: 73, KEY_K: 75, KEY_L: 76, KEY_N: 78, KEY_O: 79, KEY_P: 80, KEY_Q: 81, KEY_R: 82, KEY_S: 83, KEY_V: 86, KEY_W: 87, KEY_X: 88, KEY_Z: 90, KEY_PLUS: 107, KEY_F1: 112, KEY_MINUS: 173, KEY_APOSTROPHE: 192, KEY_BACK_SLASH: 220, KEY_MORE: 190, KEY_SLASH: 191, KEY_LESS: 188, KEY_LEFT_SQUARE_BRACKET: 219, KEY_RIGHT_SQUARE_BRACKET: 221, KEY_SINGLE_QUOTE: 222 };
class Dl extends ns {
  constructor(e4 = {}) {
    e4 = e4 || {};
    super({ name: "KeyboardNavigation", ...e4 });
    this.onCameraPitchUp = () => {
      if (this._camera) {
        this._camera.setPitch(this._camera.getPitch() + 0.1 * d);
      }
    };
    this.onCameraPitchDown = () => {
      if (this._camera) {
        this._camera.setPitch(this._camera.getPitch() - 0.1 * d);
      }
    };
    this.onCameraYawLeft = () => {
      if (this._camera) {
        this._camera.setYaw(this._camera.getYaw() - 0.1 * d);
      }
    };
    this.onCameraYawRight = () => {
      if (this._camera) {
        this._camera.setYaw(this._camera.getYaw() + 0.1 * d);
      }
    };
    this.onCameraMoveForward = () => {
      if (this._camera) {
        this.force.addA(this._camera.getForward()).normalize();
      }
    };
    this.onCameraMoveBackward = () => {
      if (this._camera) {
        this.force.addA(this._camera.getBackward()).normalize();
      }
    };
    this._camera = e4.camera || null;
    this.speed = e4.speed || 10;
    this.force = new Ke();
    this.vel = new Ke();
    this.mass = 1;
  }
  bindCamera(e4) {
    this._camera = e4;
  }
  onactivate() {
    let e4 = this.renderer;
    e4.events.on("keypress", zl.KEY_S, this.onCameraMoveBackward, this);
    e4.events.on("keypress", zl.KEY_W, this.onCameraMoveForward, this);
    e4.events.on("keypress", zl.KEY_UP, this.onCameraPitchUp, this);
    e4.events.on("keypress", zl.KEY_DOWN, this.onCameraPitchDown, this);
    e4.events.on("keypress", zl.KEY_LEFT, this.onCameraYawLeft, this);
    e4.events.on("keypress", zl.KEY_RIGHT, this.onCameraYawRight, this);
    e4.events.on("draw", this.onDraw, this, -1e3);
  }
  ondeactivate() {
    this.renderer;
  }
  oninit() {
    this.activate();
  }
  get dt() {
    return 1e-3 * this.renderer.handler.deltaTime;
  }
  onDraw() {
    if (this.renderer && this._camera) {
      let e4 = this.force.scale(1 / this.mass);
      this.vel.addA(e4);
      this.vel.scale(0.96);
      this.force.set(0, 0, 0);
      let t2 = this._camera;
      t2.eye = t2.eye.add(this.vel.scaleTo(this.dt));
      t2.update();
    }
  }
}
const Fl = ["change", "idle", "play", "pause", "stop"];
class Nl extends ns {
  constructor(e4 = {}) {
    super(e4);
    this._currVisibleIndex = 0;
    this._onViewchange = () => {
      this._timeoutStart = performance.now();
    };
    this._onVisibilityChange = (e5) => {
      if (!e5) {
        this.pause();
      }
    };
    this._onLayerLoadend = (e5) => {
      let t2 = this._layersArr[this._currentIndex];
      if (t2 && t2.isEqual(e5)) {
        let e6 = this._getFrameIndex(this._currentIndex);
        let i2 = e6 * this._frameSize, s2 = this._currentIndex;
        for (let e7 = i2; e7 < s2; e7++) {
          let t3 = this._layersArr[e7];
          t3.opacity = 0;
          t3.setVisibility(false);
        }
        t2.opacity = 1;
        let r2 = this._layersArr[this._currVisibleIndex];
        if (r2) {
          r2.opacity = 0;
          r2.setVisibility(false);
          let e7 = this._getFrameIndex(this._currVisibleIndex);
          if (this._getFrameIndex(this._currentIndex) !== e7) {
            this._removeFrameFromPlanet(e7);
          }
        }
        this.events.dispatch(this.events.idle, t2);
      }
    };
    this.events = Qi(Fl);
    this._name = e4.name || `layerAnimation-${this.__id}`;
    this._layersArr = e4.layers ? [].concat(e4.layers) : [];
    this._currentIndex = -1;
    this._playInterval = e4.playInterval || 120;
    this._playIntervalHandler = -1;
    this._playIndex = 0;
    this._frameSize = e4.frameSize || 50;
    this.repeat = e4.repeat != void 0 ? e4.repeat : true;
    this.skipTimeout = e4.skipTimeout || 5e3;
    this._timeoutStart = 0;
  }
  _getFramesNum() {
    return Math.ceil(this._layersArr.length / this._frameSize);
  }
  _setFrame(e4) {
    for (let t2 = 0, i2 = this._getFramesNum(); t2 < i2; t2++) {
      if (t2 !== e4) {
        this._removeFrameFromPlanet(t2);
      } else {
        this._appendFrameToPlanet(t2);
      }
    }
  }
  _getFrameIndex(e4) {
    return Math.floor(e4 / this._frameSize);
  }
  _appendFrameToPlanet(e4) {
    if (this.planet) {
      let t2 = e4 * this._frameSize;
      let i2 = t2 + this._frameSize;
      for (let e5 = t2, s2 = i2 > this._layersArr.length ? this._layersArr.length : i2; e5 < s2; e5++) {
        this.planet.addLayer(this._layersArr[e5]);
      }
    }
  }
  _removeFrameFromPlanet(e4) {
    if (this.planet) {
      let t2 = e4 * this._frameSize;
      let i2 = t2 + this._frameSize;
      for (let e5 = t2, s2 = i2 > this._layersArr.length ? this._layersArr.length : i2; e5 < s2; e5++) {
        this._layersArr[e5].abortLoading();
        this._layersArr[e5].remove();
        this._layersArr[e5].setVisibility(false);
      }
    }
  }
  oninit() {
    super.oninit();
    this.onactivate();
    this._initLayers();
    this.planet.events.on("layerloadend", this._onLayerLoadend);
    this._setCurrentIndexAsync(0, false, true);
  }
  onactivate() {
    super.onactivate();
    this.planet.camera.events.on("viewchange", this._onViewchange);
    this.planet.renderer.handler.events.on("visibilitychange", this._onVisibilityChange);
  }
  ondeactivate() {
    super.ondeactivate();
    this.planet.camera.events.off("viewchange", this._onViewchange);
    for (let e4 = 0; e4 < this._layersArr.length; e4++) {
      this._layersArr[e4].setVisibility(false);
    }
    this.planet.events.off("layerloadend", this._onLayerLoadend);
    this.planet.renderer.handler.events.off("visibilitychange", this._onVisibilityChange);
  }
  clear() {
    this.stop();
    this._currentIndex = -1;
    this._currVisibleIndex = -1;
    let e4 = this._layersArr;
    this._layersArr = [];
    for (let t2 = 0; t2 < e4.length; t2++) {
      e4[t2].remove();
    }
  }
  _initLayers() {
    if (this.planet) {
      for (let e4 = 0, t2 = this._layersArr.length; e4 < t2; e4++) {
        let t3 = this._layersArr[e4];
        t3.setVisibility(false);
        t3.setBaseLayer(false);
        t3.opacity = 0;
      }
      this._appendFrameToPlanet(0);
    }
  }
  setLayers(e4) {
    this.clear();
    this._layersArr = [].concat(e4);
    this._initLayers();
  }
  appendLayer(e4) {
    var _a2;
    this._layersArr.push(e4);
    e4.setVisibility(false);
    e4.setBaseLayer(false);
    e4.opacity = 0;
    (_a2 = this.planet) == null ? void 0 : _a2.addLayer(e4);
  }
  get isIdle() {
    let e4 = this._layersArr[this._currentIndex];
    return e4 && e4.isIdle || !e4;
  }
  get playInterval() {
    return this._playInterval;
  }
  set playInterval(e4) {
    if (e4 !== this._playInterval) {
      this._playInterval = e4;
      if (this.isPlaying) {
        this.pause();
        this.play();
      }
    }
  }
  get isPlaying() {
    return this._playIntervalHandler !== -1;
  }
  get layers() {
    return this._layersArr;
  }
  _checkEnd() {
    if (this._playIndex > this._layersArr.length) {
      if (this.repeat) {
        this._playIndex = 0;
      } else {
        this.pause();
      }
    }
  }
  play() {
    if (!this.isPlaying) {
      if (this._currentIndex >= this._layersArr.length - 1) {
        this.stop();
      }
      this._timeoutStart = performance.now();
      this._playIntervalHandler = setInterval(() => {
        this._checkEnd();
        this._setCurrentIndexAsync(this._playIndex, false, false);
        requestAnimationFrame(() => {
          if (this.isIdle || performance.now() - this._timeoutStart > this.skipTimeout) {
            this._playIndex++;
            this._timeoutStart = performance.now();
          }
        });
      }, this._playInterval);
      this.events.dispatch(this.events.play);
    }
  }
  stop() {
    if (this._playIndex > 0) {
      this._clearInterval();
      this._playIndex = 0;
      this.setCurrentIndex(0);
      this.events.dispatch(this.events.stop);
    }
  }
  pause() {
    if (this.isPlaying) {
      this._clearInterval();
      this.events.dispatch(this.events.pause);
    }
  }
  _clearInterval() {
    clearInterval(this._playIntervalHandler);
    this._playIntervalHandler = -1;
  }
  setCurrentIndex(e4, t2 = false) {
    this._setCurrentIndexAsync(e4, true, t2);
  }
  _setCurrentIndexAsync(e4, t2 = false, i2 = false) {
    if (e4 != this._currentIndex && e4 >= 0 && e4 < this._layersArr.length) {
      let s2 = this._currentIndex;
      this._currentIndex = e4;
      this._playIndex = e4;
      let r2 = this._getFrameIndex(s2);
      let n2 = this._getFrameIndex(this._currentIndex);
      let o2 = this._layersArr[s2], a2 = this._layersArr[e4];
      let l2 = n2 != r2;
      if (l2) {
        this._appendFrameToPlanet(n2);
      }
      if (o2) {
        if (o2.isIdle) {
          this._currVisibleIndex = s2;
        } else {
          o2.opacity = 0;
          o2.setVisibility(false);
        }
      }
      if (a2) {
        a2.opacity = 0;
        a2.setVisibility(true);
        requestAnimationFrame(() => {
          if (a2.isIdle || t2) {
            a2.opacity = 1;
            if (l2) {
              this._removeFrameFromPlanet(r2);
            }
            if (o2) {
              o2.opacity = 0;
              o2.setVisibility(false);
            }
            let e5 = this._layersArr[this._currVisibleIndex];
            if (e5) {
              e5.opacity = 0;
              e5.setVisibility(false);
            }
          }
        });
        if (!i2) {
          this.events.dispatch(this.events.change, this._currentIndex, s2);
        }
      }
    }
  }
}
const Ol = `<?xml version="1.0" encoding="utf-8"?>
<!-- Svg Vector Icons : http://www.onlinewebfonts.com/icon -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 1000 1000" enable-background="new 0 0 1000 1000" xml:space="preserve">
<metadata> Svg Vector Icons : http://www.onlinewebfonts.com/icon </metadata>
<g><path d="M500,573.5c-3.2,0-6.5-0.6-9.5-1.9L25,375.6c-9.1-3.8-15-12.7-15-22.6s5.9-18.8,15-22.6l465.5-196c6.1-2.5,12.9-2.5,19,0l465.5,196c9.1,3.8,15,12.7,15,22.6s-5.9,18.8-15,22.6l-465.5,196C506.5,572.9,503.2,573.5,500,573.5L500,573.5z M97.6,353L500,522.4L902.4,353L500,183.6L97.6,353L97.6,353z"/><path d="M500,720.5c-3.2,0-6.5-0.6-9.5-1.9L25,522.6c-12.4-5.2-18.3-19.6-13.1-32.1c5.2-12.5,19.6-18.3,32.1-13.1l456,192l456-192c12.4-5.2,26.9,0.6,32.1,13.1s-0.6,26.9-13.1,32.1l-465.5,196C506.5,719.9,503.2,720.5,500,720.5L500,720.5z"/><path d="M500,867.5c-3.2,0-6.5-0.6-9.5-1.9L25,669.6c-12.4-5.2-18.3-19.6-13.1-32.1c5.2-12.5,19.6-18.3,32.1-13.1l456,192l456-192c12.4-5.2,26.9,0.6,32.1,13.1c5.2,12.5-0.6,26.8-13.1,32.1l-465.5,196C506.5,866.9,503.2,867.5,500,867.5L500,867.5z"/></g>
</svg>`;
const Hl = `<div class="og-layerSwitcher">
      <div class="og-layerSwitcher__title">Base Layers</div>
      <div class="og-layerSwitcher__list og-layerSwitcher__baseLayers"></div>        
        
      <div class="og-layerSwitcher__title">Overlays</div>
      <div class="og-layerSwitcher__list og-layerSwitcher__overlays"></div>
         
    </div>`;
const Vl = `<button title={title} class="og-layerSwitcher__layerButton">{icon}<div class="og-layerSwitcher__name">{name}</div></button>`;
class Ul extends ts {
  constructor(e4) {
    super({ template: ft(Vl, { title: e4.model.name, name: e4.model.name, icon: e4.model.iconSrc ? `<img src="${e4.model.iconSrc}" />` : "" }), ...e4 });
    this._onVisibilityChange = (e5) => {
      if (this.el) {
        if (this.model.getVisibility()) {
          this.el.classList.add("og-layerSwitcher__visible");
        } else {
          this.el.classList.remove("og-layerSwitcher__visible");
        }
      }
    };
    this._onClick = () => {
      if (this.model.isBaseLayer()) {
        this.model.setVisibility(true);
      } else {
        this.model.setVisibility(!this.model.getVisibility());
      }
    };
    this._onDblClick = () => {
      this.model.flyExtent();
    };
  }
  render(e4) {
    super.render(e4);
    this.model.events.on("visibilitychange", this._onVisibilityChange);
    this._onVisibilityChange(this.model);
    this.el.addEventListener("click", this._onClick);
    this.el.addEventListener("dblclick", this._onDblClick);
    return this;
  }
  remove() {
    super.remove();
    this.model.events.off("visibilitychange", this._onVisibilityChange);
  }
}
class Gl extends ns {
  constructor(e4 = {}) {
    super({ name: "LayerSwitcher", ...e4 });
    this.addLayer = (e5) => {
      if (!e5.hideInLayerSwitcher) {
        let t2 = this._createLayerButton(e5);
        this._layerViews.push(t2);
        if (e5.isBaseLayer()) {
          t2.appendTo(this.$baseLayers);
        } else {
          t2.appendTo(this.$overlays);
        }
      }
    };
    this.removeLayer = (e5) => {
      for (let t2 = 0; t2 < this._layerViews.length; t2++) {
        let i2 = this._layerViews[t2];
        if (i2.model.isEqual(e5)) {
          i2.remove();
          this._layerViews.splice(t2, 1);
          break;
        }
      }
    };
    this._dialog = new ds({ title: "Layer Switcher", top: 15, useHide: true, visible: false, width: 300, maxHeight: 500 });
    this._panel = new ts({ template: Hl });
    this._toggleBtn = new _s({ classList: ["og-map-button", "og-layerSwitcher_button"], icon: Ol });
    this.$baseLayers = null;
    this.$overlays = null;
    this._layerViews = [];
  }
  oninit() {
    this._toggleBtn.appendTo(this.renderer.div);
    this._dialog.appendTo(this.planet.renderer.div);
    this._panel.appendTo(this._dialog.container);
    this.$baseLayers = this._panel.el.querySelector(".og-layerSwitcher__baseLayers");
    this.$overlays = this._panel.el.querySelector(".og-layerSwitcher__overlays");
    this._dialog.setPosition(this.planet.renderer.div.clientWidth - this._dialog.width - 67);
    this._dialog.events.on("visibility", (e4) => {
      this._toggleBtn.setActive(e4);
    });
    this._toggleBtn.events.on("change", (e4) => {
      this._dialog.setVisibility(e4);
    });
    this.planet.events.on("layeradd", this.addLayer, this);
    this.planet.events.on("layerremove", this.removeLayer, this);
    this._initLayers();
  }
  _initLayers() {
    let e4 = this.planet.layers;
    for (let t2 = 0; t2 < e4.length; t2++) {
      this.addLayer(e4[t2]);
    }
  }
  _createLayerButton(e4) {
    return new Ul({ model: e4 });
  }
  onactivate() {
  }
  ondeactivate() {
    this._dialog.hide();
  }
}
const Wl = ["change"];
const jl = `<div class="og-slider">
      <div class="og-slider-label">{label}</div>
      <div class="og-slider-panel">
        <div class="og-slider-progress"></div>      
        <div class="og-slider-pointer"></div>
      </div>
      <input type="number"/>
    </div>`;
class Yl extends ts {
  constructor(e4 = {}) {
    super({ template: ft(jl, { label: e4.label || "" }) });
    this._onResize = () => {
      this._setOffset((this._value - this._min) * this.$panel.clientWidth / (this._max - this._min));
    };
    this._onMouseWheel = (e5) => {
      e5 = e5 || window.event;
      e5.preventDefault();
      e5.stopPropagation();
      this.value = this._value + Math.sign(e5.wheelDelta) * (this._max - this._min) / 100;
    };
    this._onMouseWheelFF = (e5) => {
      this._onMouseWheel(e5);
    };
    this._onInput = (e5) => {
      e5 = e5 || window.event;
      e5.preventDefault();
      e5.stopPropagation();
      this.value = parseFloat(e5.target.value);
    };
    this._onMouseDown = (e5) => {
      e5 = e5 || window.event;
      e5.preventDefault();
      this._startPosX = e5.clientX;
      this.value = this._min + (this._max - this._min) * (e5.offsetX / this.$panel.clientWidth);
      document.addEventListener("mousemove", this._onMouseMove);
      document.addEventListener("mouseup", this._onMouseUp);
    };
    this._onMouseMove = (e5) => {
      e5 = e5 || window.event;
      e5.preventDefault();
      e5.stopPropagation();
      let t2 = this.$panel.getBoundingClientRect();
      let i2 = U(e5.clientX, t2.left, t2.right);
      let s2 = this._startPosX - i2;
      this._startPosX = i2;
      this.value = this._value - s2 * (this._max - this._min) / this.$panel.clientWidth;
    };
    this._onMouseUp = () => {
      document.removeEventListener("mouseup", this._onMouseUp);
      document.removeEventListener("mousemove", this._onMouseMove);
    };
    this.events = this.events.registerNames(Wl);
    this._value = e4.value || 0;
    this._min = e4.min || 0;
    this._max = e4.max || 1;
    this._resizeObserver = new ResizeObserver(this._onResize);
    this._startPosX = 0;
    this.$label = null;
    this.$pointer = null;
    this.$progress = null;
    this.$input = null;
    this.$panel = null;
  }
  render(e4) {
    super.render(e4);
    this.$label = this.select(".og-slider-label");
    if (this.$label.innerHTML === "") {
      this.$label.style.display = "none";
    }
    this.$pointer = this.select(".og-slider-pointer");
    this.$progress = this.select(".og-slider-progress");
    this.$panel = this.select(".og-slider-panel");
    this.$input = this.select("input");
    this._resizeObserver.observe(this.el);
    this._initEvents();
    return this;
  }
  set value(e4) {
    if (e4 !== this._value) {
      this._value = U(e4, this._min, this._max);
      this.$input.value = this._value.toString();
      this._setOffset((this._value - this._min) * this.$panel.clientWidth / (this._max - this._min));
      this.events.dispatch(this.events.change, this._value, this);
    }
  }
  get value() {
    return this._value;
  }
  _initEvents() {
    this.$panel.addEventListener("mousedown", this._onMouseDown);
    this.$panel.addEventListener("mousewheel", this._onMouseWheel);
    this.$panel.addEventListener("wheel", this._onMouseWheelFF);
    this.$input.addEventListener("input", this._onInput);
  }
  _clearEvents() {
    this.$panel.removeEventListener("mousedown", this._onMouseDown);
    this.$panel.removeEventListener("mousewheel", this._onMouseWheel);
    this.$panel.removeEventListener("wheel", this._onMouseWheelFF);
    this.$input.removeEventListener("input", this._onInput);
  }
  _setOffset(e4) {
    if (e4 >= 0 && e4 <= this.$panel.clientWidth) {
      this.$pointer.style.left = this.$progress.style.width = `${e4 * 100 / this.$panel.clientWidth}%`;
    }
  }
  remove() {
    this._clearEvents();
    super.remove();
  }
}
const ql = ["input"];
const $l = `<div class="og-color">
      <label for="{id}" class="og-color-label">{label}</label>
      <input type="color" name="{id}" value="{value}"/>
    </div>`;
let Xl = 0;
class Zl extends ts {
  constructor(e4 = {}) {
    super({ template: ft($l, { id: `color-${Xl++}`, label: e4.label || "", value: e4.value || "#000000" }) });
    this._onInput = (e5) => {
      this.value = e5.target.value;
    };
    this.events = this.events.registerNames(ql);
    this._value = e4.value || "blue";
    this.$label = null;
    this.$input = null;
  }
  render(e4) {
    super.render(e4);
    this.$label = this.select(".og-color-label");
    if (this.$label.innerHTML === "") {
      this.$label.style.display = "none";
    }
    this.$input = this.select("input");
    this._initEvents();
    return this;
  }
  set value(e4) {
    if (e4 !== this._value) {
      this._value = e4;
      this.$input.value = this._value;
      this.events.dispatch(this.events.input, this._value, this);
    }
  }
  get value() {
    return this._value;
  }
  _initEvents() {
    this.$input.addEventListener("input", this._onInput);
  }
  _clearEvents() {
    this.$input.removeEventListener("input", this._onInput);
  }
  remove() {
    this._clearEvents();
    super.remove();
  }
}
const Kl = `<?xml version="1.0" encoding="utf-8"?><svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 122.88 70.41" style="enable-background:new 0 0 122.88 70.41" xml:space="preserve"><g><path d="M60.91,19.12c6.95,0,13.24,2.95,17.8,7.72c4.55,4.77,7.37,11.37,7.37,18.64c0,1.94-0.2,3.83-0.58,5.65h31.61 c2.1,0,2.62,1.16,2.62,2.59c0,1.43-0.52,2.59-2.62,2.59H7.09c-2.1,0-2.62-1.16-2.62-2.59c0-1.43,0.52-2.59,2.62-2.59h29.23 c-0.38-1.82-0.58-3.71-0.58-5.65c0-7.28,2.82-13.87,7.37-18.64C47.67,22.08,53.96,19.12,60.91,19.12L60.91,19.12L60.91,19.12z M63.4,70.41c-2.1,0-2.62-1.16-2.62-2.59s0.52-2.59,2.62-2.59h56.86c2.1,0,2.62,1.16,2.62,2.59s-0.52,2.59-2.62,2.59H63.4 L63.4,70.41z M2.62,70.41c-2.1,0-2.62-1.16-2.62-2.59s0.52-2.59,2.62-2.59h29.51c2.1,0,2.62,1.16,2.62,2.59s-0.52,2.59-2.62,2.59 H2.62L2.62,70.41z M38.39,9.46c-0.78-1.35-0.32-3.07,1.03-3.85c1.35-0.78,3.07-0.32,3.85,1.03l3.62,6.27 c0.78,1.35,0.32,3.07-1.03,3.85c-1.35,0.78-3.07,0.32-3.85-1.03L38.39,9.46L38.39,9.46L38.39,9.46z M58.67,2.83 c0-1.56,1.27-2.83,2.83-2.83c1.56,0,2.83,1.27,2.83,2.83v7.24c0,1.56-1.27,2.83-2.83,2.83c-1.56,0-2.83-1.26-2.83-2.83V2.83 L58.67,2.83L58.67,2.83z M79.56,7.23c0.77-1.35,2.49-1.81,3.84-1.04c1.35,0.77,1.81,2.49,1.04,3.84l-3.62,6.27 c-0.77,1.35-2.49,1.81-3.84,1.04c-1.35-0.77-1.81-2.49-1.04-3.84L79.56,7.23L79.56,7.23L79.56,7.23z M95.45,21.48 c1.35-0.78,3.07-0.32,3.85,1.03c0.78,1.35,0.32,3.07-1.03,3.85L92,29.98c-1.35,0.78-3.07,0.32-3.85-1.03 c-0.78-1.35-0.32-3.07,1.03-3.85L95.45,21.48L95.45,21.48L95.45,21.48z M102.08,41.76c1.56,0,2.83,1.27,2.83,2.83 c0,1.56-1.27,2.83-2.83,2.83h-7.24c-1.56,0-2.83-1.26-2.83-2.83s1.26-2.83,2.83-2.83H102.08L102.08,41.76L102.08,41.76z M19.74,46.25c-1.56,0-2.83-1.27-2.83-2.83c0-1.56,1.27-2.83,2.83-2.83h7.24c1.56,0,2.83,1.26,2.83,2.83s-1.27,2.83-2.83,2.83 H19.74L19.74,46.25L19.74,46.25z M24.14,25.35c-1.35-0.77-1.81-2.49-1.04-3.84c0.77-1.35,2.49-1.81,3.84-1.04l6.27,3.62 c1.35,0.77,1.81,2.49,1.04,3.84c-0.77,1.35-2.49,1.81-3.84,1.04L24.14,25.35L24.14,25.35L24.14,25.35z"/></g></svg>`;
const Ql = `<?xml version="1.0"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
    <path style="text-indent:0;text-align:start;line-height:normal;text-transform:none;block-progression:tb;-inkscape-font-specification:Sans" d="M 16 4 C 9.3844277 4 4 9.3844277 4 16 C 4 22.615572 9.3844277 28 16 28 C 22.615572 28 28 22.615572 28 16 C 28 9.3844277 22.615572 4 16 4 z M 16 6 C 16.389823 6 16.778223 6.0506339 17.15625 6.09375 C 18.631659 7.6568432 21 10.9245 21 16 C 21 21.0755 18.631659 24.343157 17.15625 25.90625 C 16.778223 25.949366 16.389823 26 16 26 C 10.465308 26 6 21.534692 6 16 C 6 10.465308 10.465308 6 16 6 z" overflow="visible" font-family="Sans"/>
</svg>
`;
const Jl = `<?xml version="1.0" encoding="utf-8"?>
<!-- Generated by IcoMoon.io -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="512" height="512" viewBox="0 0 512 512">
<g>
</g>
	<path d="M257.894 156.948c-53.258 0-96.42 43.561-96.42 97.26 0 53.719 43.161 97.249 96.42 97.249 53.197 0 96.379-43.53 96.379-97.25 0-53.698-43.182-97.26-96.379-97.26zM257.894 309.873c-30.464 0-55.163-24.945-55.163-55.665s24.699-55.624 55.163-55.624c30.423 0 55.101 24.904 55.101 55.624s-24.688 55.665-55.101 55.665z" fill="#000000" />
	<path d="M241.808 43.499h32.144v79.575h-32.144v-79.575z" fill="#000000" />
	<path d="M417.209 115.897l-22.723-22.917-55.757 56.279 22.723 22.907z" fill="#000000" />
	<path d="M389.468 238.407h78.899v32.389h-78.899v-32.389z" fill="#000000" />
	<path d="M396.012 416.86l22.723-22.917-55.767-56.259-22.712 22.897z" fill="#000000" />
	<path d="M242.473 388.915h32.144v79.575h-32.144v-79.575z" fill="#000000" />
	<path d="M96.266 396.073l22.722 22.938 55.778-56.289-22.692-22.928z" fill="#000000" />
	<path d="M43.633 240.537h78.879v32.43h-78.879v-32.43z" fill="#000000" />
	<path d="M115.394 93.051l-22.681 22.907 55.757 56.258 22.702-22.917z" fill="#000000" />
</svg>`;
const eh = `<?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path fill="#000000" d="M135.688 18.5c-6.798 74.842-23.842 85.39-107.907 59.656 84.85 52.022 73.57 64.954-6.843 96.938 87.743-10.27 103.29 4.89 70.75 87.594 17.805-27.56 32.5-44.498 46.282-54.47-11.813 28.26-18.345 59.274-18.345 91.813 0 84.184 43.71 157.96 109.656 200.376-41.624-43.834-67.686-102.7-67.686-167.875 0-134.923 109.45-244.405 244.375-244.405 30.92 0 60.76 5.762 88 16.25-38.584-26.87-85.517-42.625-136.064-42.625-55.257 0-106.14 18.802-146.562 50.375 4.627-18.783 17.39-38.073 41.03-60.906C190.18 90.942 153.53 95.634 135.69 18.5zm10.03 77.188c5.67.002 11.428 1.247 16.876 3.874 14.506 6.998 22.72 21.81 22 36.938-10.26 10.87-19.507 22.696-27.594 35.344-9.035 2.753-19.075 2.27-28.25-2.156-19.37-9.343-27.5-32.6-18.156-51.97 6.715-13.92 20.638-22.036 35.125-22.03z"/></svg>`;
const th = `<div class="og-lighing og-options-container">

         <div class="og-option">
           <div class="og-suncontrol"></div>
         </div>        
         
         <div class="og-option og-atmosphere-opacity">
         </div>
         
         <div class="og-option og-simpleskybackground">
         </div>
         
        <div class="og-lighting-emptyline"></div>

         <div class="og-option og-gamma"></div>         
         <div class="og-option og-exposure"></div>
       
        <div class="og-lighting-emptyline"></div>

         <div class="og-option">
         <div class="og-layers">
           <div class="og-caption">Select layer:</div>
           <select id="layers"></select>
         </div>
         </div>

         <div class="og-option og-opacity">
         </div>
         
         <div class="og-option og-night">
         </div>
         
         <div class="og-lighting-emptyline"></div>

         <div class="og-option og-diffuse">
         </div>
      
         <div class="og-option og-ambient">
         </div>

         <div class="og-option og-specular">
         </div>        

    </div>`;
const ih = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="256" height="256" viewBox="0 0 256 256" xml:space="preserve">

<defs>
</defs>
<g style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; opacity: 1;" transform="translate(1.4065934065934016 1.4065934065934016) scale(2.81 2.81)" >
	<path d="M 45 68 c -12.682 0 -23 -10.317 -23 -23 c 0 -12.682 10.318 -23 23 -23 c 12.683 0 23 10.318 23 23 C 68 57.683 57.683 68 45 68 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
	<path d="M 45 17.556 c -1.657 0 -3 -1.343 -3 -3 V 3 c 0 -1.657 1.343 -3 3 -3 c 1.657 0 3 1.343 3 3 v 11.556 C 48 16.212 46.657 17.556 45 17.556 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
	<path d="M 45 90 c -1.657 0 -3 -1.343 -3 -3 V 75.444 c 0 -1.657 1.343 -3 3 -3 c 1.657 0 3 1.343 3 3 V 87 C 48 88.657 46.657 90 45 90 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
	<path d="M 14.556 48 H 3 c -1.657 0 -3 -1.343 -3 -3 c 0 -1.657 1.343 -3 3 -3 h 11.556 c 1.657 0 3 1.343 3 3 C 17.556 46.657 16.212 48 14.556 48 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
	<path d="M 87 48 H 75.444 c -1.657 0 -3 -1.343 -3 -3 c 0 -1.657 1.343 -3 3 -3 H 87 c 1.657 0 3 1.343 3 3 C 90 46.657 88.657 48 87 48 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
	<path d="M 66.527 26.473 c -0.768 0 -1.535 -0.293 -2.121 -0.878 c -1.172 -1.172 -1.172 -3.071 0 -4.243 l 8.171 -8.171 c 1.172 -1.172 3.07 -1.171 4.242 0 c 1.172 1.172 1.172 3.071 0 4.243 l -8.171 8.171 C 68.063 26.18 67.295 26.473 66.527 26.473 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
	<path d="M 15.302 77.698 c -0.768 0 -1.536 -0.293 -2.121 -0.879 c -1.172 -1.171 -1.172 -3.071 0 -4.242 l 8.171 -8.171 c 1.171 -1.172 3.071 -1.172 4.242 0 c 1.172 1.171 1.172 3.071 0 4.242 l -8.171 8.171 C 16.837 77.405 16.069 77.698 15.302 77.698 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
	<path d="M 23.473 26.473 c -0.768 0 -1.536 -0.293 -2.121 -0.878 l -8.171 -8.171 c -1.172 -1.172 -1.172 -3.071 0 -4.243 c 1.172 -1.172 3.072 -1.171 4.243 0 l 8.171 8.171 c 1.172 1.172 1.172 3.071 0 4.243 C 25.008 26.18 24.24 26.473 23.473 26.473 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
	<path d="M 74.698 77.698 c -0.768 0 -1.535 -0.293 -2.121 -0.879 l -8.171 -8.171 c -1.172 -1.171 -1.172 -3.071 0 -4.242 c 1.172 -1.172 3.07 -1.172 4.242 0 l 8.171 8.171 c 1.172 1.171 1.172 3.071 0 4.242 C 76.233 77.405 75.466 77.698 74.698 77.698 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
</g>
</svg>`;
const sh = 5;
class rh extends ns {
  constructor(e4 = {}) {
    super(e4);
    this._selectedLayer = null;
    this._toggleBtn = new _s({ classList: ["og-map-button", "og-lighting_button"], icon: ih });
    this._dialog = new ds({ title: "Lighting Parameters", visible: false, useHide: true, top: 60, left: 60, width: 600 });
    this._dialog.events.on("visibility", (e5) => {
      this._toggleBtn.setActive(e5);
    });
    this._panel = new ts({ template: th });
    this.$gamma = null;
    this.$exposure = null;
    this.$night = null;
    this.$opacity = null;
    this.$diffuse = null;
    this.$ambient = null;
    this.$specular = null;
    this.$atmosphereOpacity = null;
    this.$simpleSkyBackground = null;
    this._atmosphereMaxOpacity = new Yl({ label: "Max.opacity", max: 5 });
    this._atmosphereMinOpacity = new Yl({ label: "Min.opacity", max: 5 });
    this._simpleSkyBackgroundColorOne = new Zl({ label: "Color One" });
    this._simpleSkyBackgroundColorTwo = new Zl({ label: "Color Two" });
    this._gamma = new Yl({ label: "Gamma", max: 5 });
    this._exposure = new Yl({ label: "Exposure", max: 5 });
    this._night = new Yl({ label: "Nightlight", max: 5 });
    this._opacity = new Yl({ label: "Opacity", max: 1 });
    this._diffuse_r = new Yl({ label: "Diffuse R", max: sh });
    this._diffuse_g = new Yl({ label: "Diffuse G", max: sh });
    this._diffuse_b = new Yl({ label: "Diffuse B", max: sh });
    this._ambient_r = new Yl({ label: "Ambient R", max: sh });
    this._ambient_g = new Yl({ label: "Ambient G", max: sh });
    this._ambient_b = new Yl({ label: "Ambient B", max: sh });
    this._specular_r = new Yl({ label: "Specular R", max: 0.2 });
    this._specular_g = new Yl({ label: "Specular G", max: 0.2 });
    this._specular_b = new Yl({ label: "Specular B", max: 0.2 });
    this._shininess = new Yl({ label: "Shininess", max: 100 });
  }
  bindLayer(e4) {
    this._selectedLayer = e4;
    this._opacity.value = e4.opacity;
    this._update();
  }
  oninit() {
    this._toggleBtn.appendTo(this.renderer.div);
    this._dialog.appendTo(this.renderer.div);
    this._panel.appendTo(this._dialog.container);
    if (this._panel.el) {
      this.$atmosphereOpacity = this._panel.el.querySelector(".og-atmosphere-opacity");
      this.$simpleSkyBackground = this._panel.el.querySelector(".og-simpleskybackground");
      this.$gamma = this._panel.el.querySelector(".og-option.og-gamma");
      this.$exposure = this._panel.el.querySelector(".og-option.og-exposure");
      this.$opacity = this._panel.el.querySelector(".og-option.og-opacity");
      this.$diffuse = this._panel.el.querySelector(".og-option.og-diffuse");
      this.$ambient = this._panel.el.querySelector(".og-option.og-ambient");
      this.$specular = this._panel.el.querySelector(".og-option.og-specular");
      this.$night = this._panel.el.querySelector(".og-option.og-night");
    }
    this._toggleBtn.events.on("change", (e5) => {
      this._dialog.setVisibility(e5);
    });
    let e4 = this._dialog.select(".og-suncontrol");
    let t2 = new _s({ classList: ["og-suncontrol-button"], isActive: true, icon: Kl, title: "Star/stop the Sun from following the camera" });
    t2.appendTo(e4);
    let i2 = new _s({ classList: ["og-suncontrol-button"], isActive: true, icon: Ql, title: "Activate/deactivate the Sun current time positioning" });
    i2.appendTo(e4);
    t2.events.on("change", (e5) => {
      const t3 = this.planet.renderer.controls.sun;
      if (e5) {
        t3.start();
      } else {
        t3.stop();
      }
    });
    i2.events.on("change", (e5) => {
      const t3 = this.planet.renderer.controls.sun;
      if (e5) {
        t3.activate();
      } else {
        t3.deactivate();
      }
    });
    let s2 = new _s({ classList: ["og-suncontrol-button"], isActive: this.planet.lightEnabled, icon: Jl, title: "Enable/disable planet lighting" });
    s2.appendTo(e4);
    s2.events.on("change", (e5) => {
      this.planet.lightEnabled = e5;
    });
    let r2 = new _s({ classList: ["og-suncontrol-button"], isActive: this.planet.atmosphereEnabled, icon: eh, title: "Enable/disable atmosphere scattering" });
    r2.appendTo(e4);
    if (this.planet.atmosphereEnabled) {
      this.$atmosphereOpacity.style.display = "block";
      this.$simpleSkyBackground.style.display = "none";
    } else {
      this.$atmosphereOpacity.style.display = "none";
      this.$simpleSkyBackground.style.display = "flex";
    }
    r2.events.on("change", (e5) => {
      this.planet.atmosphereEnabled = e5;
      if (this.planet.atmosphereEnabled) {
        this.$atmosphereOpacity.style.display = "block";
        this.$simpleSkyBackground.style.display = "none";
      } else {
        this.$atmosphereOpacity.style.display = "none";
        this.$simpleSkyBackground.style.display = "flex";
      }
    });
    this._atmosphereMaxOpacity.appendTo(this.$atmosphereOpacity);
    this._atmosphereMinOpacity.appendTo(this.$atmosphereOpacity);
    this._simpleSkyBackgroundColorOne.appendTo(this.$simpleSkyBackground);
    this._simpleSkyBackgroundColorTwo.appendTo(this.$simpleSkyBackground);
    this._gamma.appendTo(this.$gamma);
    this._exposure.appendTo(this.$exposure);
    this._night.appendTo(this.$night);
    this._opacity.appendTo(this.$opacity);
    this._diffuse_r.appendTo(this.$diffuse);
    this._diffuse_g.appendTo(this.$diffuse);
    this._diffuse_b.appendTo(this.$diffuse);
    this._ambient_r.appendTo(this.$ambient);
    this._ambient_g.appendTo(this.$ambient);
    this._ambient_b.appendTo(this.$ambient);
    this._specular_r.appendTo(this.$specular);
    this._specular_g.appendTo(this.$specular);
    this._specular_b.appendTo(this.$specular);
    this._shininess.appendTo(this.$specular);
    this._gamma.value = this.planet.renderer.gamma;
    this._gamma.events.on("change", (e5) => {
      this.planet.renderer.gamma = e5;
    });
    this._exposure.value = this.planet.renderer.exposure;
    this._exposure.events.on("change", (e5) => {
      this.planet.renderer.exposure = e5;
    });
    this._atmosphereMinOpacity.value = this.planet.atmosphereMinOpacity;
    this._atmosphereMinOpacity.events.on("change", (e5) => {
      this.planet.atmosphereMinOpacity = e5;
    });
    this._atmosphereMaxOpacity.value = this.planet.atmosphereMaxOpacity;
    this._atmosphereMaxOpacity.events.on("change", (e5) => {
      this.planet.atmosphereMaxOpacity = e5;
      let t3 = this.planet.renderer.controls.Atmosphere;
      t3.opacity = e5;
    });
    let n2 = this.planet.renderer.controls.SimpleSkyBackground;
    if (n2) {
      this._simpleSkyBackgroundColorOne.value = n2.colorOne;
      this._simpleSkyBackgroundColorTwo.value = n2.colorTwo;
    }
    this._simpleSkyBackgroundColorOne.events.on("input", (e5) => {
      let t3 = this.planet.renderer.controls.SimpleSkyBackground;
      if (t3) {
        t3.colorOne = e5;
      }
    });
    this._simpleSkyBackgroundColorTwo.events.on("input", (e5) => {
      let t3 = this.planet.renderer.controls.SimpleSkyBackground;
      if (t3) {
        t3.colorTwo = e5;
      }
    });
    this._panel.el.querySelector("#layers").addEventListener("change", (e5) => {
      const t3 = this.planet.getLayerByName(e5.target.value);
      if (t3) {
        this.bindLayer(t3);
      }
    });
    this._night.events.on("change", (e5) => {
      if (this._selectedLayer) {
        this._selectedLayer.nightTextureCoefficient = e5;
      }
    });
    this._opacity.events.on("change", (e5) => {
      if (this._selectedLayer) this._selectedLayer.opacity = e5;
    });
    this._ambient_r.events.on("change", (e5) => {
      if (this._selectedLayer && this._selectedLayer._ambient) this._selectedLayer._ambient[0] = e5;
    });
    this._ambient_g.events.on("change", (e5) => {
      if (this._selectedLayer && this._selectedLayer._ambient) this._selectedLayer._ambient[1] = e5;
    });
    this._ambient_b.events.on("change", (e5) => {
      if (this._selectedLayer && this._selectedLayer._ambient) this._selectedLayer._ambient[2] = e5;
    });
    this._diffuse_r.events.on("change", (e5) => {
      if (this._selectedLayer && this._selectedLayer._diffuse) this._selectedLayer._diffuse[0] = e5;
    });
    this._diffuse_g.events.on("change", (e5) => {
      if (this._selectedLayer && this._selectedLayer._diffuse) this._selectedLayer._diffuse[1] = e5;
    });
    this._diffuse_b.events.on("change", (e5) => {
      if (this._selectedLayer && this._selectedLayer._diffuse) this._selectedLayer._diffuse[2] = e5;
    });
    this._specular_r.events.on("change", (e5) => {
      if (this._selectedLayer && this._selectedLayer._specular) this._selectedLayer._specular[0] = e5;
    });
    this._specular_g.events.on("change", (e5) => {
      if (this._selectedLayer && this._selectedLayer._specular) this._selectedLayer._specular[1] = e5;
    });
    this._specular_b.events.on("change", (e5) => {
      if (this._selectedLayer && this._selectedLayer._specular) this._selectedLayer._specular[2] = e5;
    });
    this._shininess.events.on("change", (e5) => {
      if (this._selectedLayer && this._selectedLayer._specular) this._selectedLayer._specular[3] = e5;
    });
    if (this.planet) {
      this.planet.events.on("layeradd", this._onLayerAdd, this);
      this.planet.events.on("layerremove", this._onLayerRemove, this);
    }
    this._fetchLayers();
  }
  _update() {
    let e4 = this._selectedLayer;
    this._opacity.value = e4 && e4.opacity ? e4.opacity : 0;
    this._night.value = e4 && e4.nightTextureCoefficient ? e4.nightTextureCoefficient : this.planet.nightTextureCoefficient;
    let t2 = e4 && e4._ambient ? e4._ambient : this.planet._ambient;
    this._ambient_r.value = t2[0];
    this._ambient_g.value = t2[1];
    this._ambient_b.value = t2[2];
    let i2 = e4 && e4._diffuse ? e4._diffuse : this.planet._diffuse;
    this._diffuse_r.value = i2[0];
    this._diffuse_g.value = i2[1];
    this._diffuse_b.value = i2[2];
    let s2 = e4 && e4._specular ? e4._specular : this.planet._specular;
    this._specular_r.value = s2[0];
    this._specular_g.value = s2[1];
    this._specular_b.value = s2[2];
    this._shininess.value = s2[3];
  }
  _fetchLayers() {
    if (this.planet) {
      for (let e4 = 0; e4 < this.planet.layers.length; e4++) {
        this._onLayerAdd(this.planet.layers[e4]);
      }
    }
  }
  _onLayerAdd(e4) {
    this.bindLayer(e4);
    let t2 = document.createElement("option");
    t2.value = e4.name;
    t2.innerText = e4.name;
    this._panel.el.querySelector("#layers").appendChild(t2);
    this._panel.el.querySelector("#layers").value = e4.name;
  }
  _onLayerRemove(e4) {
  }
}
class nh {
  constructor() {
    this._lock = 0;
  }
  lock(e4) {
    this._lock |= 1 << e4.id;
  }
  free(e4) {
    this._lock &= ~(1 << e4.id);
  }
  isFree() {
    return this._lock === 0;
  }
  isLocked() {
    return this._lock !== 0;
  }
}
const _oh = class _oh {
  constructor() {
    this.__id = _oh.__counter__++;
  }
  get id() {
    return this.__id;
  }
};
_oh.__counter__ = 0;
let oh = _oh;
class ah extends ns {
  constructor(e4 = {}) {
    super(e4);
    this._deactivate = false;
    this._shiftBusy = false;
    this._name = "mouseNavigation";
    this.grabbedPoint = new Ke();
    this._eye0 = new Ke();
    this.pointOnEarth = new Ke();
    this.earthUp = new Ke();
    this.inertia = 7e-3;
    this.grabbedSpheroid = new Zi();
    this.qRot = new Ze();
    this.scaleRot = 0;
    this.distDiff = 0.3;
    this.stepsCount = 8;
    this.stepsForward = null;
    this.stepIndex = 0;
    this._lmbDoubleClickActive = true;
    this.minSlope = e4.minSlope || 0.1;
    this._wheelDirection = 1;
    this._keyLock = new oh();
  }
  static getMovePointsFromPixelTerrain(e4, t2, i2, s2, r2, n2, o2) {
    const a2 = [];
    let l2 = e4.eye.clone(), h2 = e4.getBackward(), c2 = e4.getRight(), d2 = e4.getUp();
    let u2 = t2.getCartesianFromPixelTerrain(r2);
    if (!u2) {
      u2 = t2.getCartesianFromPixelTerrain(t2.renderer.handler.getCenter());
    }
    if (u2) {
      if (!o2) {
        o2 = Ke.sub(u2, e4.eye).normalize();
      }
      let t3 = s2 * e4.eye.distance(u2) / i2;
      if (n2) {
        t3 = -1.25 * t3;
      } else {
        t3 *= 2;
      }
      const r3 = h2.scaleTo(t3);
      const _2 = o2.dot(e4.eye.normal().negate());
      if (_2 >= 0.1) {
        const t4 = new Zi();
        t4.radius = u2.length();
        let s3 = [], n3 = [];
        let _3 = false;
        for (let e5 = 0; e5 < i2; e5++) {
          l2.addA(r3);
          const i3 = new ar(l2, o2).hitSphere(t4);
          n3[e5] = l2.clone();
          if (i3) {
            s3[e5] = new Xe().rotateBetweenVectors(u2.normal(), i3.normal());
          } else {
            _3 = true;
            break;
          }
        }
        if (!_3) {
          for (let e5 = 0; e5 < i2; e5++) {
            let t5 = s3[e5];
            a2[e5] = { eye: t5.mulVec3(n3[e5]), v: t5.mulVec3(d2), u: t5.mulVec3(c2), n: t5.mulVec3(h2) };
          }
        } else {
          l2 = e4.eye.clone();
          for (let e5 = 0; e5 < i2; e5++) {
            a2[e5] = { eye: l2.addA(r3).clone(), v: d2, u: c2, n: h2 };
          }
        }
      } else {
        for (let e5 = 0; e5 < i2; e5++) {
          a2[e5] = { eye: l2.addA(o2.scaleTo(-t3)).clone(), v: d2, u: c2, n: h2 };
        }
      }
      return a2;
    }
  }
  onactivate() {
    if (this.renderer) {
      this.renderer.events.on("mousewheel", this.onMouseWheel, this);
      this.renderer.events.on("lhold", this.onMouseLeftButtonDown, this);
      this.renderer.events.on("rhold", this.onMouseRightButtonDown, this);
      this.renderer.events.on("ldown", this.onMouseLeftButtonClick, this);
      this.renderer.events.on("lup", this.onMouseLeftButtonUp, this);
      this.renderer.events.on("rdown", this.onMouseRightButtonClick, this);
      this.renderer.events.on("draw", this.onDraw, this, -1e3);
      this.renderer.events.on("mousemove", this.onMouseMove, this);
      this.renderer.events.on("mouseleave", this.onMouseLeave, this);
      this.renderer.events.on("mouseenter", this.onMouseEnter, this);
      if (this._lmbDoubleClickActive) {
        this.renderer.events.on("ldblclick", this.onMouseLeftButtonDoubleClick, this);
      }
    }
  }
  ondeactivate() {
    if (this.renderer) {
      this.renderer.events.off("mousewheel", this.onMouseWheel);
      this.renderer.events.off("lhold", this.onMouseLeftButtonDown);
      this.renderer.events.off("rhold", this.onMouseRightButtonDown);
      this.renderer.events.off("ldown", this.onMouseLeftButtonClick);
      this.renderer.events.off("lup", this.onMouseLeftButtonUp);
      this.renderer.events.off("rdown", this.onMouseRightButtonClick);
      this.renderer.events.off("draw", this.onDraw);
      this.renderer.events.off("ldblclick", this.onMouseLeftButtonDoubleClick);
      this.renderer.events.off("mouseleave", this.onMouseLeave);
      this.renderer.events.off("mouseenter", this.onMouseEnter);
    }
  }
  activateDoubleClickZoom() {
    if (!this._lmbDoubleClickActive) {
      this._lmbDoubleClickActive = true;
      this.renderer && this.renderer.events.on("ldblclick", this.onMouseLeftButtonDoubleClick, this);
    }
  }
  deactivateDoubleClickZoom() {
    if (this._lmbDoubleClickActive) {
      this._lmbDoubleClickActive = false;
      this.renderer && this.renderer.events.off("ldblclick", this.onMouseLeftButtonDoubleClick);
    }
  }
  onMouseEnter(e4) {
    const t2 = this.renderer.events;
    if (t2.isKeyPressed(zl.KEY_ALT)) {
      t2.releaseKeys();
    }
    t2.updateButtonsStates(e4.sys.buttons);
    if (t2.mouseState.leftButtonDown) {
      this.renderer.handler.canvas.classList.add("ogGrabbingPoiner");
    } else {
      this.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
    }
  }
  onMouseLeave() {
    if (this.renderer.events.mouseState.leftButtonDown) {
      this.scaleRot = 0;
    }
    this.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
  }
  onMouseWheel(e4) {
    if (this.stepIndex) {
      return;
    }
    this.planet.stopFlying();
    this.stopRotation();
    this._deactivate = true;
    this.lockPlanet(true);
    this.stepsForward = ah.getMovePointsFromPixelTerrain(this.planet.camera, this.planet, this.stepsCount, this.distDiff, e4.pos, e4.wheelDelta > 0, e4.direction) || null;
    this._wheelDirection = e4.wheelDelta;
    if (this.stepsForward) {
      this.stepIndex = this.stepsCount;
    }
  }
  oninit() {
    this.activate();
    if (this.renderer) {
      this.renderer.events.on("keyfree", zl.KEY_ALT, this.onShiftFree, this);
      this.renderer.events.on("keyfree", zl.KEY_PRINTSCREEN, this.onShiftFree, this);
    }
  }
  onMouseLeftButtonDoubleClick(e4) {
    this.planet.stopFlying();
    this.stopRotation();
    const t2 = this.planet.getCartesianFromPixelTerrain(e4.pos);
    if (t2) {
      const e5 = this.planet.camera;
      let i2 = e5.maxAltitude + this.planet.ellipsoid.polarSize;
      let s2 = e5.minAltitude + this.planet.ellipsoid.polarSize;
      const r2 = e5.eye.length();
      const n2 = this.planet.ellipsoid.cartesianToLonLat(t2);
      if (r2 > i2 || r2 < s2) {
        this.planet.flyLonLat(new be(n2.lon, n2.lat));
        return;
      }
      if (this.renderer.events.isKeyPressed(zl.KEY_ALT)) {
        this.planet.flyLonLat(new be(n2.lon, n2.lat, e5.eye.distance(t2) * 2));
      } else {
        this.planet.flyLonLat(new be(n2.lon, n2.lat, e5.eye.distance(t2) * 0.57));
      }
    }
  }
  onMouseLeftButtonClick() {
    if (this._active) {
      this.renderer.handler.canvas.classList.add("ogGrabbingPoiner");
      this.grabbedPoint = this.planet.getCartesianFromMouseTerrain();
      if (this.grabbedPoint) {
        this._eye0.copy(this.planet.camera.eye);
        this.grabbedSpheroid.radius = this.grabbedPoint.length();
        this.stopRotation();
      }
    }
  }
  stopRotation() {
    this.qRot.clear();
    this.freePlanet();
  }
  onMouseLeftButtonUp(e4) {
    this.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
    if (e4.x === e4.prev_x && e4.y === e4.prev_y) {
      this.scaleRot = 0;
    }
  }
  onMouseLeftButtonDown(e4) {
    if (this._active) {
      if (!this.grabbedPoint) {
        return;
      }
      this.planet.stopFlying();
      if (e4.moving) {
        let t2 = this.planet.camera;
        if (t2.slope > 0.2) {
          const i2 = new ar(t2.eye, e4.direction).hitSphere(this.grabbedSpheroid);
          if (i2) {
            this.scaleRot = 1;
            this.qRot = Ze.getRotationBetweenVectors(i2.normal(), this.grabbedPoint.normal());
            let e5 = this.qRot;
            t2.eye = e5.mulVec3(t2.eye);
            t2.rotate(e5);
          }
        } else {
          let i2 = this.grabbedPoint, s2 = Ke.add(i2, t2.getRight()), r2 = Ke.add(i2, i2.normal());
          let n2 = new Ke();
          if (new ar(t2.eye, e4.direction).hitPlaneRes(or.fromPoints(i2, s2, r2), n2) === ar.INSIDE) {
            t2.eye = this._eye0.addA(n2.subA(i2).negate());
          }
        }
      }
    }
  }
  onMouseRightButtonClick(e4) {
    this.stopRotation();
    this.planet.stopFlying();
    this.pointOnEarth = this.planet.getCartesianFromPixelTerrain(e4.pos);
    if (this.pointOnEarth) {
      this.earthUp = this.pointOnEarth.normal();
    }
  }
  onMouseRightButtonDown(e4) {
    const t2 = this.planet.camera;
    if (this.pointOnEarth && e4.moving) {
      this.renderer.controlsBag.scaleRot = 1;
      let i2 = 0.5 / t2.eye.distance(this.pointOnEarth) * t2._lonLat.height * d;
      if (i2 > 7e-3) {
        i2 = 7e-3;
      } else if (i2 < 3e-3) {
        i2 = 3e-3;
      }
      t2.rotateHorizontal(i2 * (e4.x - e4.prev_x), false, this.pointOnEarth, this.earthUp);
      t2.rotateVertical(i2 * (e4.y - e4.prev_y), this.pointOnEarth, this.minSlope);
    }
  }
  onShiftFree() {
    this._shiftBusy = false;
  }
  onMouseMove(e4) {
    if (this._active && this.renderer.events.isKeyPressed(zl.KEY_ALT)) {
      if (!this._shiftBusy) {
        this._shiftBusy = true;
        this.onMouseRightButtonClick(e4);
      }
      this.onMouseRightButtonDown(e4);
    }
  }
  onDraw() {
    if (this._active) {
      const e4 = this.renderer;
      const t2 = this.planet.camera;
      let i2 = t2.eye.clone();
      if (this.stepIndex) {
        e4.controlsBag.scaleRot = 1;
        const i3 = this.stepsForward[this.stepsCount - this.stepIndex--];
        t2.eye = i3.eye;
        t2._u = i3.v;
        t2._r = i3.u;
        t2._b = i3.n;
        t2._f.set(-t2._b.x, -t2._b.y, -t2._b.z);
      } else {
        if (this._deactivate) {
          this._deactivate = false;
          this.freePlanet();
        }
      }
      if (e4.events.mouseState.leftButtonDown || !this.scaleRot) {
        return;
      }
      this.scaleRot -= this.inertia;
      if (this.scaleRot <= 0) {
        this.scaleRot = 0;
      } else {
        e4.controlsBag.scaleRot = this.scaleRot;
        let i3 = this.qRot.slerp(Ze.IDENTITY, 1 - this.scaleRot * this.scaleRot * this.scaleRot).normalize();
        if (!(i3.x || i3.y || i3.z)) {
          this.scaleRot = 0;
        }
        t2.eye = i3.mulVec3(t2.eye);
        t2.rotate(i3);
      }
      if (t2.eye.distance(i2) / t2.getAltitude() > 0.01) {
        this.lockPlanet();
      } else {
        this.freePlanet();
      }
    }
  }
  lockPlanet(e4) {
    this.planet.layerLock.lock(this._keyLock);
    !e4 && this.planet.terrainLock.lock(this._keyLock);
    this.planet._normalMapCreator.lock(this._keyLock);
  }
  freePlanet() {
    this.planet.layerLock.free(this._keyLock);
    this.planet.terrainLock.free(this._keyLock);
    this.planet._normalMapCreator.free(this._keyLock);
  }
}
const lh = 0.96;
const hh = 0.35;
class ch extends ns {
  constructor(e4 = {}) {
    super({ name: "mouseNavigation", autoActivate: true, ...e4 });
    this._shiftBusy = false;
    this._hold = false;
    this._prevVel = new Ke();
    this._screenPosIsChanged = true;
    this._onShiftFree = () => {
      this._shiftBusy = false;
    };
    this._onMouseMove = (e5) => {
      if (this._active && this.renderer.events.isKeyPressed(zl.KEY_ALT)) {
        if (!this._shiftBusy) {
          this._shiftBusy = true;
          this._onRHold(e5);
        }
        this._onRDown(e5);
      }
    };
    this._onMouseEnter = (e5) => {
      const t2 = this.renderer.events;
      if (t2.isKeyPressed(zl.KEY_ALT)) {
        t2.releaseKeys();
      }
      t2.updateButtonsStates(e5.sys.buttons);
      if (t2.mouseState.leftButtonDown) {
        this.renderer.handler.canvas.classList.add("ogGrabbingPoiner");
      } else {
        this.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
      }
    };
    this._onMouseLeave = () => {
      if (this.renderer.events.mouseState.leftButtonDown) {
        this.vel.scale(0);
      }
      this.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
    };
    this._onRHold = (e5) => {
      if (this._targetRotationPoint) {
        this._velInertia = 0.8;
        this.force_h = 0.2 * (e5.x - e5.prev_x);
        this.force_v = 0.2 * (e5.y - e5.prev_y);
      }
    };
    this._onRDown = (e5) => {
      if (this.planet) {
        this.planet.stopFlying();
        this._targetRotationPoint = this._getTargetPoint(e5.pos);
        if (this._targetRotationPoint) {
          this._targetZoomPoint = null;
          this._targetDragPoint = null;
          this.vel.set(0, 0, 0);
          this._tUp = this._targetRotationPoint.getNormal();
          this._tRad = this.planet.camera.eye.distance(this._targetRotationPoint);
        }
      }
    };
    this._onMouseWheel = (e5) => {
      if (this.planet) {
        this._targetRotationPoint = null;
        this._targetDragPoint = null;
        let t2 = this._getTargetPoint(e5.pos);
        if (!t2) return;
        this._targetZoomPoint = t2;
        this._grabbedSphere.radius = this._targetZoomPoint.length();
        this._curPitch = this.planet.camera.getPitch();
        this._curYaw = this.planet.camera.getYaw();
        this._curRoll = this.planet.camera.getRoll();
        if (Math.sign(e5.wheelDelta) !== this._wheelDirection) {
          this.vel.scale(0.3);
          this._currScreenPos.set(e5.x, e5.y);
          this._wheelDirection = Math.sign(e5.wheelDelta);
          return;
        }
        this._currScreenPos.set(e5.x, e5.y);
        this._wheelDirection = Math.sign(e5.wheelDelta);
        let i2 = 2;
        this._isTouchPad = e5.isTouchPad;
        if (e5.isTouchPad) {
          this._velInertia = 0.88;
          i2 = 0.8;
        } else {
          this._velInertia = lh;
        }
        let s2 = this.planet.camera;
        let r2 = Math.abs(s2.getAltitude() < 20 ? 20 : s2.getAltitude());
        let n2 = Math.min(r2, this.planet.camera.eye.distance(this._targetZoomPoint)) * i2;
        this.force = e5.direction.scale(Math.sign(this._wheelDirection)).normalize().scale(n2);
        this.force_roll = this._curRoll;
      }
    };
    this._onLDown = (e5) => {
      this.stop();
      this._targetRotationPoint = null;
      this._targetZoomPoint = null;
      if (!this.planet) return;
      this.planet.stopFlying();
      this._grabbedPoint = this._getTargetPoint(e5.pos);
      if (!this._grabbedPoint) return;
      this.renderer.handler.canvas.classList.add("ogGrabbingPoiner");
      this._grabbedSphere.radius = this._grabbedPoint.length();
      this._eye0 = this.planet.camera.eye.clone();
      this._grabbedCameraHeight = this._eye0.length();
      this._curPitch = this.planet.camera.getPitch();
      this._curYaw = this.planet.camera.getYaw();
      this._curRoll = this.planet.camera.getRoll();
      this._currScreenPos.copy(e5.pos);
      if (this.planet.camera.getUp().dot(new Ke(0, 0, 1)) > 0.3) {
        this.fixedUp = true;
      }
    };
    this._onLHold = (e5) => {
      if (this._grabbedPoint && this.planet) {
        let t2 = this.planet.camera;
        if (t2.slope > hh) {
          let i2 = new ar(t2.eye, e5.direction).hitSphere(this._grabbedSphere);
          if (!i2) {
            return;
          }
          this._targetDragPoint = i2;
          let s2 = new Ke();
          let r2 = Ze.getRotationBetweenVectors(this._targetDragPoint.getNormal(), this._grabbedPoint.getNormal());
          s2.copy(r2.mulVec3(t2.eye));
          this.force = s2.sub(t2.eye).scale(70);
        } else {
          let i2 = this._grabbedPoint, s2 = Ke.add(i2, t2.getRight()), r2 = Ke.add(i2, i2.getNormal());
          let n2 = new Ke();
          new ar(t2.eye, e5.direction).hitPlaneRes(or.fromPoints(i2, s2, r2), n2);
          let o2 = t2.eye.add(n2.subA(i2).negate());
          this.force = o2.sub(t2.eye).scale(70);
          this._targetDragPoint = n2;
        }
        this.vel.set(0, 0, 0);
        if (!this._currScreenPos.equal(e5.pos)) {
          this._screenPosIsChanged = true;
          this._currScreenPos.copy(e5.pos);
        }
        this._hold = true;
      }
    };
    this._onLUp = (e5) => {
      this._hold = false;
      this.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
    };
    this.speed = e4.speed || 1;
    this.force = new Ke();
    this.force_h = 0;
    this.force_v = 0;
    this.vel = new Ke();
    this.vel_h = 0;
    this.vel_v = 0;
    this.vel_roll = 0;
    this.force_roll = 0;
    this.mass = 1;
    this._velInertia = lh;
    this._lookPos = void 0;
    this._grabbedPoint = null;
    this._targetZoomPoint = null;
    this._targetDragPoint = null;
    this._targetRotationPoint = null;
    this._tUp = new Ke();
    this._tRad = 0;
    this._rotHDir = 0;
    this._rotVDir = 0;
    this._wheelDirection = 1;
    this._currScreenPos = new Qe();
    this._grabbedSphere = new Zi();
    this.fixedUp = e4.fixedUp != void 0 ? e4.fixedUp : true;
    this._rot = new Ze();
    this._curPitch = 0;
    this._curYaw = 0;
    this._curRoll = 0;
    this._eye0 = new Ke();
    this._newEye = new Ke();
    this._grabbedCameraHeight = 0;
    this._isTouchPad = false;
  }
  oninit() {
    if (this.renderer) {
      this.renderer.events.on("keyfree", zl.KEY_ALT, this._onShiftFree);
      this.renderer.events.on("keyfree", zl.KEY_PRINTSCREEN, this._onShiftFree);
    }
  }
  onactivate() {
    super.onactivate();
    let e4 = this.renderer;
    e4.events.on("mousewheel", this._onMouseWheel);
    e4.events.on("rhold", this._onRHold);
    e4.events.on("rdown", this._onRDown);
    e4.events.on("lhold", this._onLHold);
    e4.events.on("ldown", this._onLDown);
    e4.events.on("lup", this._onLUp);
    e4.events.on("draw", this.onDraw, this, -1e3);
    e4.events.on("mousemove", this._onMouseMove);
    e4.events.on("mouseleave", this._onMouseLeave);
    e4.events.on("mouseenter", this._onMouseEnter);
  }
  ondeactivate() {
    super.ondeactivate();
    let e4 = this.renderer;
    e4.events.off("mousewheel", this._onMouseWheel);
    e4.events.off("rhold", this._onRHold);
    e4.events.off("rdown", this._onRDown);
    e4.events.off("lhold", this._onLHold);
    e4.events.off("ldown", this._onLDown);
    e4.events.off("lup", this._onLUp);
    e4.events.off("draw", this.onDraw);
    e4.events.off("mousemove", this._onMouseMove);
    e4.events.off("mouseleave", this._onMouseLeave);
    e4.events.off("mouseenter", this._onMouseEnter);
  }
  onDraw() {
    this._updateVel();
    this._handleZoom();
    this._handleDrag();
    this._handleRotation();
  }
  _handleRotation() {
    if (this.planet && this._targetRotationPoint) {
      let e4 = this.planet.camera;
      let t2 = this.vel_h * this.dt;
      let i2 = this.vel_v * this.dt;
      e4.rotateHorizontal(t2, false, this._targetRotationPoint, this._tUp);
      e4.rotateVertical(i2, this._targetRotationPoint, 0.1);
      this._curPitch = e4.getPitch();
      this._curYaw = e4.getYaw();
      this._curRoll = e4.getRoll();
      this._velInertia = lh;
    }
  }
  _getTargetPoint(e4) {
    if (this.planet) {
      if (this.planet.camera.getAltitude() > 8e4) {
        return this.planet.getCartesianFromPixelEllipsoid(e4) || null;
      }
      return this.planet.getCartesianFromPixelTerrain(e4) || null;
    }
    return null;
  }
  _handleDrag() {
    if (this.planet && this._targetDragPoint && this._grabbedPoint && this.vel.length() > 0) {
      this._velInertia = lh;
      let e4 = this.planet.camera;
      if (Math.abs(e4.eyeNorm.dot(Ke.NORTH)) > 0.9) {
        this.fixedUp = false;
      }
      if (!this._screenPosIsChanged) {
        if (this.vel.length() > this._prevVel.length()) {
          this.fixedUp = false;
        }
      }
      this._screenPosIsChanged = false;
      this._prevVel.copy(this.vel);
      if (e4.slope > hh) {
        let t2 = this.vel.scaleTo(this.dt);
        let i2 = Ke.proj_b_to_plane(t2, e4.eyeNorm);
        let s2 = e4.eye.add(i2).normalize().scale(this._grabbedCameraHeight);
        if (this.fixedUp) {
          e4.eye.copy(s2);
          this._corrRoll();
          e4.setPitchYawRoll(this._curPitch, this._curYaw, this._curRoll);
        } else {
          let t3 = Ze.getRotationBetweenVectors(e4.eye.getNormal(), s2.getNormal());
          e4.rotate(t3);
          e4.eye.copy(s2);
        }
      } else {
        let t2 = this.vel.scaleTo(this.dt);
        let i2 = e4.eye.add(t2);
        e4.eye.copy(i2);
        e4.checkTerrainCollision();
      }
    }
  }
  _corrRoll() {
    if (this.planet.camera.slope < 0.5) {
      this._curRoll -= this.vel_roll * this.dt;
      if (this._curRoll < 0.01 * Math.PI / 180) {
        this._curRoll = 0.01 * Math.PI / 180;
      }
    }
  }
  _handleZoom() {
    if (this._targetZoomPoint && this.vel.length() > 0) {
      let e4 = this.planet.camera;
      let t2 = this._targetZoomPoint;
      let i2 = t2.sub(e4.eye).normalize();
      let s2 = e4.eye.clone();
      let r2 = Math.sign(this.vel.getNormal().dot(e4.getForward()));
      let n2 = this.vel.scaleTo(this.dt);
      if (this._grabbedSphere.radius > s2.length()) {
        r2 *= -1;
      }
      let o2 = e4.getForward().scaleTo(r2 * n2.length());
      let a2 = e4.eye.distance(t2);
      if (a2 < 30 * o2.length()) {
        let e5 = o2.length();
        o2.normalize().scale(e5 * 0.5);
        this.vel.scale(0.5);
      }
      s2.addA(o2);
      let l2 = e4.maxAltitude + this.planet.ellipsoid.getEquatorialSize();
      if (s2.length() > l2) {
        s2.copy(s2.getNormal().scale(l2));
        return;
      }
      let h2 = new ar(s2, i2).hitSphere(this._grabbedSphere);
      if (!h2) {
        this.vel.set(0, 0, 0);
        return;
      }
      let c2 = Ze.getRotationBetweenVectors(h2.getNormal(), t2.getNormal());
      e4.eye = c2.mulVec3(s2);
      e4.rotate(c2);
      if (this.fixedUp && a2 > 10) {
        this._corrRoll();
        e4.setPitchYawRoll(this._curPitch, this._curYaw, this._curRoll);
        e4.update();
        let i3 = e4.unproject2v(this._currScreenPos);
        let s3 = t2.sub(e4.eye).normalize();
        let r3 = new Ke();
        let n3 = new Ke();
        let o3 = or.fromPoints(t2, t2.add(e4.getUp()), t2.add(e4.getRight()));
        new ar(e4.eye, i3).hitPlaneRes(o3, r3);
        new ar(e4.eye, s3).hitPlaneRes(o3, n3);
        let a3 = n3.sub(r3);
        e4.eye = e4.eye.add(a3);
      }
      e4.checkTerrainCollision();
    }
  }
  _updateVel() {
    let e4 = this.force.scale(1 / this.mass);
    this.vel.addA(e4);
    this.vel.scale(this._velInertia);
    if (this.vel.length() < 1e-3) {
      this.vel.set(0, 0, 0);
    }
    this.force.set(0, 0, 0);
    this._updateVel_h();
    this._updateVel_v();
    this._updateVel_roll();
  }
  _updateVel_h() {
    let e4 = this.force_h / this.mass;
    this.vel_h += e4;
    this.vel_h *= this._velInertia;
    this.force_h = 0;
  }
  _updateVel_v() {
    let e4 = this.force_v / this.mass;
    this.vel_v += e4;
    this.vel_v *= this._velInertia;
    this.force_v = 0;
  }
  _updateVel_roll() {
    let e4 = this.force_roll / this.mass;
    this.vel_roll += e4;
    this.vel_roll *= this._velInertia;
    this.force_roll = 0;
  }
  get dt() {
    return 1e-3 * this.renderer.handler.deltaTime;
  }
  stop() {
    this.vel.set(0, 0, 0);
    this.vel_h = 0;
    this.vel_v = 0;
    this._velInertia = lh;
    this._targetZoomPoint = null;
    this._grabbedPoint = null;
    this._targetRotationPoint = null;
    this._targetDragPoint = null;
  }
}
const dh = 120;
const uh = (e4) => {
  if (e4 > 1e3) {
    return `${(e4 / 1e3).toFixed(1)} km`;
  } else if (e4 > 9) {
    return `${Math.round(e4)} m`;
  } else {
    return `${e4.toFixed(1)} m`;
  }
};
let _h = ur.createCylinder(1.1, 0, 2.7, 20, 1, true, false, 0, 0, 0);
const fh = { text: "", size: 11, color: "rgba(455,455,455,1.0)", outlineColor: "rgba(0,0,0,0.34)", outline: 0.23, align: "center", offset: [0, 20, 0] };
const gh = { scale: 1, instanced: true, tag: "ruler", color: "rgb(0,305,0)", object3d: _h };
class ph extends Fr {
  constructor(e4 = {}) {
    super(e4.name);
    this._onCornerLdown = (e5) => {
      var _a2, _b;
      if (!this._startLonLat) {
        (_b = (_a2 = this.renderer) == null ? void 0 : _a2.controls.mouseNavigation) == null ? void 0 : _b.deactivate();
        this._startClick.set(e5.x, e5.y);
        let t2 = e5.pickingObject.getCartesian();
        this._startPos = this._planet.getPixelFromCartesian(t2);
        this._pickedCorner = e5.pickingObject;
        if (e5.pickingObject.properties.name == "start") {
          this._anchorLonLat = this._cornerEntity[1].getLonLat().clone();
        } else {
          this._anchorLonLat = this._cornerEntity[0].getLonLat().clone();
        }
      }
    };
    this._onLUp = () => {
      var _a2;
      if (this._pickedCorner) {
        (_a2 = this.renderer.controls.mouseNavigation) == null ? void 0 : _a2.activate();
        this._pickedCorner = null;
        this._anchorLonLat = null;
      }
    };
    this._onCornerLup = () => {
      this._onLUp();
    };
    this._onCornerEnter = (e5) => {
      e5.renderer.handler.canvas.style.cursor = "pointer";
    };
    this._onCornerLeave = (e5) => {
      e5.renderer.handler.canvas.style.cursor = "default";
    };
    this._onLdblclick = () => {
      this._preventClick = true;
    };
    this._onLclick = (e5) => {
      let t2 = this._planet.getLonLatFromPixelTerrain(e5.pos);
      if (!t2) return;
      this._timeout = setTimeout(() => {
        if (!this._preventClick) {
          if (!this._startLonLat) {
            this.setVisibility(true);
            this._stopDrawing = false;
            this._startLonLat = t2;
          } else {
            this._startLonLat = null;
          }
        }
        this._preventClick = false;
        this._stopDrawing = false;
        clearTimeout(this._timeout);
      }, 200);
      if (this._startLonLat) {
        this._stopDrawing = true;
      }
    };
    this._onMouseMove = (e5) => {
      if (this._startLonLat && !this._stopDrawing) {
        this._propsLabel.label.setVisibility(true);
        let t2 = this._planet.getLonLatFromPixelTerrain(e5.pos);
        if (!t2) return;
        this._drawLine(this._startLonLat, t2);
      } else if (this._pickedCorner) {
        let t2 = this._planet.getLonLatFromPixelTerrain(e5.pos);
        if (t2) {
          if (this._pickedCorner.properties.name === "start") {
            this._drawLine(t2, this._anchorLonLat);
          } else {
            this._drawLine(this._anchorLonLat, t2);
          }
        }
      }
    };
    this.events = Qi(mh);
    this._ignoreTerrain = e4.ignoreTerrain != void 0 ? e4.ignoreTerrain : true;
    this._planet = e4.planet || null;
    this._startLonLat = null;
    this._preventClick = false;
    this._stopDrawing = false;
    this._pickedCorner = null;
    this._startPos = null;
    this._startClick = new Qe();
    this._anchorLonLat = null;
    this._heading = 0;
    this._trackLayer = new Ma("track", { entities: [], pickingEnabled: false, polygonOffsetUnits: -1, relativeToGround: true, hideInLayerSwitcher: true });
    this._labelLayer = new Ma("ruler-label", { entities: [], pickingEnabled: false, polygonOffsetUnits: -100, relativeToGround: true, hideInLayerSwitcher: true });
    this._cornersLayer = new Ma("corners", { entities: [], pickingEnabled: true, hideInLayerSwitcher: true, scaleByDistance: [100, 4e6, 1], pickingScale: 2 });
    this._propsLabel = new zr({ name: "propsLabel", label: fh });
    this._trackEntity = new zr({ polyline: { path3v: [], thickness: 4.8, color: "rgb(255,131,0)", isClosed: false } });
    this._trackEntity.polyline.altitude = 0.01;
    this._cornerEntity = [new zr({ geoObject: gh, properties: { name: "start" } }), new zr({ geoObject: gh, properties: { name: "end" } })];
  }
  set ignoreTerrain(e4) {
    this._ignoreTerrain = e4;
  }
  bindPlanet(e4) {
    this._planet = e4;
  }
  _createCorners() {
    this._cornersLayer.addEntities(this._cornerEntity);
  }
  init() {
    this._createCorners();
    this._trackLayer.addEntities([this._trackEntity]);
    this._labelLayer.addEntities([this._propsLabel]);
    this._planet.addLayer(this._labelLayer);
    this._planet.addLayer(this._trackLayer);
    this._planet.addLayer(this._cornersLayer);
    this._activate();
  }
  onremove() {
    this._deactivate();
  }
  _activate() {
    this._propsLabel.label.setVisibility(false);
    this.setVisibility(false);
    this.renderer.events.on("lclick", this._onLclick, this);
    this.renderer.events.on("mousemove", this._onMouseMove, this);
    this.renderer.events.on("ldblclick", this._onLdblclick, this);
    this.renderer.events.on("lup", this._onLUp, this);
    this._cornersLayer.events.on("mouseenter", this._onCornerEnter, this);
    this._cornersLayer.events.on("mouseleave", this._onCornerLeave, this);
    this._cornersLayer.events.on("ldown", this._onCornerLdown, this);
    this._cornersLayer.events.on("lup", this._onCornerLup, this);
  }
  _deactivate() {
    this._startLonLat = null;
    this._preventClick = false;
    this._stopDrawing = false;
    this._pickedCorner = null;
    this.renderer.events.off("lclick", this._onLclick);
    this.renderer.events.off("mousemove", this._onMouseMove);
    this.renderer.events.off("lup", this._onLUp);
    this._cornersLayer.events.off("mouseenter", this._onCornerEnter);
    this._cornersLayer.events.off("mouseleave", this._onCornerLeave);
    this._cornersLayer.events.off("ldown", this._onCornerLdown);
    this._cornersLayer.events.off("lup", this._onCornerLup);
    this.clear();
  }
  setVisibility(e4) {
    this._cornersLayer.setVisibility(e4);
    this._trackLayer.setVisibility(e4);
    this._labelLayer.setVisibility(e4);
  }
  _drawLine(e4, t2, i2) {
    if (!i2) {
      i2 = this._planet.ellipsoid.lonLatToCartesian(e4);
    }
    let s2 = this._planet.ellipsoid.lonLatToCartesian(t2);
    let r2 = this._planet.ellipsoid.inverse(e4, t2);
    let n2 = r2.distance;
    this._heading = r2.initialAzimuth;
    let o2 = [];
    let a2 = s2.sub(i2);
    let l2 = a2.length();
    a2.normalize();
    for (let e5 = 0; e5 < dh; e5++) {
      let t3 = a2.scaleTo(e5 * l2 / dh).addA(i2);
      o2.push(t3);
    }
    o2.push(s2);
    this._trackEntity.polyline.setPath3v([o2]);
    if (this._ignoreTerrain) {
      this._propsLabel.setCartesian3v(o2[Math.floor(o2.length / 2)]);
      this._propsLabel.label.setText(`${uh(n2)}, ${Math.round(this._heading)} deg`);
    }
  }
  clear() {
    this._trackEntity.remove();
    this._cornerEntity[0].remove();
    this._cornerEntity[1].remove();
    this._propsLabel.remove();
    this._planet.removeLayer(this._trackLayer);
    this._planet.removeLayer(this._cornersLayer);
  }
  isCornersPositionChanged() {
    let e4 = this._trackEntity.polyline.getPath3v()[0];
    if (e4) {
      const t2 = e4[0].clone(), i2 = e4[e4.length - 1].clone();
      return this._cornerEntity[0].getCartesian().equal(t2) && this._cornerEntity[1].getCartesian().equal(i2);
    }
    return false;
  }
  frame() {
    let e4 = this._trackEntity.polyline.getPath3v()[0];
    if (e4) {
      const t2 = e4[0].clone(), i2 = e4[e4.length - 1].clone();
      if (!this.isCornersPositionChanged()) {
        this._cornerEntity[0].setCartesian3v(t2);
        this._cornerEntity[1].setCartesian3v(i2);
        if (!this._ignoreTerrain) {
          let t3 = 0;
          for (let i3 = 0, s2 = e4.length - 1; i3 < s2; i3++) {
            t3 += e4[i3 + 1].distance(e4[i3]);
          }
          this._propsLabel.setCartesian3v(e4[Math.floor(e4.length / 2)]);
          this._propsLabel.label.setText(`${uh(t3)}, ${Math.round(this._heading)} deg`);
        }
      }
    }
  }
  get ellipsoid() {
    return this._planet ? this._planet.ellipsoid : null;
  }
}
const mh = ["add", "remove", "mousemove", "mouseenter", "mouseleave", "lclick", "rclick", "mclick", "ldblclick", "rdblclick", "mdblclick", "lup", "rup", "mup", "ldown", "rdown", "mdown", "lhold", "rhold", "mhold", "mousewheel", "touchmove", "touchstart", "touchend", "doubletouch", "touchleave", "touchenter"];
class vh extends ns {
  constructor(e4 = {}) {
    super(e4);
    this._rulerScene = new ph({ name: `rulerScene:${this.__id}`, ignoreTerrain: e4.ignoreTerrain });
  }
  set ignoreTerrain(e4) {
    this._rulerScene.ignoreTerrain = e4;
  }
  oninit() {
    this._rulerScene.bindPlanet(this.planet);
  }
  onactivate() {
    this.renderer && this.renderer.addNode(this._rulerScene);
  }
  ondeactivate() {
    this.renderer && this.renderer.removeNode(this._rulerScene);
  }
}
let yh = ur.createCylinder(1.1, 0, 2, 6, 1, true, true, 0, 0, 0);
const xh = { startColor: "rgb(255,131,0)", endColor: "rgb(255,131,0)", thickness: 5 };
const bh = { text: "", size: 11, color: "rgba(455,455,455,1.0)", outlineColor: "rgba(0,0,0,0.34)", outline: 0.23, align: "center", offset: [0, 18, 0] };
const wh = { scale: 1, instanced: true, tag: "height-ruler", color: "rgb(255,131,0)", object3d: yh };
class Ch extends ph {
  constructor(e4 = {}) {
    super(e4);
    this._geoRulerLayer = new Ma("rayHeightRuler", { entities: [], pickingEnabled: false, polygonOffsetUnits: -2, relativeToGround: false, hideInLayerSwitcher: true });
    this._rayV = new zr({ name: "verticalRay", ray: xh });
    this._rayH = new zr({ name: "heightRay", ray: xh });
    this._heightLabels = [new zr({ name: "startCornerLabel", label: { ...bh } }), new zr({ name: "endCornerLabel", label: { ...bh } }), new zr({ name: "deltaLabel", label: { ...bh } })];
  }
  setVisibility(e4) {
    super.setVisibility(e4);
    this._geoRulerLayer.setVisibility(e4);
  }
  get deltaLabel() {
    return this._heightLabels[2];
  }
  get startLabel() {
    return this._heightLabels[0];
  }
  get endLabel() {
    return this._heightLabels[1];
  }
  get corners() {
    return this._cornerEntity;
  }
  get startCorner() {
    return this.corners[0];
  }
  get endCorner() {
    return this.corners[1];
  }
  get startCornerLonLat() {
    return this.startCorner.getLonLat();
  }
  get startCornerHeight() {
    return this.startCornerLonLat.height;
  }
  get endCornerLonLat() {
    return this.endCorner.getLonLat();
  }
  get endCornerHeight() {
    return this.endCornerLonLat.height;
  }
  get maxHeightCornerLonLat() {
    if (this.startCornerHeight <= this.endCornerHeight) {
      return this.endCornerLonLat;
    } else {
      return this.startCornerLonLat;
    }
  }
  get minHeightCornerLonLat() {
    if (this.startCornerHeight > this.endCornerHeight) {
      return this.endCornerLonLat;
    } else {
      return this.startCornerLonLat;
    }
  }
  get deltaHeight() {
    return Math.abs(this.startCornerHeight - this.endCornerHeight);
  }
  _drawLine(e4, t2, i2) {
    super._drawLine(e4, t2, i2);
    this._updateHeightRaysAndLabels();
  }
  async _updateHeightRaysAndLabels() {
    const e4 = this.minHeightCornerLonLat.clone();
    e4.height = this.maxHeightCornerLonLat.height;
    this._rayH.ray.setStartPosition3v(this._planet.ellipsoid.lonLatToCartesian(this.maxHeightCornerLonLat));
    this._rayH.ray.setEndPosition3v(this._planet.ellipsoid.lonLatToCartesian(e4));
    this._rayV.ray.setStartPosition3v(this._planet.ellipsoid.lonLatToCartesian(this.minHeightCornerLonLat));
    this._rayV.ray.setEndPosition3v(this._planet.ellipsoid.lonLatToCartesian(e4));
    e4.height = this.minHeightCornerLonLat.height + this.deltaHeight / 2;
    this.deltaLabel.setLonLat(e4);
    this.startLabel.setLonLat(this.startCornerLonLat);
    this.endLabel.setLonLat(this.endCornerLonLat);
    const t2 = await this._planet.getHeightDefault(this.startCornerLonLat), i2 = await this._planet.getHeightDefault(this.endCornerLonLat);
    this.deltaLabel.label.setText(`Δ ${Math.abs(t2 - i2).toFixed(1)} m`);
    this.startLabel.label.setText(`P1 ${t2.toFixed(1)} m`);
    this.endLabel.label.setText(`P2 ${i2.toFixed(1)} m`);
  }
  clear() {
    this._rayH.remove();
    this._rayV.remove();
    this.startCorner.remove();
    this.endCorner.remove();
    this.startLabel.remove();
    this.endLabel.remove();
    this.deltaLabel.remove();
    super.clear();
    this._planet.removeLayer(this._geoRulerLayer);
  }
  _createCorners() {
    this._cornerEntity = [new zr({ geoObject: wh, properties: { name: "start" } }), new zr({ geoObject: wh, properties: { name: "end" } })];
    this._cornersLayer.setEntities(this._cornerEntity);
  }
  init() {
    super.init();
    this._createCorners();
    this._labelLayer.addEntities(this._heightLabels);
    this._geoRulerLayer.addEntities([this._rayH, this._rayV]);
    this._planet.addLayer(this._geoRulerLayer);
  }
  frame() {
    super.frame();
    this._updateHeightRaysAndLabels();
  }
}
class Th extends vh {
  constructor(e4 = {}) {
    super(e4);
    this._rulerScene = new Ch({ name: `heightRulerScene:${this.__id}`, ignoreTerrain: false });
  }
}
const Eh = `<?xml version="1.0" encoding="iso-8859-1"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg fill="#000000" height="800px" width="800px" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
	 viewBox="0 0 512 512" xml:space="preserve">
<g>
	<g>
		<path d="M369.151,0L0.001,369.15L142.85,512l369.149-369.15L369.151,0z M47.286,369.15l10.908-10.908l47.782,47.782l23.642-23.642
			L81.837,334.6l10.909-10.909l23.711,23.711L140.1,323.76l-23.711-23.711l10.909-10.909l23.711,23.711l23.642-23.642
			l-23.711-23.711l10.909-10.909l47.782,47.782l23.642-23.642l-47.782-47.782l10.908-10.908l23.71,23.71l23.642-23.642l-23.71-23.71
			l10.908-10.908l23.711,23.711l23.642-23.642l-23.711-23.711l10.909-10.909l47.782,47.782l23.642-23.642l-47.782-47.782
			l10.908-10.908l23.71,23.711l23.642-23.642l-23.711-23.71L334.6,81.837l23.711,23.71l23.642-23.642l-23.711-23.712l10.908-10.908
			l95.564,95.564L142.85,464.714L47.286,369.15z"/>
	</g>
</g>
</svg>`;
class Ah extends ns {
  constructor(e4 = {}) {
    super({ name: "RulerSwitcher", ...e4 });
    this.ruler = new Th({ ignoreTerrain: e4.ignoreTerrain });
  }
  oninit() {
    this.planet.addControl(this.ruler);
    this._createMenuBtn();
  }
  onactivate() {
    this.ruler.activate();
  }
  ondeactivate() {
    this.ruler.deactivate();
  }
  _createMenuBtn() {
    let e4 = new _s({ classList: ["og-map-button", "og-ruler_button"], icon: Eh });
    e4.appendTo(this.renderer.div);
    e4.events.on("change", (e5) => {
      if (e5) {
        this.onactivate();
      } else {
        this.ondeactivate();
      }
    });
  }
}
const Lh = [1e-3, 5e-3, 0.01, 0.05, 0.1, 0.2, 0.5, 1, 2, 3, 5, 10, 20, 30, 50, 100, 200, 300, 500, 1e3, 2e3, 3e3, 5e3, 1e4, 2e4, 3e4, 5e4, 1e5, 2e5, 3e5, 5e5, 1e6, 2e6, 3e6, 5e6, 1e7];
const Ph = `<div class="og-scale-container">
      <div class="og-scale-label"></div>
      <div class="og-scale-ruler"></div>
    </div>`;
class Sh extends ns {
  constructor(e4 = {}) {
    if (!e4.name || e4.name === "") {
      e4.name = "scaleControl";
    }
    super(e4);
    this._template = Ph;
    this._minWidth = 100;
    this._maxWidth = 150;
    this._isCenter = e4.isCenter != void 0 ? e4.isCenter : true;
    this._mPx = 0;
    this.currWidth = 0;
    this._metersInMinSize = 0;
    this.el = null;
    this._scaleLabelEl = null;
  }
  _renderTemplate() {
    return mt(this._template)[0];
  }
  oninit() {
    this.el = this._renderTemplate();
    this._scaleLabelEl = this.el.querySelector(".og-scale-label");
    this.renderer.div.appendChild(this.el);
    if (this._isCenter) {
      this.planet.camera.events.on("moveend", () => {
        this._drawScreen(this.planet.renderer.handler.getCenter());
      });
      !this.planet.terrain.isEmpty && this.planet.terrain.events.on("loadend", () => {
        this._drawScreen(this.planet.renderer.handler.getCenter());
      });
    } else {
      this.renderer.events.on("mousemove", (e4) => {
        if (!e4.leftButtonHold && !e4.rightButtonHold) {
          this._drawScreen(e4.pos);
        }
      });
      this.planet.camera.events.on("moveend", () => {
        let e4 = this.renderer.events.mouseState;
        if (!e4.leftButtonHold && !e4.rightButtonHold) {
          this._drawScreen(e4.pos);
        }
      });
    }
  }
  _drawScreen(e4) {
    let t2 = this.planet.camera;
    let i2 = e4;
    let s2 = this.planet.getDistanceFromPixel(i2) || 0;
    if (s2 === 0) {
      i2 = t2.project3v(Ke.ZERO);
      s2 = this.planet.getDistanceFromPixel(i2) || 0;
    }
    let r2 = t2.getForward().scaleTo(s2).addA(t2.eye);
    let n2 = s2 * Math.tan(t2.viewAngle * d);
    let o2 = r2.add(t2.getRight().scaleTo(n2));
    let a2 = t2.project3v(o2);
    this._mPx = n2 / a2.distance(i2);
    let l2 = this._mPx * this._minWidth;
    let h2 = Pt(Lh, l2, (e5, t3) => e5 - t3);
    if (h2 < 0) {
      h2 = ~h2;
    }
    let c2 = Lh[h2], u2 = Lh[h2 + 1];
    let _2 = (c2 - l2) / (u2 - c2);
    this.currWidth = this._minWidth + _2 * (this._maxWidth - this._minWidth);
    if (c2 >= 1e3) {
      this._scaleLabelEl.innerText = `${c2 / 1e3} km`;
    } else if (c2 >= 1) {
      this._scaleLabelEl.innerText = `${c2} m`;
    } else if (c2 >= 0.01) {
      this._scaleLabelEl.innerText = `${c2 * 100} cm`;
    } else {
      this._scaleLabelEl.innerText = `${c2 * 1e3} mm`;
    }
    this._metersInMinSize = l2;
    this.el.style.width = this.currWidth + "px";
  }
}
class Rh extends ns {
  constructor(e4) {
    super(e4);
  }
  oninit() {
    let e4 = document.createElement("div");
    e4.className = "defaultText ";
    e4.id = "ogShowFpsControl";
    document.body.appendChild(e4);
    this.renderer.events.on("draw", this._draw, this);
  }
  _draw() {
    vt("ogShowFpsControl", (1e3 / this.renderer.handler.deltaTime).toFixed(1), this.renderer.handler.canvas.clientWidth - 60, 0);
  }
}
class Mh extends ns {
  constructor(e4 = {}) {
    super({ name: "SimpleNavigation", autoActivate: true, ...e4 });
    this._onMouseLeftButtonClick = (e5) => {
      if (this._active && this.renderer) {
        this.renderer.handler.canvas.classList.add("ogGrabbingPoiner");
        this._grabbedPoint = this.renderer.getCartesianFromPixel(e5);
        if (this._grabbedPoint) {
          this._eye0.copy(this.renderer.activeCamera.eye);
        }
      }
    };
    this._onMouseLeftButtonUp = (e5) => {
      this.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
      if (e5.x === e5.prev_x && e5.y === e5.prev_y) ;
    };
    this._onMouseLeftButtonDown = (e5) => {
      if (this._active && this.renderer) {
        if (!this._grabbedPoint) {
          return;
        }
        if (e5.moving) {
          let t2 = this.renderer.activeCamera;
          let i2 = Math.abs(t2.getForward().dot(Ke.UP));
          let s2 = this._grabbedPoint, r2, n2;
          if (i2 > 0.7) {
            r2 = Ke.add(s2, Ke.LEFT);
            n2 = Ke.add(s2, t2.getRight());
          } else {
            r2 = Ke.add(s2, t2.getRight());
            n2 = Ke.add(s2, Ke.UP);
          }
          let o2 = new Ke();
          if (new ar(t2.eye, e5.direction).hitPlaneRes(or.fromPoints(s2, r2, n2), o2) === ar.INSIDE) {
            t2.eye = this._eye0.addA(o2.subA(s2).negate());
          }
        }
      }
    };
    this._onRHold = (e5) => {
      if (this._lookPos && e5.moving && this.renderer) {
        const t2 = this.renderer.activeCamera;
        this.renderer.controlsBag.scaleRot = 1;
        let i2 = 0.5 / t2.eye.distance(this._lookPos) * d;
        if (i2 > 7e-3) {
          i2 = 7e-3;
        } else if (i2 < 3e-3) {
          i2 = 3e-3;
        }
        t2.rotateHorizontal(i2 * (e5.x - e5.prev_x), false, this._lookPos, this._up);
        t2.rotateVertical(i2 * (e5.y - e5.prev_y), this._lookPos);
      }
    };
    this._onRDown = (e5) => {
      if (this.renderer) {
        this._lookPos = this.renderer.getCartesianFromPixel(e5.pos);
        if (this._lookPos) {
          this._up = Ke.UP;
        }
      }
    };
    this._onMouseWheel = (e5) => {
      if (this.renderer) {
        let t2 = this.renderer.getCartesianFromPixel(e5), i2 = 10;
        if (t2) {
          i2 = this.renderer.activeCamera.eye.distance(t2);
        }
        this.force.addA(e5.direction.scale(e5.wheelDelta)).normalize().scale(i2);
      }
    };
    this.onCameraMoveForward = () => {
      this.force.addA(this.renderer.activeCamera.getForward()).normalize();
    };
    this.onCameraMoveBackward = () => {
      this.force.addA(this.renderer.activeCamera.getBackward()).normalize();
    };
    this.onCameraStrifeLeft = () => {
      this.force.addA(this.renderer.activeCamera.getLeft()).normalize();
    };
    this.onCameraStrifeRight = () => {
      this.force.addA(this.renderer.activeCamera.getRight()).normalize();
    };
    this.onCameraLookUp = () => {
      let e5 = this.renderer.activeCamera;
      e5.setPitch(0.5);
      e5.update();
    };
    this.onCameraLookDown = () => {
      let e5 = this.renderer.activeCamera;
      e5.setPitch(-0.5);
      e5.update();
    };
    this.onCameraTurnLeft = () => {
      let e5 = this.renderer.activeCamera;
      e5.setYaw(0.5);
      e5.update();
    };
    this.onCameraTurnRight = () => {
      let e5 = this.renderer.activeCamera;
      e5.setYaw(-0.5);
      e5.update();
    };
    this.onCameraRollLeft = () => {
      let e5 = this.renderer.activeCamera;
      e5.setRoll(-0.5);
      e5.update();
    };
    this.onCameraRollRight = () => {
      let e5 = this.renderer.activeCamera;
      e5.setRoll(0.5);
      e5.update();
    };
    this.speed = e4.speed || 1;
    this.force = new Ke();
    this.vel = new Ke();
    this.mass = 1;
    this._lookPos = void 0;
    this._grabbedPoint = void 0;
    this._up = null;
    this._eye0 = new Ke();
  }
  oninit() {
  }
  onactivate() {
    super.onactivate();
    let e4 = this.renderer;
    e4.events.on("mousewheel", this._onMouseWheel);
    e4.events.on("keypress", zl.KEY_W, this.onCameraMoveForward, this);
    e4.events.on("keypress", zl.KEY_S, this.onCameraMoveBackward, this);
    e4.events.on("keypress", zl.KEY_A, this.onCameraStrifeLeft, this);
    e4.events.on("keypress", zl.KEY_D, this.onCameraStrifeRight, this);
    e4.events.on("keypress", zl.KEY_UP, this.onCameraLookUp, this);
    e4.events.on("keypress", zl.KEY_DOWN, this.onCameraLookDown, this);
    e4.events.on("keypress", zl.KEY_LEFT, this.onCameraTurnLeft, this);
    e4.events.on("keypress", zl.KEY_RIGHT, this.onCameraTurnRight, this);
    e4.events.on("keypress", zl.KEY_Q, this.onCameraRollLeft, this);
    e4.events.on("keypress", zl.KEY_E, this.onCameraRollRight, this);
    e4.events.on("rhold", this._onRHold, this);
    e4.events.on("rdown", this._onRDown, this);
    e4.events.on("lhold", this._onMouseLeftButtonDown);
    e4.events.on("ldown", this._onMouseLeftButtonClick);
    e4.events.on("lup", this._onMouseLeftButtonUp);
    e4.events.on("draw", this.onDraw, this, -1e3);
  }
  ondeactivate() {
    super.ondeactivate();
    let e4 = this.renderer;
    e4.events.off("mousewheel", this._onMouseWheel);
    e4.events.off("keypress", zl.KEY_W, this.onCameraMoveForward);
    e4.events.off("keypress", zl.KEY_S, this.onCameraMoveBackward);
    e4.events.off("keypress", zl.KEY_A, this.onCameraStrifeLeft);
    e4.events.off("keypress", zl.KEY_D, this.onCameraStrifeRight);
    e4.events.off("keypress", zl.KEY_UP, this.onCameraLookUp);
    e4.events.off("keypress", zl.KEY_DOWN, this.onCameraLookDown);
    e4.events.off("keypress", zl.KEY_LEFT, this.onCameraTurnLeft);
    e4.events.off("keypress", zl.KEY_RIGHT, this.onCameraTurnRight);
    e4.events.off("keypress", zl.KEY_Q, this.onCameraRollLeft);
    e4.events.off("keypress", zl.KEY_E, this.onCameraRollRight);
    e4.events.off("rhold", this._onRHold);
    e4.events.off("rdown", this._onRDown);
    e4.events.off("lhold", this._onMouseLeftButtonDown);
    e4.events.off("ldown", this._onMouseLeftButtonClick);
    e4.events.off("lup", this._onMouseLeftButtonUp);
    e4.events.off("draw", this.onDraw);
  }
  get dt() {
    return 1e-3 * this.renderer.handler.deltaTime;
  }
  onDraw() {
    if (this.renderer) {
      let e4 = this.force.scale(1 / this.mass);
      this.vel.addA(e4);
      this.vel.scale(0.96);
      this.force.set(0, 0, 0);
      let t2 = this.renderer.activeCamera;
      t2.eye = t2.eye.add(this.vel.scaleTo(this.dt));
      t2.update();
    }
  }
}
class Bh extends ns {
  constructor(e4 = {}) {
    super({ name: "SimpleSkyBackground", ...e4 });
    this._colorOne = new Float32Array([128 / 255, 223 / 255, 255 / 255]);
    this._colorTwo = new Float32Array([10 / 255, 15 / 255, 56 / 255]);
  }
  get colorOne() {
    let e4 = this._colorOne;
    let t2 = [Math.round(e4[0] * 255), Math.round(e4[1] * 255), Math.round(e4[2] * 255)];
    return ct(t2);
  }
  get colorTwo() {
    let e4 = this._colorTwo;
    let t2 = [Math.round(e4[0] * 255), Math.round(e4[1] * 255), Math.round(e4[2] * 255)];
    return ct(t2);
  }
  set colorOne(e4) {
    let t2 = _t(e4);
    this._colorOne[0] = t2.x;
    this._colorOne[1] = t2.y;
    this._colorOne[2] = t2.z;
  }
  set colorTwo(e4) {
    let t2 = _t(e4);
    this._colorTwo[0] = t2.x;
    this._colorTwo[1] = t2.y;
    this._colorTwo[2] = t2.z;
  }
  oninit() {
    this.renderer.handler.addProgram(kh());
    this.activate();
  }
  onactivate() {
    super.onactivate();
    this.planet.events.on("draw", this._drawBackground, this);
  }
  ondeactivate() {
    super.ondeactivate();
    this.planet.events.off("draw", this._drawBackground);
  }
  _drawBackground() {
    let e4 = this.renderer.handler;
    let t2 = e4.programs.simpleSkyBackground, i2 = t2._program, s2 = i2.uniforms, r2 = e4.gl;
    let n2 = this.planet.camera;
    r2.disable(r2.DEPTH_TEST);
    t2.activate();
    r2.bindBuffer(r2.ARRAY_BUFFER, this.renderer.screenFramePositionBuffer);
    r2.vertexAttribPointer(i2.attributes.corners, 2, r2.FLOAT, false, 0, 0);
    r2.uniform3fv(s2.camPos, [n2.eye.x, n2.eye.y, n2.eye.z]);
    r2.uniform2fv(s2.iResolution, [e4.getWidth(), e4.getHeight()]);
    r2.uniform1f(s2.fov, n2.getViewAngle());
    r2.uniform1f(s2.earthRadius, this.planet.ellipsoid.getPolarSize() + 1);
    r2.uniform3fv(s2.colorOne, this._colorOne);
    r2.uniform3fv(s2.colorTwo, this._colorTwo);
    r2.uniformMatrix4fv(s2.viewMatrix, false, n2.getViewMatrix());
    r2.drawArrays(r2.TRIANGLE_STRIP, 0, 4);
    r2.enable(r2.DEPTH_TEST);
  }
}
function kh() {
  return new Yr("simpleSkyBackground", { uniforms: { iResolution: "vec2", fov: "float", camPos: "vec3", earthRadius: "float", viewMatrix: "mat4", colorOne: "vec3", colorTwo: "vec3" }, attributes: { corners: "vec3" }, vertexShader: `attribute vec2 corners;
                        
            varying vec2 tc;
            
            void main(void) {
                gl_Position = vec4(corners, 0.0, 1.0);
                tc = corners * 0.5 + 0.5;
            }`, fragmentShader: `precision highp float;
            
            #define MAX 10e10
            #define PI 3.14159265359
            #define rad(x) x * PI / 180.
            #define ZERO vec3(0.0)          
           
            #define RED vec4(1.0, 0.0, 0.0, 1.0)
            #define GREEN vec4(0.0, 1.0, 0.0, 1.0)         
            
            uniform vec3 camPos;            
            uniform vec2 iResolution;
            uniform float fov;
            uniform float earthRadius;
            uniform mat4 viewMatrix;
            
            uniform vec3 colorOne;
            uniform vec3 colorTwo;
                         
            varying vec2 tc;
                        
            // compute the view ray in the camera coordinate
            vec3 computeView(vec2 uv){
                float w_h_ratio = iResolution.x / iResolution.y;   
                float h = tan(rad(fov/2.));
                return normalize(vec3(-w_h_ratio * h, -h, -1.) + vec3(uv.x * 2. * h * w_h_ratio, uv.y*2.*h, 0.));
            }

            // sphere of size ra centered at point ce
            vec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )
            {
                vec3 oc = ro - ce;
                float b = dot( oc, rd );
                float c = dot( oc, oc ) - ra * ra;
                float h = b * b - c;
                if( h < 0.0 ) return vec2(MAX); // no intersection
                h = sqrt( h );
                return vec2( -b-h, -b+h );
            }
            
            mat3 transpose(mat3 matrix) {
                vec3 row0 = matrix[0];
                vec3 row1 = matrix[1];
                vec3 row2 = matrix[2];
                mat3 result = mat3(
                    vec3(row0.x, row1.x, row2.x),
                    vec3(row0.y, row1.y, row2.y),
                    vec3(row0.z, row1.z, row2.z)
                );
                return result;
            }
            
            float det(mat2 matrix) {
                return matrix[0].x * matrix[1].y - matrix[0].y * matrix[1].x;
            }
            
            mat3 inverse(mat3 matrix) {
                vec3 row0 = matrix[0];
                vec3 row1 = matrix[1];
                vec3 row2 = matrix[2];
            
                vec3 minors0 = vec3(
                    det(mat2(row1.y, row1.z, row2.y, row2.z)),
                    det(mat2(row1.z, row1.x, row2.z, row2.x)),
                    det(mat2(row1.x, row1.y, row2.x, row2.y))
                );
                vec3 minors1 = vec3(
                    det(mat2(row2.y, row2.z, row0.y, row0.z)),
                    det(mat2(row2.z, row2.x, row0.z, row0.x)),
                    det(mat2(row2.x, row2.y, row0.x, row0.y))
                );
                vec3 minors2 = vec3(
                    det(mat2(row0.y, row0.z, row1.y, row1.z)),
                    det(mat2(row0.z, row0.x, row1.z, row1.x)),
                    det(mat2(row0.x, row0.y, row1.x, row1.y))
                );
            
                mat3 adj = transpose(mat3(minors0, minors1, minors2));
            
                return (1.0 / dot(row0, minors0)) * adj;
            }
            
            void main(void) {
            
                vec3 dir = computeView(tc);
                dir = inverse(mat3(viewMatrix)) * dir;
                
                vec2 ER = sphIntersect(camPos, dir, vec3(0.0), earthRadius);
                
                float bigRadius = earthRadius * 2.5;
                vec3 bigCenter = normalize(camPos) * bigRadius * 1.3;                
                               
                vec2 BIG = sphIntersect(camPos, dir, bigCenter, bigRadius);
                
                float Ix = distance(camPos + dir * BIG.y, ZERO);               
                
                float maxI = sqrt(bigRadius * bigRadius + bigRadius * bigRadius);
                                   
                gl_FragColor = vec4(mix(colorOne, colorTwo, Ix / maxI), 1.0);
            }` });
}
const Ih = 23.4392911;
const zh = 14959787e4;
function Dh(t2) {
  var i2 = t2 - Ti;
  var s2 = 282.9404 + 470935e-10 * i2;
  var r2 = 0.016709 - 1151e-12 * i2;
  var n2 = he(356.047 + 0.9856002585 * i2);
  var o2 = Ih - 3563e-10 * i2;
  var a2 = n2 + u * r2 * Math.sin(n2 * d) * (1 + r2 * Math.cos(n2 * d));
  var l2 = Math.cos(a2 * d) - r2;
  var h2 = Math.sin(a2 * d) * Math.sqrt(1 - r2 * r2);
  var c2 = Math.sqrt(l2 * l2 + h2 * h2);
  var _2 = Math.atan2(h2, l2) * u;
  var f2 = he(_2 + s2);
  l2 = c2 * Math.cos(f2 * d);
  h2 = c2 * Math.sin(f2 * d);
  var g2 = l2;
  var p2 = h2 * Math.cos(o2 * d);
  var m2 = h2 * Math.sin(o2 * d);
  var v2 = e * (i2 * 24 / 23.9344694 - 259.853 / 360);
  return Ze.zRotation(-v2).mulVec3(new Ke(-g2 * zh, -p2 * zh, m2 * zh));
}
class Fh {
  constructor(e4) {
    this._renderNode = null;
    this._position = e4.position || new Ke();
    this._ambient = e4.ambient || new Ke();
    this._diffuse = e4.diffuse || new Ke(0.8, 0.8, 0.8);
    this._specular = e4.specular || new Ke(0.18, 0.18, 0.18);
    this._shininess = e4.shininess != void 0 ? e4.shininess : 3.3;
    this._active = true;
    this._tempAmbient = this._ambient.clone();
    this._tempDiffuse = this._diffuse.clone();
    this._tempSpecular = this._specular.clone();
    this._tempShininess = this._shininess;
  }
  isActive() {
    return this._active;
  }
  setPosition3v(e4) {
    this.setPosition(e4.x, e4.y, e4.z);
  }
  setPosition(e4, t2, i2) {
    this._position.x = e4;
    this._position.y = t2;
    this._position.z = i2;
    if (this._renderNode) {
      this._renderNode._lightPosition[0] = e4;
      this._renderNode._lightPosition[1] = t2;
      this._renderNode._lightPosition[2] = i2;
    }
  }
  getPosition() {
    return this._position.clone();
  }
  setAmbient3v(e4) {
    this.setAmbient(e4.x, e4.y, e4.z);
  }
  setDiffuse3v(e4) {
    this.setDiffuse(e4.x, e4.y, e4.z);
  }
  setSpecular3v(e4) {
    this.setSpecular(e4.x, e4.y, e4.z);
  }
  setAmbient(e4, t2, i2) {
    this._ambient.set(e4, t2, i2);
    const s2 = this._renderNode;
    if (s2) {
      s2._lightParams[0] = e4;
      s2._lightParams[1] = t2;
      s2._lightParams[2] = i2;
    }
  }
  setDiffuse(e4, t2, i2) {
    this._diffuse.set(e4, t2, i2);
    const s2 = this._renderNode;
    if (s2) {
      s2._lightParams[3] = e4;
      s2._lightParams[4] = t2;
      s2._lightParams[5] = i2;
    }
  }
  setSpecular(e4, t2, i2) {
    this._specular.set(e4, t2, i2);
    const s2 = this._renderNode;
    if (s2) {
      s2._lightParams[6] = e4;
      s2._lightParams[7] = t2;
      s2._lightParams[8] = i2;
    }
  }
  setShininess(e4) {
    this._shininess = e4;
    const t2 = this._renderNode;
    if (t2) {
      t2._lightShininess = e4;
    }
  }
  addTo(e4) {
    this._renderNode = e4;
    this.setShininess(this._shininess);
    this.setAmbient3v(this._ambient);
    this.setDiffuse3v(this._diffuse);
    this.setSpecular3v(this._specular);
  }
}
class Nh extends ns {
  constructor(e4 = {}) {
    super({ autoActivate: true, ...e4 });
    this._name = "sun";
    this.activationHeight = e4.activationHeight || 12079e3;
    this.offsetVertical = e4.offsetVertical || -5e6;
    this.offsetHorizontal = e4.offsetHorizontal || 5e6;
    this.sunlight = new Fh({ ambient: new Ke(0.15, 0.15, 0.25), diffuse: new Ke(0.9, 0.9, 0.8), specular: new Ke(0.1, 0.1, 0.06), shininess: 110 });
    this._currDate = 0;
    this._prevDate = 0;
    this._clockPtr = null;
    this._lightOn = false;
    this._f = 0;
    this._k = 0;
    this._stopped = e4.stopped || false;
  }
  oninit() {
    this.planet.lightEnabled = true;
    this.sunlight.addTo(this.planet);
    this.renderer.events.on("draw", this._draw, this);
    if (!this._clockPtr) {
      this._clockPtr = this.renderer.handler.defaultClock;
    }
  }
  stop() {
    this._stopped = true;
    this.deactivate();
  }
  start() {
    this._stopped = false;
    this.activate();
  }
  onactivate() {
    super.onactivate();
    this._stopped = false;
  }
  bindClock(e4) {
    this._clockPtr = e4;
  }
  _draw() {
    if (!this._clockPtr) return;
    this._currDate = this._clockPtr.currentDate;
    if (!this._stopped) {
      let e4 = this.planet.camera;
      if (e4.getHeight() < this.activationHeight || !this._active) {
        this._lightOn = true;
        this._f = 1;
        let t2 = e4.eye.normal(), i2 = e4.getForward();
        i2.scale(Math.sign(e4.getUp().dot(t2)));
        if (e4.slope > 0.99) {
          i2 = e4.getUp();
        }
        let s2 = Ke.proj_b_to_plane(i2, t2, i2).normalize().scale(this.offsetVertical);
        let r2 = Ke.proj_b_to_plane(e4.getRight(), t2, e4.getRight()).normalize().scale(this.offsetHorizontal);
        let n2 = s2.add(r2);
        let o2 = e4.eye.add(n2);
        if (this._k > 0) {
          this._k -= 1e-3;
          let e5 = Ze.getRotationBetweenVectors(this.sunlight._position.normal(), o2.normal());
          let t3 = e5.slerp(Ze.IDENTITY, this._k).normalize();
          this.sunlight.setPosition3v(t3.mulVec3(this.sunlight._position));
        } else {
          this.sunlight.setPosition3v(o2);
        }
      } else {
        this._k = 1;
        if (this._f > 0) {
          this._f -= 1e-3;
          let e5 = Ze.getRotationBetweenVectors(this.sunlight._position.normal(), Dh(this._currDate).normal());
          let t2 = e5.slerp(Ze.IDENTITY, this._f).normalize();
          this.sunlight.setPosition3v(t2.mulVec3(this.sunlight._position));
        } else {
          if (Math.abs(this._currDate - this._prevDate) > 34e-5 && this._active || this._lightOn) {
            this._lightOn = false;
            this._prevDate = this._currDate;
            this.sunlight.setPosition3v(Dh(this._currDate));
            this._f = 0;
          }
        }
      }
    } else {
      this.sunlight.setPosition3v(Dh(this._currDate));
    }
  }
}
class Oh extends ns {
  constructor(e4 = {}) {
    super(e4);
    this._isActive = false;
    this.toogleWireframe = () => {
      if (this.renderer && this.renderer.handler.gl) {
        if (this.planet.drawMode === this.renderer.handler.gl.LINE_STRIP) {
          this.planet.setDrawMode(this.renderer.handler.gl.TRIANGLE_STRIP);
        } else {
          this.planet.setDrawMode(this.renderer.handler.gl.LINE_STRIP);
        }
      }
    };
    this._isActive = e4.isActive || false;
  }
  oninit() {
    this.renderer.events.on("charkeypress", zl.KEY_X, this.toogleWireframe, this);
    if (this._isActive) {
      this.planet.setDrawMode(this.renderer.handler.gl.LINE_STRIP);
    }
  }
}
class Hh {
  constructor() {
    this.x = 0;
    this.y = 0;
    this.prev_x = 0;
    this.prev_y = 0;
    this.grabbedPoint = null;
    this.grabbedSpheroid = new Zi();
    this._vec = new Qe();
    this._vecPrev = new Qe();
  }
  get dY() {
    return this.y - this.prev_y;
  }
  get dX() {
    return this.x - this.prev_x;
  }
  get vec() {
    return this._vec.set(this.x, this.y);
  }
  get vecPrev() {
    return this._vecPrev.set(this.prev_x, this.prev_y);
  }
}
class Vh extends ns {
  constructor(e4 = {}) {
    super(e4);
    this._name = "touchNavigation";
    this.grabbedPoint = new Ke();
    this.inertia = 7e-3;
    this.grabbedSpheroid = new Zi();
    this.planet = null;
    this.qRot = new Ze();
    this.scaleRot = 0;
    this.rot = 1;
    this._eye0 = new Ke();
    this.pointOnEarth = null;
    this.earthUp = null;
    this.touches = [new Hh(), new Hh()];
    this._keyLock = new oh();
    this._touching = false;
  }
  oninit() {
    if (this.renderer) {
      this.renderer.events.on("touchstart", this.onTouchStart, this);
      this.renderer.events.on("touchend", this.onTouchEnd, this);
      this.renderer.events.on("doubletouch", this.onDoubleTouch, this);
      this.renderer.events.on("touchcancel", this.onTouchCancel, this);
      this.renderer.events.on("touchmove", this.onTouchMove, this);
      this.renderer.events.on("draw", this.onDraw, this);
    }
  }
  onTouchStart(e4) {
    const t2 = this.renderer.handler;
    this._touching = true;
    if (e4.sys.touches.length === 2) {
      const i2 = this.touches[0];
      const s2 = this.touches[1];
      i2.x = (e4.sys.touches.item(0).clientX - e4.sys.offsetLeft) * t2.pixelRatio;
      i2.y = (e4.sys.touches.item(0).clientY - e4.sys.offsetTop) * t2.pixelRatio;
      i2.prev_x = i2.x;
      i2.prev_y = i2.y;
      i2.grabbedPoint = this.planet.getCartesianFromPixelTerrain(new Qe(i2.x, i2.y)) || null;
      s2.x = (e4.sys.touches.item(1).clientX - e4.sys.offsetLeft) * t2.pixelRatio;
      s2.y = (e4.sys.touches.item(1).clientY - e4.sys.offsetTop) * t2.pixelRatio;
      s2.prev_x = s2.x;
      s2.prev_y = s2.y;
      s2.grabbedPoint = this.planet.getCartesianFromPixelTerrain(new Qe(s2.x, s2.y)) || null;
      this.pointOnEarth = this.planet.getCartesianFromPixelTerrain(this.renderer.handler.getCenter()) || null;
      if (this.pointOnEarth) {
        this.earthUp = this.pointOnEarth.normal();
      }
      if (i2.grabbedPoint && s2.grabbedPoint) {
        i2.grabbedSpheroid.radius = i2.grabbedPoint.length();
        s2.grabbedSpheroid.radius = s2.grabbedPoint.length();
        this.stopRotation();
      }
    } else if (e4.sys.touches.length === 1) {
      this._startTouchOne(e4);
    }
  }
  _startTouchOne(e4) {
    const t2 = this.touches[0];
    const i2 = this.renderer.handler;
    t2.x = (e4.sys.touches.item(0).clientX - e4.sys.offsetLeft) * i2.pixelRatio;
    t2.y = (e4.sys.touches.item(0).clientY - e4.sys.offsetTop) * i2.pixelRatio;
    t2.prev_x = t2.x;
    t2.prev_y = t2.y;
    t2.grabbedPoint = this.planet.getCartesianFromPixelTerrain(e4) || null;
    this._eye0.copy(this.planet.camera.eye);
    if (t2.grabbedPoint) {
      t2.grabbedSpheroid.radius = t2.grabbedPoint.length();
      this.stopRotation();
    }
  }
  stopRotation() {
    this.qRot.clear();
    this.planet.layerLock.free(this._keyLock);
    this.planet.terrainLock.free(this._keyLock);
    this.planet._normalMapCreator.free(this._keyLock);
  }
  onDoubleTouch(e4) {
    this.planet.stopFlying();
    this.stopRotation();
    const t2 = this.planet.getCartesianFromPixelTerrain(e4);
    if (t2) {
      const e5 = this.planet.ellipsoid.cartesianToLonLat(t2);
      this.planet.flyLonLat(new be(e5.lon, e5.lat, this.planet.camera.eye.distance(t2) * 0.57));
    }
  }
  onTouchEnd(e4) {
    if (e4.sys.touches.length === 0) {
      this._touching = false;
    }
    if (e4.sys.touches.length === 1) {
      this._startTouchOne(e4);
    }
    if (Math.abs(this.touches[0].x - this.touches[0].prev_x) < 3 && Math.abs(this.touches[0].y - this.touches[0].prev_y) < 3) {
      this.scaleRot = 0;
    }
  }
  onTouchCancel(e4) {
  }
  onTouchMove(e4) {
    let t2 = this.planet.camera;
    const i2 = this.renderer.handler;
    if (e4.sys.touches.length === 2) {
      this.renderer.controlsBag.scaleRot = 1;
      let r2 = this.touches[0], n2 = this.touches[1];
      if (!r2.grabbedPoint || !n2.grabbedPoint) {
        return;
      }
      this.planet.stopFlying();
      r2.prev_x = r2.x;
      r2.prev_y = r2.y;
      r2.x = (e4.sys.touches.item(0).clientX - e4.sys.offsetLeft) * i2.pixelRatio;
      r2.y = (e4.sys.touches.item(0).clientY - e4.sys.offsetTop) * i2.pixelRatio;
      n2.prev_x = n2.x;
      n2.prev_y = n2.y;
      n2.x = (e4.sys.touches.item(1).clientX - e4.sys.offsetLeft) * i2.pixelRatio;
      n2.y = (e4.sys.touches.item(1).clientY - e4.sys.offsetTop) * i2.pixelRatio;
      const o2 = r2.vec.add(n2.vec).scale(0.5);
      const a2 = this.planet.getCartesianFromPixelTerrain(o2);
      if (a2) {
        this.pointOnEarth = a2;
        const e5 = Math.atan2(r2.prev_y - n2.prev_y, r2.prev_x - n2.prev_x);
        const i3 = Math.atan2(r2.y - n2.y, r2.x - n2.x);
        const o3 = i3 - e5;
        const l2 = t2.eye.distance(this.pointOnEarth);
        const h2 = r2.vec.sub(n2.vec);
        const c2 = r2.vecPrev.sub(n2.vecPrev);
        const u2 = h2.length() / c2.length();
        let _2 = l2 * -(1 - u2);
        t2.eye.addA(t2.getForward().scale(_2));
        t2.rotateAround(-o3, false, this.pointOnEarth, this.earthUp);
        const f2 = r2.vec.add(n2.vec).scale(0.5);
        const g2 = r2.vecPrev.add(n2.vecPrev).scale(0.5);
        const p2 = f2.sub(g2).scale(-1);
        var s2 = 0.5 / l2 * t2._lonLat.height * d;
        if (s2 > 3e-3) s2 = 3e-3;
        t2.rotateHorizontal(s2 * -p2.x, false, this.pointOnEarth, this.earthUp);
        t2.rotateVertical(s2 * -p2.y, this.pointOnEarth);
        t2.checkTerrainCollision();
        t2.update();
      }
      this.scaleRot = 0;
    } else if (e4.sys.touches.length === 1) {
      let s3 = this.touches[0];
      s3.prev_x = s3.x;
      s3.prev_y = s3.y;
      s3.x = (e4.sys.touches.item(0).clientX - e4.sys.offsetLeft) * i2.pixelRatio;
      s3.y = (e4.sys.touches.item(0).clientY - e4.sys.offsetTop) * i2.pixelRatio;
      if (!s3.grabbedPoint) {
        return;
      }
      this.planet.stopFlying();
      let r2 = e4.direction;
      let n2 = new ar(t2.eye, r2).hitSphere(s3.grabbedSpheroid);
      if (n2) {
        if (t2.slope > 0.2) {
          this.qRot = Ze.getRotationBetweenVectors(n2.normal(), s3.grabbedPoint.normal());
          let e5 = this.qRot;
          t2.eye = e5.mulVec3(t2.eye);
          t2.rotate(e5);
          t2.checkTerrainCollision();
          t2.update();
          this.scaleRot = 1;
        } else {
          let e5 = s3.grabbedPoint, i3 = Ke.add(e5, t2.getUp()), r3 = Ke.add(e5, e5.getNormal());
          let n3 = t2.unproject(s3.x, s3.y);
          let o2 = new Ke();
          if (new ar(t2.eye, n3).hitPlaneRes(or.fromPoints(e5, i3, r3), o2) === ar.INSIDE) {
            t2.eye = this._eye0.addA(o2.subA(e5).negate());
            t2.checkTerrainCollision();
            t2.update();
            this.scaleRot = 0;
          }
        }
      }
    }
  }
  onDraw() {
    const e4 = this.renderer;
    e4.controlsBag.scaleRot = this.scaleRot;
    if (this._touching) {
      return;
    }
    let t2 = this.planet.camera;
    let i2 = t2.eye.clone();
    if (e4.events.mouseState.leftButtonDown || !this.scaleRot) {
      return;
    }
    this.scaleRot -= this.inertia;
    if (this.scaleRot <= 0) {
      this.scaleRot = 0;
    } else {
      e4.controlsBag.scaleRot = this.scaleRot;
      let i3 = this.qRot.slerp(Ze.IDENTITY, 1 - this.scaleRot * this.scaleRot * this.scaleRot).normalize();
      if (!(i3.x || i3.y || i3.z)) {
        this.scaleRot = 0;
      }
      t2.eye = i3.mulVec3(t2.eye);
      t2.rotate(i3);
      t2.checkTerrainCollision();
      t2.update();
    }
    if (t2.eye.distance(i2) / t2.getAltitude() > 0.01) {
      this.planet.layerLock.lock(this._keyLock);
      this.planet.terrainLock.lock(this._keyLock);
      this.planet._normalMapCreator.lock(this._keyLock);
    } else {
      this.planet.layerLock.free(this._keyLock);
      this.planet.terrainLock.free(this._keyLock);
      this.planet._normalMapCreator.free(this._keyLock);
    }
  }
}
const Uh = '<?xml version="1.0"?><svg width=24 height=24 xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">    <path d="M 11 5 L 11 11 L 5 11 L 5 13 L 11 13 L 11 19 L 13 19 L 13 13 L 19 13 L 19 11 L 13 11 L 13 5 L 11 5 z"/></svg>';
const Gh = '<?xml version="1.0"?><svg width=24 height=24 xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">    <path d="M 5 11 L 5 13 L 19 13 L 19 11 L 5 11 z"/></svg>';
class Wh extends ns {
  constructor(e4 = {}) {
    super(e4);
    this._keyLock = new oh();
    this._move = 0;
    this._targetPoint = null;
  }
  oninit() {
    let e4 = new rs({ classList: ["og-map-button", "og-zoomin-button"], icon: Uh });
    e4.appendTo(this.renderer.div);
    let t2 = new rs({ classList: ["og-map-button", "og-zoomout-button"], icon: Gh });
    t2.appendTo(this.renderer.div);
    e4.events.on("mousedown", () => this.zoomIn());
    e4.events.on("mouseup", () => this.stopZoom());
    t2.events.on("mousedown", () => this.zoomOut());
    t2.events.on("mouseup", () => this.stopZoom());
    e4.events.on("touchstart", () => this.zoomIn());
    e4.events.on("touchend", () => this.stopZoom());
    e4.events.on("touchcancel", () => this.stopZoom());
    t2.events.on("touchstart", () => this.zoomOut());
    t2.events.on("touchend", () => this.stopZoom());
    t2.events.on("touchcancel", () => this.stopZoom());
    this.renderer.events.on("draw", this._draw, this);
  }
  zoomIn() {
    this.planet.layerLock.lock(this._keyLock);
    this.planet.terrainLock.lock(this._keyLock);
    this.planet._normalMapCreator.lock(this._keyLock);
    this._targetPoint = this.renderer.getCenter();
    this._move = 1;
  }
  zoomOut() {
    this.planet.layerLock.lock(this._keyLock);
    this.planet.terrainLock.lock(this._keyLock);
    this.planet._normalMapCreator.lock(this._keyLock);
    this._targetPoint = this.renderer.getCenter();
    this._move = -1;
  }
  stopZoom() {
    this._move = 0;
    this.planet.layerLock.free(this._keyLock);
    this.planet.terrainLock.free(this._keyLock);
    this.planet._normalMapCreator.free(this._keyLock);
  }
  _draw(e4) {
    const t2 = this.planet.camera;
    if (this._move !== 0) {
      const i2 = this.planet.getCartesianFromPixelTerrain(e4.getCenter());
      if (i2) {
        let e5 = t2.eye.distance(i2) * 0.035;
        t2.eye.addA(t2.getForward().scale(this._move * e5));
        t2.checkTerrainCollision();
        t2.update();
      }
    }
  }
}
const jh = 120;
function Yh(e4) {
  if (e4 > 1e3) {
    return `${(e4 / 1e3).toFixed(1)} km`;
  } else if (e4 > 9) {
    return `${Math.round(e4)} m`;
  } else {
    return `${e4.toFixed(1)} m`;
  }
}
class qh extends Fr {
  constructor(e4 = {}) {
    var _a2, _b;
    super(e4.name);
    this._ignoreTerrain = false;
    this.events = new Ji($h);
    this._ignoreTerrain = e4.ignoreTerrain != void 0 ? e4.ignoreTerrain : true;
    this._onSelect = e4.onSelect || null;
    this._autoSelectionHide = e4.autoSelectionHide || false;
    this._planet = e4.planet || null;
    this._startLonLat = null;
    this._heading = 0;
    this._propsLabel = new zr({ name: "propsLabel", label: { text: "", size: 11, color: "rgba(455,455,455,1.0)", outlineColor: "rgba(0,0,0,0.34)", outline: 0.23, align: "center", offset: [0, 18] } });
    (_b = (_a2 = this._propsLabel) == null ? void 0 : _a2.label) == null ? void 0 : _b.setVisibility(false);
    this._trackEntity = new zr({ polyline: { path3v: [], thickness: 3.8, color: "rgb(455,455,455)", isClosed: false } });
    this._trackEntity.polyline.altitude = 0.01;
    let t2 = ur.createCylinder(1.1, 0, 2.7, 20, 1, true, false, 0, 0, 0);
    this._cornerEntity = [new zr({ geoObject: { scale: 1, instanced: true, tag: "selection", color: "rgb(0,305,0)", object3d: t2 }, properties: { name: "start" } }), new zr({ geoObject: { scale: 1, instanced: true, tag: "selection", color: "rgb(455,0,0)", object3d: t2 }, properties: { name: "end" } })];
    this._trackLayer = new Ma("track", { entities: [this._trackEntity, this._propsLabel], pickingEnabled: false, polygonOffsetUnits: -1, relativeToGround: true, hideInLayerSwitcher: false });
    this._cornersLayer = new Ma("corners", { entities: [this._cornerEntity[0], this._cornerEntity[1]], pickingEnabled: true, hideInLayerSwitcher: true, scaleByDistance: [1, 4e6, 0.01], pickingScale: 2 });
  }
  set ignoreTerrain(e4) {
    this._ignoreTerrain = e4;
  }
  bindPlanet(e4) {
    this._planet = e4;
  }
  init() {
    this._activate();
  }
  onremove() {
    this._deactivate();
  }
  _activate() {
    var _a2, _b, _c2, _d2, _e2;
    (_b = (_a2 = this._propsLabel) == null ? void 0 : _a2.label) == null ? void 0 : _b.setVisibility(false);
    this._onMouseMove_ = this._onMouseMove.bind(this);
    (_c2 = this.renderer) == null ? void 0 : _c2.events.on("mousemove", this._onMouseMove_, this);
    this._onMouseLdown_ = this._onMouseLdown.bind(this);
    (_d2 = this.renderer) == null ? void 0 : _d2.events.on("ldown", this._onMouseLdown_, this);
    this._onMouseLup_ = this._onMouseLup.bind(this);
    (_e2 = this.renderer) == null ? void 0 : _e2.events.on("lup", this._onMouseLup_, this);
    this._planet.addLayer(this._trackLayer);
    this._planet.addLayer(this._cornersLayer);
  }
  _deactivate() {
    var _a2, _b, _c2;
    this._startLonLat = null;
    this._trackLayer.remove();
    this._cornersLayer.remove();
    (_a2 = this.renderer) == null ? void 0 : _a2.events.off("mousemove", this._onMouseMove_);
    (_b = this.renderer) == null ? void 0 : _b.events.off("ldown", this._onMouseLdown_);
    (_c2 = this.renderer) == null ? void 0 : _c2.events.off("lup", this._onMouseLup_);
    this.clear();
    this._onMouseMove_ = null;
    this._onMouseLdown_ = null;
    this._onMouseLup_ = null;
  }
  _onMouseLdown(e4) {
    var _a2, _b, _c2, _d2, _e2, _f2;
    e4.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
    e4.renderer.handler.canvas.style.cursor = "pointer";
    if (!this._startLonLat) {
      (_a2 = this._propsLabel.label) == null ? void 0 : _a2.setVisibility(false);
      (_b = this._trackEntity.polyline) == null ? void 0 : _b.setPath3v([]);
      (_c2 = this._cornerEntity[0].geoObject) == null ? void 0 : _c2.setVisibility(true);
      (_d2 = this._cornerEntity[1].geoObject) == null ? void 0 : _d2.setVisibility(true);
      (_f2 = (_e2 = this.renderer) == null ? void 0 : _e2.controls.mouseNavigation) == null ? void 0 : _f2.deactivate();
      this._startLonLat = this._planet.getLonLatFromPixelTerrain(e4);
      let t2 = this._planet.ellipsoid.lonLatToCartesian(this._startLonLat);
      this._cornerEntity[0].setCartesian3v(t2);
      this._cornerEntity[1].setCartesian3v(t2);
    }
  }
  _onMouseLup(e4) {
    var _a2, _b, _c2;
    if (this._startLonLat) {
      this._pickedCorner = null;
      this._anchorLonLat = null;
      (_a2 = this._propsLabel.label) == null ? void 0 : _a2.setVisibility(true);
      if (this._onSelect && typeof this._onSelect === "function") {
        let e5 = this._cornerEntity[0].getLonLat();
        let t2 = this._cornerEntity[1].getLonLat();
        let i2 = [Math.min(e5.lon, t2.lon), Math.min(e5.lat, t2.lat), Math.max(e5.lon, t2.lon), Math.max(e5.lat, t2.lat)];
        this._onSelect(i2);
      }
      if (this._autoSelectionHide) {
        this.clear();
      }
      this._startLonLat = null;
    }
    e4.renderer.handler.canvas.style.cursor = "default";
    (_c2 = (_b = this.renderer) == null ? void 0 : _b.controls.mouseNavigation) == null ? void 0 : _c2.activate();
  }
  _drawLine(e4, t2, i2) {
    var _a2;
    if (!i2) {
      i2 = this._planet.ellipsoid.lonLatToCartesian(e4);
    }
    let s2 = this._planet.ellipsoid.lonLatToCartesian(t2);
    let r2 = this._planet.ellipsoid.direct(e4, t2);
    this._heading = r2.initialAzimuth;
    let n2 = [];
    this._cornerEntity[0].setCartesian3v(i2);
    this._cornerEntity[1].setCartesian3v(s2);
    let o2 = [i2, this._planet.ellipsoid.lonLatToCartesian(new be(t2.lon, e4.lat, e4.height)), s2, this._planet.ellipsoid.lonLatToCartesian(new be(e4.lon, t2.lat, e4.height)), i2];
    n2.push(i2);
    let a2 = (e5, t3) => {
      let i3 = t3.sub(e5);
      let s3 = i3.length();
      i3.normalize();
      for (let t4 = 0; t4 < jh; t4++) {
        let r3 = i3.scaleTo(t4 * s3 / jh).addA(e5);
        n2.push(r3);
      }
    };
    for (let e5 = 0; e5 < o2.length - 1; e5++) {
      a2(o2[e5], o2[e5 + 1]);
    }
    (_a2 = this._trackEntity.polyline) == null ? void 0 : _a2.setPath3v([n2]);
    if (this._ignoreTerrain) ;
  }
  _onMouseMove(e4) {
    var _a2;
    if (this._startLonLat) {
      (_a2 = this._propsLabel.label) == null ? void 0 : _a2.setVisibility(true);
      let t2 = this._planet.getLonLatFromPixelTerrain(e4);
      if (!t2) return;
      this._drawLine(this._startLonLat, t2);
    }
  }
  clear() {
    var _a2, _b, _c2;
    (_a2 = this._trackEntity.polyline) == null ? void 0 : _a2.clear();
    (_b = this._cornerEntity[0].geoObject) == null ? void 0 : _b.setVisibility(false);
    (_c2 = this._cornerEntity[1].geoObject) == null ? void 0 : _c2.setVisibility(false);
  }
  frame() {
    var _a2, _b;
    let e4 = (_a2 = this._trackEntity.polyline) == null ? void 0 : _a2.getPath3v()[0];
    if (e4) {
      if (!this._ignoreTerrain) {
        let t2 = 0;
        for (let i2 = 0, s2 = e4.length - 1; i2 < s2; i2++) {
          t2 += e4[i2 + 1].distance(e4[i2]);
        }
        this._propsLabel.setCartesian3v(e4[Math.floor(e4.length / 2)]);
        (_b = this._propsLabel.label) == null ? void 0 : _b.setText(`${Yh(t2)}, ${Math.round(this._heading)} deg`);
      }
    }
  }
  get ellipsoid() {
    return this._planet ? this._planet.ellipsoid : null;
  }
}
const $h = ["add", "remove", "mousemove", "mouseenter", "mouseleave", "lclick", "rclick", "mclick", "ldblclick", "rdblclick", "mdblclick", "lup", "rup", "mup", "ldown", "rdown", "mdown", "lhold", "rhold", "mhold", "mousewheel", "touchmove", "touchstart", "touchend", "doubletouch", "touchleave", "touchenter"];
const Xh = `<?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--gis" preserveAspectRatio="xMidYMid meet"><path d="M2.1 0v1.914H0v6h3V3h5.1V0h-6zm9 0v3h6V0h-6zm9 0v3h6V0h-6zm9 0v3h6V0h-6zm9 0v3h6V0h-6zm9 0v3h6V0h-6zm9 0v3h6V0h-6zm9 0v3h1.8v1.2h3V0h-4.8zm1.8 7.2v6h3v-6h-3zM0 10.913v6h3v-6H0zM66.9 16.2v6h3v-6h-3zM0 19.914v6h3v-6H0zM66.9 25.2v6h3v-6h-3zM0 28.914v6h3v-6H0zM66.9 34.2v6h3v-6h-3zM0 37.914v6h3v-6H0zM66.9 43.2v6h3v-6h-3zM0 46.914v6h3v-6H0zM66.9 52.2v6h3v-6h-3zM0 55.914v5.191h3.809v-3H3v-2.19H0zm6.809 2.191v3h6v-3h-6zm9 0v3h6v-3h-6zm9 0v3h6v-3h-6zm9 0v3h6v-3h-6zm9 0v3h6v-3h-6zm9 0v3h6v-3h-6zm9 0v3h6v-3h-6zm9.648 1.899a2.076 2.076 0 0 0-2.19 2.324l3.137 33.676c.2 1.635 2.135 2.399 3.397 1.34l6.623-5.371l2.969 5.142c1.707 2.958 4.417 3.684 7.375 1.977c2.957-1.708 3.684-4.417 1.976-7.375l-2.959-5.125l7.848-3.008c1.548-.564 1.855-2.62.539-3.611L71.576 60.416a2.073 2.073 0 0 0-1.119-.412z" fill="#000000"></path></svg>`;
class Zh extends ns {
  constructor(e4 = {}) {
    super(e4);
    this._selectorScene = new qh({ name: `selectionScene:${this.__id}`, ignoreTerrain: e4.ignoreTerrain, onSelect: e4.onSelect, autoSelectionHide: e4.autoSelectionHide });
    this._toggleBtn = new _s({ classList: ["og-map-button", "og-selection_button"], icon: Xh });
  }
  set ignoreTerrain(e4) {
    this._selectorScene.ignoreTerrain = e4;
  }
  oninit() {
    this._toggleBtn.appendTo(this.renderer.div);
    this._toggleBtn.events.on("change", (e4) => {
      if (e4) {
        this.activate();
      } else {
        this.deactivate();
      }
    });
    this._selectorScene.bindPlanet(this.planet);
  }
  onactivate() {
    this.renderer.addNode(this._selectorScene);
  }
  ondeactivate() {
    this.renderer.removeNode(this._selectorScene);
  }
}
function Kh(e4, t2) {
  return new Date(+e4 + t2 * 1e3);
}
function Qh(e4, t2 = true, i2 = false) {
  let s2 = nc[e4.getMonth()], r2 = e4.getUTCDate(), n2 = e4.getUTCFullYear();
  if (t2) {
    let t3 = e4.getUTCHours().toString().padStart(2, "0"), o2 = e4.getUTCMinutes().toString().padStart(2, "0"), a2 = e4.getUTCSeconds().toString().padStart(2, "0");
    if (i2) {
      let i3 = e4.getUTCMilliseconds().toString().padStart(3, "0");
      return `${s2} ${r2} ${n2} ${t3}:${o2}:${a2}.${i3}`;
    }
    return `${s2} ${r2} ${n2} ${t3}:${o2}:${a2}`;
  }
  return `${s2} ${r2} ${n2}`;
}
function Jh() {
  return document.createElement("canvas");
}
function ec(e4, t2) {
  return e4 - e4 % t2;
}
function tc(e4, t2 = 0, i2 = 10, s2 = 2, r2 = "white") {
  e4.lineWidth = s2;
  e4.strokeStyle = r2;
  e4.beginPath();
  e4.moveTo(t2, 0);
  e4.lineTo(t2, i2);
  e4.stroke();
}
function ic(e4, t2, i2, s2, r2 = "12px Arial", n2 = "black", o2 = "left", a2 = "bottom", l2 = 0) {
  e4.save();
  e4.translate(i2, s2);
  e4.rotate(l2 * d);
  e4.fillStyle = n2;
  e4.textBaseline = a2;
  e4.font = r2;
  e4.textAlign = o2;
  e4.fillText(t2, 0, 0);
  e4.restore();
}
const sc = [[1e-3, 10], [2e-3, 10], [5e-3, 10], [0.01, 10], [0.02, 10], [0.05, 10], [0.1, 10], [0.25, 10], [0.5, 5], [1, 10], [2, 10], [5, 5], [10, 10], [15, 15], [30, 6], [60, 12], [120, 12], [300, 5], [600, 10], [900, 15], [1800, 6], [3600, 12], [7200, 10], [14400, 4], [21600, 6], [43200, 12], [86400, 24], [172800, 2], [345600, 4], [604800, 7], [1296e3, 15], [2592e3, 5], [5184e3, 6], [7776e3, 9], [15552e3, 18], [31536e3, 12], [63072e3, 2], [126144e3, 4], [15768e4, 5], [31536e4, 10], [63072e4, 2], [126144e4, 4], [15768e5, 5], [31536e5, 10], [63072e5, 2], [126144e5, 4], [15768e6, 5], [31536e6, 10]];
function rc(e4) {
  for (let t2 = 0, i2 = sc.length; t2 < i2; t2++) {
    if (sc[t2][0] > e4) {
      return sc[t2 - 1];
    }
  }
}
const nc = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
const oc = ["change", "current"];
class ac {
  constructor(e4 = {}) {
    this.events = Qi(oc);
    this._current = e4.current || /* @__PURE__ */ new Date();
    this._rangeStart = e4.rangeStart || /* @__PURE__ */ new Date();
    this._rangeEnd = e4.rangeEnd || Kh(this._rangeStart, 3600);
    this._range = this._rangeEnd.getTime() - this._rangeStart.getTime();
    this._minDate = e4.minDate || null;
    this._maxDate = e4.maxDate || null;
    this.multiplier = e4.multiplier != void 0 ? e4.multiplier : 1;
    this._requestAnimationFrameId = 0;
    this._prevNow = 0;
    this.dt = 0;
  }
  play() {
    if (!this._requestAnimationFrameId) {
      this._prevNow = window.performance.now();
      this._animationFrameCallback();
    }
  }
  stop() {
    if (this._requestAnimationFrameId) {
      window.cancelAnimationFrame(this._requestAnimationFrameId);
      this._requestAnimationFrameId = 0;
    }
  }
  stopped() {
    return this._requestAnimationFrameId == 0;
  }
  _animationFrameCallback() {
    this._requestAnimationFrameId = window.requestAnimationFrame(() => {
      this._frame();
      this._animationFrameCallback();
    });
  }
  _frame() {
    let e4 = window.performance.now();
    this.dt = e4 - this._prevNow;
    this._prevNow = e4;
    this.current = new Date(this.currentTime + this.dt * this.multiplier);
  }
  get range() {
    return this._range;
  }
  set(e4, t2) {
    if (e4 !== this._rangeStart || t2 !== this._rangeEnd) {
      this._rangeStart = e4;
      this._rangeEnd = t2;
      this._range = this._rangeEnd.getTime() - this._rangeStart.getTime();
      this.events.dispatch(this.events.change, e4, t2);
    }
  }
  get current() {
    return this._current;
  }
  get rangeStart() {
    return this._rangeStart;
  }
  get rangeEnd() {
    return this._rangeEnd;
  }
  get rangeStartTime() {
    return this._rangeStart.getTime();
  }
  get rangeEndTime() {
    return this._rangeEnd.getTime();
  }
  get currentTime() {
    return this._current.getTime();
  }
  set current(e4) {
    if (e4 !== this._current) {
      if (this._maxDate && e4 > this._maxDate) {
        this._current = this._maxDate;
      } else if (this._minDate && e4 < this._minDate) {
        this._current = this._minDate;
      } else {
        this._current = e4;
      }
      this.events.dispatch(this.events.current, this._current);
    }
  }
  set rangeStart(e4) {
    if (e4 !== this._rangeStart) {
      this._rangeStart = e4;
      this._range = this._rangeEnd.getTime() - this._rangeStart.getTime();
      this.events.dispatch(this.events.change, e4);
    }
  }
  set rangeEnd(e4) {
    if (e4 !== this._rangeEnd) {
      this._rangeEnd = e4;
      this._range = this._rangeEnd.getTime() - this._rangeStart.getTime();
      this.events.dispatch(this.events.change, e4);
    }
  }
}
const lc = 1e3;
const hc = 1 / lc;
const cc = ["startdrag", "stopdrag", "startdragcurrent", "stopdragcurrent", "setcurrent", "reset", "play", "playback", "pause", "visibility"];
const dc = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M8 5v14l11-7z" style="fill: black;"/></svg>';
const uc = `<?xml version="1.0" ?><!DOCTYPE svg  PUBLIC '-//W3C//DTD SVG 1.1//EN'  'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'><svg enable-background="new 0 0 512 512" height="512px" version="1.1" viewBox="0 0 512 512" width="512px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="Layer_6"><rect fill="#252525" height="320" width="60" x="153" y="96"/><rect fill="#252525" height="320" width="60" x="299" y="96"/></g></svg>`;
const _c = "rgba(64, 59, 59, 1.0)";
const fc = "#bfbfbf";
const gc = "#bfbfbf";
const pc = `<div class="og-timeline">

  <div class="og-timeline-top">
  </div>

  <div class="og-timeline-frame">
    <div class="og-timeline-current">
      <div class="og-timeline-current-spin">
        <div class="og-timeline-current-arrow"></div>
      </div>
    </div>
    <div class="og-timeline-scale"></div>
  </div>

  <div class="og-timeline-bottom">
    <div class="og-timeline-controls">
    </div>
  </div>

</div>`;
class mc extends ts {
  constructor(e4 = {}) {
    super({ template: pc, model: new ac({ rangeStart: e4.rangeStart, rangeEnd: e4.rangeEnd, current: e4.currentDate, minDate: e4.minDate, maxDate: e4.maxDate }) });
    this._onMouseWheel = (e5) => {
      if (this._isMouseOver) {
        let t2 = this._canvasEl.getBoundingClientRect();
        let i2 = e5.clientX - t2.left, s2 = -(i2 - this.clientWidth * 0.5);
        let r2 = this.model.rangeStartTime + this._millisecondsInPixel * i2;
        this._zoom(r2, s2, Math.sign(e5.wheelDelta));
      } else if (this._isCurrentMouseOver) {
        let t2 = -((this.model.currentTime - this.model.rangeStartTime) / this._millisecondsInPixel - this.clientWidth * 0.5);
        this._zoom(this.model.currentTime, t2, Math.sign(e5.wheelDelta));
      }
    };
    this._onMouseWheelFF = (e5) => {
      this._onMouseWheel(e5);
    };
    this._onMouseDown = (e5) => {
      if (this._isMouseOver) {
        this._isDragging = true;
        document.body.classList.add("og-timeline-unselectable");
        this._clickPosX = e5.clientX;
        this._clickTime = Date.now();
        this._clickRangeStart = this.model.rangeStart;
        this._clickRangeEnd = this.model.rangeEnd;
        this.events.dispatch(this.events.startdrag, e5);
      } else if (this._isCurrentMouseOver) {
        this._isCurrentDragging = true;
        document.body.classList.add("og-timeline-unselectable");
        this._clickPosX = e5.clientX;
        this._clickCurrentDate = this.model.current;
        this.events.dispatch(this.events.startdragcurrent, e5);
      }
    };
    this._onMouseUp = (e5) => {
      if (this._isDragging) {
        this._isDragging = false;
        document.body.classList.remove("og-timeline-unselectable");
        if (this._clickPosX === e5.clientX && Date.now() - this._clickTime < this._clickDelay) {
          let t2 = this._canvasEl.getBoundingClientRect();
          let i2 = new Date(this.model.rangeStartTime + (e5.clientX - t2.left) * this._millisecondsInPixel);
          this.model.current = i2;
          this.events.dispatch(this.events.stopdrag, i2);
          this.events.dispatch(this.events.setcurrent, i2);
        } else {
          this.events.dispatch(this.events.stopdrag, this.model.current);
        }
      } else if (this._isCurrentDragging) {
        this._isCurrentDragging = false;
        document.body.classList.remove("og-timeline-unselectable");
        this.events.dispatch(this.events.stopdragcurrent, this.model.current);
      }
    };
    this._onMouseEnter = () => {
      this._isMouseOver = true;
    };
    this._onMouseOut = () => {
      this._isMouseOver = false;
    };
    this._onCurrentMouseEnter = () => {
      this._isCurrentMouseOver = true;
    };
    this._onCurrentMouseOut = () => {
      this._isCurrentMouseOver = false;
    };
    this._onMouseMove = (e5) => {
      if (this._isDragging) {
        let t2 = (this._clickPosX - e5.clientX) * this._millisecondsInPixel * hc;
        this.model.set(Kh(this._clickRangeStart, t2), Kh(this._clickRangeEnd, t2));
      } else if (this._isCurrentDragging) {
        let t2 = (this._clickPosX - e5.clientX) * this._millisecondsInPixel * hc;
        let i2 = Kh(this._clickCurrentDate, -t2);
        if (i2 >= this.model.rangeStart && i2 <= this.model.rangeEnd) {
          this.model.current = Kh(this._clickCurrentDate, -t2);
        }
      }
    };
    this.events = this.events.registerNames(cc);
    this.fillStyle = e4.fillStyle || _c;
    this.$controls = null;
    this._frameEl = null;
    this._currentEl = null;
    this._canvasEl = Jh();
    this._ctx = this._canvasEl.getContext("2d");
    this._isMouseOver = false;
    this._isDragging = false;
    this._isCurrentDragging = false;
    this._isCurrentMouseOver = false;
    this._minWidth = 330;
    this._canvasScale = 2;
    this._millisecondsInPixel = 0;
    this._clickPosX = 0;
    this._clickRangeStart = /* @__PURE__ */ new Date();
    this._clickRangeEnd = /* @__PURE__ */ new Date();
    this._clickCurrentDate = /* @__PURE__ */ new Date();
    this._clickTime = 0;
    this._clickDelay = 450;
    this._onResizeObserver_ = this._onResizeObserver.bind(this);
    this._resizeObserver = new ResizeObserver(this._onResizeObserver_);
    this._pauseBtn = new _s({ classList: ["og-timeline-control_button"], icon: uc, name: "pause" });
    this._playBtn = new _s({ classList: ["og-timeline-control_button"], icon: dc, name: "play" });
    this._buttons = new Us({ buttons: [this._pauseBtn, this._playBtn] });
    this._visibility = false;
  }
  _onResizeObserver() {
    this.resize();
  }
  get canvasScale() {
    return this._canvasScale;
  }
  set canvasScale(e4) {
    if (e4 !== this._canvasScale) {
      this._canvasScale = e4;
      this.resize();
    }
  }
  resize() {
    this._resize();
    this.draw();
  }
  afterRender(e4) {
    this.resize();
  }
  render() {
    super.render();
    this.$controls = this.select(".og-timeline-controls");
    this._frameEl = this.select(".og-timeline-frame");
    this._currentEl = this.select(".og-timeline-current");
    this.select(".og-timeline-frame .og-timeline-scale").appendChild(this._canvasEl);
    this._resizeObserver.observe(this.el);
    this.model.events.on("change", () => {
      this.draw();
    });
    this.model.events.on("current", (e4) => {
      this._drawCurrent();
      this.events.dispatch(this.events.setcurrent, e4);
    });
    this._canvasEl.addEventListener("mouseenter", this._onMouseEnter);
    this._canvasEl.addEventListener("mouseout", this._onMouseOut);
    this._currentEl.addEventListener("mouseenter", this._onCurrentMouseEnter);
    this._currentEl.addEventListener("mouseout", this._onCurrentMouseOut);
    document.body.addEventListener("mousemove", this._onMouseMove);
    document.body.addEventListener("mousedown", this._onMouseDown);
    document.body.addEventListener("mouseup", this._onMouseUp);
    document.body.addEventListener("wheel", this._onMouseWheelFF);
    this._playBtn.appendTo(this.$controls);
    this._pauseBtn.appendTo(this.$controls);
    if (this.model.stopped()) {
      this._pauseBtn.setActive(true, true);
      this._pauseBtn.preventClick = true;
    } else {
      this._playBtn.setActive(true, true);
      this._playBtn.preventClick = true;
    }
    this._buttons.events.on("change", (e4) => {
      switch (e4.name) {
        case "play":
          this.play();
          break;
        case "pause":
          this.pause();
          break;
      }
    });
    this.setVisibility(true);
    return this;
  }
  setVisibility(e4) {
    if (e4 !== this._visibility) {
      this._visibility = e4;
      if (this.el) {
        if (e4) {
          this.el.style.display = "block";
        } else {
          this.el.style.display = "none";
        }
      }
      this.events.dispatch(this.events.visibility, e4);
    }
  }
  reset() {
    this.model.stop();
    this.events.dispatch(this.events.reset, this.model);
  }
  play() {
    this.model.multiplier = Math.abs(this.model.multiplier);
    this.model.play();
    this.events.dispatch(this.events.play, this.model);
  }
  pause() {
    this.model.stop();
    this.events.dispatch(this.events.pause, this.model);
  }
  playBack() {
    this.model.multiplier = -1 * Math.abs(this.model.multiplier);
    this.model.play();
    this.events.dispatch(this.events.playback, this.model);
  }
  _zoom(e4, t2, i2) {
    let s2 = this.model.rangeStartTime + 0.5 * this.model.range;
    let r2 = (e4 - s2) * hc;
    let n2 = Kh(this.model.rangeStart, r2), o2 = Kh(this.model.rangeEnd, r2);
    let a2 = (o2.getTime() - n2.getTime()) / 20 * hc;
    let l2 = Kh(n2, a2 * i2);
    let h2 = Kh(o2, -a2 * i2);
    let c2 = (h2.getTime() - l2.getTime()) / this.clientWidth;
    if (c2 < 31536e6 && c2 > 0.1) {
      let e5 = c2 * t2 * hc;
      this.model.set(Kh(l2, e5), Kh(h2, e5));
    }
  }
  get clientWidth() {
    return this._canvasEl ? this._canvasEl.width / this._canvasScale : 0;
  }
  get clientHeight() {
    return this._canvasEl ? this._canvasEl.height / this._canvasScale : 0;
  }
  _resize() {
    if (this._frameEl) {
      this._canvasEl.width = this._frameEl.clientWidth * this._canvasScale;
      this._canvasEl.height = this._frameEl.clientHeight * this._canvasScale;
      this._canvasEl.style.width = `${this._frameEl.clientWidth}px`;
      this._canvasEl.style.height = `${this._frameEl.clientHeight}px`;
    }
  }
  getOffsetByTime(e4) {
    return (e4 - this.model.rangeStartTime) / this._millisecondsInPixel;
  }
  remove() {
    super.remove();
    this.model.stop();
  }
  _clearCanvas() {
    this._ctx.fillStyle = this.fillStyle;
    this._ctx.fillRect(0, 0, this.clientWidth * this._canvasScale, this.clientHeight * this._canvasScale);
  }
  _drawCurrent() {
    let e4 = (this.model.currentTime - this.model.rangeStartTime) / this._millisecondsInPixel;
    if (this.model.current < this.model.rangeStart || this.model.current > this.model.rangeEnd) {
      this._currentEl.style.display = "none";
    } else {
      this._currentEl.style.display = "block";
      this._currentEl.style.transform = `translateX(${e4}px)`;
    }
  }
  draw() {
    this._millisecondsInPixel = this.model.range / this.clientWidth;
    let e4 = this._minWidth * this._millisecondsInPixel;
    let t2 = rc(e4 * hc);
    if (t2) {
      this._clearCanvas();
      let e5 = t2[0] * lc, i2 = e5 / this._millisecondsInPixel, s2 = t2[1];
      let r2 = ec(this.model.rangeStartTime, e5);
      let n2 = t2[0] < 1, o2 = t2[0] < 86400;
      for (let t3 = r2, a2 = this.model.rangeEndTime + e5; t3 < a2; t3 += e5) {
        let e6 = this.getOffsetByTime(t3);
        if (e6 >= 0 && e6 <= this.clientWidth * this._canvasScale) {
          tc(this._ctx, e6 * this._canvasScale, 10 * this._canvasScale, 2 * this._canvasScale, fc);
        }
        for (let t4 = 1; t4 < s2; t4++) {
          let r3 = e6 + t4 * (i2 / s2);
          if (r3 >= 0 && r3 <= this.clientWidth * this._canvasScale) {
            tc(this._ctx, r3 * this._canvasScale, 5 * this._canvasScale, 1 * this._canvasScale, fc);
          }
        }
        ic(this._ctx, Qh(new Date(t3), o2, n2), e6 * this._canvasScale, 26 * this._canvasScale, "24px monospace", gc, "center");
      }
      this._drawCurrent();
    }
  }
}
function vc(e4, t2) {
  const i2 = new Date(e4);
  i2.setHours(i2.getHours() + t2);
  return i2;
}
const yc = `<?xml version="1.0" encoding="utf-8"?>
<!-- Svg Vector Icons : http://www.onlinewebfonts.com/icon -->
    <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 1000 1000" enable-background="new 0 0 1000 1000" xml:space="preserve">
    <metadata> Svg Vector Icons : http://www.onlinewebfonts.com/icon </metadata>
    <g><path d="M500,10C229.4,10,10,229.4,10,500s219.4,490,490,490s490-219.4,490-490S770.6,10,500,10z M800.3,800.3c-39,39-84.5,69.7-135,91C613,913.5,557.4,924.7,500,924.7s-112.9-11.2-165.3-33.3c-50.5-21.3-95.9-52-135-91c-39-39-69.7-84.5-91-135C86.5,612.9,75.3,557.4,75.3,500s11.2-112.9,33.3-165.3c21.3-50.5,52-95.9,91-135c39-39,84.5-69.7,135-91C387.1,86.5,442.6,75.3,500,75.3s112.9,11.2,165.3,33.3c50.5,21.3,95.9,52,135,91c39,39,69.7,84.5,91,135c22.1,52.3,33.3,107.9,33.3,165.3s-11.2,112.9-33.3,165.3C869.9,715.8,839.3,761.2,800.3,800.3z"/><path d="M761.3,532.7H532.7V304c0-18.1-14.6-32.7-32.7-32.7s-32.7,14.6-32.7,32.7v261.3l0,0c0,18.1,14.6,32.7,32.7,32.7h261.3c18.1,0,32.7-14.6,32.7-32.7l0,0C794,547.3,779.4,532.7,761.3,532.7z"/></g>
</svg>`;
class xc extends ns {
  constructor(e4 = {}) {
    super({ name: "timeline", ...e4 });
    let t2 = e4.current || /* @__PURE__ */ new Date();
    let i2 = e4.rangeStart || vc(t2, -12);
    let s2 = e4.rangeEnd || vc(t2, 12);
    this._timelineView = new mc({ rangeStart: i2, rangeEnd: s2, currentDate: t2 });
    this._toggleBtn = new _s({ classList: ["og-map-button", "og-timeline_button"], icon: yc });
    this._dialog = new ds({ title: "Timeline", visible: false, resizable: true, useHide: true, top: 10, left: 60, width: 600, height: 115, minHeight: 115, maxHeight: 110 });
    this._dialog.events.on("visibility", (e5) => {
      this._toggleBtn.setActive(e5);
    });
  }
  oninit() {
    let e4 = this.renderer.div;
    this._toggleBtn.appendTo(e4);
    this._dialog.appendTo(e4);
    this._toggleBtn.events.on("change", (e5) => {
      this._dialog.setVisibility(e5);
      if (e5) {
        this._timelineView.resize();
      }
    });
    this._timelineView.appendTo(this._dialog.container);
    this._timelineView.events.on("setcurrent", (e5) => {
      this.renderer && this.renderer.handler.defaultClock.setDate(e5);
    });
    this._timelineView.events.on("startdrag", () => {
      var _a2;
      (_a2 = this.planet) == null ? void 0 : _a2.sun.stop();
      this.renderer && this.renderer.controls.mouseNavigation.deactivate();
    });
    this._timelineView.events.on("stopdrag", () => {
      this.renderer && this.renderer.controls.mouseNavigation.activate();
    });
    this._timelineView.events.on("startdragcurrent", () => {
      var _a2;
      (_a2 = this.planet) == null ? void 0 : _a2.sun.stop();
      this.renderer && this.renderer.controls.mouseNavigation.deactivate();
    });
    this._timelineView.events.on("stopdragcurrent", () => {
      this.renderer && this.renderer.controls.mouseNavigation.activate();
    });
  }
}
class bc {
  constructor() {
    this.resolve = () => {
    };
    this.reject = () => {
    };
    this.promise = new Promise((e4, t2) => {
      this.resolve = e4;
      this.reject = t2;
    });
    Object.freeze(this);
  }
}
const wc = 5;
const Cc = ["startcollecting", "profilecollected", "clear"];
const Tc = 0;
const Ec = 1;
const Ac = 2;
const Lc = 0;
const Pc = 1;
const Sc = 1;
const Rc = 1;
const Mc = 0.1;
const Bc = 0.2;
const kc = 0.1;
class Ic {
  constructor(e4 = {}) {
    this.events = Qi(Cc);
    this.planet = e4.planet || null;
    this._warningHeightLevel = wc;
    this._pointsReady = false;
    this._isWarning = false;
    this._minX = 0;
    this._planeDistance = this._maxX = 1e3;
    this._minY = 0;
    this._maxY = 200;
    this._drawData = [[], []];
    this._promiseArr = [];
    this._promiseCounter = 0;
    this._pMaxY = 0;
    this._pMinY = 0;
    this._pDist = 0;
    this._pTrackCoords = [];
    this._pGroundCoords = [];
    this._pIndex = 0;
  }
  bindPlanet(e4) {
    this.planet = e4;
  }
  setWarningHeightLevel(e4 = 0) {
    this._warningHeightLevel = e4;
  }
  setRange(e4, t2, i2, s2) {
    this._minX = e4;
    this._maxX = t2;
    if (i2) {
      this._minY = i2;
    }
    if (s2) {
      this._maxY = s2;
    }
  }
  _getHeightAsync(e4, t2, i2) {
    let s2 = new bc();
    if (this.planet) {
      let r2 = this.planet.terrain.geoid.getHeightLonLat(e4);
      this.planet.terrain.getHeightAsync(e4, (n2) => {
        if (this.planet && i2 === this._promiseCounter) {
          n2 += r2;
          this._pGroundCoords[t2][1] = n2;
          this._pGroundCoords[t2][2] = Tc;
          this._pGroundCoords[t2][3] = e4.height;
          if (n2 > this._pMaxY) this._pMaxY = n2;
          if (n2 < this._pMinY) this._pMinY = n2;
          this._updatePointType(t2);
          s2.resolve(n2);
        } else {
          s2.reject();
        }
      });
    } else {
      s2.reject();
    }
    return s2.promise;
  }
  _collectCoordsBetweenTwoTrackPoints(e4, t2, i2, s2, r2, n2) {
    if (!this.planet) return;
    for (let o2 = 1; o2 <= t2; o2++) {
      this._pDist += Sc;
      this._pIndex++;
      let t3 = o2 * i2;
      let a2 = s2.add(r2.scaleTo(t3));
      let l2 = this.planet.ellipsoid.cartesianToLonLat(a2);
      this._pGroundCoords[this._pIndex] = [this._pDist, 0, Tc, 0, e4];
      ((e5, t4) => {
        this._promiseArr.push(this._getHeightAsync(e5, t4, n2));
      })(l2, this._pIndex);
    }
  }
  _collectAllPoints(e4, t2) {
    if (!this.planet) return;
    if (t2 !== this._promiseCounter) return;
    let i2 = new Ke(), s2 = new Ke();
    for (let r2 = 1, n2 = e4.length; r2 < n2; r2++) {
      let n3 = e4[r2 - 1], o2 = e4[r2];
      this.planet.ellipsoid.lonLatToCartesianRes(n3, i2);
      this.planet.ellipsoid.lonLatToCartesianRes(o2, s2);
      let a2 = s2.sub(i2);
      let l2 = a2.length();
      let h2 = this.planet.ellipsoid.getSurfaceNormal3v(i2);
      let c2 = Ke.proj_b_to_plane(a2, h2);
      let d2 = c2.length();
      let u2 = Math.floor(d2 / Sc);
      let _2 = Sc * l2 / d2;
      this._getGroundElevation(n3, r2 - 1, t2);
      c2.normalize();
      a2.normalize();
      this._collectCoordsBetweenTwoTrackPoints(r2 - 1, u2, _2, i2, a2, t2);
      this._pDist += d2 - u2 * Sc;
      this._pIndex++;
      let f2 = o2.height;
      if (f2 > this._pMaxY) this._pMaxY = f2;
      if (f2 < this._pMinY) this._pMinY = f2;
      this._pTrackCoords[r2] = [this._pDist, f2, this._pIndex];
    }
  }
  _getGroundElevation(e4, t2, i2) {
    this._pGroundCoords[this._pIndex] = [this._pDist, 0, Tc, 0, t2];
    this._promiseArr.push(this._getHeightAsync(e4, this._pIndex, i2));
  }
  _calcPointsAsync(e4, t2) {
    return new Promise((i2, s2) => {
      this._pTrackCoords = [[0, e4[0].height, 0]];
      this._pMaxY = e4[0].height;
      this._pMinY = this._pMaxY;
      this._pDist = 0;
      this._pGroundCoords = [];
      this._pIndex = 0;
      this._promiseArr = [];
      this._collectAllPoints(e4, t2);
      this._getGroundElevation(e4[e4.length - 1], e4.length - 1, t2);
      Promise.all(this._promiseArr).then(() => {
        i2({ dist: this._pDist, minY: this._pMinY, maxY: this._pMaxY, trackCoords: this._pTrackCoords, groundCoords: this._pGroundCoords });
      });
    });
  }
  get minX() {
    return this._minX;
  }
  get planeDistance() {
    return this._planeDistance;
  }
  get maxX() {
    return this._maxX;
  }
  get minY() {
    return this._minY;
  }
  get maxY() {
    return this._maxY;
  }
  get pointsReady() {
    return this._pointsReady;
  }
  get isWarningOrCollision() {
    return this._isWarning;
  }
  get drawData() {
    return this._drawData;
  }
  collectProfile(e4) {
    let t2 = new bc();
    if (!this.planet) t2.reject();
    this._pointsReady = false;
    this._isWarning = false;
    if (!e4 || !e4.length) {
      t2.reject();
      return t2.promise;
    }
    this.events.dispatch(this.events.startcollecting, this);
    this._promiseCounter++;
    ((i2) => {
      this._calcPointsAsync(e4, i2).then((e5) => {
        if (i2 === this._promiseCounter) {
          this._planeDistance = e5.dist;
          this.setRange(0, e5.dist, e5.minY - Mc * Math.abs(e5.minY), e5.maxY + Math.abs(e5.maxY) * Bc);
          this._pointsReady = true;
          this._drawData = [e5.trackCoords, e5.groundCoords];
          this.events.dispatch(this.events.profilecollected, this._drawData, this);
          t2.resolve(this._drawData);
        }
      });
    })(this._promiseCounter);
    return t2.promise;
  }
  _updatePointType(e4) {
    if (this._pGroundCoords[e4][3] >= this._pGroundCoords[e4][1] && this._pGroundCoords[e4][3] < this._pGroundCoords[e4][1] + this._warningHeightLevel - kc) {
      this._pGroundCoords[e4][2] = Ec;
    }
    if (this._pGroundCoords[e4][3] <= this._pGroundCoords[e4][1] + Rc) {
      this._pGroundCoords[e4][2] = Ac;
    }
    if (this._pGroundCoords[e4][2] === Ec || this._pGroundCoords[e4][2] === Ac) {
      this._isWarning = true;
    }
  }
  _setPointsType() {
    this._isWarning = false;
    this._pTrackCoords = this._drawData[Lc];
    this._pGroundCoords = this._drawData[Pc];
    for (let e4 = 0; e4 < this._pGroundCoords.length; e4++) {
      this._updatePointType(e4);
    }
    this._drawData[Pc] = this._pGroundCoords;
    this.events.dispatch(this.events.profilecollected, this._drawData, this);
  }
  clear() {
    this._promiseCounter = 0;
    this._pointsReady = false;
    this._isWarning = false;
    this._drawData = [[], []];
    this._pMaxY = 0;
    this._pMinY = 0;
    this._pDist = 0;
    this._pTrackCoords = [];
    this._pGroundCoords = [];
    this._pIndex = 0;
    this.events.dispatch(this.events.clear, this._drawData, this);
  }
}
const zc = "rgb(63, 63, 63)";
const Dc = "rgb(0, 255, 50)";
const Fc = "rgb(198, 198, 198)";
const Nc = "rgb(64, 68, 82)";
const Oc = "rgb(255, 255, 0)";
const Hc = "rgb(255, 0, 0)";
const Vc = [Fc, Oc, Hc];
const Uc = 0.5;
const Gc = 5;
const Wc = ["startdrag", "stopdrag", "pointer", "mouseenter", "mouseleave", "dblclick", "tracklength", "groundlength", "warninglength", "collisionlength"];
const jc = `<div class="og-elevationprofile">
      <div class="og-elevationprofile-loading" style="display: none;">
        <div class="loadingio-spinner-bars-r354qqyl5v">
          <div class="ldio-p0v5a1f6oz">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
          </div>
        </div> 
      </div>     
    </div>`;
class Yc extends ts {
  constructor(e4 = {}) {
    super({ template: jc, model: new Ic() });
    this._onMouseDblClick = (e5) => {
      let t2 = this.$canvas.getBoundingClientRect();
      let i2 = e5.clientX - t2.left;
      let s2 = this._leftDistance + (this._rightDistance - this._leftDistance) * i2 / this.clientWidth;
      let r2 = this.model.drawData[1];
      let n2 = this.model.drawData[0];
      let o2;
      if (s2 < 0) {
        o2 = 1;
        s2 = 0;
        i2 = (0 - this._leftDistance) * this.clientWidth / (this._rightDistance - this._leftDistance);
      } else if (s2 > this.model.planeDistance) {
        o2 = r2.length - 1;
        s2 = this.model.planeDistance;
        i2 = (s2 - this._leftDistance) * this.clientWidth / (this._rightDistance - this._leftDistance);
      } else {
        o2 = -1 - Pt(r2, s2, (e6, t3) => e6 - t3[0]);
      }
      let a2 = r2[o2 - 1], l2 = r2[o2];
      let h2 = (s2 - a2[0]) / (l2[0] - a2[0]);
      let c2 = a2[1] + h2 * (l2[1] - a2[1]);
      let d2 = a2[4];
      let u2 = n2[d2], _2 = n2[d2 + 1];
      h2 = (s2 - u2[0]) / (_2[0] - u2[0]);
      let f2 = u2[1] + h2 * (_2[1] - u2[1]);
      this.events.dispatch(this.events.dblclick, s2, u2, _2, a2, l2, d2, o2 - 1, f2 - c2);
    };
    this._onMouseEnter = (e5) => {
      this._isMouseOver = true;
      this.events.dispatch(this.events.mouseenter, e5);
    };
    this._onMouseOut = (e5) => {
      this._isMouseOver = false;
      this.events.dispatch(this.events.mouseleave, e5);
    };
    this._onMouseDown = (e5) => {
      if (this._isMouseOver) {
        this._isDragging = true;
        document.body.classList.add("og-timeline-unselectable");
        this._clickPosX = e5.clientX;
        if (!this._customFrame) {
          this._leftDistance = this.model.minX;
          this._rightDistance = this.model.maxX;
        }
        this._clickLeftDistance = this._leftDistance;
        this._clickRightDistance = this._rightDistance;
        this.events.dispatch(this.events.startdrag, e5);
      }
    };
    this._onMouseUp = (e5) => {
      if (this._isDragging) {
        this._isDragging = false;
        document.body.classList.remove("og-timeline-unselectable");
        this.events.dispatch(this.events.stopdrag, e5);
      }
    };
    this._onCanvasMouseMove = (e5) => {
      if (this.model.pointsReady) {
        if (!this._isDragging) {
          if (!this._customFrame) {
            this._leftDistance = this.model.minX;
            this._rightDistance = this.model.maxX;
          }
          let t2 = this.$pointerCanvas.getBoundingClientRect();
          let i2 = e5.clientX - t2.left;
          this.redrawPointerCanvas(i2);
        } else {
          this.clearPointerCanvas();
        }
      }
    };
    this._onMouseMove = (e5) => {
      if (this._isDragging && this.model.pointsReady) {
        let t2 = this._clickPosX - e5.clientX;
        let i2 = t2 * this._canvasScale / this._pixelsInMeter_x;
        this.setFrame(this._clickLeftDistance + i2, this._clickRightDistance + i2);
      }
    };
    this._onMouseWheelFF = (e5) => {
      this._onMouseWheel(e5);
    };
    this._onMouseWheel = (e5) => {
      if (this._isMouseOver && this.model.pointsReady) {
        if (!this._customFrame) {
          this._leftDistance = this.model.minX;
          this._rightDistance = this.model.maxX;
        }
        this._customFrame = true;
        let t2 = Math.sign(e5.wheelDelta) * (this._rightDistance - this._leftDistance) / 20;
        let i2 = this.$canvas.getBoundingClientRect();
        let s2 = e5.clientX - i2.left, r2 = s2 - this.$canvas.clientWidth * 0.5;
        let n2 = r2 * this._canvasScale / this._pixelsInMeter_x;
        let o2 = n2 + this._leftDistance + t2;
        let a2 = n2 + this._rightDistance - t2;
        n2 = -r2 * (a2 - o2) / this.clientWidth;
        this.setFrame(o2 + n2, a2 + n2);
        this.redrawPointerCanvas(s2);
      }
    };
    this.events = this.events.registerNames(Wc);
    this.fillStyle = e4.fillStyle || zc;
    this._customFrame = false;
    this._leftDistance = 0;
    this._rightDistance = 0;
    this._pixelsInMeter_x = 0;
    this._pixelsInMeter_y = 0;
    this._canvasScale = 2;
    this.$canvas = document.createElement("canvas");
    this.$canvas.style.position = "absolute";
    this._ctx = this.$canvas.getContext("2d");
    this.$pointerCanvas = document.createElement("canvas");
    this.$pointerCanvas.style.pointerEvents = "none";
    this.$pointerCanvas.style.position = "absolute";
    this._pointerCtx = this.$pointerCanvas.getContext("2d");
    this.$loading = null;
    this._isMouseOver = false;
    this._isDragging = false;
    this._clickPosX = 0;
    this._clickLeftDistance = 0;
    this._clickRightDistance = 0;
    this._timeStartHandler = 0;
    this._onResizeObserver_ = this._onResizeObserver.bind(this);
    this._resizeObserver = new ResizeObserver(this._onResizeObserver_);
  }
  _onResizeObserver() {
    this.resize();
  }
  get canvasScale() {
    return this._canvasScale;
  }
  set canvasScale(e4) {
    if (e4 !== this._canvasScale) {
      this._canvasScale = e4;
      this.resize();
    }
  }
  resize() {
    this._resize();
    this.draw();
  }
  render() {
    super.render();
    this._resizeObserver.observe(this.el);
    this.el.appendChild(this.$canvas);
    this.el.appendChild(this.$pointerCanvas);
    this.model.events.on("profilecollected", (e4) => {
      this._hideLoading();
      this.clearPointerCanvas();
      this.draw();
    });
    this.model.events.on("startcollecting", () => {
      clearTimeout(this._timeStartHandler);
      this._timeStartHandler = setTimeout(() => {
        this._showLoading();
      }, 450);
    });
    this.model.events.on("clear", () => {
      this._customFrame = false;
      this._leftDistance = 0;
      this.clearCanvas();
      this.clearPointerCanvas();
    });
    this.$loading = this.select(".og-elevationprofile-loading");
    this.$canvas.addEventListener("mouseenter", this._onMouseEnter);
    this.$canvas.addEventListener("mouseout", this._onMouseOut);
    this.$canvas.addEventListener("dblclick", this._onMouseDblClick);
    this.$canvas.addEventListener("mousemove", this._onCanvasMouseMove);
    document.body.addEventListener("mousemove", this._onMouseMove);
    document.body.addEventListener("mousedown", this._onMouseDown);
    document.body.addEventListener("mouseup", this._onMouseUp);
    document.body.addEventListener("wheel", this._onMouseWheelFF);
    return this;
  }
  _hideLoading() {
    clearTimeout(this._timeStartHandler);
    this.$loading.style.display = "none";
  }
  _showLoading() {
    this.$loading.style.display = "flex";
  }
  redrawPointerCanvas(e4) {
    this.clearPointerCanvas();
    let t2 = this._leftDistance + (this._rightDistance - this._leftDistance) * e4 / this.clientWidth;
    let i2 = this.model.drawData[1];
    let s2 = this.model.drawData[0];
    let r2;
    if (t2 < 0) {
      r2 = 1;
      t2 = 0;
      e4 = (0 - this._leftDistance) * this.clientWidth / (this._rightDistance - this._leftDistance);
    } else if (t2 > this.model.planeDistance) {
      r2 = i2.length - 1;
      t2 = this.model.planeDistance;
      e4 = (t2 - this._leftDistance) * this.clientWidth / (this._rightDistance - this._leftDistance);
    } else {
      r2 = -1 - Pt(i2, t2, (e5, t3) => e5 - t3[0]);
    }
    let n2 = i2[r2 - 1], o2 = i2[r2];
    let a2 = (t2 - n2[0]) / (o2[0] - n2[0]);
    let l2 = n2[1] + a2 * (o2[1] - n2[1]);
    let h2 = n2[4];
    let c2 = s2[h2], d2 = s2[h2 + 1];
    a2 = (t2 - c2[0]) / (d2[0] - c2[0]);
    let u2 = c2[1] + a2 * (d2[1] - c2[1]);
    let _2 = (this.model.maxY - u2) * this._pixelsInMeter_y;
    let f2 = (this.model.maxY - l2) * this._pixelsInMeter_y;
    this.events.dispatch(this.events.pointer, t2, c2, d2, n2, o2, h2, r2 - 1, u2 - l2);
    let g2 = this._pointerCtx;
    g2.lineWidth = 3;
    g2.strokeStyle = "rgba(64,64,64,0.6)";
    g2.beginPath();
    g2.moveTo(e4 * this._canvasScale, 0);
    g2.lineTo(e4 * this._canvasScale, this.clientHeight * this._canvasScale);
    g2.stroke();
    g2.beginPath();
    g2.arc(e4 * this._canvasScale, f2, 4, 0, 2 * Math.PI, false);
    g2.fillStyle = "#FFB277";
    g2.fill();
    g2.lineWidth = 4;
    g2.strokeStyle = "#FFB277";
    g2.stroke();
    g2.beginPath();
    g2.arc(e4 * this._canvasScale, _2, 4, 0, 2 * Math.PI, false);
    g2.fillStyle = "#FFB277";
    g2.fill();
    g2.lineWidth = 4;
    g2.strokeStyle = "#FFB277";
    g2.stroke();
    g2.lineWidth = 3;
    g2.strokeStyle = "#FFB277";
    g2.beginPath();
    g2.moveTo(e4 * this._canvasScale, f2);
    g2.lineTo(e4 * this._canvasScale, _2);
    g2.stroke();
    g2.fillStyle = "white";
    g2.font = `${28 / devicePixelRatio}px Arial`;
    g2.textBaseline = "middle";
    g2.textAlign = "left";
    g2.fillText(`${Math.round(u2 - l2).toString()} m`, (e4 + 5) * this._canvasScale, f2 + (_2 - f2) * 0.5);
    g2.fillStyle = "white";
    g2.font = `${28 / devicePixelRatio}px Arial`;
    g2.textAlign = "right";
    let p2 = Jt(t2);
    g2.fillText(`${p2[0]} ${p2[1]}`, (e4 - 5) * this._canvasScale, (this.clientHeight - 7) * this._canvasScale);
  }
  get clientWidth() {
    return this.$canvas ? this.$canvas.width / this._canvasScale : 0;
  }
  get clientHeight() {
    return this.$canvas ? this.$canvas.height / this._canvasScale : 0;
  }
  _resize() {
    if (this.el) {
      this.$canvas.width = this.el.clientWidth * this._canvasScale;
      this.$canvas.height = this.el.clientHeight * this._canvasScale;
      this.$canvas.style.width = `${this.el.clientWidth}px`;
      this.$canvas.style.height = `${this.el.clientHeight}px`;
      this.$pointerCanvas.width = this.el.clientWidth * this._canvasScale;
      this.$pointerCanvas.height = this.el.clientHeight * this._canvasScale;
      this.$pointerCanvas.style.width = `${this.el.clientWidth}px`;
      this.$pointerCanvas.style.height = `${this.el.clientHeight}px`;
      if (this._customFrame) {
        this._pixelsInMeter_x = this._canvasScale * this.clientWidth / (this._rightDistance - this._leftDistance);
      }
    }
  }
  clearPointerCanvas() {
    this._pointerCtx.fillStyle = "rgba(0,0,0,0)";
    this._pointerCtx.clearRect(0, 0, this.clientWidth * this._canvasScale, this.clientHeight * this._canvasScale);
  }
  clearCanvas() {
    const e4 = this._ctx.createLinearGradient(0, 0, 0, this.clientHeight * this._canvasScale);
    e4.addColorStop(0, "black");
    e4.addColorStop(1, this.fillStyle);
    this._ctx.fillStyle = e4;
    this._ctx.fillRect(0, 0, this.clientWidth * this._canvasScale, this.clientHeight * this._canvasScale);
  }
  setFrame(e4, t2) {
    this._leftDistance = e4;
    this._rightDistance = t2;
    this._customFrame = true;
    this._pixelsInMeter_x = this._canvasScale * this.clientWidth / (this._rightDistance - this._leftDistance);
    this.model.setRange(e4, t2);
    this.draw();
  }
  _updateUnits() {
    if (!this._customFrame) {
      this._pixelsInMeter_x = this._canvasScale * this.clientWidth / (this.model.maxX - this.model.minX);
    }
    this._pixelsInMeter_y = this._canvasScale * this.clientHeight / (this.model.maxY - this.model.minY);
  }
  clear() {
    this.model.clear();
    this.clearCanvas();
  }
  draw() {
    let e4 = this.model.drawData[0];
    if (e4.length > 1) {
      this._updateUnits();
      this.clearCanvas();
      let t2 = this.model.drawData[1];
      this._drawTrack(e4, t2);
      this._drawTerrain(t2);
      this._drawWarningAndCollision(t2);
      this._drawLabels(e4, t2);
    } else {
      this.clearCanvas();
    }
  }
  _drawLabels(e4, t2) {
    let i2 = this._ctx;
    if (i2) {
      let s2 = e4[0];
      const r2 = this.model.maxY;
      let n2 = (-this._leftDistance + s2[0]) * this._pixelsInMeter_x, o2 = (r2 - s2[1]) * this._pixelsInMeter_y;
      (r2 - t2[s2[2]][1]) * this._pixelsInMeter_y;
      i2.beginPath();
      i2.fillStyle = "#F7F718";
      i2.fillRect(n2 - 4, o2 - 4, 8, 8);
      i2.stroke();
      i2.fillStyle = "white";
      i2.font = `${26 / devicePixelRatio}px Arial`;
      i2.textBaseline = "bottom";
      i2.textAlign = "left";
      i2.fillText(`${Math.round(s2[1] - t2[s2[2]][1]).toString()} m`, n2 + 1, o2 - 10);
      i2.stroke();
      for (let s3 = 1, a2 = e4.length; s3 < a2; s3++) {
        let a3 = e4[s3];
        n2 = (-this._leftDistance + a3[0]) * this._pixelsInMeter_x;
        o2 = (r2 - a3[1]) * this._pixelsInMeter_y;
        (r2 - t2[a3[2]][1]) * this._pixelsInMeter_y;
        i2.beginPath();
        i2.fillStyle = "#F7F718";
        i2.fillRect(n2 - 4, o2 - 4, 8, 8);
        i2.stroke();
        i2.fillStyle = "white";
        i2.fillText(`${Math.round(a3[1] - t2[a3[2]][1]).toString()} m`, n2 + 1, o2 - 10);
        i2.stroke();
      }
    }
  }
  _drawTrack(e4, t2) {
    let i2 = e4[0];
    let s2 = this._ctx;
    if (s2) {
      const r2 = this.model.maxY;
      s2.lineWidth = Gc;
      s2.strokeStyle = Dc;
      s2.beginPath();
      s2.moveTo((-this._leftDistance + i2[0]) * this._pixelsInMeter_x, (r2 - i2[1]) * this._pixelsInMeter_y);
      let n2 = 0;
      for (let t3 = 1, i3 = e4.length; t3 < i3; t3++) {
        let i4 = e4[t3];
        s2.lineTo((-this._leftDistance + i4[0]) * this._pixelsInMeter_x, (r2 - i4[1]) * this._pixelsInMeter_y);
        let o3 = e4[t3 - 1];
        let a3 = i4[0] - o3[0], l3 = i4[1] - o3[1], h2 = a3 * a3, c2 = l3 * l3;
        n2 += Math.sqrt(h2 + c2);
      }
      s2.stroke();
      s2.lineWidth = 2;
      s2.strokeStyle = "rgba(255,255,255,0.7)";
      s2.beginPath();
      let o2 = (-this._leftDistance + i2[0]) * this._pixelsInMeter_x, a2 = (r2 - i2[1]) * this._pixelsInMeter_y, l2 = (r2 - t2[i2[2]][1]) * this._pixelsInMeter_y;
      s2.moveTo(o2, a2);
      s2.lineTo(o2, l2);
      for (let i3 = 1, n3 = e4.length; i3 < n3; i3++) {
        let n4 = e4[i3];
        o2 = (-this._leftDistance + n4[0]) * this._pixelsInMeter_x;
        a2 = (r2 - n4[1]) * this._pixelsInMeter_y;
        l2 = (r2 - t2[n4[2]][1]) * this._pixelsInMeter_y;
        s2.strokeStyle = "rgba(255,255,255,0.7)";
        s2.moveTo(o2, a2);
        s2.lineTo(o2, l2);
      }
      s2.stroke();
      this.events.dispatch(this.events.tracklength, n2);
    }
  }
  _drawTerrain(e4) {
    let t2 = e4[0];
    let i2 = this._ctx;
    if (i2) {
      const s2 = this.model.maxY;
      i2.lineWidth = Gc;
      i2.strokeStyle = Fc;
      i2.beginPath();
      i2.moveTo((-this._leftDistance + t2[0]) * this._pixelsInMeter_x, this.$canvas.height);
      i2.lineTo((-this._leftDistance + t2[0]) * this._pixelsInMeter_x, (s2 - t2[1]) * this._pixelsInMeter_y);
      let r2 = 0;
      for (let t3 = 1, n2 = e4.length; t3 < n2; t3++) {
        let n3 = e4[t3];
        i2.lineTo((-this._leftDistance + n3[0]) * this._pixelsInMeter_x, (s2 - n3[1]) * this._pixelsInMeter_y);
        let o2 = e4[t3 - 1];
        let a2 = n3[0] - o2[0], l2 = n3[1] - o2[1], h2 = a2 * a2, c2 = l2 * l2;
        r2 += Math.sqrt(h2 + c2);
      }
      i2.lineTo((-this._leftDistance + e4[e4.length - 1][0]) * this._pixelsInMeter_x, this.$canvas.height);
      i2.closePath();
      i2.stroke();
      i2.save();
      i2.fillStyle = Nc;
      i2.globalAlpha = Uc;
      i2.fill();
      i2.restore();
      i2.globalAlpha = 1;
      this.events.dispatch(this.events.groundlength, r2);
    }
  }
  _drawWarningAndCollision(e4) {
    let t2 = this._ctx;
    if (t2 && e4.length > 1) {
      let i2 = this.model.maxY;
      t2.lineWidth = Gc;
      t2.beginPath();
      let s2 = 0, r2 = 0;
      for (let n2 = 0, o2 = e4.length - 1; n2 < o2; n2++) {
        let o3 = e4[n2], a2 = e4[n2 + 1];
        if (o3[2] !== Tc && a2[2] !== Tc) {
          let e5 = a2[0] - o3[0], n3 = a2[1] - o3[1], l2 = e5 * e5, h2 = n3 * n3;
          if (o3[2] === Ac) {
            t2.stroke();
            t2.beginPath();
            t2.strokeStyle = Vc[Ac];
            r2 += Math.sqrt(l2 + h2);
          } else if (o3[2] === Ec) {
            t2.stroke();
            t2.beginPath();
            t2.strokeStyle = Vc[Ec];
            s2 += Math.sqrt(l2 + h2);
          }
          t2.moveTo((-this._leftDistance + o3[0]) * this._pixelsInMeter_x, (i2 - o3[1]) * this._pixelsInMeter_y);
          t2.lineTo((-this._leftDistance + a2[0]) * this._pixelsInMeter_x, (i2 - a2[1]) * this._pixelsInMeter_y);
        }
      }
      t2.stroke();
      this.events.dispatch(this.events.warninglength, s2);
      this.events.dispatch(this.events.collisionlength, r2);
    }
  }
}
let qc = ur.createCylinder(0.33, 0, 1, 20, 1, true, false, 0, 0, 0);
let $c = ur.createCylinder(0.33, 0.33, 1.1, 20, 1, true, true, 0, -0.55, 0);
const Xc = { startPosition: new Ke(), endPosition: new Ke(), startColor: "rgba(255,131,0,0.2)", endColor: "rgba(255,131,0,1.0)", thickness: 2.7 };
const Zc = { src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjEuNBNAaMQAAAiLSURBVHhe7Z0r0BxFEMcjIhAIRERERAQCgUAgEBEIBAIRiUAgIiIQiAgEIlUREQgEIgIREYFAIBCIiAgEIiIiAoGIoHimqPAKz5CP/t23/8vcbe89d/dmZ/pf9avLdZK72e6+ee3M7Imjo6Opc8o4b7xn3DIeGEOJz+Y7+C6+k+/2yjQZXOMEOGdcNe4anv4wvjV+m73bT3wGn8VneqIMlIUyeWXNGteYKTj4feNrI9W/xi/HfxxVfCffnYqyUcbJJINrzIjTxjvGV0aqn43fj/+YhSgLZUpFmd81uAbv2rLANWbAC8ZHxp+GxC8ufZ+rKGNaI1FLcC1ck3etB8U1HhCqzk8N6T/jENV7X6LsXIN008iqeXCNB+B54zND+tt4ePzHIsS1cE0SicA1e74YFdc4IgyjrhvqTP3TvJas9Bq59oP2EVzjCJw03jI0TCMBcurUDS1qBCU9PnjbwCeerwbFNQ4MVd9tQ5pyG7+v0mvHJ6N3FF3jgFwy1JPvmlipUfIFvmHY6/luEFzjANDO0fGRfm1eQ0+UzlriqzOG58tecY0985LxnYH+al5D3ZKP8Bm+83zaG66xRy4a6uzU3NZvK/nqkUEH0fNtL7jGHqBH+4EhTWEGL2ddMwYZJbjGPaGgHxuIDA7tJ/mQGdLek8A17sHTxucGiva+P6kGxbf42PP9TrjGHUmDH1V+/xokCVzjDkTwx1HvSeAat4R2SWP8CP7wko9ZmrZ3n8A1bok6fBH88SRf4/u9ksA1bgFr4ZDG+qHxpLuKLFD1YrMRrnFDLhjocfMaGl8aIjLh5sVoLa5xA140+lhxG+pHNAk7TRu7xjXQ+9TK3Jru4ecqxYB7B88YXsw6cY1rUKcv7ujlI907YLbQi1knrnEFavej05ef1ClkpZUXOxfX2AH3p6Pdz1/E6FnDi2EL19iBVu3Gbd18pdgwU+jFsIVrdHjDQHGDJ39pkojm2ovlAq5xCXqWWtETmo7uG2t3L7vGJTTbF73+6UhNARtVvZjOcY0JZ42Y45+uGK2t7BC6xoQbBoqO3/SkGpt5Gy+2M1xjw3MGGZRubgxNS5qv6dxw4hob9OuPsf90pWnizlrANRpM+sSvvwypFqBGb8W6ZWjgHjOKtn/6Ug3OMv1WrFsG4ykjqv3yxGiudbdw4U2DbvjEuL8cqSZv7TJaeNOg1b2h8nTHWIj3whuDSQOUHmcSKkPagr5wNE0afLhioOj8lSc16QvTw2nwYfk8vlB5YjnfPOZp8FX9x8kd5Uqju3kzkCYAPUQU1X+5UjPACaatBEiPcAmVrfmKIQU/Jn/qEpNCs82lSgCOL0U/Na+hcvVD8/qKMU8AjiZDsdGjfCnGl415AnyCJVSVZptIlAD3sISqEgt9ZwnAHSIU07/1SMv7T5EA7CpFPzavofKljuA5EkCbPmICqB4p1m+SAPQGQ3XqMgnAQwtCdeo6CRBTwPXqJgnAKpFQnbpDAsQcQL26RwLEzt96dZ8ECFWsSIDKFQlQuSIBKlckQOUiAThLJlSnZqOAmAeoV7N5gJgJrFd3SQCePBGqU7dIgLgbWK9mdwO1ITRUn66QADoQIlYE1SPF+gIJEGsC69PCmkDOk0WxKrgeaQf4aRIA9AiYUD2a7wuA2BlUn1gKOE8A9ouj2BtYvh42r4z+5gnATlEUHcHy9X3z+poxT4A4H6Aecfxv63wAiOXh9ah1QgioHxAnhJYr1fKz9h/SBOA0aRSnhJUrJQCP/m0lAMQ5geWr85xA0I2haAbKk4b4K08KVTMQ08LlSU37vPqHNPgiVgiVK5r4hXgvvGm4aKC4PVyOFMuNnhfABEFMCpWnjZ8YAjxfBkUiTF/q/LH0rxXrlqFBJ4friVOh6Uod+oUHRYiWIYFnzaG4QzhdqefPo/+9GK9MAJ42SQ0QtcB0pV//wtAvxTUmqBaIiaHpSff9Z0fCduEaE+gLxBNEpyliRuzctl+4xiU0Ioh5gelIsfrQ8GI6xzUuwdjxgRGalojZacOL6RzX6KDNI0wmhPKWev6tWT8P19jBFwaKDmG+0pD9tnHS8OK4gGvsgDuFUQPkr7UdvxTXuAI9Wk7nzYfykX6clwwvdi6ucQ3MKqEYFeQjxYKFvRtV/cI1roG9hDpdNNYPHl6KAWc9re31L+MaN4DHzMUUcT4iFi8bXqxW4ho3RP2Bx81raHw9al557J8Xo7W4xi24ZqAYHYwv+XztbN8qXOMW0OFQpzBuG48n+XrrTt8yrnFLWELGViMUSTC85GN8Ptvftw+ucQcYGTD7hCIJhpN8y8rtrXv8Hq5xR7hpdNdAkQT9Sz7Fx70EH1zjHlAl6Z5BdAz7k3xJLdta2bsPrnFP0j5BzBXsL/mwlzZ/GdfYA/RMbxgo5gl2l3yHL/fq7XfhGnskfSpp3DvYXKmvZs/5HwrX2DOcP6QVRVqoGOqWfMSmnFcNz6e94RoH4IyhziGLFeMmUlv4RItv8RU+83zZK65xIGjDOH9AnZoYKj6RfIFvrhqDtPcernFg2KTwpSHVvMQsvXa2bnNus+ezwXCNI6DaQOPbGoeLumZ8gC9G+9WnuMYRYeOJdh+hGiaP0mvkiF584PlmFFzjAWAxgzqJqMRESK+Ja91pAUffuMYDwvGlaSJQTU65j0DZ0+aNaztveNd+EFxjBjB3QPWYOm9Kh1WkZeUa2KDJNXnXelBcY0bQPnKs2fIj7nOsFZbLRJkp+0Hb+HW4xgzhMGuqTubEl2sC9igcYpqZ71zeH0HZKCNlpczetWSFa8wcJQO7lrtONiUQ3xh9TDbxGXxWVxNEGSjLZIKe4honxlnjdYMFqnSyhhxB8Nl8B9/Fd/LdXpkmg2ssANpdfpEsXacdZq6BJ6Tya+VZyWnnUsLG3/Fv+Lf8H/4vn8FnZd2W78bRif8BxMOwtJg5Ph4AAAAASUVORK5CYII=", color: "rgb(255,131,0)", size: [8, 8] };
const Kc = { text: "", face: "arial", size: 10.5, color: "rgba(455,455,455,1.0)", outlineColor: "rgba(0,0,0,0.34)", outline: 0.23, align: "left", offset: [5, 15, -5] };
const Qc = { face: "arial", text: "", size: 10.5, color: "rgba(455,455,455,1.0)", outlineColor: "rgba(0,0,0,0.34)", outline: 0.23, align: "right", offset: [-47, 25, 0] };
const Jc = { instanced: true, tag: "ground-pointer", color: "rgb(0,305,0)", object3d: qc };
const ed = { instanced: true, tag: "head-pointer", color: "rgb(305,305,0)", object3d: $c };
class td extends Fr {
  constructor(e4 = {}) {
    super("ElevationProfileScene");
    this._onLClick = (e5) => {
      let t2 = this._planet.getCartesianFromPixelTerrain(e5.pos);
      if (t2) {
        this.addGroundPoint3vAsync(t2);
      }
    };
    this._onMouseMove = (e5) => {
      this._planet.getCartesianFromMouseTerrain();
      if (this._pickedGroundEntity) {
        let t2 = new Qe(e5.x, e5.y).sub(this._startClickPos), i2 = this._startEntityPos.add(t2);
        let s2 = this._planet.getCartesianFromPixelTerrain(i2);
        if (s2) {
          this.setGroundPointCartesian3v(this._pickedGroundEntity.properties.index, s2);
        }
      } else if (this._pickedHeadEntity) {
        let t2 = this._planet.camera;
        let i2 = this._pickedHeadEntity.properties.groundEntity.getCartesian();
        let s2 = this._planet.ellipsoid.getSurfaceNormal3v(i2);
        let r2 = i2.add(s2);
        let n2 = i2.add(t2.getRight());
        let o2 = new Ke();
        if (new ar(t2.eye, e5.direction).hitPlaneRes(or.fromPoints(i2, r2, n2), o2) === ar.INSIDE) {
          let e6 = Ke.proj_b_to_a(o2, i2);
          let t3 = e6.sub(i2).dot(i2);
          let r3 = i2.add(s2.scale(Math.sign(t3) * e6.distance(i2)));
          this.setHeadPointCartesian3v(this._pickedHeadEntity.properties.index, r3);
        }
      }
    };
    this._onLUp = (e5) => {
    };
    this._onGroundPointerEnter = (e5) => {
      e5.renderer.handler.canvas.style.cursor = "pointer";
    };
    this._onGroundPointerLeave = (e5) => {
      e5.renderer.handler.canvas.style.cursor = "default";
    };
    this._onGroundPointerLDown = (e5) => {
      this._clampToGround = false;
      this.renderer.controls.mouseNavigation.deactivate();
      this._pickedGroundEntity = e5.pickingObject;
      const t2 = this._pickedGroundEntity.getCartesian();
      this._startClickPos.set(e5.x, e5.y);
      this._startEntityPos = this._planet.getPixelFromCartesian(t2);
    };
    this._onGroundPointerLUp = (e5) => {
      this._clampToGround = true;
      this.renderer.controls.mouseNavigation.activate();
      this._pickedGroundEntity = null;
    };
    this._onHeadPointerEnter = (e5) => {
      e5.renderer.handler.canvas.style.cursor = "pointer";
    };
    this._onHeadPointerLeave = (e5) => {
      e5.renderer.handler.canvas.style.cursor = "default";
    };
    this._onHeadPointerLDown = (e5) => {
      this.renderer.controls.mouseNavigation.deactivate();
      this._pickedHeadEntity = e5.pickingObject;
    };
    this._onHeadPointerLUp = (e5) => {
      this.renderer.controls.mouseNavigation.activate();
      this._pickedHeadEntity = null;
    };
    this.events = Qi(id);
    this._planet = e4.planet || null;
    this._pickedGroundEntity = null;
    this._pickedHeadEntity = null;
    this._startClickPos = new Qe();
    this._startEntityPos = new Qe();
    this._clampToGround = true;
    this._trackLayer = new Ma("track", { entities: [], pickingEnabled: false, polygonOffsetUnits: -1, relativeToGround: true, hideInLayerSwitcher: true });
    this._groundPointersLayer = new Ma("ground-pointers", { entities: [], pickingEnabled: true, hideInLayerSwitcher: true, scaleByDistance: [1, 5e3, 0.02], pickingScale: 1.5 });
    this._headPointersLayer = new Ma("head-pointers", { entities: [], pickingEnabled: true, hideInLayerSwitcher: true, scaleByDistance: [1, 1e4, 0.02], pickingScale: 1 });
    this._columnPointersLayer = new Ma("column-pointers", { entities: [], pickingEnabled: false, hideInLayerSwitcher: true });
    this._trackEntity = new zr({ polyline: { path3v: [], thickness: 3.8, color: "rgba(0,305,0,0.8)", isClosed: false } });
    this._trackLayer = new Ma("column-pointers", { entities: [this._trackEntity], pickingEnabled: false, hideInLayerSwitcher: true });
    this._heightsLayer = new Ma("heights-labels", { entities: [], pickingEnabled: false, hideInLayerSwitcher: true });
    this._pointerHeadEntity = new zr({ cartesian: new Ke(), billboard: Zc });
    this._pointerLabelEntity = new zr({ cartesian: new Ke(), label: Kc });
    this._pointerRayEntity = new zr({ cartesian: new Ke(), ray: Xc });
    this._pointerLayer = new Ma("pointer", { entities: [this._pointerHeadEntity, this._pointerLabelEntity, this._pointerRayEntity], pickingEnabled: false, hideInLayerSwitcher: true });
  }
  flyExtent() {
    let e4 = this._headPointersLayer.getEntities();
    let t2 = 180, i2 = 180, s2 = -180, r2 = -180, n2 = -1e6;
    if (e4.length > 1) {
      for (let o2 = 0; o2 < e4.length; o2++) {
        let a2 = e4[o2].getLonLat();
        if (a2.lon < t2) t2 = a2.lon;
        if (a2.lat < i2) i2 = a2.lat;
        if (a2.lon > s2) s2 = a2.lon;
        if (a2.lat > r2) r2 = a2.lat;
        if (a2.height > n2) n2 = a2.height;
      }
      this._planet.camera.flyExtent(new Ye(new be(t2, i2), new be(s2, r2)), n2, null, 0);
    }
  }
  get planet() {
    return this._planet;
  }
  _createGroundPointer(e4, t2 = 10) {
    let i2 = this.ellipsoid.getSurfaceNormal3v(e4);
    let s2 = e4.add(i2.scale(t2));
    let r2 = new zr({ ray: { startPosition: e4, endPosition: s2, startColor: "rgba(255,255,255,0.2)", endColor: "rgba(355,355,355,1.0)", thickness: 3.2 } });
    let n2 = new zr({ cartesian: e4, geoObject: Jc });
    let o2 = new zr({ cartesian: s2, geoObject: ed, properties: {} });
    let a2 = new zr({ cartesian: s2, label: Qc });
    a2.appendChild(new zr({ cartesian: s2, label: { ...Qc, offset: [-47, 45, 0] } }));
    const l2 = this._groundPointersLayer.getEntities().length;
    r2.properties = n2.properties = o2.properties = { index: l2, altitude: t2, lonLatEll: new be(), headEntity: o2, groundEntity: n2, columnEntity: r2, heightLabelEntity: a2 };
    return { headEntity: o2, groundEntity: n2, columnEntity: r2, heightLabelEntity: a2 };
  }
  setPointerCartesian3v(e4, t2) {
    this._pointerLabelEntity.setCartesian3v(e4);
    this._pointerLabelEntity.label.setText(`${Math.round(t2).toString()} m`);
    this._pointerRayEntity.ray.setEndPosition3v(e4);
    let i2 = this._planet.ellipsoid.getSurfaceNormal3v(e4);
    this._pointerRayEntity.ray.setStartPosition3v(e4.add(i2.scale(-t2)));
    this._pointerHeadEntity.setCartesian3v(e4);
  }
  bindPlanet(e4) {
    this._planet = e4;
  }
  init() {
    this._activate();
  }
  onremove() {
    this._deactivate();
  }
  _activate() {
    this._planet.addLayer(this._trackLayer);
    this._planet.addLayer(this._groundPointersLayer);
    this._planet.addLayer(this._columnPointersLayer);
    this._planet.addLayer(this._headPointersLayer);
    this._planet.addLayer(this._heightsLayer);
    this._planet.addLayer(this._pointerLayer);
    this.renderer.events.on("ldblclick", this._onLClick);
    this.renderer.events.on("mousemove", this._onMouseMove);
    this.renderer.events.on("lup", this._onLUp);
    this._groundPointersLayer.events.on("mouseenter", this._onGroundPointerEnter);
    this._groundPointersLayer.events.on("mouseleave", this._onGroundPointerLeave);
    this._groundPointersLayer.events.on("ldown", this._onGroundPointerLDown);
    this._groundPointersLayer.events.on("lup", this._onGroundPointerLUp);
    this._headPointersLayer.events.on("mouseenter", this._onHeadPointerEnter);
    this._headPointersLayer.events.on("mouseleave", this._onHeadPointerLeave);
    this._headPointersLayer.events.on("ldown", this._onHeadPointerLDown);
    this._headPointersLayer.events.on("lup", this._onHeadPointerLUp);
    this.setPointerVisibility(false);
  }
  getPointLonLat(e4) {
    let t2 = this._headPointersLayer.getEntities()[e4];
    if (t2) {
      return t2.getLonLat();
    }
  }
  getPointsLonLat() {
    let e4 = this._headPointersLayer.getEntities();
    let t2 = new Array(e4.length);
    for (let i2 = 0, s2 = t2.length; i2 < s2; i2++) {
      let s3 = e4[i2];
      t2[i2] = s3.getLonLat();
    }
    return t2;
  }
  getHeightMSL(e4) {
    if (this._planet && this._planet.terrain.geoid) {
      return this._planet.terrain.geoid.getHeightLonLat(e4);
    }
    return 0;
  }
  getHeightELLAsync(e4) {
    return new Promise((t2, i2) => {
      this._planet.terrain.getHeightAsync(e4, (s2) => {
        if (this._planet) {
          let i3 = this.getHeightMSL(e4);
          t2(s2 + i3);
        } else {
          i2();
        }
      });
    });
  }
  addPointLonLatArrayAsync(e4, t2 = false) {
    if (!this._planet) {
      throw new Error("Planet is not defined");
    }
    let i2 = this._planet.ellipsoid;
    for (let t3 = 0, s3 = e4.length - 1; t3 < s3; t3++) {
      let s4 = i2.lonLatToCartesian(e4[t3]), r2 = i2.lonLatToCartesian(e4[t3 + 1]);
      if (s4.distance(r2) > 1e5) {
        throw new Error("Track is too long! 100 km is maximum.");
      }
    }
    let s2 = new Array(e4.length);
    for (let t3 = 0, i3 = e4.length; t3 < i3; t3++) {
      s2[t3] = this.addPointLonLatAsync(e4[t3], true);
    }
    Promise.all(s2).then(() => {
      if (!t2) {
        this.events.dispatch(this.events.change, this);
      }
    });
    return s2;
  }
  addPointLonLatAsync(e4, t2 = false) {
    let i2 = this._planet.ellipsoid.lonLatToCartesian(e4);
    let s2 = this._planet.ellipsoid.getSurfaceNormal3v(i2);
    let r2 = new be(e4.lon, e4.lat);
    let n2 = this._planet.ellipsoid.lonLatToCartesian(r2);
    let { headEntity: o2, groundEntity: a2, columnEntity: l2, heightLabelEntity: h2 } = this._createGroundPointer(n2);
    this._groundPointersLayer.add(a2);
    this._columnPointersLayer.add(l2);
    this._headPointersLayer.add(o2);
    this._heightsLayer.add(h2);
    this._trackEntity.polyline.appendPoint3v(o2.getCartesian());
    a2.properties.lonLatEll.lon = r2.lon;
    a2.properties.lonLatEll.lat = r2.lat;
    a2.properties.lonLatEll.height = r2.height;
    return new Promise((r3) => {
      this.getHeightELLAsync(e4).then((n3) => {
        var _a2;
        a2.properties.lonLatEll.height = n3;
        let l3 = 10, c2;
        if (e4.height === 0) {
          c2 = i2.add(s2.scaleTo(n3));
          i2 = c2.add(s2.scaleTo(l3));
        } else {
          l3 = e4.height - n3;
          c2 = i2.sub(s2.scaleTo(l3));
        }
        a2.setCartesian3v(c2);
        h2.setCartesian3v(i2);
        h2.label.setText(`${n3.toFixed(1)} m`);
        h2.childEntities[0].label.setText(`${l3.toFixed(1)} m`);
        o2.properties.altitude = l3;
        o2.setCartesian3v(i2);
        o2.properties.columnEntity.ray.setStartPosition3v(c2);
        o2.properties.columnEntity.ray.setEndPosition3v(i2);
        (_a2 = this._trackEntity.polyline) == null ? void 0 : _a2.setPoint3v(i2, o2.properties.index);
        if (!t2) {
          this.events.dispatch(this.events.addpoint, o2, this);
          this.events.dispatch(this.events.change, this);
        }
        r3(o2);
      });
    });
  }
  addGroundPointLonLatAsync(e4, t2 = 10, i2 = false) {
    let s2 = this._planet.ellipsoid.lonLatToCartesian(e4);
    return this._addPoint(s2, e4, t2, i2);
  }
  addGroundPoint3vAsync(e4, t2 = 10, i2 = false) {
    let s2 = this._planet.ellipsoid.cartesianToLonLat(e4);
    return this._addPoint(e4, s2, t2, i2);
  }
  _addPoint(e4, t2, i2, s2 = false) {
    return new Promise((r2, n2) => {
      let { headEntity: o2, groundEntity: a2, columnEntity: l2, heightLabelEntity: h2 } = this._createGroundPointer(e4, i2);
      this._groundPointersLayer.add(a2);
      this._columnPointersLayer.add(l2);
      this._headPointersLayer.add(o2);
      this._heightsLayer.add(h2);
      this._trackEntity.polyline.appendPoint3v(o2.getCartesian());
      a2.properties.lonLatEll.lon = t2.lon;
      a2.properties.lonLatEll.lat = t2.lat;
      a2.properties.lonLatEll.height = t2.height;
      this.getHeightELLAsync(t2).then((e5) => {
        var _a2;
        a2.properties.lonLatEll.height = t2.height = e5;
        let n3 = this._planet.ellipsoid.lonLatToCartesian(t2);
        let l3 = this._planet.ellipsoid.getSurfaceNormal3v(n3);
        let c2 = n3.add(l3.scale(i2));
        h2.setCartesian3v(c2);
        h2.label.setText(`${e5.toFixed(1)} m`);
        h2.childEntities[0].label.setText(`${i2.toFixed(1)} m`);
        o2.setCartesian3v(c2);
        o2.properties.columnEntity.ray.setEndPosition3v(c2);
        (_a2 = this._trackEntity.polyline) == null ? void 0 : _a2.setPoint3v(c2, o2.properties.index);
        if (!s2) {
          this.events.dispatch(this.events.addpoint, o2, this);
          this.events.dispatch(this.events.change, this);
        }
        r2(o2);
      });
    });
  }
  setHeadPointCartesian3v(e4, t2) {
    const i2 = this._headPointersLayer.getEntities()[e4];
    if (i2) {
      let s2 = this._planet.ellipsoid.lonLatToCartesian(i2.properties.lonLatEll);
      let r2 = t2.length() - s2.length();
      if (r2 <= 0) {
        t2 = s2;
        r2 = 0;
      }
      i2.properties.altitude = r2;
      i2.setCartesian3v(t2);
      i2.properties.columnEntity.ray.setEndPosition3v(t2);
      i2.properties.heightLabelEntity.setCartesian3v(t2);
      i2.properties.heightLabelEntity.childEntities[0].label.setText(`${r2.toFixed(1)} m`);
      this._trackEntity.polyline.setPoint3v(t2, e4);
      this.events.dispatch(this.events.change, this._pickedHeadEntity);
    }
  }
  setGroundPointCartesian3v(e4, t2) {
    var _a2;
    let i2 = this._groundPointersLayer.getEntities()[e4];
    if (i2) {
      let e5 = this._planet.ellipsoid.cartesianToLonLat(t2);
      i2.properties.lonLatEll.lon = e5.lon;
      i2.properties.lonLatEll.lat = e5.lat;
      i2.properties.lonLatEll.height = e5.height;
      let s2 = this._planet.ellipsoid.getSurfaceNormal3v(t2);
      let r2 = i2.properties.headEntity;
      let n2 = i2.properties.heightLabelEntity;
      let o2 = i2.properties.altitude;
      i2.setCartesian3v(t2);
      let a2 = t2.add(s2.scale(o2));
      r2.setCartesian3v(a2);
      r2.properties.columnEntity.ray.setStartPosition3v(t2);
      r2.properties.columnEntity.ray.setEndPosition3v(a2);
      (_a2 = this._trackEntity.polyline) == null ? void 0 : _a2.setPoint3v(a2, r2.properties.index);
      n2.setCartesian3v(a2);
      n2.label.setText(`${e5.height.toFixed(1)} m`);
      n2.childEntities[0].label.setText(`${o2.toFixed(1)} m`);
      this.events.dispatch(this.events.change, i2.properties.headEntity);
    }
  }
  _deactivate() {
    this.renderer.events.off("ldblclick", this._onLClick);
    this.renderer.events.off("mousemove", this._onMouseMove);
    this.renderer.events.off("lup", this._onLUp);
    this._groundPointersLayer.events.off("mouseenter", this._onGroundPointerEnter);
    this._groundPointersLayer.events.off("mouseleave", this._onGroundPointerLeave);
    this._groundPointersLayer.events.off("ldown", this._onGroundPointerLDown);
    this._groundPointersLayer.events.off("lup", this._onGroundPointerLUp);
    this._headPointersLayer.events.off("mouseenter", this._onHeadPointerEnter);
    this._headPointersLayer.events.off("mouseleave", this._onHeadPointerLeave);
    this._headPointersLayer.events.off("ldown", this._onHeadPointerLDown);
    this._headPointersLayer.events.off("lup", this._onHeadPointerLUp);
    this._trackLayer.remove();
    this._groundPointersLayer.remove();
    this._headPointersLayer.remove();
    this._columnPointersLayer.remove();
    this._trackLayer.remove();
    this._heightsLayer.remove();
    this._pointerLayer.remove();
    this.clear();
  }
  setPointerVisibility(e4) {
    this._pointerLayer.setVisibility(e4);
  }
  setVisibility(e4) {
    this._groundPointersLayer.setVisibility(e4);
    this._trackLayer.setVisibility(e4);
    this._columnPointersLayer.setVisibility(e4);
    this._headPointersLayer.setVisibility(e4);
    this._trackLayer.setVisibility(e4);
    this._heightsLayer.setVisibility(e4);
    this._pointerLayer.setVisibility(e4);
  }
  clear() {
    this._headPointersLayer.setEntities([]);
    this._groundPointersLayer.setEntities([]);
    this._columnPointersLayer.setEntities([]);
    this._heightsLayer.setEntities([]);
    this._trackEntity.polyline.setPath3v([]);
  }
  frame() {
    if (this._clampToGround) {
      let e4 = new Ke();
      const t2 = this._planet._renderedNodes;
      const i2 = this._groundPointersLayer.getEntities();
      for (let s2 = 0; s2 < i2.length; s2++) {
        let r2 = i2[s2];
        for (let i3 = 0; i3 < t2.length; i3++) {
          let s3 = t2[i3];
          if (s3.segment.isEntityInside(r2)) {
            s3.segment.getEntityTerrainPoint(r2, e4);
            r2.setCartesian3v(e4);
            r2.properties.columnEntity.ray.setStartPosition3v(e4);
            break;
          }
        }
      }
    }
  }
  get ellipsoid() {
    return this._planet ? this._planet.ellipsoid : null;
  }
}
const id = ["change", "addpoint"];
const sd = '<div class="og-elevationprofile-buttons"></div>';
const rd = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg width="30" height="30" viewBox="0 0 30 30" version="1.1">
  <g transform="translate(0,-289.0625)">
    <path d="M 15 6 C 10.041282 6 6 10.04128 6 15 C 6 19.95872 10.041282 24 15 24 C 16.586491 24 18.07668 23.58246 19.373047 22.857422 L 17.888672 21.375 C 17.00816 21.772814 16.032235 22 15 22 C 11.122162 22 8 18.87784 8 15 C 8 11.12216 11.122162 8 15 8 C 18.877838 8 22 11.12216 22 15 L 19 15 L 23 20 L 27 15 L 24 15 C 24 10.04128 19.958718 6 15 6 z " transform="translate(0,289.0625)" />
  </g>
</svg>`;
const nd = `<?xml version="1.0" encoding="utf-8"?><svg width="800px" height="800px" viewBox="0 0 32 32" id="icon" xmlns="http://www.w3.org/2000/svg"><defs><style>.cls-1{fill:none;}</style></defs><title>list</title><rect x="10" y="6" width="18" height="2"/><rect x="10" y="24" width="18" height="2"/><rect x="10" y="15" width="18" height="2"/><rect x="4" y="15" width="2" height="2"/><rect x="4" y="6" width="2" height="2"/><rect x="4" y="24" width="2" height="2"/></svg>`;
const od = `<?xml version="1.0" encoding="utf-8"?>
<!-- Svg Vector Icons : http://www.onlinewebfonts.com/icon -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 256 256" enable-background="new 0 0 256 256" xml:space="preserve">
<metadata> Svg Vector Icons : http://www.onlinewebfonts.com/icon </metadata>
<g><g><path fill="#000000" d="M127,169.4c23.7,0,42.8-18.3,42.8-41s-19.2-41-42.8-41c-23.7,0-42.8,18.4-42.8,41S103.4,169.4,127,169.4z"/><path fill="#000000" d="M221.7,120.2c-3.8-44-40.9-78.9-87-82V15h-16.3v23.6c-44.8,4-80.3,38.5-84.1,81.7H10v15.6h24.3c3.8,43.1,39.3,77.4,84.1,81.7V241h16.3v-23.2c46-3.1,83.2-37.9,87-82H246v-15.6H221.7L221.7,120.2L221.7,120.2z M128,201.6c-42.5,0-76.7-33-76.7-73.4c0-40.4,34.5-73.4,76.7-73.4c42.5,0,76.7,33,76.7,73.4C204.7,168.5,170.5,201.6,128,201.6L128,201.6z"/></g></g>
</svg>`;
const ad = ["reset", "list", "location"];
class ld extends ts {
  constructor(e4 = {}) {
    super({ ...e4, template: sd });
    this.events = this.events.registerNames(ad);
    this.pointListBtn = new _s({ classList: ["og-elevationprofile-button"], icon: nd, title: "Point List" });
    this.pointListBtn.events.on("change", (e5) => {
      this.events.dispatch(this.events.list, e5);
    });
  }
  render(e4) {
    super.render(e4);
    let t2 = new rs({ classList: ["og-elevationprofile-button"], icon: rd, title: "Reset" });
    t2.appendTo(this.el);
    t2.events.on("click", () => {
      this.model.clear();
      this.events.dispatch(this.events.reset, this);
    });
    this.pointListBtn.appendTo(this.el);
    let i2 = new rs({ classList: ["og-elevationprofile-button", "og-elevationprofile-button__location"], icon: od, title: "View bounds" });
    i2.appendTo(this.el);
    i2.events.on("click", () => {
      this.events.dispatch(this.events.location, this);
    });
    return this;
  }
}
const hd = `<div class="og-elevationprofile-list">
        <textarea placeholder="[[lon, lat, height], [lon, lat, height], ..., [lon, lat, height]]"></textarea>
        <div class="og-elevationprofile-list-buttons"></div>
    </div>`;
class cd extends ds {
  constructor(e4) {
    super({ title: "Points List", visible: false, resizable: true, useHide: true, top: 150, left: 200, width: 400, height: 300, minHeight: 100, minWidth: 100, ...e4 });
    this._onApplyClick = () => {
      try {
        this.model.clear();
        let e5 = JSON.parse(this.$textarea.value);
        let t2 = new Array(e5.length);
        for (let i2 = 0; i2 < e5.length; i2++) {
          let s2 = e5[i2];
          t2[i2] = new be(s2[0], s2[1], s2[2]);
        }
        this.model.addPointLonLatArrayAsync(t2);
      } catch (e5) {
        console.error(e5);
      }
    };
    this.$textarea = null;
  }
  render(e4) {
    super.render(e4);
    let t2 = new ts({ template: hd });
    t2.appendTo(this.container);
    let i2 = new rs({ classList: ["og-elevationprofile-list-apply"], icon: "Apply" });
    i2.appendTo(t2.select(".og-elevationprofile-list-buttons"));
    i2.events.on("click", this._onApplyClick);
    this.$textarea = t2.select("textarea");
    return this;
  }
}
const dd = `<div class="og-elevationprofile-legend">
        <div class="og-elevationprofile-legend__row og-elevationprofile-legend__track">
          <div class="og-elevationprofile-square"></div>
          <div class="og-elevationprofile-value">0</div>
          <div class="og-elevationprofile-units">m</div>
        </div>
        <div class="og-elevationprofile-legend__row og-elevationprofile-legend__ground">
          <div class="og-elevationprofile-square"></div>
          <div class="og-elevationprofile-value">0</div>
          <div class="og-elevationprofile-units">m</div>
        </div>
        <div class="og-elevationprofile-legend__row og-elevationprofile-legend__warning">        
          <div class="og-elevationprofile-square"></div>
          <div class="og-elevationprofile-value">0</div>
          <div class="og-elevationprofile-units">m</div>
        </div>
        <div class="og-elevationprofile-legend__row og-elevationprofile-legend__collision">
          <div class="og-elevationprofile-square"></div>
          <div class="og-elevationprofile-value">0</div>
          <div class="og-elevationprofile-units">m</div>
        </div>
      </div>`;
class ud extends ts {
  constructor(e4 = {}) {
    super({ ...e4, template: dd });
    this.$groundValue = null;
    this.$trackValue = null;
    this.$warningValue = null;
    this.$collisionValue = null;
    this.$trackUnits = null;
    this.$groundUnits = null;
    this.$warningUnits = null;
    this.$collisionUnits = null;
  }
  render(e4) {
    super.render(e4);
    this.$trackValue = this.select(".og-elevationprofile-legend__track .og-elevationprofile-value");
    this.$groundValue = this.select(".og-elevationprofile-legend__ground .og-elevationprofile-value");
    this.$warningValue = this.select(".og-elevationprofile-legend__warning .og-elevationprofile-value");
    this.$collisionValue = this.select(".og-elevationprofile-legend__collision .og-elevationprofile-value");
    this.$trackUnits = this.select(".og-elevationprofile-legend__track .og-elevationprofile-units");
    this.$groundUnits = this.select(".og-elevationprofile-legend__ground .og-elevationprofile-units");
    this.$warningUnits = this.select(".og-elevationprofile-legend__warning .og-elevationprofile-units");
    this.$collisionUnits = this.select(".og-elevationprofile-legend__collision .og-elevationprofile-units");
    return this;
  }
  clear() {
    this.$trackValue && (this.$trackValue.innerText = "0");
    this.$trackUnits && (this.$trackUnits.innerText = "m");
    this.$groundValue && (this.$groundValue.innerText = "0");
    this.$groundUnits && (this.$groundUnits.innerText = "m");
    this.$warningValue && (this.$warningValue.innerText = "0");
    this.$warningUnits && (this.$warningUnits.innerText = "m");
    this.$collisionValue && (this.$collisionValue.innerText = "0");
    this.$collisionUnits && (this.$collisionUnits.innerText = "m");
  }
  setTrackLength(e4) {
    let t2 = Jt(e4);
    this.$trackValue.innerText = t2[0];
    this.$trackUnits.innerText = t2[1];
  }
  setGroundLength(e4) {
    let t2 = Jt(e4);
    this.$groundValue.innerText = t2[0];
    this.$groundUnits.innerText = t2[1];
  }
  setWarningLength(e4) {
    let t2 = Jt(e4);
    this.$warningValue.innerText = t2[0];
    this.$warningUnits.innerText = t2[1];
  }
  setCollisionLength(e4) {
    let t2 = Jt(e4);
    this.$collisionValue.innerText = t2[0];
    this.$collisionUnits.innerText = t2[1];
  }
}
const _d = `<div class="og-elevationprofile__container">
      <div class="og-elevationprofile__menu"></div>
      <div class="og-elevationprofile__graph"></div>
    </div>`;
const fd = `<svg style="width: 2em; height: 2em;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M128 896v-158.293333l331.946667-191.573334 160.853333 93.866667L896 480V896H128M896 381.44l-275.2 159.146667-160.853333-92.586667L128 640v-94.293333l331.946667-191.573334 160.853333 93.866667L896 288v93.44z" fill="" /></svg>`;
class gd extends ns {
  constructor(e4 = {}) {
    super({ name: "ElevationProfileControl", ...e4 });
    this._onSceneChange = () => {
      this._collectProfileThrottled();
    };
    this._onElevationProfilePointer = (e5, t2, i2, s2, r2, n2, o2, a2) => {
      let l2 = this._elevationProfileScene.getPointLonLat(n2);
      let h2 = this._elevationProfileScene.getPointLonLat(n2 + 1);
      let c2 = this.planet.ellipsoid.lonLatToCartesian(l2), d2 = this.planet.ellipsoid.lonLatToCartesian(h2);
      let u2 = (e5 - t2[0]) / (i2[0] - t2[0]);
      let _2 = d2.sub(c2);
      this._elevationProfileScene.setPointerCartesian3v(c2.add(_2.scale(u2)), a2);
    };
    this._onElevationProfileDblClick = (e5, t2, i2, s2, r2, n2, o2, a2) => {
      let l2 = this._elevationProfileScene.getPointLonLat(n2);
      let h2 = this._elevationProfileScene.getPointLonLat(n2 + 1);
      let c2 = this.planet.ellipsoid.lonLatToCartesian(l2), d2 = this.planet.ellipsoid.lonLatToCartesian(h2);
      let u2 = (e5 - t2[0]) / (i2[0] - t2[0]);
      let _2 = d2.sub(c2);
      let f2 = c2.add(_2.scale(u2));
      this.planet.camera.flyDistance(f2, this.planet.camera.eye.distance(f2));
    };
    this._onElevationProfileMouseEnter = () => {
      if (this._elevationProfileView.model.pointsReady) {
        this._elevationProfileScene.setPointerVisibility(true);
      }
    };
    this._onElevationProfileMouseLeave = () => {
    };
    this._elevationProfileScene = new td();
    this._elevationProfileView = new Yc();
    this._elevationProfileLegend = new ud();
    this._elevationProfileButtonsView = new ld({ model: this._elevationProfileView.model });
    this._elevationProfileView.events.on("pointer", this._onElevationProfilePointer);
    this._elevationProfileView.events.on("dblclick", this._onElevationProfileDblClick);
    this._elevationProfileView.events.on("mouseenter", this._onElevationProfileMouseEnter);
    this._elevationProfileView.events.on("mouseleave", this._onElevationProfileMouseLeave);
    this._dialog = new ds({ title: "Elevation Profile", visible: false, resizable: true, useHide: true, top: 175, left: 65, width: 400, height: 200, minHeight: 100, minWidth: 100 });
    this._graphView = new ts({ template: _d });
    this._poiListDialog = new cd({ model: this._elevationProfileScene });
    this._toggleBtn = new _s({ classList: ["og-map-button", "og-elevationprofile_button"], icon: fd });
    this._collectProfileThrottled = Dt(() => {
      let e5 = this._elevationProfileScene.getPointsLonLat();
      this._elevationProfileView.model.collectProfile(e5);
    }, 250);
  }
  oninit() {
    this._dialog.appendTo(this.planet.renderer.div);
    this._graphView.appendTo(this._dialog.container);
    this._toggleBtn.appendTo(this.renderer.div);
    this._dialog.events.on("visibility", (e4) => {
      this._toggleBtn.setActive(e4);
      if (e4) {
        this.activate();
        this._elevationProfileView.resize();
      } else {
        this.deactivate();
      }
    });
    this._toggleBtn.events.on("change", (e4) => {
      this._dialog.setVisibility(e4);
    });
    this._elevationProfileView.appendTo(this._graphView.select(".og-elevationprofile__graph"));
    this._elevationProfileView.model.bindPlanet(this.planet);
    this._elevationProfileView.model.events.on("clear", () => {
      this._elevationProfileScene.clear();
      this._elevationProfileLegend.clear();
    });
    this._elevationProfileView.model.events.on("startcollecting", () => {
      this._elevationProfileScene.setPointerVisibility(false);
    });
    this._elevationProfileView.events.on("tracklength", (e4) => {
      this._elevationProfileLegend.setTrackLength(e4);
    });
    this._elevationProfileView.events.on("groundlength", (e4) => {
      this._elevationProfileLegend.setGroundLength(e4);
    });
    this._elevationProfileView.events.on("warninglength", (e4) => {
      this._elevationProfileLegend.setWarningLength(e4);
    });
    this._elevationProfileView.events.on("collisionlength", (e4) => {
      this._elevationProfileLegend.setCollisionLength(e4);
    });
    this._poiListDialog.appendTo(this.planet.renderer.div);
    this._poiListDialog.events.on("visibility", (e4) => {
      this._elevationProfileButtonsView.pointListBtn.setActive(e4, true);
    });
    this._elevationProfileLegend.appendTo(this._graphView.select(".og-elevationprofile__menu"));
    this._elevationProfileButtonsView.appendTo(this._graphView.select(".og-elevationprofile__menu"));
    this._elevationProfileButtonsView.events.on("list", (e4) => {
      this._poiListDialog.setVisibility(e4);
    });
    this._elevationProfileButtonsView.events.on("location", (e4) => {
      this._elevationProfileScene.flyExtent();
    });
    this._elevationProfileButtonsView.events.on("reset", (e4) => {
      this._elevationProfileScene.setPointerVisibility(false);
    });
    this._elevationProfileScene.events.on("change", this._onSceneChange);
  }
  onactivate() {
    this.planet && this._elevationProfileScene.bindPlanet(this.planet);
    this.renderer && this.renderer.addNode(this._elevationProfileScene);
  }
  ondeactivate() {
    this._poiListDialog.setVisibility(false);
    this._elevationProfileView.model.clear();
    this.renderer && this.renderer.removeNode(this._elevationProfileScene);
    this._dialog.hide();
  }
}
const pd = `<div class="og-atmosphere og-options-container">
         
         <div class="og-option og-atmosphere-maxOpacity"></div> 
         <div class="og-option og-atmosphere-minOpacity"></div>
         
       <div class="og-emptyline-2"></div>
         
         <div class="og-option og-atmosphere-rayleight"></div>
         <div class="og-option og-atmosphere-mie"></div>
         
       <div class="og-emptyline-2"></div>
                  
         <div class="og-option og-atmosphere-height"></div> 
         <div class="og-option og-atmosphere-bottomRadius"></div>
         
       <div class="og-emptyline-2"></div>
         
         <div class="og-option og-atmosphere-mieScatteringCoefficient"></div>  
         <div class="og-option og-atmosphere-mieExtinctionCoefficient"></div>
         
       <div class="og-emptyline-2"></div>
         
         <div class="og-option og-atmosphere-rayleighScatteringCoefficientA"></div>    
         <div class="og-option og-atmosphere-rayleighScatteringCoefficientB"></div>    
         <div class="og-option og-atmosphere-rayleighScatteringCoefficientC"></div>
         
       <div class="og-emptyline-2"></div>
         
         <div class="og-option og-atmosphere-ozoneAbsorptionCoefficientA"></div>    
         <div class="og-option og-atmosphere-ozoneAbsorptionCoefficientB"></div>    
         <div class="og-option og-atmosphere-ozoneAbsorptionCoefficientC"></div>
         
       <div class="og-emptyline-2"></div>
         
         <div class="og-option og-atmosphere-ozoneDensityHeight"></div>    
         <div class="og-option og-atmosphere-ozoneDensityWide"></div>    
         
       <div class="og-emptyline-2"></div>
         
         <div class="og-option og-atmosphere-sunAngularRadius"></div> 
         <div class="og-option og-atmosphere-sunIntensity"></div> 
         <div class="og-option og-atmosphere-earthAlbedo"></div>
       
    </div>`;
const md = `<?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path fill="#000000" d="M135.688 18.5c-6.798 74.842-23.842 85.39-107.907 59.656 84.85 52.022 73.57 64.954-6.843 96.938 87.743-10.27 103.29 4.89 70.75 87.594 17.805-27.56 32.5-44.498 46.282-54.47-11.813 28.26-18.345 59.274-18.345 91.813 0 84.184 43.71 157.96 109.656 200.376-41.624-43.834-67.686-102.7-67.686-167.875 0-134.923 109.45-244.405 244.375-244.405 30.92 0 60.76 5.762 88 16.25-38.584-26.87-85.517-42.625-136.064-42.625-55.257 0-106.14 18.802-146.562 50.375 4.627-18.783 17.39-38.073 41.03-60.906C190.18 90.942 153.53 95.634 135.69 18.5zm10.03 77.188c5.67.002 11.428 1.247 16.876 3.874 14.506 6.998 22.72 21.81 22 36.938-10.26 10.87-19.507 22.696-27.594 35.344-9.035 2.753-19.075 2.27-28.25-2.156-19.37-9.343-27.5-32.6-18.156-51.97 6.715-13.92 20.638-22.036 35.125-22.03z"/></svg>`;
class vd extends ns {
  constructor(e4 = {}) {
    super(e4);
    this.$maxOpacity = null;
    this.$minOpacity = null;
    this.$rayleight = null;
    this.$mie = null;
    this.$height = null;
    this.$bottomRadius = null;
    this.$mieScatteringCoefficient = null;
    this.$mieExtinctionCoefficient = null;
    this.$rayleighScatteringCoefficientA = null;
    this.$rayleighScatteringCoefficientB = null;
    this.$rayleighScatteringCoefficientC = null;
    this.$ozoneAbsorptionCoefficientA = null;
    this.$ozoneAbsorptionCoefficientB = null;
    this.$ozoneAbsorptionCoefficientC = null;
    this.$sunAngularRadius = null;
    this.$sunIntensity = null;
    this.$groundAlbedo = null;
    this.$ozoneDensityHeight = null;
    this.$ozoneDensityWide = null;
    this._toggleBtn = new _s({ classList: ["og-map-button", "og-atmosphere_button"], icon: md });
    this._dialog = new ds({ title: "Atmosphere Parameters", visible: false, useHide: true, top: 60, left: 60, width: 720 });
    this._dialog.events.on("visibility", (e5) => {
      this._toggleBtn.setActive(e5);
    });
    this._panel = new ts({ template: pd });
    this._maxOpacity = new Yl({ label: "Max.opacity", max: 5 });
    this._minOpacity = new Yl({ label: "Min.opacity", max: 5 });
    this._rayleight = new Yl({ label: "Rayleight Scale", min: -10, max: 10 });
    this._mie = new Yl({ label: "Mie Scale", min: -10, max: 10 });
    this._height = new Yl({ label: "Height", max: 1e6 });
    this._bottomRadius = new Yl({ label: "Planet Radius", max: 5 * 6356752314245179e-9 });
    this._mieScatteringCoefficient = new Yl({ label: "Mie Scattering Coefficient e-6", min: -10 * 3.996, max: 10 * 3.996 });
    this._mieExtinctionCoefficient = new Yl({ label: "Mie Extinction Coef.e-6", min: -10 * 4.44, max: 10 * 4.44 });
    this._rayleighScatteringCoefficientA = new Yl({ label: "Rayleight Scattering Coef A.e-6", min: -10 * 5.802, max: 10 * 5.802 });
    this._rayleighScatteringCoefficientB = new Yl({ label: "Rayleight Scattering Coef B.e-6", min: -10 * 13.558, max: 10 * 13.558 });
    this._rayleighScatteringCoefficientC = new Yl({ label: "Rayleight Scattering Coef C.e-6", min: -10 * 33.1, max: 10 * 33.1 });
    this._ozoneAbsorptionCoefficientA = new Yl({ label: "Ozone absorbtion Coef A.e-6", min: -10 * 0.65, max: 10 * 0.65 });
    this._ozoneAbsorptionCoefficientB = new Yl({ label: "Ozone absorbtion Coef B.e-6", min: -10 * 0.65, max: 10 * 1.881 });
    this._ozoneAbsorptionCoefficientC = new Yl({ label: "Ozone absorbtion Coef C.e-6", min: -10 * 0.085, max: 10 * 0.085 });
    this._ozoneDensityHeight = new Yl({ label: "Ozone Density Height", max: 100 * 25e3 });
    this._ozoneDensityWide = new Yl({ label: "Ozone Density Wide", max: 100 * 25e3 });
    this._sunAngularRadius = new Yl({ label: "Sun Angular Radius", max: 1e3 * 4685e-6 });
    this._sunIntensity = new Yl({ label: "Sun Intensity", max: 10 * 1 });
    this._groundAlbedo = new Yl({ label: "Earth Albedo", max: 10 * 0.05 });
    this._parameters = { ATMOS_HEIGHT: 0, RAYLEIGH_SCALE: 0, MIE_SCALE: 0, GROUND_ALBEDO: 0, BOTTOM_RADIUS: 0, rayleighScatteringCoefficient_0: 0, rayleighScatteringCoefficient_1: 0, rayleighScatteringCoefficient_2: 0, mieScatteringCoefficient: 0, mieExtinctionCoefficient: 0, ozoneAbsorptionCoefficient_0: 0, ozoneAbsorptionCoefficient_1: 0, ozoneAbsorptionCoefficient_2: 0, SUN_ANGULAR_RADIUS: 0, SUN_INTENSITY: 0, ozoneDensityHeight: 0, ozoneDensityWide: 0 };
  }
  oninit() {
    this._toggleBtn.appendTo(this.renderer.div);
    this._dialog.appendTo(this.renderer.div);
    this._panel.appendTo(this._dialog.container);
    if (this._panel.el) {
      this.$height = this._panel.el.querySelector(".og-option.og-atmosphere-height");
      this.$maxOpacity = this._panel.el.querySelector(".og-option.og-atmosphere-maxOpacity");
      this.$minOpacity = this._panel.el.querySelector(".og-option.og-atmosphere-minOpacity");
      this.$rayleight = this._panel.el.querySelector(".og-option.og-atmosphere-rayleight");
      this.$mie = this._panel.el.querySelector(".og-option.og-atmosphere-mie");
      this.$bottomRadius = this._panel.el.querySelector(".og-option.og-atmosphere-bottomRadius");
      this.$mieScatteringCoefficient = this._panel.el.querySelector(".og-option.og-atmosphere-mieScatteringCoefficient");
      this.$mieExtinctionCoefficient = this._panel.el.querySelector(".og-option.og-atmosphere-mieExtinctionCoefficient");
      this.$rayleighScatteringCoefficientA = this._panel.el.querySelector(".og-option.og-atmosphere-rayleighScatteringCoefficientA");
      this.$rayleighScatteringCoefficientB = this._panel.el.querySelector(".og-option.og-atmosphere-rayleighScatteringCoefficientB");
      this.$rayleighScatteringCoefficientC = this._panel.el.querySelector(".og-option.og-atmosphere-rayleighScatteringCoefficientC");
      this.$ozoneAbsorptionCoefficientA = this._panel.el.querySelector(".og-option.og-atmosphere-ozoneAbsorptionCoefficientA");
      this.$ozoneAbsorptionCoefficientB = this._panel.el.querySelector(".og-option.og-atmosphere-ozoneAbsorptionCoefficientB");
      this.$ozoneAbsorptionCoefficientC = this._panel.el.querySelector(".og-option.og-atmosphere-ozoneAbsorptionCoefficientC");
      this.$sunAngularRadius = this._panel.el.querySelector(".og-option.og-atmosphere-sunAngularRadius");
      this.$sunIntensity = this._panel.el.querySelector(".og-option.og-atmosphere-sunIntensity");
      this.$groundAlbedo = this._panel.el.querySelector(".og-option.og-atmosphere-earthAlbedo");
      this.$ozoneDensityHeight = this._panel.el.querySelector(".og-option.og-atmosphere-ozoneDensityHeight");
      this.$ozoneDensityWide = this._panel.el.querySelector(".og-option.og-atmosphere-ozoneDensityWide");
    }
    this._toggleBtn.events.on("change", (e4) => {
      this._dialog.setVisibility(e4);
    });
    this._maxOpacity.appendTo(this.$maxOpacity);
    this._minOpacity.appendTo(this.$minOpacity);
    this._height.appendTo(this.$height);
    this._rayleight.appendTo(this.$rayleight);
    this._mie.appendTo(this.$mie);
    this._bottomRadius.appendTo(this.$bottomRadius);
    this._mieScatteringCoefficient.appendTo(this.$mieScatteringCoefficient);
    this._mieExtinctionCoefficient.appendTo(this.$mieExtinctionCoefficient);
    this._rayleighScatteringCoefficientA.appendTo(this.$rayleighScatteringCoefficientA);
    this._rayleighScatteringCoefficientB.appendTo(this.$rayleighScatteringCoefficientB);
    this._rayleighScatteringCoefficientC.appendTo(this.$rayleighScatteringCoefficientC);
    this._ozoneAbsorptionCoefficientA.appendTo(this.$ozoneAbsorptionCoefficientA);
    this._ozoneAbsorptionCoefficientB.appendTo(this.$ozoneAbsorptionCoefficientB);
    this._ozoneAbsorptionCoefficientC.appendTo(this.$ozoneAbsorptionCoefficientC);
    this._sunAngularRadius.appendTo(this.$sunAngularRadius);
    this._sunIntensity.appendTo(this.$sunIntensity);
    this._groundAlbedo.appendTo(this.$groundAlbedo);
    this._ozoneDensityHeight.appendTo(this.$ozoneDensityHeight);
    this._ozoneDensityWide.appendTo(this.$ozoneDensityWide);
    if (this.planet) {
      this._parameters = this.planet.atmosphereControl.parameters;
      this._height.value = this._parameters.ATMOS_HEIGHT;
      this._rayleight.value = this._parameters.RAYLEIGH_SCALE;
      this._mie.value = this._parameters.MIE_SCALE;
      this._bottomRadius.value = this._parameters.BOTTOM_RADIUS;
      this._mieScatteringCoefficient.value = this._parameters.mieScatteringCoefficient;
      this._mieExtinctionCoefficient.value = this._parameters.mieExtinctionCoefficient;
      this._rayleighScatteringCoefficientA.value = this._parameters.rayleighScatteringCoefficient_0;
      this._rayleighScatteringCoefficientB.value = this._parameters.rayleighScatteringCoefficient_1;
      this._rayleighScatteringCoefficientC.value = this._parameters.rayleighScatteringCoefficient_2;
      this._ozoneAbsorptionCoefficientA.value = this._parameters.ozoneAbsorptionCoefficient_0;
      this._ozoneAbsorptionCoefficientB.value = this._parameters.ozoneAbsorptionCoefficient_1;
      this._ozoneAbsorptionCoefficientC.value = this._parameters.ozoneAbsorptionCoefficient_2;
      this._sunAngularRadius.value = this._parameters.SUN_ANGULAR_RADIUS;
      this._sunIntensity.value = this._parameters.SUN_INTENSITY;
      this._groundAlbedo.value = this._parameters.GROUND_ALBEDO;
      this._ozoneDensityHeight.value = this._parameters.ozoneDensityHeight;
      this._ozoneDensityWide.value = this._parameters.ozoneDensityWide;
    }
    this._minOpacity.value = this.planet.atmosphereMinOpacity;
    this._minOpacity.events.on("change", (e4) => {
      this.planet.atmosphereMinOpacity = e4;
    });
    this._maxOpacity.value = this.planet.atmosphereMaxOpacity;
    this._maxOpacity.events.on("change", (e4) => {
      this.planet.atmosphereMaxOpacity = e4;
    });
    this._rayleight.events.on("change", (e4) => {
      this._parameters.RAYLEIGH_SCALE = e4;
      this._update();
    });
    this._mie.events.on("change", (e4) => {
      this._parameters.MIE_SCALE = e4;
      this._update();
    });
    this._height.events.on("change", (e4) => {
      this._parameters.ATMOS_HEIGHT = e4;
      this._update();
    });
    this._bottomRadius.events.on("change", (e4) => {
      this._parameters.BOTTOM_RADIUS = e4;
      this._update();
    });
    this._mieScatteringCoefficient.events.on("change", (e4) => {
      this._parameters.mieScatteringCoefficient = e4;
      this._update();
    });
    this._mieExtinctionCoefficient.events.on("change", (e4) => {
      this._parameters.mieExtinctionCoefficient = e4;
      this._update();
    });
    this._rayleighScatteringCoefficientA.events.on("change", (e4) => {
      this._parameters.rayleighScatteringCoefficient_0 = e4;
      this._update();
    });
    this._rayleighScatteringCoefficientB.events.on("change", (e4) => {
      this._parameters.rayleighScatteringCoefficient_1 = e4;
      this._update();
    });
    this._rayleighScatteringCoefficientC.events.on("change", (e4) => {
      this._parameters.rayleighScatteringCoefficient_2 = e4;
      this._update();
    });
    this._ozoneAbsorptionCoefficientA.events.on("change", (e4) => {
      this._parameters.ozoneAbsorptionCoefficient_0 = e4;
      this._update();
    });
    this._ozoneAbsorptionCoefficientB.events.on("change", (e4) => {
      this._parameters.ozoneAbsorptionCoefficient_1 = e4;
      this._update();
    });
    this._ozoneAbsorptionCoefficientC.events.on("change", (e4) => {
      this._parameters.ozoneAbsorptionCoefficient_2 = e4;
      this._update();
    });
    this._sunAngularRadius.events.on("change", (e4) => {
      this._parameters.SUN_ANGULAR_RADIUS = e4;
      this._update();
    });
    this._sunIntensity.events.on("change", (e4) => {
      this._parameters.SUN_INTENSITY = e4;
      this._update();
    });
    this._groundAlbedo.events.on("change", (e4) => {
      this._parameters.GROUND_ALBEDO = e4;
      this._update();
    });
    this._ozoneDensityHeight.events.on("change", (e4) => {
      this._parameters.ozoneDensityHeight = e4;
      this._update();
    });
    this._ozoneDensityWide.events.on("change", (e4) => {
      this._parameters.ozoneDensityWide = e4;
      this._update();
    });
  }
  _update() {
    if (this.planet) {
      this.planet.atmosphereControl.setParameters(this._parameters);
    }
  }
}
const yd = "rgb(253,77,77)";
const xd = "rgb(248,115,115)";
const bd = "rgb(73,73,239)";
const wd = "rgb(90,90,253)";
const Cd = "rgb(26,122,26)";
const Td = "rgb(55,191,55)";
const Ed = "rgba(255,255,255,0.8)";
const Ad = "rgba(255,255,255,1.0)";
const Ld = 0.1;
const Pd = new Ke(Ld, Ld, Ld);
const Sd = 0.17;
const Rd = 0.04;
const Md = 95e-4;
const Bd = ur.createCylinder(Md, Md, 1 - Sd).scale(Pd);
const kd = ur.createCylinder(0, Rd, Sd, 16, 16, false, true, 0, -0.17).scale(Pd);
class Id extends zr {
  constructor(e4 = {}) {
    const t2 = 1;
    super({ independentPicking: true, yaw: e4.yaw || 0, pitch: e4.pitch || 0, roll: e4.roll || 0, forceGlobalPosition: true, geoObject: { color: e4.color || yd, scale: t2, tag: "line", object3d: Bd }, properties: e4.properties });
    this._size = e4.size != void 0 ? e4.size : 1;
    this.appendChild(new zr({ yaw: e4.yaw || 0, pitch: e4.pitch || 0, roll: e4.roll || 0, forceGlobalPosition: true, geoObject: { color: e4.color || yd, scale: t2, tag: "tip", object3d: kd }, properties: e4.properties }));
  }
  setSize(e4) {
    this._size = e4;
    const t2 = new Ke(1, (this._size - Sd) / (1 - Sd), 1);
    const i2 = new Ke(0, this._size * Ld, 0);
    let s2 = this;
    let r2 = s2.childEntities[0];
    s2.setScale3v(t2);
    r2.geoObject.setTranslate3v(i2);
  }
  setColorHTML(e4) {
    let t2 = this;
    let i2 = t2.childEntities[0];
    t2.geoObject.setColorHTML(e4);
    i2.geoObject.setColorHTML(e4);
  }
}
class zd extends zr {
  constructor(e4 = {}) {
    super(e4);
    this._size = e4.size != void 0 ? e4.size : 1;
    this.childEntities = [];
    this._init();
  }
  _init() {
    let e4 = new Id({ color: yd, yaw: 0, pitch: 0, roll: 90 * d, properties: { opName: "move_x", noEdit: true, style: { color: yd, selectColor: xd } } });
    let t2 = new Id({ color: bd, yaw: 0, pitch: 0, roll: 0, properties: { opName: "move_y", noEdit: true, style: { color: bd, selectColor: wd } } });
    let i2 = new Id({ color: Cd, yaw: 0, pitch: 90 * d, roll: 0, properties: { opName: "move_z", noEdit: true, style: { color: Cd, selectColor: Td } } });
    this.appendChild(e4);
    this.appendChild(t2);
    this.appendChild(i2);
    this.setSize(this._size);
  }
  setSize(e4) {
    this.childEntities[0].setSize(e4);
    this.childEntities[1].setSize(e4);
    this.childEntities[2].setSize(e4);
  }
  setPitch(e4) {
    let t2 = this.childEntities[0];
    let i2 = t2.childEntities[0];
    t2.setPitch(e4);
    i2.setPitch(e4);
    t2 = this.childEntities[1];
    i2 = t2.childEntities[0];
    t2.setPitch(e4);
    i2.setPitch(e4);
    t2 = this.childEntities[2];
    i2 = t2.childEntities[0];
    t2.setPitch(e4 + 90);
    i2.setPitch(e4 + 90);
  }
  setYaw(e4) {
    let t2 = this.childEntities[0];
    let i2 = t2.childEntities[0];
    t2.setYaw(e4);
    i2.setYaw(e4);
    t2 = this.childEntities[1];
    i2 = t2.childEntities[0];
    t2.setYaw(e4);
    i2.setYaw(e4);
    t2 = this.childEntities[2];
    i2 = t2.childEntities[0];
    t2.setYaw(e4);
    i2.setYaw(e4);
  }
  setRoll(e4) {
    let t2 = this.childEntities[0];
    let i2 = t2.childEntities[0];
    t2.setRoll(e4 + 90);
    i2.setRoll(e4 + 90);
    t2 = this.childEntities[1];
    i2 = t2.childEntities[0];
    t2.setRoll(e4);
    i2.setRoll(e4);
  }
  getY() {
    return this.childEntities[1].getAbsoluteRotation().mulVec3(Ke.UP).normalize();
  }
}
const Dd = ur.createPlane(1, 1, -0.5, 0, 0.5);
class Fd extends zr {
  constructor(e4 = {}) {
    super(e4);
    this._init();
  }
  _init() {
    let e4 = new zr({ independentPicking: true, scale: 0.025, forceGlobalPosition: true, geoObject: { color: Ed, tag: "plane", object3d: Dd }, properties: { opName: "move_xz", noEdit: true, style: { color: Ed, selectColor: Ad } } });
    this.appendChild(e4);
  }
}
const Nd = 360;
const Od = 0.95;
const Hd = new Array(Nd);
const Vd = new Array(Nd);
const Ud = new Array(Nd);
class Gd extends zr {
  constructor(e4 = {}) {
    super(e4);
    this._init();
  }
  _init() {
    const e4 = Nd;
    let t2 = new zr({ independentPicking: true, polyline: { path3v: [Array.from({ length: e4 }, (e5, t3) => new Ke())], thickness: 3.1, color: yd, isClosed: true }, properties: { opName: "rotate_pitch", noEdit: true, style: { color: yd, selectColor: xd } } });
    let i2 = new zr({ independentPicking: true, polyline: { path3v: [Array.from({ length: e4 }, (e5, t3) => new Ke())], thickness: 2.5, color: bd, isClosed: true }, properties: { opName: "rotate_yaw", noEdit: true, style: { color: bd, selectColor: wd } } });
    let s2 = new zr({ independentPicking: true, polyline: { path3v: [Array.from({ length: e4 }, (e5, t3) => new Ke())], thickness: 2.5, color: Cd, isClosed: true }, properties: { opName: "rotate_roll", noEdit: true, style: { color: Cd, selectColor: Td } } });
    this.appendChild(t2);
    this.appendChild(i2);
    this.appendChild(s2);
  }
  setCartesian3v(e4, t2 = 0) {
    super.setCartesian3v(e4);
    if (this._entityCollection && this._entityCollection.renderNode) {
      let i2 = this._entityCollection.renderNode;
      let s2 = i2.renderer.activeCamera;
      let r2 = i2.getFrameRotation(e4).conjugate();
      let n2 = s2.eye.distance(e4) * 0.15;
      let o2 = Ze.xRotation(0);
      let a2 = Ze.yRotation(t2);
      let l2 = Ze.zRotation(0);
      let h2 = l2.mul(o2).mul(a2).mul(i2.getFrameRotation(e4)).conjugate();
      for (let t3 = 0, i3 = 0, s3 = 360 / Nd; t3 < Nd; t3 += s3, i3++) {
        let s4 = t3 * d, o3 = Math.cos(s4), a3 = Math.sin(s4);
        let l3 = h2.mulVec3(new Ke(0, a3, o3)).normalize().scale(n2).add(e4);
        let c3 = r2.mulVec3(new Ke(o3, 0, a3)).normalize().scale(n2).add(e4);
        let u3 = h2.mulVec3(new Ke(o3, a3, 0)).normalize().scale(n2).add(e4);
        Hd[i3] = l3;
        Vd[i3] = c3;
        Ud[i3] = u3;
      }
      this.childEntities[0].polyline.setPath3v([Hd], void 0, true);
      this.childEntities[1].polyline.setPath3v([Vd], void 0, true);
      this.childEntities[2].polyline.setPath3v([Ud], void 0, true);
      let c2 = h2.mulVec3(new Ke(1, 0, 0)).normalize();
      let u2 = r2.mulVec3(new Ke(0, 1, 0)).normalize();
      let _2 = h2.mulVec3(new Ke(0, 0, 1)).normalize();
      this.childEntities[0].polyline.setVisibleSphere(e4, Math.abs(c2.dot(s2.getForward())) > Od ? 0 : n2);
      this.childEntities[1].polyline.setVisibleSphere(e4, Math.abs(u2.dot(s2.getForward())) > Od ? 0 : n2);
      this.childEntities[2].polyline.setVisibleSphere(e4, Math.abs(_2.dot(s2.getForward())) > Od ? 0 : n2);
    }
  }
}
const Wd = 20;
class jd extends zr {
  constructor(e4 = {}) {
    super({ ...e4, forceGlobalPosition: true });
    this._init();
  }
  _init() {
    const e4 = Wd;
    let t2 = [], i2 = [], s2 = [];
    let r2 = ut(xd), n2 = ut(wd), o2 = ut(Td);
    for (let a3 = 0; a3 < e4; a3++) {
      let e5 = 1;
      if (a3 < 5) {
        let t3 = a3 / 5;
        e5 = 0.5 * (1 - Math.cos(Math.PI * t3));
      } else if (a3 > 15) {
        let t3 = (a3 - 15) / 5;
        e5 = 1 - 0.5 * (1 - Math.cos(Math.PI * t3));
      }
      i2.push([o2[0], o2[1], o2[2], e5]);
      t2.push([r2[0], r2[1], r2[2], e5]);
      s2.push([n2[0], n2[1], n2[2], e5]);
    }
    let a2 = new zr({ polyline: { path3v: [Array.from({ length: e4 }, (e5, t3) => new Ke())], thickness: 2.5, pathColors: [t2], isClosed: false } });
    let l2 = new zr({ polyline: { path3v: [Array.from({ length: e4 }, (e5, t3) => new Ke())], thickness: 2.5, pathColors: [s2], isClosed: false } });
    let h2 = new zr({ polyline: { path3v: [Array.from({ length: e4 }, (e5, t3) => new Ke())], thickness: 2.5, pathColors: [i2], isClosed: false } });
    this.appendChild(a2);
    this.appendChild(l2);
    this.appendChild(h2);
  }
  setCartesian3v(e4) {
    super.setCartesian3v(e4);
    if (this._entityCollection && this._entityCollection.renderNode) {
      let t2 = this._entityCollection.renderNode;
      let i2 = t2.renderer.activeCamera;
      let s2 = i2.eye.distance(e4) * 0.05;
      if (t2.planet) {
        let i3 = [], r2 = [], n2 = [];
        let o2 = t2.planet.ellipsoid.getSurfaceNormal3v(e4);
        let a2 = this._lonLat;
        let l2 = Wd / 2;
        for (let t3 = -10; t3 < l2; t3++) {
          n2.push(new be(a2.lon, a2.lat + t3, a2.height));
          r2.push(new be(a2.lon + t3, a2.lat, a2.height));
          i3.push(e4.add(o2.scaleTo(t3 * s2)));
        }
        this.childEntities[0].polyline.setPathLonLatFast([r2]);
        this.childEntities[1].polyline.setPath3vFast([i3]);
        this.childEntities[2].polyline.setPathLonLatFast([n2]);
      } else {
        let t3 = [], i3 = [], r2 = [];
        let n2 = Ke.UNIT_Y, o2 = Ke.UNIT_X, a2 = Ke.UNIT_Z;
        let l2 = Wd / 2;
        for (let h2 = -10; h2 < l2; h2++) {
          i3.push(e4.add(o2.scaleTo(h2 * s2)));
          r2.push(e4.add(n2.scaleTo(h2 * s2)));
          t3.push(e4.add(a2.scaleTo(h2 * s2)));
        }
        this.childEntities[0].polyline.setPath3vFast([i3]);
        this.childEntities[1].polyline.setPath3vFast([r2]);
        this.childEntities[2].polyline.setPath3vFast([t3]);
      }
    }
  }
}
function Yd(e4, t2, i2, s2, r2, n2) {
  let o2 = r2.add(Ke.UP), a2 = r2.add(e4);
  let l2 = new Ke();
  if (new ar(t2, i2).hitPlaneRes(or.fromPoints(r2, o2, a2), l2) === ar.INSIDE) {
    let i3 = Ke.proj_b_to_a(l2, e4);
    if (new ar(t2, s2).hitPlaneRes(or.fromPoints(r2, o2, a2), l2) === ar.INSIDE) {
      let t3 = Ke.proj_b_to_a(l2, e4);
      let s3 = t3.sub(i3);
      n2.copy(r2.add(s3));
    }
  }
}
class qd extends Fr {
  constructor(e4 = {}) {
    super(e4.name || "GeoObjectEditorScene");
    this._onAxisLayerMouseEnter = (e5) => {
      this.renderer.handler.canvas.style.cursor = "pointer";
      e5.pickingObject.setColorHTML(e5.pickingObject.properties.style.selectColor);
    };
    this._onAxisLayerMouseLeave = (e5) => {
      this.renderer.handler.canvas.style.cursor = "default";
      e5.pickingObject.setColorHTML(e5.pickingObject.properties.style.color);
    };
    this._onAxisLayerLUp = (e5) => {
      this._selectedMove = null;
      this._navActivate();
      this._setAxisTrackVisibility(false);
    };
    this._onAxisLayerLDown = (e5) => {
      this._clickPos = e5.pos.clone();
      if (this._selectedEntity) {
        this._selectedEntityCart = this._selectedEntity.getAbsoluteCartesian();
        this._setAxisTrackVisibility(true);
      }
      this._selectedMove = e5.pickingObject.properties.opName;
      this._navDeactivate();
    };
    this._onPlaneLayerMouseEnter = (e5) => {
      this.renderer.handler.canvas.style.cursor = "pointer";
      e5.pickingObject.geoObject.setColorHTML(e5.pickingObject.properties.style.selectColor);
    };
    this._onPlaneLayerMouseLeave = (e5) => {
      this.renderer.handler.canvas.style.cursor = "default";
      e5.pickingObject.geoObject.setColorHTML(e5.pickingObject.properties.style.color);
    };
    this._onPlaneLayerLUp = (e5) => {
      this._selectedMove = null;
      this._navActivate();
      this._setAxisTrackVisibility(false);
    };
    this._onPlaneLayerLDown = (e5) => {
      this._clickPos = e5.pos.clone();
      if (this._selectedEntity) {
        this._selectedEntityCart = this._selectedEntity.getAbsoluteCartesian();
        this._setAxisTrackVisibility(true);
      }
      this._selectedMove = e5.pickingObject.properties.opName;
      this._navDeactivate();
    };
    this._onRotateLayerMouseEnter = (e5) => {
      this.renderer.handler.canvas.style.cursor = "pointer";
      e5.pickingObject.polyline.setColorHTML(e5.pickingObject.properties.style.selectColor);
    };
    this._onRotateLayerMouseLeave = (e5) => {
      this.renderer.handler.canvas.style.cursor = "default";
      e5.pickingObject.polyline.setColorHTML(e5.pickingObject.properties.style.color);
    };
    this._onRotateLayerLUp = (e5) => {
      this._selectedMove = null;
      this._navActivate();
    };
    this._onRotateLayerLDown = (e5) => {
      this._clickPos = e5.pos.clone();
      if (this._selectedEntity) {
        this._selectedEntityCart = this._selectedEntity.getAbsoluteCartesian();
        if (this._selectedEntity) {
          this._selectedEntityPitch = this._selectedEntity.getAbsolutePitch();
          this._selectedEntityYaw = this._selectedEntity.getAbsoluteYaw();
          this._selectedEntityRoll = this._selectedEntity.getAbsoluteRoll();
        }
      }
      this._selectedMove = e5.pickingObject.properties.opName;
      this._navDeactivate();
    };
    this._onMouseMove = (e5) => {
      if (this._selectedEntity && this._selectedMove && this._ops[this._selectedMove]) {
        this._ops[this._selectedMove](e5);
      }
    };
    this._onLclick = (e5) => {
      if (e5.pickingObject && e5.pickingObject instanceof zr) {
        this.select(e5.pickingObject);
      }
    };
    this._moveX = (e5) => {
      if (!this._selectedEntity) return;
      let t2 = this.renderer.activeCamera;
      let i2 = this._selectedEntityCart;
      let s2 = t2.unproject(this._clickPos.x, this._clickPos.y);
      let r2 = new Ke();
      if (this.planet) {
        let n2 = new ar(t2.eye, s2).hitSphere(new Zi(i2.length(), new Ke()));
        let o2 = new ar(t2.eye, e5.direction).hitSphere(new Zi(i2.length(), new Ke()));
        if (!o2) return;
        let a2 = Ze.getRotationBetweenVectors(n2.normal(), o2.normal());
        r2 = a2.mulVec3(i2);
        if (this._ellipsoid) {
          let e6 = this._ellipsoid.cartesianToLonLat(i2);
          let t3 = this._ellipsoid.cartesianToLonLat(r2);
          this._ellipsoid.lonLatToCartesianRes(new be(t3.lon, e6.lat, e6.height), r2);
        }
      } else {
        Yd(Ke.UNIT_X, t2.eye, s2, e5.direction, i2, r2);
      }
      this._selectedEntity.setAbsoluteCartesian3v(r2);
      this.events.dispatch(this.events.position, r2, this._selectedEntity);
      this.events.dispatch(this.events.change, this._selectedEntity);
    };
    this._moveY = (e5) => {
      if (!this._selectedEntity) return;
      let t2 = this.renderer.activeCamera;
      let i2 = this._selectedEntityCart;
      let s2 = Ke.UP;
      if (this.planet) {
        s2 = this._axisEntity.getY();
      }
      let r2 = i2.add(s2);
      let n2 = i2.add(t2.getRight());
      let o2 = new Ke();
      let a2 = t2.unproject(this._clickPos.x, this._clickPos.y);
      if (new ar(t2.eye, a2).hitPlaneRes(or.fromPoints(i2, r2, n2), o2) === ar.INSIDE) {
        let a3 = Ke.proj_b_to_a(o2, s2);
        if (new ar(t2.eye, e5.direction).hitPlaneRes(or.fromPoints(i2, r2, n2), o2) === ar.INSIDE) {
          let e6 = Ke.proj_b_to_a(o2, s2);
          let t3 = e6.sub(a3);
          let i3 = this._selectedEntityCart.add(t3);
          this._selectedEntity.setAbsoluteCartesian3v(i3);
          this.events.dispatch(this.events.position, o2, this._selectedEntity);
          this.events.dispatch(this.events.change, this._selectedEntity);
        }
      }
    };
    this._moveZ = (e5) => {
      if (!this._selectedEntity) return;
      let t2 = this.renderer.activeCamera;
      let i2 = this._selectedEntityCart;
      let s2 = t2.unproject(this._clickPos.x, this._clickPos.y);
      let r2 = new Ke();
      if (this.planet) {
        let n2 = new ar(t2.eye, s2).hitSphere(new Zi(i2.length(), new Ke()));
        let o2 = new ar(t2.eye, e5.direction).hitSphere(new Zi(i2.length(), new Ke()));
        if (!o2) return;
        let a2 = Ze.getRotationBetweenVectors(n2.normal(), o2.normal());
        r2 = a2.mulVec3(i2);
        if (this._ellipsoid) {
          let e6 = this._ellipsoid.cartesianToLonLat(i2);
          let t3 = this._ellipsoid.cartesianToLonLat(r2);
          this._ellipsoid.lonLatToCartesianRes(new be(e6.lon, t3.lat, e6.height), r2);
        }
      } else {
        Yd(Ke.UNIT_Z, t2.eye, s2, e5.direction, i2, r2);
      }
      this._selectedEntity.setAbsoluteCartesian3v(r2);
      this.events.dispatch(this.events.position, r2, this._selectedEntity);
      this.events.dispatch(this.events.change, this._selectedEntity);
    };
    this._moveXZ = (e5) => {
      if (!this._selectedEntity) return;
      let t2 = this.renderer.activeCamera;
      let i2 = this._selectedEntityCart;
      let s2 = t2.unproject(this._clickPos.x, this._clickPos.y);
      let r2 = new Ke();
      if (this.planet) {
        let n2 = new ar(t2.eye, s2).hitSphere(new Zi(i2.length(), new Ke()));
        let o2 = new ar(t2.eye, e5.direction).hitSphere(new Zi(i2.length(), new Ke()));
        if (!o2) return;
        let a2 = Ze.getRotationBetweenVectors(n2.normal(), o2.normal());
        r2 = a2.mulVec3(i2);
        if (this._ellipsoid) {
          let e6 = this._ellipsoid.cartesianToLonLat(r2);
          let t3 = this._selectedEntity.getLonLat().height;
          this._ellipsoid.lonLatToCartesianRes(new be(e6.lon, e6.lat, t3), r2);
        }
      } else {
        let n2 = i2.add(Ke.UNIT_X), o2 = i2.add(Ke.UNIT_Z);
        let a2 = new Ke(), l2 = new Ke();
        if (new ar(t2.eye, s2).hitPlaneRes(or.fromPoints(i2, n2, o2), a2) === ar.INSIDE) {
          if (new ar(t2.eye, e5.direction).hitPlaneRes(or.fromPoints(i2, n2, o2), l2) === ar.INSIDE) {
            let e6 = l2.sub(a2);
            r2 = i2.add(e6);
          }
        }
      }
      this._selectedEntity.setAbsoluteCartesian3v(r2);
      this.events.dispatch(this.events.position, r2, this._selectedEntity);
      this.events.dispatch(this.events.change, this._selectedEntity);
    };
    this._moveXY = (e5) => {
      console.log("moveXY");
    };
    this._moveZY = (e5) => {
      console.log("moveZY");
    };
    this._rotatePitch = (e5) => {
      if (!this._selectedEntity) return;
      let t2 = this.renderer.activeCamera;
      let i2 = this._selectedEntityCart;
      let s2 = Ze.xRotation(0);
      let r2 = Ze.yRotation(this._selectedEntity.getYaw());
      let n2 = Ze.zRotation(0);
      let o2 = n2.mul(s2).mul(r2).mul(this.getFrameRotation(i2)).conjugate();
      let a2 = o2.mulVec3(new Ke(1, 0, 0)).normalize();
      let l2 = t2.unproject(this._clickPos.x, this._clickPos.y);
      let h2 = new or(i2, a2);
      let c2 = new Ke(), d2 = new Ke();
      if (new ar(t2.eye, l2).hitPlaneRes(h2, c2) === ar.INSIDE) {
        if (new ar(t2.eye, e5.direction).hitPlaneRes(h2, d2) === ar.INSIDE) {
          let e6 = c2.sub(i2).normalize(), t3 = d2.sub(i2).normalize();
          let s3 = Math.sign(e6.cross(t3).dot(a2));
          let r3 = Math.acos(e6.dot(t3));
          let n3 = this._selectedEntityPitch + s3 * r3;
          this._selectedEntity.setAbsolutePitch(n3);
          this.events.dispatch(this.events.pitch, n3, this._selectedEntity);
          this.events.dispatch(this.events.change, this._selectedEntity);
        }
      }
    };
    this._rotateYaw = (e5) => {
      if (!this._selectedEntity) return;
      let t2 = this.renderer.activeCamera;
      let i2 = this._selectedEntityCart;
      let s2 = this.getFrameRotation(i2).conjugate();
      let r2 = s2.mulVec3(new Ke(0, 1, 0)).normalize();
      let n2 = t2.unproject(this._clickPos.x, this._clickPos.y);
      let o2 = new or(i2, r2);
      let a2 = new Ke(), l2 = new Ke();
      if (new ar(t2.eye, n2).hitPlaneRes(o2, a2) === ar.INSIDE) {
        if (new ar(t2.eye, e5.direction).hitPlaneRes(o2, l2) === ar.INSIDE) {
          let e6 = a2.sub(i2).normalize(), t3 = l2.sub(i2).normalize();
          let s3 = Math.sign(t3.cross(e6).dot(r2));
          let n3 = Math.acos(e6.dot(t3));
          let o3 = this._selectedEntityYaw + s3 * n3;
          this._selectedEntity.setAbsoluteYaw(o3);
          this.events.dispatch(this.events.yaw, o3, this._selectedEntity);
          this.events.dispatch(this.events.change, this._selectedEntity);
        }
      }
    };
    this._rotateRoll = (e5) => {
      if (!this._selectedEntity) return;
      let t2 = this.renderer.activeCamera;
      let i2 = this._selectedEntityCart;
      this.getFrameRotation(i2).conjugate();
      let s2 = Ze.xRotation(0);
      let r2 = Ze.yRotation(this._selectedEntity.getYaw());
      let n2 = Ze.zRotation(0);
      let o2 = n2.mul(s2).mul(r2).mul(this.getFrameRotation(i2)).conjugate();
      let a2 = o2.mulVec3(new Ke(0, 0, 1)).normalize();
      let l2 = t2.unproject(this._clickPos.x, this._clickPos.y);
      let h2 = new or(i2, a2);
      let c2 = new Ke(), d2 = new Ke();
      if (new ar(t2.eye, l2).hitPlaneRes(h2, c2) === ar.INSIDE) {
        if (new ar(t2.eye, e5.direction).hitPlaneRes(h2, d2) === ar.INSIDE) {
          let e6 = c2.sub(i2).normalize(), t3 = d2.sub(i2).normalize();
          let s3 = Math.sign(e6.cross(t3).dot(a2));
          let r3 = Math.acos(e6.dot(t3));
          let n3 = this._selectedEntityRoll + s3 * r3;
          this._selectedEntity.setAbsoluteRoll(n3);
          this.events.dispatch(this.events.roll, n3, this._selectedEntity);
          this.events.dispatch(this.events.change, this._selectedEntity);
        }
      }
    };
    this._scale = (e5) => {
      let t2 = 1;
      this.events.dispatch(this.events.scale, t2, this._selectedEntity);
      this.events.dispatch(this.events.change, this._selectedEntity);
    };
    this._scaleX = (e5) => {
    };
    this._scaleY = (e5) => {
    };
    this._scaleZ = (e5) => {
    };
    this.events = Qi($d);
    this._planet = e4.planet || null;
    this._startPos = null;
    this._startClick = new Qe();
    this._axisEntity = new zd();
    this._planeEntity = new Fd();
    this._rotateEntity = new Gd();
    this._axisTrackEntity = new jd();
    this._moveLayer = new ko({ scaleByDistance: [0.1, l, 0.1], useLighting: false, pickingScale: [5, 1.1, 5], visibility: false, depthOrder: 1e3 });
    this._planeLayer = new ko({ scaleByDistance: [0.1, l, 0.1], useLighting: false, visibility: false, depthOrder: 1e3 });
    this._rotateLayer = new ko({ useLighting: false, visibility: false, depthOrder: 1e3, pickingScale: 5 });
    this._selectedEntity = null;
    this._clickPos = new Qe();
    this._selectedEntityCart = new Ke();
    this._selectedEntityPitch = 0;
    this._selectedEntityYaw = 0;
    this._selectedEntityRoll = 0;
    this._selectedMove = null;
    this._axisTrackVisibility = false;
    this._axisTrackLayer = new ko({ useLighting: false, visibility: false, pickingScale: 5, pickingEnabled: false, opacity: 0.6 });
    this._ops = { move_x: this._moveX, move_y: this._moveY, move_z: this._moveZ, move_xz: this._moveXZ, move_xy: this._moveXY, move_zy: this._moveZY, rotate_pitch: this._rotatePitch, rotate_yaw: this._rotateYaw, rotate_roll: this._rotateRoll, scale: this._scale, scale_x: this._scaleX, scale_y: this._scaleY, scale_z: this._scaleZ };
  }
  get ellipsoid() {
    if (this._planet) {
      return this._planet.ellipsoid;
    }
  }
  get planet() {
    return this._planet;
  }
  bindPlanet(e4) {
    this._planet = e4;
  }
  init() {
    this.activate();
  }
  onremove() {
    this.deactivate();
  }
  _addAxisLayers() {
    this._moveLayer.addTo(this);
    this._planeLayer.addTo(this);
    this._rotateLayer.addTo(this);
    this._axisTrackLayer.addTo(this);
    this._moveLayer.add(this._axisEntity);
    this._moveLayer.events.on("mouseenter", this._onAxisLayerMouseEnter);
    this._moveLayer.events.on("mouseleave", this._onAxisLayerMouseLeave);
    this._moveLayer.events.on("lup", this._onAxisLayerLUp);
    this._moveLayer.events.on("ldown", this._onAxisLayerLDown);
    this._planeLayer.add(this._planeEntity);
    this._planeLayer.events.on("mouseenter", this._onPlaneLayerMouseEnter);
    this._planeLayer.events.on("mouseleave", this._onPlaneLayerMouseLeave);
    this._planeLayer.events.on("lup", this._onPlaneLayerLUp);
    this._planeLayer.events.on("ldown", this._onPlaneLayerLDown);
    this._rotateLayer.add(this._rotateEntity);
    this._rotateLayer.events.on("mouseenter", this._onRotateLayerMouseEnter);
    this._rotateLayer.events.on("mouseleave", this._onRotateLayerMouseLeave);
    this._rotateLayer.events.on("lup", this._onRotateLayerLUp);
    this._rotateLayer.events.on("ldown", this._onRotateLayerLDown);
    this._axisTrackLayer.add(this._axisTrackEntity);
  }
  _navActivate() {
    if (this.renderer) {
      if (this.renderer.controls.mouseNavigation) {
        this.renderer.controls.mouseNavigation.activate();
      }
      if (this.renderer.controls.SimpleNavigation) {
        this.renderer.controls.SimpleNavigation.activate();
      }
    }
  }
  _navDeactivate() {
    if (this.renderer) {
      if (this.renderer.controls.mouseNavigation) {
        this.renderer.controls.mouseNavigation.deactivate();
      }
      if (this.renderer.controls.SimpleNavigation) {
        this.renderer.controls.SimpleNavigation.deactivate();
      }
    }
  }
  _removeAxisLayers() {
    this._moveLayer.remove();
    this._planeLayer.remove();
    this._rotateLayer.remove();
  }
  activate() {
    this.renderer.events.on("lclick", this._onLclick);
    this.renderer.events.on("mousemove", this._onMouseMove);
    this._addAxisLayers();
  }
  deactivate() {
    this.renderer.events.off("lclick", this._onLclick);
    this.renderer.events.off("mousemove", this._onMouseMove);
    this._removeAxisLayers();
    this.clear();
  }
  _setAxisTrackVisibility(e4) {
    if (e4 !== this._axisTrackVisibility) {
      this._axisTrackVisibility = e4;
      this._axisTrackLayer.setVisibility(e4);
    }
  }
  setVisibility(e4) {
    this._moveLayer.setVisibility(e4);
    this._planeLayer.setVisibility(e4);
    this._rotateLayer.setVisibility(e4);
    this.unlockView();
  }
  readyToEdit(e4) {
    return !e4.properties || !e4.properties.noEdit;
  }
  select(e4) {
    if ((!this._selectedEntity || this._selectedEntity && !e4.isEqual(this._selectedEntity)) && this.readyToEdit(e4)) {
      if (this._selectedEntity) {
        this.unselect();
      }
      this._selectedEntity = e4;
      this.renderer && this.renderer.setRelativeCenter();
      this.setVisibility(true);
      this.events.dispatch(this.events.select, this._selectedEntity);
    }
  }
  unselect() {
    this.setVisibility(false);
    let e4 = this._selectedEntity;
    this._selectedEntity = null;
    this.events.dispatch(this.events.unselect, e4);
  }
  clear() {
    this.removeEntityCollection(this._moveLayer);
    this.removeEntityCollection(this._planeLayer);
    this.removeEntityCollection(this._rotateLayer);
  }
  frame() {
    if (this._selectedEntity) {
      let e4 = this._selectedEntity.getAbsoluteCartesian();
      this._axisEntity.setCartesian3v(e4);
      this._planeEntity.setCartesian3v(e4);
      this._rotateEntity.setCartesian3v(e4, this._selectedEntity.getAbsoluteYaw());
      this._axisTrackEntity.setCartesian3v(e4);
    }
  }
  get _ellipsoid() {
    return this._planet ? this._planet.ellipsoid : null;
  }
  getFrameRotation(e4) {
    return this._planet ? this._planet.getFrameRotation(e4) : super.getFrameRotation(e4);
  }
  getSelectedEntity() {
    return this._selectedEntity;
  }
  lockView() {
    if (this.renderer && this._selectedEntity) {
      let e4 = this.renderer.controls.CameraLock;
      e4.lockView(this._selectedEntity);
    }
  }
  unlockView() {
    if (this.renderer && this._selectedEntity) {
      let e4 = this.renderer.controls.CameraLock;
      if (e4) {
        e4.unlockView();
      }
    }
  }
}
const $d = ["mousemove", "mouseenter", "mouseleave", "lclick", "rclick", "mclick", "ldblclick", "rdblclick", "mdblclick", "lup", "rup", "mup", "ldown", "rdown", "mdown", "lhold", "rhold", "mhold", "mousewheel", "touchmove", "touchstart", "touchend", "doubletouch", "touchleave", "touchenter", "select", "unselect", "change", "position", "pitch", "yaw", "roll", "scale"];
const Xd = ["change"];
const Zd = `<div class="og-input">
      <div class="og-input-label">{label}</div>
      <input type="{type}"/>
    </div>`;
class Kd extends ts {
  constructor(e4 = {}) {
    super({ template: ft(Zd, { label: e4.label || "", type: e4.type || "text" }) });
    this._onResize = () => {
    };
    this._onMouseWheel = (e5) => {
      e5 = e5 || window.event;
      e5.preventDefault();
      e5.stopPropagation();
    };
    this._onMouseWheelFF = (e5) => {
      this._onMouseWheel(e5);
    };
    this._onInput = (e5) => {
      e5 = e5 || window.event;
      e5.preventDefault();
      e5.stopPropagation();
      this._setValue(e5.target.value);
    };
    this.events = this.events.registerNames(Xd);
    this._value = e4.value || "";
    this._maxFixed = e4.maxFixed != void 0 ? e4.maxFixed : -1;
    this.$label = null;
    this.$input = null;
  }
  render(e4) {
    super.render(e4);
    this.$label = this.select(".og-input-label");
    if (this.$label.innerHTML === "") {
      this.$label.style.display = "none";
    }
    this.$input = this.select("input");
    this._initEvents();
    return this;
  }
  set value(e4) {
    if (e4 !== this._value) {
      if (typeof e4 === "number") {
        this._value = ii(e4, this._maxFixed);
      } else {
        this._value = e4;
      }
      if (this.$input) {
        this.$input.value = this._value;
      }
      this.events.dispatch(this.events.change, this._value, this);
    }
  }
  _setValue(e4) {
    if (e4 !== this._value) {
      if (typeof e4 === "number") {
        this._value = ii(e4, this._maxFixed);
      } else {
        this._value = e4;
      }
      this.events.dispatch(this.events.change, this._value, this);
    }
  }
  get value() {
    return this._value;
  }
  _initEvents() {
    this.el.addEventListener("mousewheel", this._onMouseWheel);
    this.el.addEventListener("wheel", this._onMouseWheelFF);
    this.$input.addEventListener("input", this._onInput);
  }
  _clearEvents() {
    this.el.removeEventListener("mousewheel", this._onMouseWheel);
    this.el.removeEventListener("wheel", this._onMouseWheelFF);
    this.$input.removeEventListener("input", this._onInput);
  }
  remove() {
    this._clearEvents();
    super.remove();
  }
  set visibility(e4) {
    if (this.el) {
      if (e4) {
        this.el.style.display = "";
      } else {
        this.el.style.display = "none";
      }
    }
  }
}
const Qd = ["change"];
const Jd = `<div class="og-checkbox">
      <div class="og-input-label">{label}</div>
      <div class="og-checkbox-input">
        <input type="checkbox" {checked}/>
      </div>
    </div>`;
class eu extends ts {
  constructor(e4 = {}) {
    super({ template: ft(Jd, { label: e4.label || "", checked: e4.checked ? "checked" : "" }) });
    this._onResize = () => {
    };
    this._onMouseWheel = (e5) => {
      e5 = e5 || window.event;
      e5.preventDefault();
      e5.stopPropagation();
    };
    this._onMouseWheelFF = (e5) => {
      this._onMouseWheel(e5);
    };
    this._onClick = (e5) => {
      e5 = e5 || window.event;
      e5.stopPropagation();
      this.checked = !this._checked;
    };
    this._checked = e4.checked || false;
    this._disabled = e4.disabled || false;
    this.events = this.events.registerNames(Qd);
    this.$label = null;
    this.$input = null;
  }
  set disabled(e4) {
    this._disabled = e4;
    this._updateDisabled();
  }
  _updateDisabled() {
    if (!this.el) return;
    if (this._disabled) {
      this.el.classList.add("og-input-disabled");
    } else {
      this.el.classList.remove("og-input-disabled");
    }
  }
  get disabled() {
    return this._disabled;
  }
  render(e4) {
    super.render(e4);
    this.$label = this.select(".og-input-label");
    if (this.$label.innerHTML === "") {
      this.$label.style.display = "none";
    }
    this.$input = this.select("input");
    this.$input.checked = this._checked;
    this._updateDisabled();
    this._initEvents();
    return this;
  }
  set checked(e4) {
    if (e4 !== this._checked) {
      this._checked = e4;
      if (this.$input) {
        this.$input.checked = this._checked;
      }
      this.events.dispatch(this.events.change, this._checked, this);
    }
  }
  get checked() {
    return this._checked;
  }
  _initEvents() {
    this.el.addEventListener("mousewheel", this._onMouseWheel);
    this.el.addEventListener("wheel", this._onMouseWheelFF);
    this.$input.addEventListener("click", this._onClick);
  }
  _clearEvents() {
    this.el.removeEventListener("mousewheel", this._onMouseWheel);
    this.el.removeEventListener("wheel", this._onMouseWheelFF);
    this.$input.removeEventListener("click", this._onClick);
  }
  remove() {
    this._clearEvents();
    super.remove();
  }
  set visibility(e4) {
    if (this.el) {
      if (e4) {
        this.el.style.display = "";
      } else {
        this.el.style.display = "none";
      }
    }
  }
}
const tu = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" id="filter-center-focus">
  <path d="M5 15H3v4c0 1.1.9 2 2 2h4v-2H5v-4zM5 5h4V3H5c-1.1 0-2 .9-2 2v4h2V5zm14-2h-4v2h4v4h2V5c0-1.1-.9-2-2-2zm0 16h-4v2h4c1.1 0 2-.9 2-2v-4h-2v4zM12 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
</svg>`;
class iu extends ds {
  constructor(e4) {
    super({ title: "GeoObject Properties", visible: false, resizable: true, useHide: true, top: 25, right: 85, width: 252, height: 480, minHeight: 100, minWidth: 100, model: e4.model });
    this._onVisibility = (e5) => {
      this.model.setVisibility(e5);
    };
    this._onSelect = (e5) => {
      this.show();
      this._refresh(e5);
    };
    this._onUnselect = (e5) => {
      this.hide();
    };
    this._onChangeRelativePosition = (e5) => {
      let t2 = this.model.getSelectedEntity();
      if (t2) {
        t2.relativePosition = e5;
        this._refresh(t2);
      }
    };
    this._onPosition = (e5, t2) => {
      this._refresh(t2);
    };
    this._onPitch = (e5, t2) => {
      this._pitchView.stopPropagation();
      this._pitchView.value = t2.getPitch() * u;
      this._absolutePitchView.stopPropagation();
      this._absolutePitchView.value = t2.getAbsolutePitch() * u;
    };
    this._onYaw = (e5, t2) => {
      this._yawView.stopPropagation();
      this._yawView.value = t2.getYaw() * u;
      this._absoluteYawView.stopPropagation();
      this._absoluteYawView.value = t2.getAbsoluteYaw() * u;
    };
    this._onRoll = (e5, t2) => {
      this._rollView.stopPropagation();
      this._rollView.value = t2.getRoll() * u;
      this._absoluteRollView.stopPropagation();
      this._absoluteRollView.value = t2.getAbsoluteRoll() * u;
    };
    this._onChangeLon = (e5) => {
      let t2 = this.model.getSelectedEntity();
      if (t2) {
        let i2 = t2.getLonLat();
        t2.setLonLat2(parseFloat(e5), i2.lat, i2.height);
        this._refresh(t2);
      }
    };
    this._onChangeLat = (e5) => {
      let t2 = this.model.getSelectedEntity();
      if (t2) {
        let i2 = t2.getLonLat();
        t2.setLonLat2(i2.lon, parseFloat(e5), i2.height);
        this._refresh(t2);
      }
    };
    this._onChangeHeight = (e5) => {
      let t2 = this.model.getSelectedEntity();
      if (t2) {
        let i2 = t2.getLonLat();
        t2.setLonLat2(i2.lon, i2.lat, parseFloat(e5));
        this._refresh(t2);
      }
    };
    this._onChangeX = (e5) => {
      let t2 = this.model.getSelectedEntity();
      if (t2) {
        let i2 = t2.getCartesian();
        t2.setCartesian(parseFloat(e5), i2.y, i2.z);
        this._refresh(t2);
      }
    };
    this._onChangeY = (e5) => {
      let t2 = this.model.getSelectedEntity();
      if (t2) {
        let i2 = t2.getCartesian();
        t2.setCartesian(i2.x, parseFloat(e5), i2.z);
        this._refresh(t2);
      }
    };
    this._onChangeZ = (e5) => {
      let t2 = this.model.getSelectedEntity();
      if (t2) {
        let i2 = t2.getCartesian();
        t2.setCartesian(i2.x, i2.y, parseFloat(e5));
        this._refresh(t2);
      }
    };
    this._onChangeAbsoluteX = (e5) => {
      let t2 = this.model.getSelectedEntity();
      if (t2) {
        let i2 = t2.getAbsoluteCartesian();
        t2.setAbsoluteCartesian(parseFloat(e5), i2.y, i2.z);
        this._refresh(t2);
      }
    };
    this._onChangeAbsoluteY = (e5) => {
      let t2 = this.model.getSelectedEntity();
      if (t2) {
        let i2 = t2.getAbsoluteCartesian();
        t2.setAbsoluteCartesian(i2.x, parseFloat(e5), i2.z);
        this._refresh(t2);
      }
    };
    this._onChangeAbsoluteZ = (e5) => {
      let t2 = this.model.getSelectedEntity();
      if (t2) {
        let i2 = t2.getAbsoluteCartesian();
        t2.setAbsoluteCartesian(i2.x, i2.y, parseFloat(e5));
        this._refresh(t2);
      }
    };
    this._onChangePitch = (e5) => {
      let t2 = this.model.getSelectedEntity();
      if (t2) {
        t2.setPitch(parseFloat(e5) * d);
        this._refresh(t2);
      }
    };
    this._onChangeYaw = (e5) => {
      let t2 = this.model.getSelectedEntity();
      if (t2) {
        t2.setYaw(parseFloat(e5) * d);
        this._refresh(t2);
      }
    };
    this._onChangeRoll = (e5) => {
      let t2 = this.model.getSelectedEntity();
      if (t2) {
        t2.setRoll(parseFloat(e5) * d);
        this._refresh(t2);
      }
    };
    this._onChangeAbsolutePitch = (e5) => {
      let t2 = this.model.getSelectedEntity();
      if (t2) {
        t2.setAbsolutePitch(parseFloat(e5) * d);
        this._refresh(t2);
      }
    };
    this._onChangeAbsoluteYaw = (e5) => {
      let t2 = this.model.getSelectedEntity();
      if (t2) {
        t2.setAbsoluteYaw(parseFloat(e5) * d);
        this._refresh(t2);
      }
    };
    this._onChangeAbsoluteRoll = (e5) => {
      let t2 = this.model.getSelectedEntity();
      if (t2) {
        t2.setAbsoluteRoll(parseFloat(e5) * d);
        this._refresh(t2);
      }
    };
    this._onChangeScale = (e5) => {
      let t2 = this.model.getSelectedEntity();
      if (t2) {
        let i2 = parseFloat(e5);
        t2.setScale(i2);
        this._scaleXView.stopPropagation();
        this._scaleYView.stopPropagation();
        this._scaleZView.stopPropagation();
        this._scaleXView.value = i2;
        this._scaleYView.value = i2;
        this._scaleZView.value = i2;
      }
    };
    this._onChangeScaleX = (e5) => {
      let t2 = this.model.getSelectedEntity();
      if (t2) {
        let i2 = t2.getScale();
        t2.setScale3v(new Ke(parseFloat(e5), i2.y, i2.z));
      }
    };
    this._onChangeScaleY = (e5) => {
      let t2 = this.model.getSelectedEntity();
      if (t2) {
        let i2 = t2.getScale();
        t2.setScale3v(new Ke(i2.x, parseFloat(e5), i2.z));
      }
    };
    this._onChangeScaleZ = (e5) => {
      let t2 = this.model.getSelectedEntity();
      if (t2) {
        let i2 = t2.getScale();
        t2.setScale3v(new Ke(i2.x, i2.y, parseFloat(e5)));
      }
    };
    this._onGround = () => {
      let e5 = this.model.getSelectedEntity();
      if (e5 && this.model.planet) {
        if (this.model.planet.terrain) {
          this.model.planet.terrain.getHeightAsync(e5.getLonLat(), (e6) => {
            this._heightView.value = e6;
          });
        } else {
          this._heightView.value = 0;
        }
      }
    };
    this._relativePositionView = new eu({ label: "Relative position" });
    this._lonView = new Kd({ label: "Lon", type: "number", min: -180, max: 180, maxFixed: 10 });
    this._latView = new Kd({ label: "Lat", type: "number", min: -90, max: 90, maxFixed: 10 });
    this._heightView = new Kd({ label: "Height", type: "number", maxFixed: 4 });
    this._xView = new Kd({ label: "X", type: "number", maxFixed: 10 });
    this._yView = new Kd({ label: "Y", type: "number" });
    this._zView = new Kd({ label: "Z", type: "number" });
    this._absXView = new Kd({ label: "Absolute X", type: "number", maxFixed: 10 });
    this._absYView = new Kd({ label: "Absolute Y", type: "number" });
    this._absZView = new Kd({ label: "Absolute Z", type: "number" });
    this._pitchView = new Kd({ label: "Pitch", type: "number", maxFixed: 2 });
    this._yawView = new Kd({ label: "Yaw", type: "number", maxFixed: 2 });
    this._rollView = new Kd({ label: "Roll", type: "number", maxFixed: 2 });
    this._absolutePitchView = new Kd({ label: "Absolute pitch", type: "number", maxFixed: 2 });
    this._absoluteYawView = new Kd({ label: "Absolute yaw", type: "number", maxFixed: 2 });
    this._absoluteRollView = new Kd({ label: "Absolute roll", type: "number", maxFixed: 2 });
    this._scaleView = new Kd({ label: "Scale", type: "number", maxFixed: 2 });
    this._scaleXView = new Kd({ label: "Scale X", type: "number", maxFixed: 2 });
    this._scaleYView = new Kd({ label: "Scale Y", type: "number", maxFixed: 2 });
    this._scaleZView = new Kd({ label: "Scale Z", type: "number", maxFixed: 2 });
    this._groundBtn = new rs({ text: "Ground", title: "Put on the ground", name: "ground", classList: ["og-editor-ground_button"] });
  }
  render(e4) {
    var _a2;
    super.render(e4);
    this._initSceneEvents();
    let t2 = document.createElement("div");
    t2.classList.add("og-editor_toolbar");
    (_a2 = this.container) == null ? void 0 : _a2.appendChild(t2);
    let i2 = new _s({ classList: ["og-editor_toolbar-button"], icon: tu, title: "Lock/Unlock camera view" });
    i2.appendTo(t2);
    i2.events.on("change", (e5) => {
      if (e5) {
        this.model.lockView();
      } else {
        this.model.unlockView();
      }
    });
    this.events.on("visibility", (e5) => {
      if (!e5) {
        i2.events.stopPropagation();
        i2.setActive(false);
      }
    });
    this.events.on("visibility", this._onVisibility);
    this._relativePositionView.appendTo(this.container);
    if (this.model.planet) {
      this._lonView.appendTo(this.container);
      this._latView.appendTo(this.container);
      this._heightView.appendTo(this.container);
    }
    this._xView.appendTo(this.container);
    this._yView.appendTo(this.container);
    this._zView.appendTo(this.container);
    this._absXView.appendTo(this.container);
    this._absYView.appendTo(this.container);
    this._absZView.appendTo(this.container);
    this._pitchView.appendTo(this.container);
    this._yawView.appendTo(this.container);
    this._rollView.appendTo(this.container);
    this._absolutePitchView.appendTo(this.container);
    this._absoluteYawView.appendTo(this.container);
    this._absoluteRollView.appendTo(this.container);
    this._scaleView.appendTo(this.container);
    this._scaleXView.appendTo(this.container);
    this._scaleYView.appendTo(this.container);
    this._scaleZView.appendTo(this.container);
    if (this.model.planet) {
      this._groundBtn.appendTo(this.container);
    }
    this._relativePositionView.events.on("change", this._onChangeRelativePosition);
    this._lonView.events.on("change", this._onChangeLon);
    this._latView.events.on("change", this._onChangeLat);
    this._heightView.events.on("change", this._onChangeHeight);
    this._xView.events.on("change", this._onChangeX);
    this._yView.events.on("change", this._onChangeY);
    this._zView.events.on("change", this._onChangeZ);
    this._absXView.events.on("change", this._onChangeAbsoluteX);
    this._absYView.events.on("change", this._onChangeAbsoluteY);
    this._absZView.events.on("change", this._onChangeAbsoluteZ);
    this._pitchView.events.on("change", this._onChangePitch);
    this._yawView.events.on("change", this._onChangeYaw);
    this._rollView.events.on("change", this._onChangeRoll);
    this._absolutePitchView.events.on("change", this._onChangeAbsolutePitch);
    this._absoluteYawView.events.on("change", this._onChangeAbsoluteYaw);
    this._absoluteRollView.events.on("change", this._onChangeAbsoluteRoll);
    this._scaleView.events.on("change", this._onChangeScale);
    this._scaleXView.events.on("change", this._onChangeScaleX);
    this._scaleYView.events.on("change", this._onChangeScaleY);
    this._scaleZView.events.on("change", this._onChangeScaleZ);
    this._groundBtn.appendTo(this.container);
    this._groundBtn.events.on("click", this._onGround);
    return this;
  }
  remove() {
    super.remove();
    this._clearSceneEvents();
  }
  _initSceneEvents() {
    this.model.events.on("select", this._onSelect);
    this.model.events.on("unselect", this._onUnselect);
    this.model.events.on("position", this._onPosition);
    this.model.events.on("pitch", this._onPitch);
    this.model.events.on("yaw", this._onYaw);
    this.model.events.on("roll", this._onRoll);
  }
  _clearSceneEvents() {
    this.model.events.off("select", this._onSelect);
    this.model.events.off("unselect", this._onUnselect);
    this.model.events.off("position", this._onPosition);
    this.model.events.off("pitch", this._onPitch);
    this.model.events.off("yaw", this._onYaw);
    this.model.events.off("roll", this._onRoll);
  }
  _refresh(e4) {
    if (!e4.parent) {
      this._relativePositionView.disabled = true;
    } else {
      this._relativePositionView.disabled = false;
    }
    this._relativePositionView.checked = e4.relativePosition;
    let t2 = e4.getLonLat();
    this._lonView.stopPropagation();
    this._latView.stopPropagation();
    this._heightView.stopPropagation();
    this._lonView.value = t2.lon;
    this._latView.value = t2.lat;
    this._heightView.value = t2.height;
    let i2 = e4.getCartesian();
    this._xView.stopPropagation();
    this._yView.stopPropagation();
    this._zView.stopPropagation();
    this._xView.value = i2.x;
    this._yView.value = i2.y;
    this._zView.value = i2.z;
    i2 = e4.getAbsoluteCartesian();
    this._absXView.stopPropagation();
    this._absYView.stopPropagation();
    this._absZView.stopPropagation();
    this._absXView.value = i2.x;
    this._absYView.value = i2.y;
    this._absZView.value = i2.z;
    this._pitchView.stopPropagation();
    this._yawView.stopPropagation();
    this._rollView.stopPropagation();
    this._pitchView.value = e4.getPitch() * u;
    this._yawView.value = e4.getYaw() * u;
    this._rollView.value = e4.getRoll() * u;
    this._absolutePitchView.stopPropagation();
    this._absoluteYawView.stopPropagation();
    this._absoluteRollView.stopPropagation();
    this._absolutePitchView.value = e4.getAbsolutePitch() * u;
    this._absoluteYawView.value = e4.getAbsoluteYaw() * u;
    this._absoluteRollView.value = e4.getAbsoluteRoll() * u;
    this._scaleView.stopPropagation();
    let s2 = e4.getScale();
    if (s2.x === s2.y && s2.y === s2.z) {
      this._scaleView.value = s2.x;
    } else {
      this._scaleView.value = 1;
    }
    this._scaleXView.stopPropagation();
    this._scaleYView.stopPropagation();
    this._scaleZView.stopPropagation();
    this._scaleXView.value = s2.x;
    this._scaleYView.value = s2.y;
    this._scaleZView.value = s2.z;
  }
  hide() {
    super.hide();
    this.model.events.stopPropagation();
    this.model.unselect();
  }
}
const su = 1e-3;
const ru = 120;
const nu = ["lockview", "unlockview"];
class ou extends ns {
  constructor(e4 = {}) {
    super(e4);
    this._onLockViewDraw = () => {
      if (this.renderer && this._lockEntity) {
        if (this._isFromTheBack) ;
        else {
          this.renderer.activeCamera.viewDistance(this._lockEntity.getAbsoluteCartesian(), this._lockDistance);
        }
      }
    };
    this._onMouseWheel = (e5) => {
      if (this.renderer && this._lockEntity) {
        if (this._isFromTheBack) ;
        else {
          let t2 = this.renderer.activeCamera.eye.distance(this._lockEntity.getAbsoluteCartesian());
          this._lockDistance -= 0.33 * t2 * Math.sign(e5.wheelDelta);
          if (this._lockDistance < su) {
            this._lockDistance = su;
          }
          this.renderer.activeCamera.viewDistance(this._lockEntity.getAbsoluteCartesian(), this._lockDistance);
        }
      }
    };
    this._onMouseMove = (e5) => {
      if (this._lockEntity && this.renderer) {
        if (e5.rightButtonDown || this.renderer.events.isKeyPressed(zl.KEY_ALT)) {
          let t2 = this._lockEntity.getAbsoluteCartesian(), i2 = this.renderer.activeCamera, s2 = 0.5 / d;
          if (s2 > 7e-3) s2 = 7e-3;
          if (this.planet) {
            i2.rotateHorizontal(s2 * (e5.x - e5.prev_x), false, t2, t2.isZero() ? Ke.UP : t2.normal());
          } else {
            i2.rotateHorizontal(s2 * (e5.x - e5.prev_x), false, t2, Ke.UP);
          }
          i2.rotateVertical(s2 * (e5.y - e5.prev_y), t2);
          this._viewDir = t2.sub(i2.eye).normalize();
        }
      }
    };
    this.events = Qi(nu);
    this._name = "CameraLock";
    this.planet = e4.planet || null;
    this._lockDistance = 0;
    this._isFromTheBack = false;
    this._lockEntity = null;
    this._viewDir = new Ke(0, 0, 0);
  }
  onactivate() {
    if (this.renderer) ;
  }
  ondeactivate() {
    if (this.renderer) {
      this.unlockView();
    }
  }
  oninit() {
    this.activate();
    if (this.renderer) ;
  }
  flyCartesian(e4, t2 = ru) {
    if (e4.isZero() || !this.renderer) {
      return;
    }
    this.unlockView();
    if (this.planet) {
      let i2 = this.planet.camera;
      if (this.isVisibleDistance(e4)) {
        i2.flyDistance(e4, t2);
      }
      if (i2.eye.distance(e4) < 1e6) {
        i2.flyDistance(e4, t2);
      } else {
        i2.viewDistance(e4, t2);
      }
    } else {
      this.renderer.activeCamera.viewDistance(e4, t2);
    }
  }
  lockView(e4, t2 = false) {
    if (!this.renderer) return;
    this._lockDistance = this._getDistance(e4, this._lockEntity);
    this._isFromTheBack = t2;
    this._deactivateLockViewEvents();
    this._lockEntity = e4;
    let i2 = this.renderer.activeCamera;
    if (this.planet) {
      this.planet.camera.stopFlying();
    }
    i2.viewDistance(e4.getAbsoluteCartesian(), this._lockDistance);
    this._deactivateNav();
    this._activateLockViewEvents();
    this._viewDir = e4.getAbsoluteCartesian().sub(i2.eye).normalize();
    this.events.dispatch(this.events.lockview, this._lockEntity, t2);
  }
  _activateNav() {
    if (this.renderer && this.renderer.controls.mouseNavigation) {
      this.renderer.controls.mouseNavigation.activate();
    }
    if (this.renderer && this.renderer.controls.simpleNavigation) {
      this.renderer.controls.simpleNavigation.activate();
    }
  }
  _deactivateNav() {
    if (this.renderer && this.renderer.controls.mouseNavigation) {
      this.renderer.controls.mouseNavigation.deactivate();
      this.renderer.controls.mouseNavigation.stop();
    }
    if (this.renderer && this.renderer.controls.simpleNavigation) {
      this.renderer.controls.simpleNavigation.deactivate();
    }
  }
  unlockView() {
    if (this._lockEntity) {
      this._deactivateLockViewEvents();
      this._activateNav();
      this.events.dispatch(this.events.unlockview, this._lockEntity);
      this._lockEntity = null;
    }
  }
  _getCenterDist() {
    if (this.renderer) {
      return this.renderer.getDistanceFromPixel(this.renderer.handler.getCenter()) || 0;
    }
    return 0;
  }
  _getDistance(e4, t2) {
    if (this.renderer) {
      let i2 = e4.getAbsoluteCartesian();
      let s2 = this.renderer.activeCamera;
      let r2 = s2.eye.distance(i2);
      if (t2) {
        r2 = s2.eye.distance(t2.getAbsoluteCartesian());
      }
      if (this.isVisibleDistance(i2)) {
        return r2;
      }
      if (s2.eye.distance(i2) < 1e6) {
        return this._getCenterDist();
      } else {
        return ru;
      }
    }
    return 0;
  }
  isVisibleDistance(e4, t2 = 0) {
    if (this.planet) {
      let i2 = this.planet.ellipsoid.equatorialSize;
      let s2 = this.planet.camera.eye;
      let r2 = s2.distance(e4);
      return r2 < Math.sqrt(s2.length2() - i2 * i2) + t2;
    }
    return true;
  }
  get lockEntity() {
    return this._lockEntity;
  }
  flyLonLat(e4, t2 = ru) {
    if (this.planet) {
      let i2 = this.planet.ellipsoid.lonLatToCartesian(e4);
      this.flyCartesian(i2, t2);
    }
  }
  _activateLockViewEvents() {
    if (this.renderer) {
      this.renderer.events.on("mousewheel", this._onMouseWheel);
      this.renderer.events.on("mousemove", this._onMouseMove);
      this.renderer.events.on("draw", this._onLockViewDraw);
    }
  }
  _deactivateLockViewEvents() {
    if (this.renderer) {
      this.renderer.events.off("mousewheel", this._onMouseWheel);
      this.renderer.events.off("mousemove", this._onMouseMove);
      if (this._lockEntity) {
        this.renderer.events.off("draw", this._onLockViewDraw);
      }
    }
  }
}
class au extends ns {
  constructor(e4 = {}) {
    super(e4);
    this._geoObjectEditopScene = new qd({ name: `geoObjectEditorScene:${this.__id}` });
    this._dialog = new iu({ model: this._geoObjectEditopScene });
  }
  oninit() {
    if (this.renderer) {
      this.renderer.addControl(new ou({ planet: this.planet }));
      this._geoObjectEditopScene.bindPlanet(this.planet);
      this._dialog.appendTo(this.renderer.div || document.body);
      this.activate();
    }
  }
  onactivate() {
    this.renderer && this.renderer.addNode(this._geoObjectEditopScene);
  }
  ondeactivate() {
    this.renderer && this.renderer.removeNode(this._geoObjectEditopScene);
    this._dialog.hide();
  }
}
const lu = ["click"];
const hu = `<button class="og-object3d-collection__item">
        <div class="og-object3d-collection__item_name">{name}</div>
    </button>`;
class cu extends ts {
  constructor(e4) {
    super({ template: ft(hu, { name: e4.model.name }), ...e4 });
    this.events = Qi(lu);
  }
  render(e4) {
    var _a2;
    super.render(e4);
    (_a2 = this.el) == null ? void 0 : _a2.addEventListener("click", (e5) => {
      this.events.dispatch(this.events.click, this.model, this, e5);
    });
    return this;
  }
}
const du = ["select"];
const uu = `<div class="og-object3d-collection"></div>`;
class _u extends ts {
  constructor(e4) {
    super({ template: uu, model: e4.model, ...e4 });
    this._onAdd = (e5) => {
      this._addItem(e5);
    };
    this.events = Qi(du);
    this._activeView = null;
  }
  _addItem(e4) {
    let t2 = new cu({ model: e4 });
    t2.appendTo(this.el);
    t2.events.on("click", (e5) => {
      var _a2, _b;
      if (this._activeView) {
        (_a2 = this._activeView.el) == null ? void 0 : _a2.classList.remove("active");
      }
      this._activeView = t2;
      (_b = this._activeView.el) == null ? void 0 : _b.classList.add("active");
      this.events.dispatch(this.events.select, e5, t2);
    });
  }
  render(e4) {
    super.render(e4);
    let t2 = this.model.getItems();
    for (let e5 of t2) {
      this._addItem(e5);
    }
    this._initEvents();
    return this;
  }
  _initEvents() {
    this.model.events.on("add", this._onAdd);
  }
}
const fu = ["select"];
const gu = `<svg class="svg-icon" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M426.666667 170.666667H170.666667c-47.146667 0-84.906667 38.186667-84.906667 85.333333L85.333333 768c0 47.146667 38.186667 85.333333 85.333334 85.333333h682.666666c47.146667 0 85.333333-38.186667 85.333334-85.333333V341.333333c0-47.146667-38.186667-85.333333-85.333334-85.333333H512l-85.333333-85.333333z"  /></svg>`;
class pu extends ds {
  constructor(e4) {
    super({ classList: ["og-object3d-manager"], title: "Object3D Collection", visible: false, resizable: true, useHide: true, top: 25, right: 85, width: 252, height: 480, minHeight: 100, minWidth: 100 });
    this._onLoadClick = () => {
      let e5 = new ts({ initRender: true, template: `<input type="file" accept=".obj,.mtl" multiple />` });
      if (e5.el) {
        e5.el.addEventListener("change", (e6) => {
          const t2 = e6.target;
          if (t2.files) {
            const e7 = Array.from(t2.files);
            const i2 = e7.find((e8) => e8.name.toLowerCase().endsWith(".obj"));
            const s2 = e7.find((e8) => e8.name.toLowerCase().endsWith(".mtl"));
            if (i2) {
              mu(i2, s2).then(this._addObject);
            }
          }
        });
        e5.el.click();
      }
    };
    this._addObject = (e5) => {
      this._object3dCollectionView.model.addItem(e5);
    };
    this.events = Qi(fu);
    this._object3dCollectionView = new _u({ model: e4.model });
  }
  render(e4) {
    var _a2;
    super.render(e4);
    let t2 = document.createElement("div");
    t2.classList.add("og-editor_toolbar");
    (_a2 = this.container) == null ? void 0 : _a2.appendChild(t2);
    let i2 = new rs({ classList: ["og-editor_toolbar-button"], icon: gu, title: "Load 3D object" });
    i2.appendTo(t2);
    i2.events.on("click", this._onLoadClick);
    this._object3dCollectionView.appendTo(this.container);
    this._object3dCollectionView.events.on("select", (e5) => {
      this.events.dispatch(this.events.select, e5);
    });
    return this;
  }
}
async function mu(e4, t2) {
  return await ur.readFileObj(e4, t2).then((i2) => ({ name: e4.name, objects: t2 ? i2 : [ur.merge(i2)] }));
}
const vu = ["add", "remove"];
class yu {
  constructor(e4 = {}) {
    this.events = Qi(vu, this);
    this._items = yu.createItemsMap(e4.collection || []);
  }
  static createItemsMap(e4) {
    let t2 = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < e4.length; i2++) {
      t2.set(e4[i2].name, e4[i2]);
    }
    return t2;
  }
  getItem(e4) {
    return this._items.get(e4);
  }
  addItem(e4, t2 = false) {
    if (!this._items.has(e4.name) || t2) {
      this._items.set(e4.name, e4);
      this.events.dispatch(this.events.add, e4);
    }
  }
  getItems() {
    return Array.from(this._items, ([e4, t2]) => t2);
  }
}
class xu extends ns {
  constructor(e4 = {}) {
    super(e4);
    this._onSelect = (e5) => {
      this._currentItem = e5;
    };
    this._onClick = (e5) => {
      if (!this.planet) return;
      if (!this._layer) return;
      if (!this._currentItem) return;
      let t2 = this.planet.getLonLatFromPixelTerrain(e5.pos);
      if (t2) {
        this.renderer.setRelativeCenter(this.planet.camera.eye);
        if (this.renderer.events.isKeyPressed(zl.KEY_CTRL)) {
          let e6 = this._createEntity(this._currentItem, t2);
          this._layer.add(e6);
        }
      }
    };
    this._layer = e4.layer || null;
    this._currentItem = null;
    this._collection = new yu({ collection: e4.collection });
    this._dialog = new pu({ model: this._collection });
  }
  oninit() {
    if (this.renderer) {
      this._dialog.appendTo(this.renderer.div || document.body);
      this._dialog.events.on("select", this._onSelect);
      this.activate();
    }
  }
  onactivate() {
    this._dialog.show();
    this._initEvents();
  }
  ondeactivate() {
    this._dialog.hide();
    this._clearEvents();
  }
  bindLayer(e4) {
    this._layer = e4;
  }
  _initEvents() {
    if (this.planet && this.planet.renderer) {
      this.planet.renderer.events.on("lclick", this._onClick);
    }
  }
  _clearEvents() {
    if (this.planet && this.planet.renderer) {
      this.planet.renderer.events.off("lclick", this._onClick);
    }
  }
  _createEntity(e4, t2) {
    let i2 = e4.name;
    let s2 = e4.scale;
    let r2 = new zr({ lonlat: t2, pitch: 0, yaw: 0, roll: 0, scale: s2 });
    for (let t3 = 0; t3 < e4.objects.length; t3++) {
      let s3 = e4.objects[t3];
      let n2 = new zr({ forceGlobalPosition: true, forceGlobalRotation: true, forceGlobalScale: true, geoObject: { tag: `${i2}:${t3.toString()}`, object3d: s3 } });
      r2.appendChild(n2);
    }
    return r2;
  }
}
class bu {
  constructor(e4) {
    this.camera = e4.camera;
    this.frameBuffer = e4.frameBuffer;
    this.handler = e4.handler || null;
    this._composer = null;
    this._composerIndex = -1;
    this.frameBuffer.init();
  }
  addTo(e4) {
    if (!this._composer) {
      this._composer = e4;
      this._composerIndex = e4.handlers.length;
      this._composer._handlers.push(this);
    }
  }
  remove() {
    if (this._composer) {
      this._composer._handlers.splice(this._composerIndex, 1);
      this._composer = null;
      this._composerIndex = -1;
    }
  }
  frame() {
    if (this.handler) {
      this.handler(this.camera, this.frameBuffer, this.frameBuffer.handler.gl);
    }
  }
}
class wu extends ns {
  constructor(e4) {
    super({ name: "CameraFrameComposer", autoActivate: true, ...e4 });
    this._onPostdraw = () => {
      for (let e5 = 0; e5 < this._handlers.length; e5++) {
        this._handlers[e5].frame();
      }
    };
    this._handlers = e4.handlers || [];
  }
  get handlers() {
    return [...this._handlers];
  }
  add(e4) {
    e4.addTo(this);
  }
  oninit() {
    super.oninit();
  }
  activate() {
    var _a2;
    super.activate();
    (_a2 = this.renderer) == null ? void 0 : _a2.events.on("postdraw", this._onPostdraw);
  }
  deactivate() {
    var _a2;
    super.deactivate();
    (_a2 = this.renderer) == null ? void 0 : _a2.events.off("postdraw", this._onPostdraw);
  }
}
const Cu = Object.freeze(Object.defineProperty({ __proto__: null, AtmosphereConfig: vd, CameraFrameComposer: wu, CameraFrameHandler: bu, CameraLock: ou, CompassButton: as, Control: ns, DebugInfo: Hs, DrawingControl: Ya, DrawingSwitcher: Za, EarthCoordinates: Rl, ElevationProfileControl: gd, GeoImageDragControl: Il, GeoObjectEditor: au, HeightRuler: Th, KeyboardNavigation: Dl, LayerAnimation: Nl, LayerSwitcher: Gl, Lighting: rh, MouseNavigation: ch, Object3dManager: xu, OldMouseNavigation: ah, Ruler: vh, RulerSwitcher: Ah, ScaleControl: Sh, Selection: Zh, ShowFps: Rh, SimpleNavigation: Mh, SimpleSkyBackground: Bh, Sun: Nh, TimelineControl: xc, ToggleWireframe: Oh, TouchNavigation: Vh, ZoomControl: Wh }, Symbol.toStringTag, { value: "Module" }));
class Tu extends Fr {
  constructor(e4 = 100) {
    super("Axes");
    this.size = e4;
    this.axesBuffer = null;
    this.axesColorBuffer = null;
  }
  init() {
    this.createAxesBuffer(this.size);
    this.drawMode = this.renderer.handler.gl.LINES;
    this.renderer.handler.addProgram(new Yr("axesShader", { uniforms: { projectionViewMatrix: "mat4" }, attributes: { aVertexPosition: "vec3", aVertexColor: "vec4" }, vertexShader: `attribute vec3 aVertexPosition;
            attribute vec4 aVertexColor;
            uniform mat4 projectionViewMatrix;
            varying vec4 vColor;
            void main(void) {
                gl_Position = projectionViewMatrix * vec4(aVertexPosition, 1.0);
                vColor = aVertexColor;
            }`, fragmentShader: `precision highp float;
            varying vec4 vColor;
            void main(void) {
                gl_FragColor = vColor;
            }` }));
  }
  frame() {
    this.renderer.handler.programs.axesShader.activate().set({ projectionViewMatrix: this.renderer.activeCamera.getProjectionViewMatrix(), aVertexPosition: this.axesBuffer, aVertexColor: this.axesColorBuffer });
    this.renderer.handler.programs.axesShader.drawArrays(this.drawMode, this.axesBuffer.numItems);
  }
  createAxesBuffer(e4) {
    const t2 = [0, 0, 0, e4 - 1, 0, 0, 0, 0, 0, 0, e4 - 1, 0, 0, 0, 0, 0, 0, e4 - 1];
    const i2 = [1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1];
    this.axesBuffer = this.renderer.handler.createArrayBuffer(new Float32Array(t2), 3, 6);
    this.axesColorBuffer = this.renderer.handler.createArrayBuffer(new Float32Array(i2), 4, 6);
  }
}
function Eu(e4) {
  return new Uint32Array(e4);
}
function Au(e4) {
  return new Uint32Array(e4);
}
function Lu(e4) {
  let t2 = [];
  let i2 = 1, s2 = 1;
  let r2 = 1, n2 = 1;
  let o2 = 0, a2 = 0, l2 = 0;
  for (let h2 = i2; h2 < e4 - 1 - r2; h2++) {
    for (let i3 = s2; i3 < e4 - n2; i3++) {
      o2 = h2 * e4 + i3;
      l2 = (h2 + 1) * e4;
      a2 = l2 + i3;
      t2.push(o2, a2);
    }
    t2.push(a2, l2 + s2);
  }
  t2.push(t2[t2.length - 1], e4 * e4 - e4);
  return Eu(t2);
}
function Pu(e4, t2) {
  let i2 = [];
  const s2 = (e4 - 1) / t2;
  const r2 = e4 * e4 - e4;
  let n2 = 0;
  for (let t3 = 0; t3 < e4 - 2; t3++) {
    if (t3 % s2 === 0) {
      n2 = t3;
    }
    let o2 = r2 - e4 * t3 - e4 + 1, a2 = r2 - e4 * n2;
    i2.push(a2, o2);
  }
  if (t2 === e4 - 1) {
    i2.push(e4);
    i2.push(0);
  }
  return Eu(i2);
}
function Su(e4, t2) {
  let i2 = [];
  const s2 = (e4 - 1) / t2;
  let r2 = 0;
  for (let t3 = 0; t3 < e4 - 2; t3++) {
    if (t3 % s2 === 0) {
      r2 = t3;
    }
    let n2 = e4 + t3 + 1, o2 = r2;
    i2.push(o2, n2);
  }
  if (t2 === e4 - 1) {
    i2.push(e4 - 2);
    i2.push(e4 - 1);
  }
  return Eu(i2);
}
function Ru(e4, t2) {
  let i2 = [];
  const s2 = (e4 - 1) / t2;
  let r2 = 0;
  for (let t3 = 0; t3 < e4 - 2; t3++) {
    if (t3 % s2 === 0) {
      r2 = t3;
    }
    let n2 = e4 * (t3 + 1) + e4 - 2, o2 = e4 + e4 * r2 - 1;
    i2.push(o2, n2);
  }
  if (t2 === e4 - 1) {
    i2.push(e4 * (e4 - 1) - 1);
    i2.push(e4 * e4 - 1);
  }
  return Eu(i2);
}
function Mu(e4, t2) {
  let i2 = [];
  const s2 = (e4 - 1) / t2;
  let r2 = 0;
  const n2 = e4 * (e4 - 1) - 2;
  const o2 = e4 * e4 - 1;
  for (let t3 = 0; t3 < e4 - 2; t3++) {
    if (t3 % s2 === 0) {
      r2 = t3;
    }
    let e5 = n2 - t3, a2 = o2 - r2;
    i2.push(a2, e5);
  }
  if (t2 === e4 - 1) {
    i2.push(e4 * e4 - e4 + 1);
  }
  i2.push(e4 * e4 - e4);
  return Eu(i2);
}
function Bu(e4) {
  let t2 = [[], [], [], []];
  for (let i2 = 0; i2 <= e4; i2++) {
    let s2 = Math.pow(2, i2), r2 = s2 + 1;
    t2[xs][i2] = [];
    t2[Cs][i2] = [];
    t2[ws][i2] = [];
    t2[bs][i2] = [];
    for (let s3 = 0; s3 <= e4; s3++) {
      let e5 = Math.pow(2, s3);
      t2[Cs][i2][s3] = Pu(r2, e5);
      t2[xs][i2][s3] = Su(r2, e5);
      t2[bs][i2][s3] = Ru(r2, e5);
      t2[ws][i2][s3] = Mu(r2, e5);
    }
  }
  return t2;
}
function ku(e4) {
  let t2 = [];
  for (let i2 = 0; i2 <= e4; i2++) {
    const e5 = Math.pow(2, i2);
    t2[i2] = Lu(e5 + 1);
  }
  return t2;
}
function Iu(e4) {
  let t2 = new Uint16Array((e4 + 1) * (e4 + 1) * 2);
  let i2 = 0;
  for (let s2 = 0; s2 <= e4; s2++) {
    for (let r2 = 0; r2 <= e4; r2++) {
      t2[i2++] = r2 / e4 * 65535;
      t2[i2++] = s2 / e4 * 65535;
    }
  }
  return t2;
}
class zu {
  constructor(e4 = 0) {
    this._maxGridSize = e4;
    this.centerIndexesTable = ku(this._maxGridSize);
    this.skirtsIndexesTable = Bu(this._maxGridSize);
  }
  get maxGridSize() {
    return this._maxGridSize;
  }
  init() {
    this.centerIndexesTable = ku(this._maxGridSize);
    this.skirtsIndexesTable = Bu(this._maxGridSize);
  }
  setMaxGridSize(e4) {
    this._maxGridSize = e4;
    this.init();
  }
  createSegmentIndexes(e4, t2) {
    if (e4) {
      let i2 = this.centerIndexesTable[e4], s2 = this.skirtsIndexesTable[Cs][e4][t2[Cs]], r2 = this.skirtsIndexesTable[xs][e4][t2[xs]], n2 = this.skirtsIndexesTable[bs][e4][t2[bs]], o2 = this.skirtsIndexesTable[ws][e4][t2[ws]];
      let a2 = Au(i2.length + s2.length + r2.length + n2.length + o2.length);
      a2.set(i2, 0);
      a2.set(s2, i2.length);
      a2.set(r2, i2.length + s2.length);
      a2.set(n2, i2.length + s2.length + r2.length);
      a2.set(o2, i2.length + s2.length + r2.length + n2.length);
      return a2;
    } else {
      return Eu([0, 2, 1, 3]);
    }
  }
  initTextureCoordsTable(e4) {
    let t2 = [];
    for (let i2 = 0; i2 <= e4; i2++) {
      const e5 = Math.pow(2, i2);
      t2[i2] = Iu(e5);
    }
    return t2;
  }
}
let Du = new zu();
function Fu() {
  return Du;
}
var Nu = "precision highp float;\n\nattribute vec3 aVertexPositionHigh;\r\nattribute vec3 aVertexPositionLow;\r\nattribute vec2 aTextureCoord;\n\nuniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform vec3 eyePositionHigh;\r\nuniform vec3 eyePositionLow;\r\nuniform float height;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void) {\n\n    vTextureCoord = aTextureCoord;\r\n    vec3 nh = height * normalize(aVertexPositionHigh + aVertexPositionLow);\n\n    mat4 viewMatrixRTE = viewMatrix;\r\n    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);\r\n    mat4 m = projectionMatrix * viewMatrixRTE;\n\n    vec3 highDiff = aVertexPositionHigh - eyePositionHigh;\r\n    vec3 lowDiff = aVertexPositionLow - eyePositionLow + nh;\n\n    \n    gl_Position = m * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);\r\n}";
var Ou = "precision highp float;\n\n#ifdef WEBGL2\r\n    #define TEXTURE_FUNC texture\r\n#else\r\n    #define TEXTURE_FUNC texture2D\r\n#endif\n\n#define SLICE_SIZE 5\n\n#define blend(DEST, SAMPLER, OFFSET, OPACITY) \\\r\nsrc = TEXTURE_FUNC(SAMPLER, OFFSET.xy + vTextureCoord.xy * OFFSET.zw); \\\r\nDEST = DEST * (1.0 - src.a * OPACITY) + src * OPACITY;\n\n#define blendPicking(DEST, OFFSET, SAMPLER, MASK, COLOR, OPACITY) \\\r\ntc = OFFSET.xy + vTextureCoord.xy * OFFSET.zw; \\\r\nt = TEXTURE_FUNC(SAMPLER, tc); \\\r\np = TEXTURE_FUNC(MASK, tc); \\\r\nDEST = mix(DEST, vec4(max(COLOR.rgb, p.rgb), OPACITY), (t.a == 0.0 ? 0.0: 1.0) * COLOR.a);\n\nconst vec3 nightStep = 10.0 * vec3(0.58, 0.48, 0.25);\n\nuniform vec4 tileOffsetArr[SLICE_SIZE];\r\nuniform float layerOpacityArr[SLICE_SIZE];\r\nuniform sampler2D defaultTexture;\r\nuniform sampler2D samplerArr[SLICE_SIZE];\r\nuniform int samplerCount;\r\nvarying vec2 vTextureCoord;\n\nvoid main(void) {\r\n    gl_FragColor = texture2D(defaultTexture, vTextureCoord);\r\n    if (samplerCount == 0) return;\n\n    vec4 src;\n\n    blend(gl_FragColor, samplerArr[0], tileOffsetArr[0], layerOpacityArr[0]);\r\n    if (samplerCount == 1) return;\n\n    blend(gl_FragColor, samplerArr[1], tileOffsetArr[1], layerOpacityArr[1]);\r\n    if (samplerCount == 2) return;\n\n    blend(gl_FragColor, samplerArr[2], tileOffsetArr[2], layerOpacityArr[2]);\r\n    if (samplerCount == 3) return;\n\n    blend(gl_FragColor, samplerArr[3], tileOffsetArr[3], layerOpacityArr[3]);\r\n    if (samplerCount == 4) return;\n\n    blend(gl_FragColor, samplerArr[4], tileOffsetArr[4], layerOpacityArr[4]);\r\n}";
var Hu = "attribute vec3 aVertexPositionHigh;\r\nattribute vec3 aVertexPositionLow;\r\nattribute vec2 aTextureCoord;\n\nuniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform vec4 uGlobalTextureCoord;\r\nuniform vec3 uNormalMapBias;\r\nuniform vec3 eyePositionHigh;\r\nuniform vec3 eyePositionLow;\r\nuniform float height;\n\nvarying vec4 vTextureCoord;\r\nvarying vec3 v_vertex;\r\nvarying vec3 cameraPosition;\r\nvarying vec2 vGlobalTextureCoord;\r\nvarying float v_height;\n\nvoid main(void) {\n\n    vec3 aVertexPosition = aVertexPositionHigh + aVertexPositionLow;\r\n    vec3 nh = height * normalize(aVertexPosition);\n\n    vTextureCoord.xy = aTextureCoord;\r\n    vGlobalTextureCoord = uGlobalTextureCoord.xy + (uGlobalTextureCoord.zw - uGlobalTextureCoord.xy) * aTextureCoord;\r\n    vTextureCoord.zw = uNormalMapBias.z * ( aTextureCoord + uNormalMapBias.xy );\n\n    cameraPosition = eyePositionHigh + eyePositionLow;\n\n    vec3 highDiff = aVertexPositionHigh - eyePositionHigh;\r\n    vec3 lowDiff = aVertexPositionLow - eyePositionLow + nh;\n\n    mat4 viewMatrixRTE = viewMatrix;\r\n    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n    v_height = height;\r\n    v_vertex = aVertexPosition + nh;\n\n    gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);\r\n}";
var Vu = "precision highp float;\n\nfloat getLerpValue(in float min, in float max, in float between)\r\n{\r\n    return (clamp(between, min, max) - min) / (max - min);\r\n}\n\nvec3 aces(vec3 color)\r\n{\r\n    float a = 2.51;\r\n    float b = 0.03;\r\n    float c = 2.43;\r\n    float d = 0.59;\r\n    float e = 0.14;\r\n    return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);\r\n}\n\nbool intersectSphere(vec3 rayOrigin, vec3 rayDirection, float radius, inout float t1, inout float t2)\r\n{\r\n    float b = dot(rayDirection, rayOrigin);\r\n    float c = dot(rayOrigin, rayOrigin) - radius * radius;\r\n    float d = b * b - c;\r\n    if (d < 0.0) {\r\n        return false;\r\n    }\r\n    t1 = -b - sqrt(d);\r\n    t2 = -b + sqrt(d);\r\n    return true;\r\n}\n\nbool intersectSphere(vec3 rayOrigin, vec3 rayDirection, float radius, inout float t)\r\n{\r\n    float b = dot(rayDirection, rayOrigin);\r\n    float c = dot(rayOrigin, rayOrigin) - radius * radius;\r\n    float d = b * b - c;\r\n    if (d < 0.0) {\r\n        return false;\r\n    }\r\n    t = -b - sqrt(d);\r\n    return true;\r\n}\n\nfloat intersectSphere(vec3 ro, vec3 rd, vec4 sph)\r\n{\r\n    vec3 oc = ro - sph.xyz;\r\n    float b = dot(oc, rd);\r\n    float c = dot(oc, oc) - sph.w * sph.w;\r\n    float h = b * b - c;\r\n    if (h < 0.0) return -1.0;\r\n    h = sqrt(h);\r\n    return -b - h;\r\n}\n\nbool intersectEllipsoid(in vec3 ro, in vec3 rd, in vec3 ra, inout float t)\r\n{\r\n    vec3 ocn = ro / ra;\r\n    vec3 rdn = rd / ra;\r\n    float a = dot(rdn, rdn);\r\n    float b = dot(ocn, rdn);\r\n    float c = dot(ocn, ocn);\r\n    float h = b * b - a * (c - 1.0);\n\n    if (h < 0.0)\r\n    {\r\n        return false;\r\n    }\n\n    t = (-b - sqrt(h)) / a;\n\n    return true;\r\n}\n\nbool intersectEllipsoid(in vec3 ro, in vec3 rd, in vec3 ra, inout float t1, inout float t2)\r\n{\r\n    vec3 ocn = ro / ra;\r\n    vec3 rdn = rd / ra;\r\n    float a = dot(rdn, rdn);\r\n    float b = dot(ocn, rdn);\r\n    float c = dot(ocn, ocn);\r\n    float h = b * b - a * (c - 1.0);\n\n    if (h < 0.0)\r\n    {\r\n        return false;\r\n    }\n\n    h = sqrt(h);\r\n    t1 = (-b - h) / a;\r\n    t2 = (-b + h) / a;\n\n    return true;\r\n}\n\nvec3 normalEllipsoid(in vec3 pos, in vec3 ra)\r\n{\r\n    return normalize(pos / (ra * ra));\r\n}\r\n#ifdef WEBGL2\r\n    #define TEXTURE_FUNC texture\r\n#else\r\n    #define TEXTURE_FUNC texture2D\r\n#endif\n\n#define SLICE_SIZE 5\n\n#define blend(DEST, SAMPLER, OFFSET, OPACITY) \\\r\nsrc = TEXTURE_FUNC(SAMPLER, OFFSET.xy + vTextureCoord.xy * OFFSET.zw); \\\r\nDEST = DEST * (1.0 - src.a * OPACITY) + src * OPACITY;\n\n#define blendPicking(DEST, OFFSET, SAMPLER, MASK, COLOR, OPACITY) \\\r\ntc = OFFSET.xy + vTextureCoord.xy * OFFSET.zw; \\\r\nt = TEXTURE_FUNC(SAMPLER, tc); \\\r\np = TEXTURE_FUNC(MASK, tc); \\\r\nDEST = mix(DEST, vec4(max(COLOR.rgb, p.rgb), OPACITY), (t.a == 0.0 ? 0.0: 1.0) * COLOR.a);\n\nconst vec3 nightStep = 10.0 * vec3(0.58, 0.48, 0.25);\n\nuniform vec4 specular;\r\nuniform vec3 diffuse;\r\nuniform vec3 ambient;\n\nuniform sampler2D uNormalMap;\r\nuniform sampler2D nightTexture;\r\nuniform sampler2D specularTexture;\r\nuniform sampler2D defaultTexture;\r\nuniform sampler2D samplerArr[SLICE_SIZE];\n\nuniform vec4 tileOffsetArr[SLICE_SIZE];\r\nuniform vec3 lightPosition;\r\nuniform float layerOpacityArr[SLICE_SIZE];\n\nuniform int samplerCount;\r\nuniform float nightTextureCoefficient;\r\nuniform float camHeight;\n\nvarying vec4 vTextureCoord;\r\nvarying vec3 v_vertex;\r\nvarying vec3 cameraPosition;\r\nvarying vec2 vGlobalTextureCoord;\r\nvarying float v_height;\n\nvec3 sunPos;\n\nvoid main(void) {\n\n    sunPos = lightPosition;\n\n    vec3 texNormal = texture2D(uNormalMap, vTextureCoord.zw).rgb;\r\n    vec3 normal = normalize((texNormal - 0.5) * 2.0);\n\n    float minH = 1200000.0;\r\n    float maxH = minH * 3.0;\r\n    float nightCoef = getLerpValue(minH, maxH, camHeight) * nightTextureCoefficient;\n\n    \n    \n    \n    \n\n    vec3 lightDir = normalize(sunPos);\r\n    vec3 viewDir = normalize(cameraPosition - v_vertex);\n\n    float overGround = 1.0 - step(0.1, v_height);\n\n    float shininess = texture2D(specularTexture, vGlobalTextureCoord.st).r * 255.0 * overGround;\r\n    vec3 reflectionDirection = reflect(-lightDir, normal);\r\n    float reflection = max(dot(reflectionDirection, viewDir), 0.0);\r\n    vec3 spec = specular.rgb * pow(reflection, specular.w) * shininess;\r\n    float diffuseLightWeighting = max(dot(normal, lightDir), 0.0);\r\n    vec4 nightImageColor = texture2D(nightTexture, vGlobalTextureCoord.st);\r\n    vec3 night = nightStep * (.18 - diffuseLightWeighting * 3.0) * nightImageColor.rgb * nightCoef;\r\n    night *= overGround * step(0.0, night);\r\n    vec4 lightWeighting = vec4(ambient + diffuse * diffuseLightWeighting + night, 1.0);\n\n    gl_FragColor = texture2D(defaultTexture, vTextureCoord.xy);\r\n    if (samplerCount == 0) {\r\n        gl_FragColor = gl_FragColor * lightWeighting + vec4(spec, 0.0);\r\n        return;\r\n    }\n\n    vec4 src;\n\n    blend(gl_FragColor, samplerArr[0], tileOffsetArr[0], layerOpacityArr[0]);\r\n    if (samplerCount == 1) {\r\n        gl_FragColor = gl_FragColor * lightWeighting + vec4(spec, 0.0);\r\n        return;\r\n    }\n\n    blend(gl_FragColor, samplerArr[1], tileOffsetArr[1], layerOpacityArr[1]);\r\n    if (samplerCount == 2) {\r\n        gl_FragColor = gl_FragColor * lightWeighting + vec4(spec, 0.0);\r\n        return;\r\n    }\n\n    blend(gl_FragColor, samplerArr[2], tileOffsetArr[2], layerOpacityArr[2]);\r\n    if (samplerCount == 3) {\r\n        gl_FragColor = gl_FragColor * lightWeighting + vec4(spec, 0.0);\r\n        return;\r\n    }\n\n    blend(gl_FragColor, samplerArr[3], tileOffsetArr[3], layerOpacityArr[3]);\r\n    if (samplerCount == 4) {\r\n        gl_FragColor = gl_FragColor * lightWeighting + vec4(spec, 0.0);\r\n        return;\r\n    }\n\n    blend(gl_FragColor, samplerArr[4], tileOffsetArr[4], layerOpacityArr[4]);\r\n    gl_FragColor = gl_FragColor * lightWeighting + vec4(spec, 0.0);\r\n}";
var Uu = "#version 300 es\n\nprecision highp float;\n\nin vec3 aVertexPositionHigh;\r\nin vec3 aVertexPositionLow;\r\nin vec2 aTextureCoord;\n\nuniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform vec4 uGlobalTextureCoord;\r\nuniform vec3 uNormalMapBias;\r\nuniform vec3 eyePositionHigh;\r\nuniform vec3 eyePositionLow;\r\nuniform float height;\n\nout vec4 vTextureCoord;\r\nout vec3 v_vertex;\r\nout vec3 cameraPosition;\r\nout vec2 vGlobalTextureCoord;\r\nout float v_height;\n\nvoid main(void) {\n\n    vec3 aVertexPosition = aVertexPositionHigh + aVertexPositionLow;\r\n    vec3 nh = height * normalize(aVertexPosition);\n\n    vTextureCoord.xy = aTextureCoord;\r\n    vGlobalTextureCoord = uGlobalTextureCoord.xy + (uGlobalTextureCoord.zw - uGlobalTextureCoord.xy) * aTextureCoord;\r\n    vTextureCoord.zw = uNormalMapBias.z * (aTextureCoord + uNormalMapBias.xy);\n\n    cameraPosition = eyePositionHigh + eyePositionLow;\n\n    vec3 highDiff = aVertexPositionHigh - eyePositionHigh;\r\n    vec3 lowDiff = aVertexPositionLow - eyePositionLow + nh;\n\n    mat4 viewMatrixRTE = viewMatrix;\r\n    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n    v_height = height;\r\n    v_vertex = aVertexPosition + nh;\n\n    gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);\r\n}";
var Gu = "#version 300 es\n\nprecision highp float;\n\n#ifdef WEBGL2\r\n    #define TEXTURE_FUNC texture\r\n#else\r\n    #define TEXTURE_FUNC texture2D\r\n#endif\n\n#define SLICE_SIZE 5\n\n#define blend(DEST, SAMPLER, OFFSET, OPACITY) \\\r\nsrc = TEXTURE_FUNC(SAMPLER, OFFSET.xy + vTextureCoord.xy * OFFSET.zw); \\\r\nDEST = DEST * (1.0 - src.a * OPACITY) + src * OPACITY;\n\n#define blendPicking(DEST, OFFSET, SAMPLER, MASK, COLOR, OPACITY) \\\r\ntc = OFFSET.xy + vTextureCoord.xy * OFFSET.zw; \\\r\nt = TEXTURE_FUNC(SAMPLER, tc); \\\r\np = TEXTURE_FUNC(MASK, tc); \\\r\nDEST = mix(DEST, vec4(max(COLOR.rgb, p.rgb), OPACITY), (t.a == 0.0 ? 0.0: 1.0) * COLOR.a);\n\nconst vec3 nightStep = 10.0 * vec3(0.58, 0.48, 0.25);\n\nfloat getLerpValue(in float min, in float max, in float between)\r\n{\r\n    return (clamp(between, min, max) - min) / (max - min);\r\n}\n\nvec3 aces(vec3 color)\r\n{\r\n    float a = 2.51;\r\n    float b = 0.03;\r\n    float c = 2.43;\r\n    float d = 0.59;\r\n    float e = 0.14;\r\n    return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);\r\n}\n\nbool intersectSphere(vec3 rayOrigin, vec3 rayDirection, float radius, inout float t1, inout float t2)\r\n{\r\n    float b = dot(rayDirection, rayOrigin);\r\n    float c = dot(rayOrigin, rayOrigin) - radius * radius;\r\n    float d = b * b - c;\r\n    if (d < 0.0) {\r\n        return false;\r\n    }\r\n    t1 = -b - sqrt(d);\r\n    t2 = -b + sqrt(d);\r\n    return true;\r\n}\n\nbool intersectSphere(vec3 rayOrigin, vec3 rayDirection, float radius, inout float t)\r\n{\r\n    float b = dot(rayDirection, rayOrigin);\r\n    float c = dot(rayOrigin, rayOrigin) - radius * radius;\r\n    float d = b * b - c;\r\n    if (d < 0.0) {\r\n        return false;\r\n    }\r\n    t = -b - sqrt(d);\r\n    return true;\r\n}\n\nfloat intersectSphere(vec3 ro, vec3 rd, vec4 sph)\r\n{\r\n    vec3 oc = ro - sph.xyz;\r\n    float b = dot(oc, rd);\r\n    float c = dot(oc, oc) - sph.w * sph.w;\r\n    float h = b * b - c;\r\n    if (h < 0.0) return -1.0;\r\n    h = sqrt(h);\r\n    return -b - h;\r\n}\n\nbool intersectEllipsoid(in vec3 ro, in vec3 rd, in vec3 ra, inout float t)\r\n{\r\n    vec3 ocn = ro / ra;\r\n    vec3 rdn = rd / ra;\r\n    float a = dot(rdn, rdn);\r\n    float b = dot(ocn, rdn);\r\n    float c = dot(ocn, ocn);\r\n    float h = b * b - a * (c - 1.0);\n\n    if (h < 0.0)\r\n    {\r\n        return false;\r\n    }\n\n    t = (-b - sqrt(h)) / a;\n\n    return true;\r\n}\n\nbool intersectEllipsoid(in vec3 ro, in vec3 rd, in vec3 ra, inout float t1, inout float t2)\r\n{\r\n    vec3 ocn = ro / ra;\r\n    vec3 rdn = rd / ra;\r\n    float a = dot(rdn, rdn);\r\n    float b = dot(ocn, rdn);\r\n    float c = dot(ocn, ocn);\r\n    float h = b * b - a * (c - 1.0);\n\n    if (h < 0.0)\r\n    {\r\n        return false;\r\n    }\n\n    h = sqrt(h);\r\n    t1 = (-b - h) / a;\r\n    t2 = (-b + h) / a;\n\n    return true;\r\n}\n\nvec3 normalEllipsoid(in vec3 pos, in vec3 ra)\r\n{\r\n    return normalize(pos / (ra * ra));\r\n}\n\n#define PI 3.1415926538\n\n#define ATMOS_HEIGHT float(${ATMOS_HEIGHT})\r\n#define RAYLEIGH_SCALE float(${RAYLEIGH_SCALE})\r\n#define MIE_SCALE float(${MIE_SCALE})\n\n#define SAMPLE_COUNT 16\r\n#define SQRT_SAMPLE_COUNT 4\n\nconst float GROUND_ALBEDO = float(${GROUND_ALBEDO}) / PI;\n\nconst float BOTTOM_RADIUS = float(${BOTTOM_RADIUS});\r\nconst float TOP_RADIUS = BOTTOM_RADIUS + ATMOS_HEIGHT;\r\nconst float EQUATORIAL_RADIUS = 6378137.0;\n\nconst vec3 bottomRadii = vec3(EQUATORIAL_RADIUS, EQUATORIAL_RADIUS, BOTTOM_RADIUS);\r\nconst vec3 topRadii = bottomRadii + ATMOS_HEIGHT;\n\nconst vec3 SPHERE_TO_ELLIPSOID_SCALE = vec3(BOTTOM_RADIUS) / bottomRadii;\n\nconst vec2 rayleighMieHeights = vec2(RAYLEIGH_SCALE, MIE_SCALE) * ATMOS_HEIGHT;\n\nconst vec3 rayleighScatteringCoefficient = vec3(float(${rayleighScatteringCoefficient_0}), float(${rayleighScatteringCoefficient_1}), float(${rayleighScatteringCoefficient_2})) * 1e-6;\n\nconst float mieScatteringCoefficient = float(${mieScatteringCoefficient}) * 1e-6;\r\nconst float mieExtinctionCoefficient = float(${mieExtinctionCoefficient}) * 1e-6;\r\nconst vec3 ozoneAbsorptionCoefficient = vec3(float(${ozoneAbsorptionCoefficient_0}), float(${ozoneAbsorptionCoefficient_1}), float(${ozoneAbsorptionCoefficient_2})) * 1e-6;\n\nconst float SUN_ANGULAR_RADIUS = float(${SUN_ANGULAR_RADIUS});\r\nconst float SUN_INTENSITY = float(${SUN_INTENSITY});\n\nconst float ozoneDensityHeight = float(${ozoneDensityHeight}); \nconst float ozoneDensityWide = float(${ozoneDensityWide}); \n\nvec3 sunWithBloom(vec3 rayDir, vec3 sunDir)\r\n{\r\n    float minSunCosTheta = cos(SUN_ANGULAR_RADIUS);\r\n    float cosTheta = dot(rayDir, sunDir);\n\n    if (cosTheta >= minSunCosTheta)\r\n        return vec3(1.0);\n\n    float offset = minSunCosTheta - cosTheta;\r\n    float gaussianBloom = exp(- offset * 15000.0) * 0.7;\r\n    float invBloom = 1.0 / (0.09 + offset * 200.0) * 0.01;\n\n    return vec3(gaussianBloom + invBloom);\r\n}\n\nfloat rayleighPhase(float angle)\r\n{\r\n    return 3.0 / (16.0 * PI) * (1.0 + (angle * angle));\r\n}\n\nfloat miePhase(float angle)\r\n{\r\n    float g = 0.8;\r\n    return 3.0 / (8.0 * PI) * ((1.0 - g * g) * (1.0 + angle * angle)) / ((2.0 + g * g) * pow(1.0 + g * g - 2.0 * g * angle, 1.5));\r\n}\n\nvec3 opticalDepth(float height, float angle)\r\n{\r\n    vec3 rayOrigin = vec3(0.0, BOTTOM_RADIUS + height, 0.0);\r\n    vec3 rayDirection = vec3(sqrt(1.0 - angle * angle), angle, 0.0);\n\n    float t1, t2;\r\n    intersectSphere(rayOrigin, rayDirection, TOP_RADIUS, t1, t2);\r\n    float segmentLength = t2 / float(SAMPLE_COUNT);\n\n    float t = segmentLength * 0.5;\r\n    vec3 opticalDepth = vec3(0.0);\n\n    for (int i = 0; i < SAMPLE_COUNT; i++)\r\n    {\r\n        vec3 position = rayOrigin + t * rayDirection;\r\n        float height = length(position) - BOTTOM_RADIUS;\r\n        opticalDepth.xy += exp(-height / rayleighMieHeights) * segmentLength;\r\n        opticalDepth.z += (1.0 - min(abs(height - ozoneDensityHeight) / ozoneDensityWide, 1.0)) * segmentLength;\r\n        t += segmentLength;\r\n    }\n\n    return opticalDepth;\r\n}\n\nvec3 transmittance(float height, float angle)\r\n{\r\n    vec3 opticalDepth = opticalDepth(height, angle);\r\n    return exp(-(rayleighScatteringCoefficient * opticalDepth.x + mieExtinctionCoefficient * opticalDepth.y + ozoneAbsorptionCoefficient * opticalDepth.z));\r\n}\r\n\nuniform vec4 specular;\r\nuniform vec3 diffuse;\r\nuniform vec3 ambient;\n\nuniform vec3 lightPosition;\n\nuniform sampler2D uNormalMap;\r\nuniform sampler2D nightTexture;\r\nuniform sampler2D specularTexture;\r\nuniform sampler2D transmittanceTexture;\r\nuniform sampler2D scatteringTexture;\r\nuniform sampler2D defaultTexture;\r\nuniform sampler2D samplerArr[SLICE_SIZE];\n\nuniform vec4 tileOffsetArr[SLICE_SIZE];\r\nuniform float layerOpacityArr[SLICE_SIZE];\n\nuniform int samplerCount;\r\nuniform float nightTextureCoefficient;\n\nuniform vec2 maxMinOpacity;\r\nuniform float camHeight;\n\nuniform float transitionOpacity;\n\nin vec4 vTextureCoord;\r\nin vec3 v_vertex;\r\nin vec3 cameraPosition;\r\nin vec2 vGlobalTextureCoord;\r\nin float v_height;\n\nvec3 sunPos;\n\nlayout (location = 0) out vec4 diffuseColor;\n\nvec3 transmittanceFromTexture(float height, float angle)\r\n{\r\n    float u = (angle + 1.0) * 0.5;\r\n    float v = height / ATMOS_HEIGHT;\r\n    return texture(transmittanceTexture, vec2(u, v)).xyz;\r\n}\n\nvec3 multipleScatteringContributionFromTexture(float height, float angle)\r\n{\r\n    float u = (angle + 1.0) * 0.5;\r\n    float v = height / ATMOS_HEIGHT;\r\n    return texture(scatteringTexture, vec2(u, v)).xyz;\r\n}\n\nvoid getSunIlluminance(in vec3 point, in vec3 lightDir, out vec3 sunIlluminance)\r\n{\r\n    \n    \n    \n\n    float mu_s = dot(normalize(point), lightDir);\r\n    float height = length(point) - BOTTOM_RADIUS;\r\n    sunIlluminance = SUN_INTENSITY * transmittanceFromTexture(height, mu_s);\r\n}\n\nvoid atmosGroundColor(out vec4 fragColor, in vec3 normal)\r\n{\r\n    vec3 cameraPosition = cameraPosition;\n\n    if (length(cameraPosition * SPHERE_TO_ELLIPSOID_SCALE) < BOTTOM_RADIUS + 1.0) {\r\n        cameraPosition = normalize(cameraPosition * SPHERE_TO_ELLIPSOID_SCALE) * (BOTTOM_RADIUS + 1.0) / SPHERE_TO_ELLIPSOID_SCALE;\r\n    }\n\n    vec3 rayDirection = normalize(v_vertex - cameraPosition);\r\n    vec3 lightDir = normalize(sunPos);\n\n    rayDirection = normalize(rayDirection * SPHERE_TO_ELLIPSOID_SCALE);\r\n    vec3 camPos = cameraPosition * SPHERE_TO_ELLIPSOID_SCALE;\r\n    lightDir = normalize(lightDir * SPHERE_TO_ELLIPSOID_SCALE);\r\n\n    vec3 light = vec3(0.0);\r\n    vec3 transmittanceFromCameraToSpace = vec3(1.0);\r\n    float offset = 0.0;\r\n    float distanceToSpace = 0.0;\n\n    intersectSphere(camPos, rayDirection, TOP_RADIUS, offset, distanceToSpace);\n\n    vec3 rayOrigin = camPos;\n\n    \n    if (offset > 0.0)\r\n    {\r\n        \n        rayOrigin += rayDirection * offset;\r\n    }\n\n    float height = length(rayOrigin) - BOTTOM_RADIUS;\r\n    float rayAngle = dot(rayOrigin, rayDirection) / length(rayOrigin);\r\n    bool cameraBelow = rayAngle < 0.0;\n\n    transmittanceFromCameraToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);\n\n    float phaseAngle = dot(lightDir, rayDirection);\r\n    float rayleighPhase = rayleighPhase(phaseAngle);\r\n    float miePhase = miePhase(phaseAngle);\n\n    float distanceToGround = 0.0;\n\n    bool hitGround = intersectSphere(camPos, rayDirection, BOTTOM_RADIUS, distanceToGround) && distanceToGround > 0.0;\r\n    \r\n\n    if (length(v_vertex * SPHERE_TO_ELLIPSOID_SCALE) > BOTTOM_RADIUS) {\r\n        distanceToGround = distance(camPos, v_vertex * SPHERE_TO_ELLIPSOID_SCALE);\r\n    }\n\n    float segmentLength = (distanceToGround - max(offset, 0.0)) / float(SAMPLE_COUNT);\n\n    float t = segmentLength * 0.5;\n\n    vec3 transmittanceCamera;\r\n    vec3 transmittanceLight;\n\n    for (int i = 0; i < SAMPLE_COUNT; i++)\r\n    {\r\n        vec3 position = rayOrigin + t * rayDirection;\r\n        float height = length(position) - BOTTOM_RADIUS;\r\n        vec3 up = position / length(position);\r\n        float rayAngle = dot(up, rayDirection);\r\n        float lightAngle = dot(up, lightDir);\r\n        vec3 transmittanceToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);\r\n        transmittanceCamera = cameraBelow ? (transmittanceToSpace / transmittanceFromCameraToSpace) : (transmittanceFromCameraToSpace / transmittanceToSpace);\r\n        transmittanceLight = transmittanceFromTexture(height, lightAngle);\r\n        vec2 opticalDensity = exp(-height / rayleighMieHeights);\r\n        vec3 scatteredLight = transmittanceLight * (rayleighScatteringCoefficient * opticalDensity.x * rayleighPhase + mieScatteringCoefficient * opticalDensity.y * miePhase);\r\n        scatteredLight += multipleScatteringContributionFromTexture(height, lightAngle) * (rayleighScatteringCoefficient * opticalDensity.x + mieScatteringCoefficient * opticalDensity.y);\r\n        light += transmittanceCamera * scatteredLight * segmentLength;\r\n        t += segmentLength;\r\n    }\n\n    light *= SUN_INTENSITY;\n\n    vec3 hitPoint = camPos + rayDirection * distanceToGround;\r\n    vec3 up = normalize(hitPoint);\r\n    float diffuseAngle = max(dot(up, lightDir), 0.0);\n\n    float lightAngle = dot(normal, lightDir);\r\n    vec3 tA = transmittanceCamera * GROUND_ALBEDO * SUN_INTENSITY;\r\n    vec3 scatteringLight = multipleScatteringContributionFromTexture(height, lightAngle);\r\n    vec3 diffuseTransmittanceLight = transmittanceLight * diffuseAngle;\r\n    light += tA * (scatteringLight + diffuseTransmittanceLight);\n\n    fragColor = vec4(pow(light * 8.0, vec3(1.0 / 2.2)), 1.0);\r\n}\n\nvoid getAtmosFadingOpacity(out float opacity)\r\n{\r\n    float c = length(cameraPosition);\r\n    float maxDist = sqrt(c * c - BOTTOM_RADIUS * BOTTOM_RADIUS);\r\n    float minDist = c - BOTTOM_RADIUS;\r\n    float vertDist = distance(cameraPosition, v_vertex);\r\n    opacity = clamp(maxMinOpacity.y + (maxMinOpacity.x - maxMinOpacity.y) * getLerpValue(minDist, maxDist, vertDist), 0.0, 1.0);\r\n}\n\nvoid main(void) {\n\n    sunPos = lightPosition;\n\n    vec3 texNormal = texture(uNormalMap, vTextureCoord.zw).rgb;\r\n    vec3 normal = normalize((texNormal - 0.5) * 2.0);\n\n    float minH = 1200000.0;\r\n    float maxH = minH * 3.0;\r\n    float nightCoef = getLerpValue(minH, maxH, camHeight) * nightTextureCoefficient;\n\n    \n    \n    \n    \n\n    vec3 lightDir = normalize(sunPos);\r\n    vec3 viewDir = normalize(cameraPosition - v_vertex);\n\n    vec4 atmosColor;\r\n    atmosGroundColor(atmosColor, normal);\n\n    vec3 sunIlluminance;\r\n    getSunIlluminance(v_vertex * SPHERE_TO_ELLIPSOID_SCALE, lightDir * SPHERE_TO_ELLIPSOID_SCALE, sunIlluminance);\n\n    float overGround = 1.0 - step(0.1, v_height);\n\n    float shininess = texture(specularTexture, vGlobalTextureCoord.st).r * 255.0 * overGround;\r\n    vec3 reflectionDirection = reflect(-lightDir, normal);\r\n    float reflection = max(dot(reflectionDirection, viewDir), 0.0);\r\n    vec3 spec = sunIlluminance * specular.rgb * pow(reflection, specular.w) * shininess;\r\n    float diffuseLightWeighting = max(dot(normal, lightDir), 0.0);\n\n    vec4 nightImageColor = texture(nightTexture, vGlobalTextureCoord.st);\r\n    vec3 night = nightStep * (.18 - diffuseLightWeighting * 3.0) * nightImageColor.rgb * nightCoef;\r\n    night *= overGround * step(0.0, night);\r\n    vec4 lightWeighting = vec4(ambient + sunIlluminance * diffuse * diffuseLightWeighting + night, 1.0);\n\n    float fadingOpacity;\r\n    getAtmosFadingOpacity(fadingOpacity);\n\n    getSunIlluminance(cameraPosition, viewDir * SPHERE_TO_ELLIPSOID_SCALE, sunIlluminance);\n\n    spec *= sunIlluminance;\n\n    diffuseColor = texture(defaultTexture, vTextureCoord.xy);\r\n    if (samplerCount == 0) {\r\n        diffuseColor = mix(diffuseColor * lightWeighting, atmosColor, fadingOpacity) + vec4(spec, 0.0);\r\n        diffuseColor *= transitionOpacity;\r\n        return;\r\n    }\n\n    vec4 src;\n\n    blend(diffuseColor, samplerArr[0], tileOffsetArr[0], layerOpacityArr[0]);\r\n    if (samplerCount == 1) {\r\n        diffuseColor = mix(diffuseColor * lightWeighting, atmosColor * diffuseColor.a, fadingOpacity) + vec4(spec, 0.0);\r\n        diffuseColor *= transitionOpacity;\r\n        return;\r\n    }\n\n    blend(diffuseColor, samplerArr[1], tileOffsetArr[1], layerOpacityArr[1]);\r\n    if (samplerCount == 2) {\r\n        diffuseColor = mix(diffuseColor * lightWeighting, atmosColor * diffuseColor.a, fadingOpacity) + vec4(spec, 0.0);\r\n        diffuseColor *= transitionOpacity;\r\n        return;\r\n    }\n\n    blend(diffuseColor, samplerArr[2], tileOffsetArr[2], layerOpacityArr[2]);\r\n    if (samplerCount == 3) {\r\n        diffuseColor = mix(diffuseColor * lightWeighting, atmosColor * diffuseColor.a, fadingOpacity) + vec4(spec, 0.0);\r\n        diffuseColor *= transitionOpacity;\r\n        return;\r\n    }\n\n    blend(diffuseColor, samplerArr[3], tileOffsetArr[3], layerOpacityArr[3]);\r\n    if (samplerCount == 4) {\r\n        diffuseColor = mix(diffuseColor * lightWeighting, atmosColor * diffuseColor.a, fadingOpacity) + vec4(spec, 0.0);\r\n        diffuseColor *= transitionOpacity;\r\n        return;\r\n    }\n\n    blend(diffuseColor, samplerArr[4], tileOffsetArr[4], layerOpacityArr[4]);\r\n    diffuseColor = mix(diffuseColor * lightWeighting, atmosColor * diffuseColor.a, fadingOpacity) + vec4(spec, 0.0);\r\n    diffuseColor *= transitionOpacity;\r\n}";
var Wu = "#version 300 es\n\nprecision highp float;\n\nin vec3 aVertexPositionHigh;\r\nin vec3 aVertexPositionLow;\r\nin vec2 aTextureCoord;\n\nuniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform vec4 uGlobalTextureCoord;\r\nuniform vec3 uNormalMapBias;\r\nuniform vec3 eyePositionHigh;\r\nuniform vec3 eyePositionLow;\r\nuniform float height;\n\nout vec4 vTextureCoord;\r\nout vec3 v_vertex;\r\nout vec3 cameraPosition;\r\nout vec2 vGlobalTextureCoord;\r\nout float v_height;\n\nvoid main(void) {\n\n    vec3 aVertexPosition = aVertexPositionHigh + aVertexPositionLow;\r\n    vec3 nh = height * normalize(aVertexPosition);\n\n    vTextureCoord.xy = aTextureCoord;\r\n    vGlobalTextureCoord = uGlobalTextureCoord.xy + (uGlobalTextureCoord.zw - uGlobalTextureCoord.xy) * aTextureCoord;\r\n    vTextureCoord.zw = uNormalMapBias.z * (aTextureCoord + uNormalMapBias.xy);\n\n    cameraPosition = eyePositionHigh + eyePositionLow;\n\n    vec3 highDiff = aVertexPositionHigh - eyePositionHigh;\r\n    vec3 lowDiff = aVertexPositionLow - eyePositionLow + nh;\n\n    mat4 viewMatrixRTE = viewMatrix;\r\n    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n    v_height = height;\r\n    v_vertex = aVertexPosition + nh;\n\n    gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);\r\n}";
var ju = "#version 300 es\n\nprecision highp float;\n\nfloat getLerpValue(in float min, in float max, in float between)\r\n{\r\n    return (clamp(between, min, max) - min) / (max - min);\r\n}\n\nvec3 aces(vec3 color)\r\n{\r\n    float a = 2.51;\r\n    float b = 0.03;\r\n    float c = 2.43;\r\n    float d = 0.59;\r\n    float e = 0.14;\r\n    return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);\r\n}\n\nbool intersectSphere(vec3 rayOrigin, vec3 rayDirection, float radius, inout float t1, inout float t2)\r\n{\r\n    float b = dot(rayDirection, rayOrigin);\r\n    float c = dot(rayOrigin, rayOrigin) - radius * radius;\r\n    float d = b * b - c;\r\n    if (d < 0.0) {\r\n        return false;\r\n    }\r\n    t1 = -b - sqrt(d);\r\n    t2 = -b + sqrt(d);\r\n    return true;\r\n}\n\nbool intersectSphere(vec3 rayOrigin, vec3 rayDirection, float radius, inout float t)\r\n{\r\n    float b = dot(rayDirection, rayOrigin);\r\n    float c = dot(rayOrigin, rayOrigin) - radius * radius;\r\n    float d = b * b - c;\r\n    if (d < 0.0) {\r\n        return false;\r\n    }\r\n    t = -b - sqrt(d);\r\n    return true;\r\n}\n\nfloat intersectSphere(vec3 ro, vec3 rd, vec4 sph)\r\n{\r\n    vec3 oc = ro - sph.xyz;\r\n    float b = dot(oc, rd);\r\n    float c = dot(oc, oc) - sph.w * sph.w;\r\n    float h = b * b - c;\r\n    if (h < 0.0) return -1.0;\r\n    h = sqrt(h);\r\n    return -b - h;\r\n}\n\nbool intersectEllipsoid(in vec3 ro, in vec3 rd, in vec3 ra, inout float t)\r\n{\r\n    vec3 ocn = ro / ra;\r\n    vec3 rdn = rd / ra;\r\n    float a = dot(rdn, rdn);\r\n    float b = dot(ocn, rdn);\r\n    float c = dot(ocn, ocn);\r\n    float h = b * b - a * (c - 1.0);\n\n    if (h < 0.0)\r\n    {\r\n        return false;\r\n    }\n\n    t = (-b - sqrt(h)) / a;\n\n    return true;\r\n}\n\nbool intersectEllipsoid(in vec3 ro, in vec3 rd, in vec3 ra, inout float t1, inout float t2)\r\n{\r\n    vec3 ocn = ro / ra;\r\n    vec3 rdn = rd / ra;\r\n    float a = dot(rdn, rdn);\r\n    float b = dot(ocn, rdn);\r\n    float c = dot(ocn, ocn);\r\n    float h = b * b - a * (c - 1.0);\n\n    if (h < 0.0)\r\n    {\r\n        return false;\r\n    }\n\n    h = sqrt(h);\r\n    t1 = (-b - h) / a;\r\n    t2 = (-b + h) / a;\n\n    return true;\r\n}\n\nvec3 normalEllipsoid(in vec3 pos, in vec3 ra)\r\n{\r\n    return normalize(pos / (ra * ra));\r\n}\r\n#ifdef WEBGL2\r\n    #define TEXTURE_FUNC texture\r\n#else\r\n    #define TEXTURE_FUNC texture2D\r\n#endif\n\n#define SLICE_SIZE 5\n\n#define blend(DEST, SAMPLER, OFFSET, OPACITY) \\\r\nsrc = TEXTURE_FUNC(SAMPLER, OFFSET.xy + vTextureCoord.xy * OFFSET.zw); \\\r\nDEST = DEST * (1.0 - src.a * OPACITY) + src * OPACITY;\n\n#define blendPicking(DEST, OFFSET, SAMPLER, MASK, COLOR, OPACITY) \\\r\ntc = OFFSET.xy + vTextureCoord.xy * OFFSET.zw; \\\r\nt = TEXTURE_FUNC(SAMPLER, tc); \\\r\np = TEXTURE_FUNC(MASK, tc); \\\r\nDEST = mix(DEST, vec4(max(COLOR.rgb, p.rgb), OPACITY), (t.a == 0.0 ? 0.0: 1.0) * COLOR.a);\n\nconst vec3 nightStep = 10.0 * vec3(0.58, 0.48, 0.25);\n\nuniform vec4 specular;\r\nuniform vec3 diffuse;\r\nuniform vec3 ambient;\n\nuniform sampler2D uNormalMap;\r\nuniform sampler2D nightTexture;\r\nuniform sampler2D specularTexture;\r\nuniform sampler2D defaultTexture;\r\nuniform sampler2D samplerArr[SLICE_SIZE];\n\nuniform vec4 tileOffsetArr[SLICE_SIZE];\r\nuniform vec3 lightPosition;\r\nuniform float layerOpacityArr[SLICE_SIZE];\n\nuniform int samplerCount;\r\nuniform float nightTextureCoefficient;\n\nuniform float transitionOpacity;\n\nuniform float camHeight;\n\nin vec4 vTextureCoord;\r\nin vec3 v_vertex;\r\nin vec3 cameraPosition;\r\nin vec2 vGlobalTextureCoord;\r\nin float v_height;\n\nvec3 sunPos;\n\nlayout (location = 0) out vec4 diffuseColor;\n\nvoid main(void) {\n\n    sunPos = lightPosition;\n\n    vec3 texNormal = texture(uNormalMap, vTextureCoord.zw).rgb;\r\n    vec3 normal = normalize((texNormal - 0.5) * 2.0);\n\n    float minH = 1200000.0;\r\n    float maxH = minH * 3.0;\r\n    float nightCoef = getLerpValue(minH, maxH, camHeight) * nightTextureCoefficient;\n\n    \n    \n    \n    \n\n    vec3 lightDir = normalize(sunPos);\r\n    vec3 viewDir = normalize(cameraPosition - v_vertex);\n\n    float overGround = 1.0 - step(0.1, v_height);\n\n    float shininess = texture(specularTexture, vGlobalTextureCoord.st).r * 255.0 * overGround;\r\n    vec3 reflectionDirection = reflect(-lightDir, normal);\r\n    float reflection = max(dot(reflectionDirection, viewDir), 0.0);\r\n    vec3 spec = specular.rgb * pow(reflection, specular.w) * shininess;\r\n    float diffuseLightWeighting = max(dot(normal, lightDir), 0.0);\r\n    vec4 nightImageColor = texture(nightTexture, vGlobalTextureCoord.st);\r\n    vec3 night = nightStep * (.18 - diffuseLightWeighting * 3.0) * nightImageColor.rgb * nightCoef;\r\n    night *= overGround * step(0.0, night);\r\n    vec4 lightWeighting = vec4(ambient + diffuse * diffuseLightWeighting + night, 1.0);\n\n    diffuseColor = texture(defaultTexture, vTextureCoord.xy);\n\n    if (samplerCount == 0) {\r\n        diffuseColor = diffuseColor * lightWeighting + vec4(spec, 0.0);\r\n        diffuseColor *= transitionOpacity;\r\n        return;\r\n    }\n\n    vec4 src;\n\n    blend(diffuseColor, samplerArr[0], tileOffsetArr[0], layerOpacityArr[0]);\r\n    if (samplerCount == 1) {\r\n        diffuseColor = diffuseColor * lightWeighting + vec4(spec, 0.0);\r\n        diffuseColor *= transitionOpacity;\r\n        return;\r\n    }\n\n    blend(diffuseColor, samplerArr[1], tileOffsetArr[1], layerOpacityArr[1]);\r\n    if (samplerCount == 2) {\r\n        diffuseColor = diffuseColor * lightWeighting + vec4(spec, 0.0);\r\n        diffuseColor *= transitionOpacity;\r\n        return;\r\n    }\n\n    blend(diffuseColor, samplerArr[2], tileOffsetArr[2], layerOpacityArr[2]);\r\n    if (samplerCount == 3) {\r\n        diffuseColor = diffuseColor * lightWeighting + vec4(spec, 0.0);\r\n        diffuseColor *= transitionOpacity;\r\n        return;\r\n    }\n\n    blend(diffuseColor, samplerArr[3], tileOffsetArr[3], layerOpacityArr[3]);\r\n    if (samplerCount == 4) {\r\n        diffuseColor = diffuseColor * lightWeighting + vec4(spec, 0.0);\r\n        diffuseColor *= transitionOpacity;\r\n        return;\r\n    }\n\n    blend(diffuseColor, samplerArr[4], tileOffsetArr[4], layerOpacityArr[4]);\r\n    diffuseColor = diffuseColor * lightWeighting + vec4(spec, 0.0);\r\n    diffuseColor *= transitionOpacity;\r\n}";
var Yu = "precision highp float;\n\nattribute vec3 aVertexPositionHigh;\r\nattribute vec3 aVertexPositionLow;\r\nattribute vec2 aTextureCoord;\n\nuniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform vec3 eyePositionHigh;\r\nuniform vec3 eyePositionLow;\r\nuniform float height;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void) {\n\n    vTextureCoord = aTextureCoord;\n\n    mat4 viewMatrixRTE = viewMatrix;\r\n    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n    mat4 m = projectionMatrix * viewMatrixRTE;\n\n    vec3 nh = height * normalize(aVertexPositionHigh + aVertexPositionLow);\n\n    vec3 highDiff = aVertexPositionHigh - eyePositionHigh;\r\n    vec3 lowDiff = aVertexPositionLow - eyePositionLow + nh;\n\n    gl_Position = m * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);\r\n}";
var qu = "precision highp float;\n\n#ifdef WEBGL2\r\n    #define TEXTURE_FUNC texture\r\n#else\r\n    #define TEXTURE_FUNC texture2D\r\n#endif\n\n#define SLICE_SIZE 5\n\n#define blend(DEST, SAMPLER, OFFSET, OPACITY) \\\r\nsrc = TEXTURE_FUNC(SAMPLER, OFFSET.xy + vTextureCoord.xy * OFFSET.zw); \\\r\nDEST = DEST * (1.0 - src.a * OPACITY) + src * OPACITY;\n\n#define blendPicking(DEST, OFFSET, SAMPLER, MASK, COLOR, OPACITY) \\\r\ntc = OFFSET.xy + vTextureCoord.xy * OFFSET.zw; \\\r\nt = TEXTURE_FUNC(SAMPLER, tc); \\\r\np = TEXTURE_FUNC(MASK, tc); \\\r\nDEST = mix(DEST, vec4(max(COLOR.rgb, p.rgb), OPACITY), (t.a == 0.0 ? 0.0: 1.0) * COLOR.a);\n\nconst vec3 nightStep = 10.0 * vec3(0.58, 0.48, 0.25);\n\nuniform vec4 tileOffsetArr[SLICE_SIZE];\r\nuniform vec4 pickingColorArr[SLICE_SIZE];\r\nuniform sampler2D samplerArr[SLICE_SIZE];\r\nuniform sampler2D pickingMaskArr[SLICE_SIZE];\r\nuniform int samplerCount;\r\nvarying vec2 vTextureCoord;\n\nvoid main(void) {\n\n    gl_FragColor = vec4(0.0);\n\n    if (samplerCount == 0) return;\n\n    vec2 tc;\r\n    vec4 t;\r\n    vec4 p;\n\n    blendPicking(gl_FragColor, tileOffsetArr[0], samplerArr[0], pickingMaskArr[0], pickingColorArr[0], 1.0);\r\n    if (samplerCount == 1) return;\n\n    blendPicking(gl_FragColor, tileOffsetArr[1], samplerArr[1], pickingMaskArr[1], pickingColorArr[1], 1.0);\r\n    if (samplerCount == 2) return;\n\n    blendPicking(gl_FragColor, tileOffsetArr[2], samplerArr[2], pickingMaskArr[2], pickingColorArr[2], 1.0);\r\n    if (samplerCount == 3) return;\n\n    blendPicking(gl_FragColor, tileOffsetArr[3], samplerArr[3], pickingMaskArr[3], pickingColorArr[3], 1.0);\r\n    if (samplerCount == 4) return;\n\n    blendPicking(gl_FragColor, tileOffsetArr[4], samplerArr[4], pickingMaskArr[4], pickingColorArr[4], 1.0);\r\n}";
var $u = "#version 300 es\n\nprecision highp float;\n\nin vec3 aVertexPositionHigh;\r\nin vec3 aVertexPositionLow;\n\nuniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform vec3 eyePositionHigh;\r\nuniform vec3 eyePositionLow;\r\nuniform float height;\n\nvoid main(void) {\n\n    mat4 viewMatrixRTE = viewMatrix;\r\n    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n    mat4 m = projectionMatrix * viewMatrixRTE;\n\n    vec3 nh = height * normalize(aVertexPositionHigh + aVertexPositionLow);\n\n    vec3 eyePosition = eyePositionHigh + eyePositionLow;\r\n    vec3 vertexPosition = aVertexPositionHigh + aVertexPositionLow;\n\n    vec3 highDiff = aVertexPositionHigh - eyePositionHigh;\r\n    vec3 lowDiff = aVertexPositionLow - eyePositionLow + nh;\n\n    gl_Position = m * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);\r\n}";
var Xu = "#version 300 es\n\nprecision highp float;\n\nuniform float frustumPickingColor;\n\nlayout (location = 0) out vec4 frustumColor;\r\nlayout (location = 1) out vec4 depthColor;\n\nvoid main(void) {\r\n    frustumColor = vec4(frustumPickingColor, frustumPickingColor, frustumPickingColor, 1.0);\r\n    depthColor = vec4(gl_FragCoord.z, gl_FragCoord.z, gl_FragCoord.z, 1.0);\r\n}";
function Zu() {
  return new Yr("drawnode_screen_nl", { uniforms: { projectionMatrix: "mat4", viewMatrix: "mat4", eyePositionHigh: "vec3", eyePositionLow: "vec3", samplerCount: "int", tileOffsetArr: "vec4", layerOpacityArr: "float", samplerArr: "sampler2darray", defaultTexture: "sampler2d", height: "float" }, attributes: { aVertexPositionHigh: "vec3", aVertexPositionLow: "vec3", aTextureCoord: "vec2" }, vertexShader: Nu, fragmentShader: Ou });
}
function Ku() {
  return new Yr("drawnode_screen_wl", { uniforms: { projectionMatrix: "mat4", viewMatrix: "mat4", eyePositionHigh: "vec3", eyePositionLow: "vec3", height: "float", uGlobalTextureCoord: "vec4", uNormalMapBias: "vec3", samplerCount: "int", tileOffsetArr: "vec4", layerOpacityArr: "float", samplerArr: "sampler2darray", defaultTexture: "sampler2d", uNormalMap: "sampler2d", nightTexture: "sampler2d", specularTexture: "sampler2d", lightPosition: "vec3", diffuse: "vec3", ambient: "vec3", specular: "vec4", camHeight: "float", nightTextureCoefficient: "float" }, attributes: { aVertexPositionHigh: "vec3", aVertexPositionLow: "vec3", aTextureCoord: "vec2" }, vertexShader: Hu, fragmentShader: Vu });
}
function Qu() {
  return new Yr("drawnode_screen_wl", { uniforms: { projectionMatrix: "mat4", viewMatrix: "mat4", eyePositionHigh: "vec3", eyePositionLow: "vec3", height: "float", uGlobalTextureCoord: "vec4", uNormalMapBias: "vec3", samplerCount: "int", tileOffsetArr: "vec4", layerOpacityArr: "float", samplerArr: "sampler2darray", defaultTexture: "sampler2d", uNormalMap: "sampler2d", nightTexture: "sampler2d", specularTexture: "sampler2d", lightPosition: "vec3", diffuse: "vec3", ambient: "vec3", specular: "vec4", camHeight: "float", nightTextureCoefficient: "float", transitionOpacity: "float" }, attributes: { aVertexPositionHigh: "vec3", aVertexPositionLow: "vec3", aTextureCoord: "vec2" }, vertexShader: Wu, fragmentShader: ju });
}
function Ju(e4) {
  return new Yr("drawnode_screen_wl", { uniforms: { projectionMatrix: "mat4", viewMatrix: "mat4", eyePositionHigh: "vec3", eyePositionLow: "vec3", height: "float", uGlobalTextureCoord: "vec4", uNormalMapBias: "vec3", samplerCount: "int", tileOffsetArr: "vec4", layerOpacityArr: "float", samplerArr: "sampler2darray", defaultTexture: "sampler2d", uNormalMap: "sampler2d", nightTexture: "sampler2d", specularTexture: "sampler2d", lightPosition: "vec3", diffuse: "vec3", ambient: "vec3", specular: "vec4", transmittanceTexture: "sampler2D", scatteringTexture: "sampler2D", camHeight: "float", nightTextureCoefficient: "float", maxMinOpacity: "vec2", transitionOpacity: "float" }, attributes: { aVertexPositionHigh: "vec3", aVertexPositionLow: "vec3", aTextureCoord: "vec2" }, vertexShader: Uu, fragmentShader: gt(Gu, e4) });
}
function e_() {
  return new Yr("drawnode_colorPicking", { uniforms: { projectionMatrix: "mat4", viewMatrix: "mat4", eyePositionHigh: "vec3", eyePositionLow: "vec3", samplerCount: "int", tileOffsetArr: "vec4", samplerArr: "sampler2darray", pickingMaskArr: "sampler2darray", pickingColorArr: "vec4", height: "float" }, attributes: { aVertexPositionHigh: "vec3", aVertexPositionLow: "vec3", aTextureCoord: "vec2" }, vertexShader: Yu, fragmentShader: qu });
}
function t_() {
  return new Yr("drawnode_depth", { uniforms: { projectionMatrix: "mat4", viewMatrix: "mat4", height: "float", eyePositionHigh: "vec3", eyePositionLow: "vec3", frustumPickingColor: "float" }, attributes: { aVertexPositionHigh: "vec3", aVertexPositionLow: "vec3" }, vertexShader: $u, fragmentShader: Xu });
}
var i_ = "attribute vec2 a_position;\n\nvoid main(void)\r\n{\r\n    gl_Position = vec4(a_position, 0.0, 1.0);\r\n}";
var s_ = "precision highp float;\n\nfloat getLerpValue(in float min, in float max, in float between)\r\n{\r\n    return (clamp(between, min, max) - min) / (max - min);\r\n}\n\nvec3 aces(vec3 color)\r\n{\r\n    float a = 2.51;\r\n    float b = 0.03;\r\n    float c = 2.43;\r\n    float d = 0.59;\r\n    float e = 0.14;\r\n    return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);\r\n}\n\nbool intersectSphere(vec3 rayOrigin, vec3 rayDirection, float radius, inout float t1, inout float t2)\r\n{\r\n    float b = dot(rayDirection, rayOrigin);\r\n    float c = dot(rayOrigin, rayOrigin) - radius * radius;\r\n    float d = b * b - c;\r\n    if (d < 0.0) {\r\n        return false;\r\n    }\r\n    t1 = -b - sqrt(d);\r\n    t2 = -b + sqrt(d);\r\n    return true;\r\n}\n\nbool intersectSphere(vec3 rayOrigin, vec3 rayDirection, float radius, inout float t)\r\n{\r\n    float b = dot(rayDirection, rayOrigin);\r\n    float c = dot(rayOrigin, rayOrigin) - radius * radius;\r\n    float d = b * b - c;\r\n    if (d < 0.0) {\r\n        return false;\r\n    }\r\n    t = -b - sqrt(d);\r\n    return true;\r\n}\n\nfloat intersectSphere(vec3 ro, vec3 rd, vec4 sph)\r\n{\r\n    vec3 oc = ro - sph.xyz;\r\n    float b = dot(oc, rd);\r\n    float c = dot(oc, oc) - sph.w * sph.w;\r\n    float h = b * b - c;\r\n    if (h < 0.0) return -1.0;\r\n    h = sqrt(h);\r\n    return -b - h;\r\n}\n\nbool intersectEllipsoid(in vec3 ro, in vec3 rd, in vec3 ra, inout float t)\r\n{\r\n    vec3 ocn = ro / ra;\r\n    vec3 rdn = rd / ra;\r\n    float a = dot(rdn, rdn);\r\n    float b = dot(ocn, rdn);\r\n    float c = dot(ocn, ocn);\r\n    float h = b * b - a * (c - 1.0);\n\n    if (h < 0.0)\r\n    {\r\n        return false;\r\n    }\n\n    t = (-b - sqrt(h)) / a;\n\n    return true;\r\n}\n\nbool intersectEllipsoid(in vec3 ro, in vec3 rd, in vec3 ra, inout float t1, inout float t2)\r\n{\r\n    vec3 ocn = ro / ra;\r\n    vec3 rdn = rd / ra;\r\n    float a = dot(rdn, rdn);\r\n    float b = dot(ocn, rdn);\r\n    float c = dot(ocn, ocn);\r\n    float h = b * b - a * (c - 1.0);\n\n    if (h < 0.0)\r\n    {\r\n        return false;\r\n    }\n\n    h = sqrt(h);\r\n    t1 = (-b - h) / a;\r\n    t2 = (-b + h) / a;\n\n    return true;\r\n}\n\nvec3 normalEllipsoid(in vec3 pos, in vec3 ra)\r\n{\r\n    return normalize(pos / (ra * ra));\r\n}\n\n#define PI 3.1415926538\n\n#define ATMOS_HEIGHT float(${ATMOS_HEIGHT})\r\n#define RAYLEIGH_SCALE float(${RAYLEIGH_SCALE})\r\n#define MIE_SCALE float(${MIE_SCALE})\n\n#define SAMPLE_COUNT 16\r\n#define SQRT_SAMPLE_COUNT 4\n\nconst float GROUND_ALBEDO = float(${GROUND_ALBEDO}) / PI;\n\nconst float BOTTOM_RADIUS = float(${BOTTOM_RADIUS});\r\nconst float TOP_RADIUS = BOTTOM_RADIUS + ATMOS_HEIGHT;\r\nconst float EQUATORIAL_RADIUS = 6378137.0;\n\nconst vec3 bottomRadii = vec3(EQUATORIAL_RADIUS, EQUATORIAL_RADIUS, BOTTOM_RADIUS);\r\nconst vec3 topRadii = bottomRadii + ATMOS_HEIGHT;\n\nconst vec3 SPHERE_TO_ELLIPSOID_SCALE = vec3(BOTTOM_RADIUS) / bottomRadii;\n\nconst vec2 rayleighMieHeights = vec2(RAYLEIGH_SCALE, MIE_SCALE) * ATMOS_HEIGHT;\n\nconst vec3 rayleighScatteringCoefficient = vec3(float(${rayleighScatteringCoefficient_0}), float(${rayleighScatteringCoefficient_1}), float(${rayleighScatteringCoefficient_2})) * 1e-6;\n\nconst float mieScatteringCoefficient = float(${mieScatteringCoefficient}) * 1e-6;\r\nconst float mieExtinctionCoefficient = float(${mieExtinctionCoefficient}) * 1e-6;\r\nconst vec3 ozoneAbsorptionCoefficient = vec3(float(${ozoneAbsorptionCoefficient_0}), float(${ozoneAbsorptionCoefficient_1}), float(${ozoneAbsorptionCoefficient_2})) * 1e-6;\n\nconst float SUN_ANGULAR_RADIUS = float(${SUN_ANGULAR_RADIUS});\r\nconst float SUN_INTENSITY = float(${SUN_INTENSITY});\n\nconst float ozoneDensityHeight = float(${ozoneDensityHeight}); \nconst float ozoneDensityWide = float(${ozoneDensityWide}); \n\nvec3 sunWithBloom(vec3 rayDir, vec3 sunDir)\r\n{\r\n    float minSunCosTheta = cos(SUN_ANGULAR_RADIUS);\r\n    float cosTheta = dot(rayDir, sunDir);\n\n    if (cosTheta >= minSunCosTheta)\r\n        return vec3(1.0);\n\n    float offset = minSunCosTheta - cosTheta;\r\n    float gaussianBloom = exp(- offset * 15000.0) * 0.7;\r\n    float invBloom = 1.0 / (0.09 + offset * 200.0) * 0.01;\n\n    return vec3(gaussianBloom + invBloom);\r\n}\n\nfloat rayleighPhase(float angle)\r\n{\r\n    return 3.0 / (16.0 * PI) * (1.0 + (angle * angle));\r\n}\n\nfloat miePhase(float angle)\r\n{\r\n    float g = 0.8;\r\n    return 3.0 / (8.0 * PI) * ((1.0 - g * g) * (1.0 + angle * angle)) / ((2.0 + g * g) * pow(1.0 + g * g - 2.0 * g * angle, 1.5));\r\n}\n\nvec3 opticalDepth(float height, float angle)\r\n{\r\n    vec3 rayOrigin = vec3(0.0, BOTTOM_RADIUS + height, 0.0);\r\n    vec3 rayDirection = vec3(sqrt(1.0 - angle * angle), angle, 0.0);\n\n    float t1, t2;\r\n    intersectSphere(rayOrigin, rayDirection, TOP_RADIUS, t1, t2);\r\n    float segmentLength = t2 / float(SAMPLE_COUNT);\n\n    float t = segmentLength * 0.5;\r\n    vec3 opticalDepth = vec3(0.0);\n\n    for (int i = 0; i < SAMPLE_COUNT; i++)\r\n    {\r\n        vec3 position = rayOrigin + t * rayDirection;\r\n        float height = length(position) - BOTTOM_RADIUS;\r\n        opticalDepth.xy += exp(-height / rayleighMieHeights) * segmentLength;\r\n        opticalDepth.z += (1.0 - min(abs(height - ozoneDensityHeight) / ozoneDensityWide, 1.0)) * segmentLength;\r\n        t += segmentLength;\r\n    }\n\n    return opticalDepth;\r\n}\n\nvec3 transmittance(float height, float angle)\r\n{\r\n    vec3 opticalDepth = opticalDepth(height, angle);\r\n    return exp(-(rayleighScatteringCoefficient * opticalDepth.x + mieExtinctionCoefficient * opticalDepth.y + ozoneAbsorptionCoefficient * opticalDepth.z));\r\n}\n\nuniform vec2 iResolution;\n\nvoid main(void)\r\n{\r\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\r\n    float height = uv.y * ATMOS_HEIGHT;\r\n    float angle = uv.x * 2.0 - 1.0;\r\n    gl_FragColor = vec4(transmittance(height, angle), 1.0);\r\n}";
var r_ = "attribute vec2 a_position;\n\nvoid main(void)\r\n{\r\n    gl_Position = vec4(a_position, 0.0, 1.0);\r\n}";
var n_ = "precision highp float;\n\nfloat getLerpValue(in float min, in float max, in float between)\r\n{\r\n    return (clamp(between, min, max) - min) / (max - min);\r\n}\n\nvec3 aces(vec3 color)\r\n{\r\n    float a = 2.51;\r\n    float b = 0.03;\r\n    float c = 2.43;\r\n    float d = 0.59;\r\n    float e = 0.14;\r\n    return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);\r\n}\n\nbool intersectSphere(vec3 rayOrigin, vec3 rayDirection, float radius, inout float t1, inout float t2)\r\n{\r\n    float b = dot(rayDirection, rayOrigin);\r\n    float c = dot(rayOrigin, rayOrigin) - radius * radius;\r\n    float d = b * b - c;\r\n    if (d < 0.0) {\r\n        return false;\r\n    }\r\n    t1 = -b - sqrt(d);\r\n    t2 = -b + sqrt(d);\r\n    return true;\r\n}\n\nbool intersectSphere(vec3 rayOrigin, vec3 rayDirection, float radius, inout float t)\r\n{\r\n    float b = dot(rayDirection, rayOrigin);\r\n    float c = dot(rayOrigin, rayOrigin) - radius * radius;\r\n    float d = b * b - c;\r\n    if (d < 0.0) {\r\n        return false;\r\n    }\r\n    t = -b - sqrt(d);\r\n    return true;\r\n}\n\nfloat intersectSphere(vec3 ro, vec3 rd, vec4 sph)\r\n{\r\n    vec3 oc = ro - sph.xyz;\r\n    float b = dot(oc, rd);\r\n    float c = dot(oc, oc) - sph.w * sph.w;\r\n    float h = b * b - c;\r\n    if (h < 0.0) return -1.0;\r\n    h = sqrt(h);\r\n    return -b - h;\r\n}\n\nbool intersectEllipsoid(in vec3 ro, in vec3 rd, in vec3 ra, inout float t)\r\n{\r\n    vec3 ocn = ro / ra;\r\n    vec3 rdn = rd / ra;\r\n    float a = dot(rdn, rdn);\r\n    float b = dot(ocn, rdn);\r\n    float c = dot(ocn, ocn);\r\n    float h = b * b - a * (c - 1.0);\n\n    if (h < 0.0)\r\n    {\r\n        return false;\r\n    }\n\n    t = (-b - sqrt(h)) / a;\n\n    return true;\r\n}\n\nbool intersectEllipsoid(in vec3 ro, in vec3 rd, in vec3 ra, inout float t1, inout float t2)\r\n{\r\n    vec3 ocn = ro / ra;\r\n    vec3 rdn = rd / ra;\r\n    float a = dot(rdn, rdn);\r\n    float b = dot(ocn, rdn);\r\n    float c = dot(ocn, ocn);\r\n    float h = b * b - a * (c - 1.0);\n\n    if (h < 0.0)\r\n    {\r\n        return false;\r\n    }\n\n    h = sqrt(h);\r\n    t1 = (-b - h) / a;\r\n    t2 = (-b + h) / a;\n\n    return true;\r\n}\n\nvec3 normalEllipsoid(in vec3 pos, in vec3 ra)\r\n{\r\n    return normalize(pos / (ra * ra));\r\n}\n\n#define PI 3.1415926538\n\n#define ATMOS_HEIGHT float(${ATMOS_HEIGHT})\r\n#define RAYLEIGH_SCALE float(${RAYLEIGH_SCALE})\r\n#define MIE_SCALE float(${MIE_SCALE})\n\n#define SAMPLE_COUNT 16\r\n#define SQRT_SAMPLE_COUNT 4\n\nconst float GROUND_ALBEDO = float(${GROUND_ALBEDO}) / PI;\n\nconst float BOTTOM_RADIUS = float(${BOTTOM_RADIUS});\r\nconst float TOP_RADIUS = BOTTOM_RADIUS + ATMOS_HEIGHT;\r\nconst float EQUATORIAL_RADIUS = 6378137.0;\n\nconst vec3 bottomRadii = vec3(EQUATORIAL_RADIUS, EQUATORIAL_RADIUS, BOTTOM_RADIUS);\r\nconst vec3 topRadii = bottomRadii + ATMOS_HEIGHT;\n\nconst vec3 SPHERE_TO_ELLIPSOID_SCALE = vec3(BOTTOM_RADIUS) / bottomRadii;\n\nconst vec2 rayleighMieHeights = vec2(RAYLEIGH_SCALE, MIE_SCALE) * ATMOS_HEIGHT;\n\nconst vec3 rayleighScatteringCoefficient = vec3(float(${rayleighScatteringCoefficient_0}), float(${rayleighScatteringCoefficient_1}), float(${rayleighScatteringCoefficient_2})) * 1e-6;\n\nconst float mieScatteringCoefficient = float(${mieScatteringCoefficient}) * 1e-6;\r\nconst float mieExtinctionCoefficient = float(${mieExtinctionCoefficient}) * 1e-6;\r\nconst vec3 ozoneAbsorptionCoefficient = vec3(float(${ozoneAbsorptionCoefficient_0}), float(${ozoneAbsorptionCoefficient_1}), float(${ozoneAbsorptionCoefficient_2})) * 1e-6;\n\nconst float SUN_ANGULAR_RADIUS = float(${SUN_ANGULAR_RADIUS});\r\nconst float SUN_INTENSITY = float(${SUN_INTENSITY});\n\nconst float ozoneDensityHeight = float(${ozoneDensityHeight}); \nconst float ozoneDensityWide = float(${ozoneDensityWide}); \n\nvec3 sunWithBloom(vec3 rayDir, vec3 sunDir)\r\n{\r\n    float minSunCosTheta = cos(SUN_ANGULAR_RADIUS);\r\n    float cosTheta = dot(rayDir, sunDir);\n\n    if (cosTheta >= minSunCosTheta)\r\n        return vec3(1.0);\n\n    float offset = minSunCosTheta - cosTheta;\r\n    float gaussianBloom = exp(- offset * 15000.0) * 0.7;\r\n    float invBloom = 1.0 / (0.09 + offset * 200.0) * 0.01;\n\n    return vec3(gaussianBloom + invBloom);\r\n}\n\nfloat rayleighPhase(float angle)\r\n{\r\n    return 3.0 / (16.0 * PI) * (1.0 + (angle * angle));\r\n}\n\nfloat miePhase(float angle)\r\n{\r\n    float g = 0.8;\r\n    return 3.0 / (8.0 * PI) * ((1.0 - g * g) * (1.0 + angle * angle)) / ((2.0 + g * g) * pow(1.0 + g * g - 2.0 * g * angle, 1.5));\r\n}\n\nvec3 opticalDepth(float height, float angle)\r\n{\r\n    vec3 rayOrigin = vec3(0.0, BOTTOM_RADIUS + height, 0.0);\r\n    vec3 rayDirection = vec3(sqrt(1.0 - angle * angle), angle, 0.0);\n\n    float t1, t2;\r\n    intersectSphere(rayOrigin, rayDirection, TOP_RADIUS, t1, t2);\r\n    float segmentLength = t2 / float(SAMPLE_COUNT);\n\n    float t = segmentLength * 0.5;\r\n    vec3 opticalDepth = vec3(0.0);\n\n    for (int i = 0; i < SAMPLE_COUNT; i++)\r\n    {\r\n        vec3 position = rayOrigin + t * rayDirection;\r\n        float height = length(position) - BOTTOM_RADIUS;\r\n        opticalDepth.xy += exp(-height / rayleighMieHeights) * segmentLength;\r\n        opticalDepth.z += (1.0 - min(abs(height - ozoneDensityHeight) / ozoneDensityWide, 1.0)) * segmentLength;\r\n        t += segmentLength;\r\n    }\n\n    return opticalDepth;\r\n}\n\nvec3 transmittance(float height, float angle)\r\n{\r\n    vec3 opticalDepth = opticalDepth(height, angle);\r\n    return exp(-(rayleighScatteringCoefficient * opticalDepth.x + mieExtinctionCoefficient * opticalDepth.y + ozoneAbsorptionCoefficient * opticalDepth.z));\r\n}\n\nuniform sampler2D transmittanceTexture;\r\nuniform vec2 iResolution;\n\nvec3 transmittanceFromTexture(float height, float angle)\r\n{\r\n    float u = (angle + 1.0) * 0.5;\r\n    float v = height / ATMOS_HEIGHT;\r\n    return texture2D(transmittanceTexture, vec2(u, v)).xyz;\r\n}\n\nvoid main(void)\r\n{\r\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n    float height = uv.y * ATMOS_HEIGHT;\r\n    float angle = uv.x * 2.0 - 1.0;\n\n    vec3 rayOrigin = vec3(0.0, BOTTOM_RADIUS + height, 0.0);\r\n    vec3 up = rayOrigin / length(rayOrigin);\r\n    vec3 lightDirection = vec3(sqrt(1.0 - angle * angle), angle, 0.0);\n\n    const float isotropicPhase = 1.0 / (4.0 * PI);\n\n    vec3 light = vec3(0.0);\r\n    vec3 lightTransferFactor = vec3(0.0);\n\n    for (int i = 0; i < SQRT_SAMPLE_COUNT; i++)\r\n    {\r\n        for (int j = 0; j < SQRT_SAMPLE_COUNT; j++)\r\n        {\r\n            float u = ((0.5 + float(i)) / float(SQRT_SAMPLE_COUNT)) * 2.0 - 1.0;\r\n            float v = (0.5 + float(j)) / float(SQRT_SAMPLE_COUNT);\r\n            float r = sqrt(1.0 - u * u);\r\n            float theta = 2.0 * PI * v;\r\n            vec3 rayDirection = vec3(cos(theta) * r, sin(theta) * r, u);\n\n            float rayAngle = dot(up, rayDirection);\r\n            bool cameraBelow = rayAngle < 0.0;\n\n            vec3 transmittanceFromCameraToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);\n\n            float offset = 0.0;\r\n            float distanceToSpace = 0.0;\n\n            intersectSphere(rayOrigin, rayDirection, TOP_RADIUS, offset, distanceToSpace);\n\n            float distanceToGround = 0.0;\r\n            bool hitGround = intersectSphere(rayOrigin, rayDirection, BOTTOM_RADIUS, distanceToGround) && distanceToGround > 0.0;\r\n            float segmentLength = (hitGround ? distanceToGround : distanceToSpace) / float(SAMPLE_COUNT);\r\n            float t = segmentLength * 0.5;\n\n            vec3 transmittanceCamera;\r\n            vec3 transmittanceLight;\n\n            for (int k = 0; k < SAMPLE_COUNT; k++)\r\n            {\r\n                vec3 position = rayOrigin + t * rayDirection;\r\n                float height = length(position) - BOTTOM_RADIUS;\r\n                vec3 up = position / length(position);\r\n                float rayAngle = dot(up, rayDirection);\r\n                float lightAngle = dot(up, lightDirection);\n\n                float distanceToGround;\r\n                float shadow = intersectSphere(position, lightDirection, BOTTOM_RADIUS, distanceToGround) && distanceToGround >= 0.0 ? 0.0 : 1.0;\r\n                vec3 transmittanceToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);\n\n                transmittanceCamera = cameraBelow ? (transmittanceToSpace / transmittanceFromCameraToSpace) : (transmittanceFromCameraToSpace / transmittanceToSpace);\r\n                transmittanceLight = transmittanceFromTexture(height, lightAngle);\n\n                vec2 opticalDensity = exp(-height / rayleighMieHeights);\r\n                vec3 scatteredLight = transmittanceLight * (rayleighScatteringCoefficient * opticalDensity.x + mieScatteringCoefficient * opticalDensity.y) * isotropicPhase;\n\n                light += shadow * transmittanceCamera * scatteredLight * segmentLength;\r\n                lightTransferFactor += transmittanceCamera * (rayleighScatteringCoefficient * opticalDensity.x + mieScatteringCoefficient * opticalDensity.y) * segmentLength;\n\n                t += segmentLength;\r\n            }\n\n            if (hitGround)\r\n            {\r\n                vec3 hitPoint = rayOrigin + rayDirection * distanceToGround;\r\n                vec3 normal = normalize(hitPoint);\r\n                float diffuseAngle = max(dot(normal, lightDirection), 0.0);\r\n                light += transmittanceCamera * transmittanceLight * GROUND_ALBEDO * diffuseAngle;\r\n            }\r\n        }\r\n    }\n\n    light /= float(SAMPLE_COUNT);\r\n    lightTransferFactor /= float(SAMPLE_COUNT);\r\n    vec3 color = light / (1.0 - lightTransferFactor);\r\n    gl_FragColor = vec4(color, 1.0);\r\n}";
function o_(e4) {
  return new Yr("transmittance", { uniforms: { iResolution: "vec2" }, attributes: { a_position: "vec2" }, vertexShader: i_, fragmentShader: gt(s_, e4) });
}
function a_(e4) {
  return new Yr("scattering", { uniforms: { iResolution: "vec2", transmittanceTexture: "sampler2d" }, attributes: { a_position: "vec2" }, vertexShader: r_, fragmentShader: gt(n_, e4) });
}
class l_ {
  constructor(e4, t2 = {}) {
    this.handler = e4;
    this._fbo = null;
    this._width = t2.width || e4.canvas.width;
    this._height = t2.height || e4.canvas.height;
    this._depthComponent = t2.depthComponent != void 0 ? t2.depthComponent : "DEPTH_COMPONENT16";
    this._useDepth = t2.useDepth != void 0 ? t2.useDepth : true;
    this._active = false;
    this._size = t2.size || 1;
    this._depthRenderbuffer = null;
    this._filter = t2.filter || "NEAREST";
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  setSize(e4, t2, i2 = false) {
    this._width = e4;
    this._height = t2;
    if (this._active) {
      this.handler.gl.viewport(0, 0, this._width, this._height);
    }
    if (this._useDepth || i2) {
      this.destroy();
      this.init();
    }
  }
  init() {
  }
  destroy() {
  }
  isComplete() {
    let e4 = this.handler.gl;
    return e4.checkFramebufferStatus(e4.FRAMEBUFFER) === e4.FRAMEBUFFER_COMPLETE;
  }
  checkStatus() {
    let e4 = this.handler.gl;
    return e4.checkFramebufferStatus(e4.FRAMEBUFFER);
  }
  activate() {
    let e4 = this.handler.gl;
    e4.bindFramebuffer(e4.FRAMEBUFFER, null);
    e4.bindFramebuffer(e4.FRAMEBUFFER, this._fbo);
    e4.viewport(0, 0, this._width, this._height);
    this._active = true;
    let t2 = this.handler.framebufferStack.current().data;
    t2 && (t2._active = false);
    this.handler.framebufferStack.push(this);
    return this;
  }
  deactivate() {
    let e4 = this.handler, t2 = e4.gl;
    t2.bindFramebuffer(t2.FRAMEBUFFER, null);
    this._active = false;
    let i2 = this.handler.framebufferStack.popPrev();
    if (i2) {
      t2.bindFramebuffer(t2.FRAMEBUFFER, i2._fbo);
      t2.viewport(0, 0, i2._width, i2._height);
    } else {
      t2.viewport(0, 0, e4.canvas.width, e4.canvas.height);
    }
  }
}
class h_ {
  constructor(e4 = 256, t2 = 256) {
    this._canvas = document.createElement("canvas");
    this._canvas.width = e4;
    this._canvas.height = t2;
    this._context = this._canvas.getContext("2d", { willReadFrequently: true });
  }
  getCanvas() {
    return this._canvas;
  }
  getContext() {
    return this._context;
  }
  fillEmpty() {
    let e4 = this._context.getImageData(0, 0, this._canvas.width, this._canvas.height);
    let t2 = e4.data;
    for (let e5 = 0, i2 = t2.length; e5 < i2; e5 += 4) {
      t2[e5] = t2[e5 + 1] = t2[e5 + 2] = t2[e5 + 3] = 0;
    }
    this._context.putImageData(e4, 0, 0);
  }
  fill(e4) {
    this._context.fillStyle = e4;
    this._context.fill();
  }
  getData() {
    let e4 = this._context.getImageData(0, 0, this._canvas.width, this._canvas.height);
    return e4.data;
  }
  fillColor(e4) {
    this._context.fillStyle = e4;
    this._context.fillRect(0, 0, this._canvas.width, this._canvas.height);
  }
  setData(e4) {
    let t2 = this._context.createImageData(this._canvas.width, this._canvas.height);
    t2.data.set(e4);
    this._context.putImageData(t2, 0, 0);
  }
  resize(e4, t2) {
    this._canvas.width = e4;
    this._canvas.height = t2;
    this._context = this._canvas.getContext("2d");
  }
  drawImage(e4, t2, i2, s2, r2) {
    this._context.drawImage(e4, t2 || 0, i2 || 0, s2 || e4.width, r2 || e4.height);
  }
  getImage() {
    let e4 = new Image();
    e4.width = this.getWidth();
    e4.height = this.getHeight();
    e4.src = this._canvas.toDataURL("image/png");
    return e4;
  }
  getTextWidth(e4) {
    let t2 = this._context.measureText(e4);
    return Math.round(t2.width);
  }
  drawText(e4, t2 = 0, i2 = 14, s2 = "normal 14px Verdana", r2 = "black") {
    this._context.fillStyle = r2;
    this._context.font = s2;
    this._context.fillText(e4, t2, i2);
  }
  getWidth() {
    return this._canvas.width;
  }
  getHeight() {
    return this._canvas.height;
  }
  load(e4, t2) {
    let i2 = new Image();
    let s2 = this;
    i2.onload = function() {
      s2.resize(i2.width, i2.height);
      s2._context.drawImage(i2, 0, 0, i2.width, i2.height);
      t2 && t2(i2);
    };
    i2.src = e4;
  }
  openImage() {
    let e4 = this.getImage();
    let t2 = e4.src;
    let i2 = "<!DOCTYPE html>";
    i2 += "<html>";
    i2 += "<head><title>Print</title></head>";
    i2 += "<body>";
    i2 += '<img src="' + t2 + '">';
    i2 += "</body>";
    i2 += "</html>";
    let s2 = window.open("", "", "width=" + e4.width + "px ,height=" + e4.height + "px");
    if (s2) {
      s2.document.open();
      s2.document.write(i2);
      s2.document.close();
      s2.focus();
    }
  }
  destroy() {
    this._canvas.width = 1;
    this._canvas.height = 1;
    this._canvas = null;
    this._context = null;
  }
}
const c_ = { UNSIGNED_BYTE: Uint8Array, FLOAT: Float32Array };
function d_(e4, t2, i2) {
  return new Promise((s2, r2) => {
    function n2() {
      const o2 = e4.clientWaitSync(t2, i2, 0);
      if (o2 == e4.WAIT_FAILED) {
        r2();
      } else if (o2 == e4.TIMEOUT_EXPIRED) {
        requestAnimationFrame(n2);
      } else {
        s2();
      }
    }
    n2();
  });
}
class u_ extends l_ {
  constructor(e4, t2 = {}) {
    super(e4, t2);
    this.readPixelBuffersAsync = (e5) => {
      const t3 = this.handler.gl;
      if (this._skipFrame) return;
      this._skipFrame = true;
      let i2 = this.width, s2 = this.height;
      let r2 = this.pixelBuffers;
      this.activate();
      for (let e6 = 0; e6 < r2.length; e6++) {
        let n3 = r2[e6];
        t3.bindBuffer(t3.PIXEL_PACK_BUFFER, n3.buffer);
        t3.bufferData(t3.PIXEL_PACK_BUFFER, n3.data.byteLength, t3.STREAM_READ);
        t3.readBuffer(n3.glAttachment);
        t3.readPixels(0, 0, i2, s2, t3.RGBA, n3.glType, 0);
        t3.bindBuffer(t3.PIXEL_PACK_BUFFER, null);
      }
      this.deactivate();
      const n2 = t3.fenceSync(t3.SYNC_GPU_COMMANDS_COMPLETE, 0);
      t3.flush();
      d_(t3, n2, 0).then(() => {
        this._skipFrame = false;
        t3.deleteSync(n2);
        for (let i3 = 0; i3 < r2.length; i3++) {
          let s3 = r2[i3];
          if (s3.data) {
            t3.bindBuffer(t3.PIXEL_PACK_BUFFER, s3.buffer);
            t3.getBufferSubData(t3.PIXEL_PACK_BUFFER, 0, s3.data);
            e5 && e5(this);
          }
        }
        t3.bindBuffer(t3.PIXEL_PACK_BUFFER, null);
      });
    };
    this._targets = u_.createTargets(t2.targets);
    this._size = this._targets.length;
    this._renderbufferTarget = t2.renderbufferTarget != void 0 ? t2.renderbufferTarget : "DEPTH_ATTACHMENT";
    this.textures = t2.textures || new Array(this._size);
    this.pixelBuffers = [];
    this._skipFrame = false;
  }
  static createTargets(e4) {
    let t2 = 0;
    let i2 = 0;
    if (e4) {
      return e4.map((e5) => {
        let s2 = e5.attachment || "COLOR_ATTACHMENT";
        if (s2 === "COLOR_ATTACHMENT") {
          s2 = `COLOR_ATTACHMENT${t2++}`;
        }
        let r2 = e5.type || "UNSIGNED_BYTE";
        return { internalFormat: e5.internalFormat || "RGBA", format: e5.format || "RGBA", type: r2, attachment: s2, filter: e5.filter || "NEAREST", pixelBufferIndex: e5.readAsync ? i2++ : -1, TypeArrayConstructor: c_[r2] };
      });
    }
    return [{ internalFormat: "RGBA", format: "RGBA", type: "UNSIGNED_BYTE", attachment: "COLOR_ATTACHMENT0", filter: "NEAREST", pixelBufferIndex: -1, TypeArrayConstructor: c_.UNSIGNED_BYTE }];
  }
  destroy() {
    let e4 = this.handler.gl;
    if (!e4) return;
    for (let t2 = 0; t2 < this.textures.length; t2++) {
      e4.deleteTexture(this.textures[t2]);
    }
    this.textures = new Array(this._size);
    for (let t2 = 0; t2 < this.pixelBuffers.length; t2++) {
      this.pixelBuffers[t2].data = null;
      e4.deleteBuffer(this.pixelBuffers[t2].buffer);
    }
    this.pixelBuffers = [];
    e4.deleteFramebuffer(this._fbo);
    e4.deleteRenderbuffer(this._depthRenderbuffer);
    this._depthRenderbuffer = null;
    this._fbo = null;
    this._active = false;
  }
  init() {
    let e4 = this.handler.gl;
    if (!e4) return;
    this._fbo = e4.createFramebuffer();
    e4.bindFramebuffer(e4.FRAMEBUFFER, this._fbo);
    let t2 = [];
    for (let i2 = 0; i2 < this._targets.length; i2++) {
      let s2 = this._targets[i2];
      let r2 = this.textures[i2] || this.handler.createEmptyTexture2DExt(this._width, this._height, s2.filter, s2.internalFormat, s2.format, s2.type);
      let n2 = e4[s2.attachment];
      if (r2) {
        this.bindOutputTexture(r2, n2);
        this.textures[i2] = r2;
      }
      if (s2.attachment !== "DEPTH_ATTACHMENT") {
        t2.push(n2);
      }
      if (s2.pixelBufferIndex !== -1) {
        this._createPixelBuffer(s2);
      }
    }
    e4.drawBuffers && e4.drawBuffers(t2);
    if (this._useDepth) {
      this._depthRenderbuffer = e4.createRenderbuffer();
      e4.bindRenderbuffer(e4.RENDERBUFFER, this._depthRenderbuffer);
      e4.renderbufferStorage(e4.RENDERBUFFER, e4[this._depthComponent], this._width, this._height);
      e4.framebufferRenderbuffer(e4.FRAMEBUFFER, e4[this._renderbufferTarget], e4.RENDERBUFFER, this._depthRenderbuffer);
      e4.bindRenderbuffer(e4.RENDERBUFFER, null);
    }
    e4.bindFramebuffer(e4.FRAMEBUFFER, null);
  }
  getPixelBufferData(e4) {
    let t2 = this._targets[e4].pixelBufferIndex;
    return t2 !== -1 ? this.pixelBuffers[t2].data : null;
  }
  _createPixelBuffer(e4) {
    let t2 = this.handler.gl;
    let i2 = e4.pixelBufferIndex;
    let s2 = this.pixelBuffers[i2];
    if (!s2) {
      s2 = this.pixelBuffers[i2] = { buffer: null, data: null, glType: -1, glAttachment: -1 };
    }
    let r2 = this.width * this.height * 4;
    s2.data = null;
    s2.data = new e4.TypeArrayConstructor(r2);
    s2.buffer = t2.createBuffer();
    t2.bindBuffer(t2.PIXEL_PACK_BUFFER, s2.buffer);
    t2.bufferData(t2.PIXEL_PACK_BUFFER, r2, t2.STREAM_READ);
    t2.bindBuffer(t2.PIXEL_PACK_BUFFER, null);
    s2.glType = t2[e4.type];
    s2.glAttachment = t2[e4.attachment];
  }
  bindOutputTexture(e4, t2) {
    let i2 = this.handler.gl;
    i2.bindTexture(i2.TEXTURE_2D, e4);
    i2.framebufferTexture2D(i2.FRAMEBUFFER, t2 || i2.COLOR_ATTACHMENT0, i2.TEXTURE_2D, e4, 0);
    i2.bindTexture(i2.TEXTURE_2D, null);
  }
  readPixels(e4, t2, i2, s2 = 0, r2 = 1, n2 = 1) {
    let o2 = this.handler.gl;
    o2.bindFramebuffer(o2.FRAMEBUFFER, this._fbo);
    o2.readBuffer && o2.readBuffer(o2.COLOR_ATTACHMENT0 + s2 || 0);
    o2.readPixels(t2 * this._width, i2 * this._height, r2, n2, o2.RGBA, o2[this._targets[s2].type], e4);
    o2.bindFramebuffer(o2.FRAMEBUFFER, null);
  }
  readAllPixels(e4, t2 = 0) {
    let i2 = this.handler.gl;
    i2.bindFramebuffer(i2.FRAMEBUFFER, this._fbo);
    i2.readBuffer && i2.readBuffer(i2.COLOR_ATTACHMENT0 + t2);
    i2.readPixels(0, 0, this._width, this._height, i2.RGBA, i2[this._targets[t2].type], e4);
    i2.bindFramebuffer(i2.FRAMEBUFFER, null);
  }
  getImage() {
    let e4 = new Uint8Array(4 * this._width * this._height);
    this.readAllPixels(e4);
    let t2 = new h_(this._width, this._height);
    t2.setData(e4);
    return t2.getImage();
  }
  readData(e4, t2, i2, s2 = 0) {
    const r2 = this.width;
    const n2 = this.height;
    const o2 = Math.floor(e4 * (r2 - 1));
    const a2 = Math.floor(t2 * (n2 - 1));
    const l2 = (a2 * r2 + o2) * 4;
    const h2 = this.pixelBuffers[s2].data;
    if (h2) {
      i2[0] = h2[l2];
      i2[1] = h2[l2 + 1];
      i2[2] = h2[l2 + 2];
      i2[3] = h2[l2 + 3];
    }
  }
}
var __ = "attribute vec2 corners;\n\nvoid main(void) {\r\n    gl_Position = vec4(corners, 0.0, 1.0);\r\n}";
var f_ = "precision lowp float;\n\nfloat getLerpValue(in float min, in float max, in float between)\r\n{\r\n    return (clamp(between, min, max) - min) / (max - min);\r\n}\n\nvec3 aces(vec3 color)\r\n{\r\n    float a = 2.51;\r\n    float b = 0.03;\r\n    float c = 2.43;\r\n    float d = 0.59;\r\n    float e = 0.14;\r\n    return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);\r\n}\n\nbool intersectSphere(vec3 rayOrigin, vec3 rayDirection, float radius, inout float t1, inout float t2)\r\n{\r\n    float b = dot(rayDirection, rayOrigin);\r\n    float c = dot(rayOrigin, rayOrigin) - radius * radius;\r\n    float d = b * b - c;\r\n    if (d < 0.0) {\r\n        return false;\r\n    }\r\n    t1 = -b - sqrt(d);\r\n    t2 = -b + sqrt(d);\r\n    return true;\r\n}\n\nbool intersectSphere(vec3 rayOrigin, vec3 rayDirection, float radius, inout float t)\r\n{\r\n    float b = dot(rayDirection, rayOrigin);\r\n    float c = dot(rayOrigin, rayOrigin) - radius * radius;\r\n    float d = b * b - c;\r\n    if (d < 0.0) {\r\n        return false;\r\n    }\r\n    t = -b - sqrt(d);\r\n    return true;\r\n}\n\nfloat intersectSphere(vec3 ro, vec3 rd, vec4 sph)\r\n{\r\n    vec3 oc = ro - sph.xyz;\r\n    float b = dot(oc, rd);\r\n    float c = dot(oc, oc) - sph.w * sph.w;\r\n    float h = b * b - c;\r\n    if (h < 0.0) return -1.0;\r\n    h = sqrt(h);\r\n    return -b - h;\r\n}\n\nbool intersectEllipsoid(in vec3 ro, in vec3 rd, in vec3 ra, inout float t)\r\n{\r\n    vec3 ocn = ro / ra;\r\n    vec3 rdn = rd / ra;\r\n    float a = dot(rdn, rdn);\r\n    float b = dot(ocn, rdn);\r\n    float c = dot(ocn, ocn);\r\n    float h = b * b - a * (c - 1.0);\n\n    if (h < 0.0)\r\n    {\r\n        return false;\r\n    }\n\n    t = (-b - sqrt(h)) / a;\n\n    return true;\r\n}\n\nbool intersectEllipsoid(in vec3 ro, in vec3 rd, in vec3 ra, inout float t1, inout float t2)\r\n{\r\n    vec3 ocn = ro / ra;\r\n    vec3 rdn = rd / ra;\r\n    float a = dot(rdn, rdn);\r\n    float b = dot(ocn, rdn);\r\n    float c = dot(ocn, ocn);\r\n    float h = b * b - a * (c - 1.0);\n\n    if (h < 0.0)\r\n    {\r\n        return false;\r\n    }\n\n    h = sqrt(h);\r\n    t1 = (-b - h) / a;\r\n    t2 = (-b + h) / a;\n\n    return true;\r\n}\n\nvec3 normalEllipsoid(in vec3 pos, in vec3 ra)\r\n{\r\n    return normalize(pos / (ra * ra));\r\n}\n\n#define PI 3.1415926538\n\n#define ATMOS_HEIGHT float(${ATMOS_HEIGHT})\r\n#define RAYLEIGH_SCALE float(${RAYLEIGH_SCALE})\r\n#define MIE_SCALE float(${MIE_SCALE})\n\n#define SAMPLE_COUNT 16\r\n#define SQRT_SAMPLE_COUNT 4\n\nconst float GROUND_ALBEDO = float(${GROUND_ALBEDO}) / PI;\n\nconst float BOTTOM_RADIUS = float(${BOTTOM_RADIUS});\r\nconst float TOP_RADIUS = BOTTOM_RADIUS + ATMOS_HEIGHT;\r\nconst float EQUATORIAL_RADIUS = 6378137.0;\n\nconst vec3 bottomRadii = vec3(EQUATORIAL_RADIUS, EQUATORIAL_RADIUS, BOTTOM_RADIUS);\r\nconst vec3 topRadii = bottomRadii + ATMOS_HEIGHT;\n\nconst vec3 SPHERE_TO_ELLIPSOID_SCALE = vec3(BOTTOM_RADIUS) / bottomRadii;\n\nconst vec2 rayleighMieHeights = vec2(RAYLEIGH_SCALE, MIE_SCALE) * ATMOS_HEIGHT;\n\nconst vec3 rayleighScatteringCoefficient = vec3(float(${rayleighScatteringCoefficient_0}), float(${rayleighScatteringCoefficient_1}), float(${rayleighScatteringCoefficient_2})) * 1e-6;\n\nconst float mieScatteringCoefficient = float(${mieScatteringCoefficient}) * 1e-6;\r\nconst float mieExtinctionCoefficient = float(${mieExtinctionCoefficient}) * 1e-6;\r\nconst vec3 ozoneAbsorptionCoefficient = vec3(float(${ozoneAbsorptionCoefficient_0}), float(${ozoneAbsorptionCoefficient_1}), float(${ozoneAbsorptionCoefficient_2})) * 1e-6;\n\nconst float SUN_ANGULAR_RADIUS = float(${SUN_ANGULAR_RADIUS});\r\nconst float SUN_INTENSITY = float(${SUN_INTENSITY});\n\nconst float ozoneDensityHeight = float(${ozoneDensityHeight}); \nconst float ozoneDensityWide = float(${ozoneDensityWide}); \n\nvec3 sunWithBloom(vec3 rayDir, vec3 sunDir)\r\n{\r\n    float minSunCosTheta = cos(SUN_ANGULAR_RADIUS);\r\n    float cosTheta = dot(rayDir, sunDir);\n\n    if (cosTheta >= minSunCosTheta)\r\n        return vec3(1.0);\n\n    float offset = minSunCosTheta - cosTheta;\r\n    float gaussianBloom = exp(- offset * 15000.0) * 0.7;\r\n    float invBloom = 1.0 / (0.09 + offset * 200.0) * 0.01;\n\n    return vec3(gaussianBloom + invBloom);\r\n}\n\nfloat rayleighPhase(float angle)\r\n{\r\n    return 3.0 / (16.0 * PI) * (1.0 + (angle * angle));\r\n}\n\nfloat miePhase(float angle)\r\n{\r\n    float g = 0.8;\r\n    return 3.0 / (8.0 * PI) * ((1.0 - g * g) * (1.0 + angle * angle)) / ((2.0 + g * g) * pow(1.0 + g * g - 2.0 * g * angle, 1.5));\r\n}\n\nvec3 opticalDepth(float height, float angle)\r\n{\r\n    vec3 rayOrigin = vec3(0.0, BOTTOM_RADIUS + height, 0.0);\r\n    vec3 rayDirection = vec3(sqrt(1.0 - angle * angle), angle, 0.0);\n\n    float t1, t2;\r\n    intersectSphere(rayOrigin, rayDirection, TOP_RADIUS, t1, t2);\r\n    float segmentLength = t2 / float(SAMPLE_COUNT);\n\n    float t = segmentLength * 0.5;\r\n    vec3 opticalDepth = vec3(0.0);\n\n    for (int i = 0; i < SAMPLE_COUNT; i++)\r\n    {\r\n        vec3 position = rayOrigin + t * rayDirection;\r\n        float height = length(position) - BOTTOM_RADIUS;\r\n        opticalDepth.xy += exp(-height / rayleighMieHeights) * segmentLength;\r\n        opticalDepth.z += (1.0 - min(abs(height - ozoneDensityHeight) / ozoneDensityWide, 1.0)) * segmentLength;\r\n        t += segmentLength;\r\n    }\n\n    return opticalDepth;\r\n}\n\nvec3 transmittance(float height, float angle)\r\n{\r\n    vec3 opticalDepth = opticalDepth(height, angle);\r\n    return exp(-(rayleighScatteringCoefficient * opticalDepth.x + mieExtinctionCoefficient * opticalDepth.y + ozoneAbsorptionCoefficient * opticalDepth.z));\r\n}\n\nuniform mat4 viewMatrix;\r\nuniform vec3 sunPos;\r\nuniform vec3 camPos;\r\nuniform vec2 iResolution;\r\nuniform float fov;\r\nuniform float opacity;\n\nuniform sampler2D transmittanceTexture;\r\nuniform sampler2D scatteringTexture;\n\nvec3 transmittanceFromTexture(float height, float angle)\r\n{\r\n    float u = (angle + 1.0) * 0.5;\r\n    float v = height / ATMOS_HEIGHT;\r\n    return texture2D(transmittanceTexture, vec2(u, v)).xyz;\r\n}\n\nvec3 multipleScatteringContributionFromTexture(float height, float angle)\r\n{\r\n    float u = (angle + 1.0) * 0.5;\r\n    float v = height / ATMOS_HEIGHT;\r\n    return texture2D(scatteringTexture, vec2(u, v)).xyz;\r\n}\n\nbool intersectEllipsoidToSphere(in vec3 ro, in vec3 rd, in vec3 ellRadii, in float sphereRadius, out float t1, out float t2)\r\n{\r\n    float offset = 0.0,\r\n    distanceToSpace = 0.0;\n\n    if (intersectEllipsoid(ro, rd, ellRadii, offset, distanceToSpace)) {\r\n        vec3 hitEll = ro + rd * offset;\r\n        vec3 nEll = normalEllipsoid(hitEll, ellRadii);\r\n        float t = 0.0;\r\n        bool intersectsSphere = intersectSphere(hitEll, nEll, sphereRadius, t);\r\n        vec3 hitSphere = hitEll + nEll * t;\r\n        t1 = length(hitSphere - ro);\n\n        hitEll = ro + rd * distanceToSpace;\r\n        nEll = normalEllipsoid(hitEll, ellRadii);\r\n        t = 0.0;\r\n        intersectsSphere = intersectSphere(hitEll, nEll, sphereRadius, t);\r\n        hitSphere = hitEll + nEll * t;\r\n        t2 = length(hitSphere - ro);\n\n        return true;\r\n    }\r\n    return false;\r\n}\n\nmat4 transpose(in mat4 m)\r\n{\r\n    vec4 i0 = m[0];\r\n    vec4 i1 = m[1];\r\n    vec4 i2 = m[2];\r\n    vec4 i3 = m[3];\n\n    mat4 outMatrix = mat4(\r\n    vec4(i0.x, i1.x, i2.x, i3.x),\r\n    vec4(i0.y, i1.y, i2.y, i3.y),\r\n    vec4(i0.z, i1.z, i2.z, i3.z),\r\n    vec4(i0.w, i1.w, i2.w, i3.w)\r\n    );\n\n    return outMatrix;\r\n}\n\nvoid mainImage(out vec4 fragColor)\r\n{\r\n    vec3 cameraPosition = camPos;\n\n    vec3 lightDirection = normalize(sunPos);\n\n    vec2 uv = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.y;\r\n    float fieldOfView = fov;\r\n    float z = 1.0 / tan(fieldOfView * 0.5 * PI / 180.0);\r\n    vec3 rayDirection = normalize(vec3(uv, -z));\r\n    vec4 rd = transpose(viewMatrix) * vec4(rayDirection, 1.0);\r\n    rayDirection = rd.xyz;\n\n    vec3 light = vec3(0.0);\r\n    vec3 transmittanceFromCameraToSpace = vec3(1.0);\r\n    float offset = 0.0;\r\n    float distanceToSpace = 0.0;\n\n    rayDirection = normalize(rayDirection * SPHERE_TO_ELLIPSOID_SCALE);\r\n    cameraPosition *= SPHERE_TO_ELLIPSOID_SCALE;\r\n    lightDirection = normalize(lightDirection * SPHERE_TO_ELLIPSOID_SCALE);\n\n    if (length(cameraPosition) < BOTTOM_RADIUS + 100.0) {\r\n        cameraPosition = normalize(cameraPosition) * (BOTTOM_RADIUS + 100.0);\r\n    }\n\n    if (intersectSphere(cameraPosition, rayDirection, TOP_RADIUS, offset, distanceToSpace))\r\n    {\r\n        vec3 rayOrigin = cameraPosition;\n\n        \n        if (offset > 0.0) {\r\n            \n            rayOrigin = cameraPosition + rayDirection * offset;\r\n        }\n\n        float height = length(rayOrigin) - BOTTOM_RADIUS;\r\n        float rayAngle = dot(rayOrigin, rayDirection) / length(rayOrigin);\r\n        bool cameraBelow = rayAngle < 0.0;\n\n        transmittanceFromCameraToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);\n\n        float phaseAngle = dot(lightDirection, rayDirection);\r\n        float rayleighPhase = rayleighPhase(phaseAngle);\r\n        float miePhase = miePhase(phaseAngle);\n\n        float distanceToGround = 0.0;\n\n        bool hitGround = intersectSphere(cameraPosition, rayDirection, BOTTOM_RADIUS, distanceToGround) && distanceToGround > 0.0;\n\n        if (intersectSphere(cameraPosition, rayDirection, BOTTOM_RADIUS - 100000.0, distanceToGround) && hitGround)\r\n        {\r\n            discard;\r\n        }\n\n        float segmentLength = ((hitGround ? distanceToGround : distanceToSpace) - max(offset, 0.0)) / float(SAMPLE_COUNT);\n\n        float t = segmentLength * 0.5;\n\n        vec3 transmittanceCamera;\r\n        vec3 transmittanceLight;\n\n        for (int i = 0; i < SAMPLE_COUNT; i++)\r\n        {\r\n            vec3 position = rayOrigin + t * rayDirection;\r\n            float height = length(position) - BOTTOM_RADIUS;\r\n            vec3 up = position / length(position);\r\n            float rayAngle = dot(up, rayDirection);\r\n            float lightAngle = dot(up, lightDirection);\r\n            vec3 transmittanceToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);\r\n            transmittanceCamera = cameraBelow ? (transmittanceToSpace / transmittanceFromCameraToSpace) : (transmittanceFromCameraToSpace / transmittanceToSpace);\r\n            transmittanceLight = transmittanceFromTexture(height, lightAngle);\r\n            vec2 opticalDensity = exp(-height / rayleighMieHeights);\r\n            vec3 scatteredLight = transmittanceLight * (rayleighScatteringCoefficient * opticalDensity.x * rayleighPhase + mieScatteringCoefficient * opticalDensity.y * miePhase);\r\n            scatteredLight += multipleScatteringContributionFromTexture(height, lightAngle) * (rayleighScatteringCoefficient * opticalDensity.x + mieScatteringCoefficient * opticalDensity.y);\r\n            light += transmittanceCamera * scatteredLight * segmentLength;\r\n            t += segmentLength;\r\n        }\n\n        light *= SUN_INTENSITY;\n\n        if (hitGround)\r\n        {\r\n            vec3 hitPoint = cameraPosition + rayDirection * distanceToGround;\r\n            vec3 up = hitPoint / length(hitPoint);\r\n            float diffuseAngle = max(dot(up, lightDirection), 0.0);\r\n            float lightAngle = dot(up, lightDirection);\r\n            light += transmittanceCamera * GROUND_ALBEDO * multipleScatteringContributionFromTexture(height, lightAngle) * SUN_INTENSITY;\r\n            light += transmittanceCamera * transmittanceLight * GROUND_ALBEDO * diffuseAngle * SUN_INTENSITY;\r\n        }\r\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    float distanceToGround = 0.0;\r\n    bool hitGround = intersectSphere(cameraPosition, rayDirection, BOTTOM_RADIUS, distanceToGround) && distanceToGround > 0.0;\r\n    if (!hitGround)\r\n    {\r\n        vec3 sunLum = sunWithBloom(rayDirection, lightDirection) * vec3(1.0, 1.0, 0.8);\r\n        \n        sunLum = smoothstep(0.002, 1.0, sunLum);\r\n        light += sunLum * SUN_INTENSITY * transmittanceFromCameraToSpace;\r\n    }\n\n    fragColor = vec4(pow(light * 8.0, vec3(1.0 / 2.2)), clamp(opacity, 0.0, 1.0));\r\n}\n\nvoid main(void)\r\n{\r\n    mainImage(gl_FragColor);\r\n}";
class g_ extends ns {
  constructor(e4 = {}) {
    super({ name: "Atmosphere", ...e4 });
    this._transmittanceBuffer = null;
    this._scatteringBuffer = null;
    this.opacity = 1;
    this._parameters = { ATMOS_HEIGHT: e4.height || 1e5, RAYLEIGH_SCALE: e4.rayleighScale || 0.08, MIE_SCALE: e4.mieScale || 0.012, GROUND_ALBEDO: e4.groundAlbedo || 0.05, BOTTOM_RADIUS: e4.bottomRadius || 6356752314245179e-9, rayleighScatteringCoefficient_0: e4.rayleighScatteringCoefficient_0 || 5.802, rayleighScatteringCoefficient_1: e4.rayleighScatteringCoefficient_1 || 13.558, rayleighScatteringCoefficient_2: e4.rayleighScatteringCoefficient_2 || 33.1, mieScatteringCoefficient: e4.mieScatteringCoefficient || 3.996, mieExtinctionCoefficient: e4.mieExtinctionCoefficient || 4.44, ozoneAbsorptionCoefficient_0: e4.ozoneAbsorptionCoefficient_0 || 0.65, ozoneAbsorptionCoefficient_1: e4.ozoneAbsorptionCoefficient_1 || 1.881, ozoneAbsorptionCoefficient_2: e4.ozoneAbsorptionCoefficient_2 || 0.085, SUN_ANGULAR_RADIUS: e4.sunAngularRadius || 4685e-6, SUN_INTENSITY: e4.sunIntensity || 1, ozoneDensityHeight: e4.ozoneDensityHeight || 25e3, ozoneDensityWide: e4.ozoneDensityWide || 15e3 };
  }
  setParameters(e4) {
    this._parameters = JSON.parse(JSON.stringify(e4));
    this.initLookupTexturesShaders();
    this.drawLookupTextures();
    this.removeLookupTexturesShaders();
    this.initPlanetAtmosphereShader();
  }
  get parameters() {
    return JSON.parse(JSON.stringify(this._parameters));
  }
  initPlanetAtmosphereShader() {
    var _a2;
    (_a2 = this.planet) == null ? void 0 : _a2.initAtmosphereShader(this._parameters);
  }
  oninit() {
    if (this.renderer) {
      this._initLookupTextures();
      this.initLookupTexturesShaders();
      this.drawLookupTextures();
      this.removeLookupTexturesShaders();
      this.initBackgroundShader();
      this.activate();
    }
  }
  initLookupTexturesShaders() {
    if (this.renderer) {
      this.renderer.handler.addProgram(o_(this._parameters), true);
      this.renderer.handler.addProgram(a_(this._parameters), true);
    }
  }
  initBackgroundShader() {
    if (this.renderer) {
      this.renderer.handler.addProgram(p_(this._parameters), true);
    }
  }
  removeBackgroundShader() {
    if (this.renderer) {
      this.renderer.handler.removeProgram("atmosphereBackground");
    }
  }
  removeLookupTexturesShaders() {
    var _a2, _b;
    if (this.renderer) {
      let e4 = this.renderer.handler;
      if ((_a2 = this._scatteringBuffer) == null ? void 0 : _a2.isComplete()) {
        e4.removeProgram("scattering");
      }
      if ((_b = this._transmittanceBuffer) == null ? void 0 : _b.isComplete()) {
        e4.removeProgram("transmittance");
      }
    }
  }
  onactivate() {
    super.onactivate();
    this.planet && this.planet.events.on("draw", this._drawBackground, this);
  }
  ondeactivate() {
    super.ondeactivate();
    this.planet && this.planet.events.off("draw", this._drawBackground);
  }
  _initLookupTextures() {
    let e4 = 1024, t2 = 1024;
    this._transmittanceBuffer = new u_(this.renderer.handler, { width: e4, height: t2, useDepth: false, targets: [{ filter: "LINEAR", type: "FLOAT", internalFormat: "RGBA16F" }] });
    this._transmittanceBuffer.init();
    this._scatteringBuffer = new u_(this.renderer.handler, { width: e4, height: t2, useDepth: false, targets: [{ filter: "LINEAR", type: "FLOAT", internalFormat: "RGBA16F" }] });
    this._scatteringBuffer.init();
  }
  _renderLookupTextures() {
    if (!this.renderer) return;
    let e4 = this.renderer.screenFramePositionBuffer;
    let t2 = this.renderer.handler;
    let i2 = t2.gl;
    if (this._transmittanceBuffer) {
      this._transmittanceBuffer.activate();
      let s2 = t2.programs.transmittance;
      let r2 = s2._program.attributes;
      let n2 = s2._program.uniforms;
      s2.activate();
      i2.clearColor(0, 0, 0, 1);
      i2.clear(i2.COLOR_BUFFER_BIT | i2.DEPTH_BUFFER_BIT);
      i2.uniform2fv(n2.iResolution, [this._transmittanceBuffer.width, this._transmittanceBuffer.height]);
      i2.bindBuffer(i2.ARRAY_BUFFER, e4);
      i2.vertexAttribPointer(r2.a_position, e4.itemSize, i2.FLOAT, false, 0, 0);
      i2.drawArrays(i2.TRIANGLE_STRIP, 0, e4.numItems);
      this._transmittanceBuffer.deactivate();
    }
    if (this._scatteringBuffer && this._transmittanceBuffer) {
      this._scatteringBuffer.activate();
      let s2 = t2.programs.scattering;
      let r2 = s2._program.attributes;
      let n2 = s2._program.uniforms;
      s2.activate();
      i2.clearColor(0, 0, 0, 1);
      i2.clear(i2.COLOR_BUFFER_BIT | i2.DEPTH_BUFFER_BIT);
      i2.uniform2fv(n2.iResolution, [this._scatteringBuffer.width, this._scatteringBuffer.height]);
      i2.activeTexture(i2.TEXTURE0);
      i2.bindTexture(i2.TEXTURE_2D, this._transmittanceBuffer.textures[0]);
      i2.uniform1i(n2.transmittanceTexture, 0);
      i2.bindBuffer(i2.ARRAY_BUFFER, e4);
      i2.vertexAttribPointer(r2.a_position, e4.itemSize, i2.FLOAT, false, 0, 0);
      i2.drawArrays(i2.TRIANGLE_STRIP, 0, e4.numItems);
      this._scatteringBuffer.deactivate();
    }
  }
  drawLookupTextures() {
    this._renderLookupTextures();
  }
  _drawBackground() {
    let e4 = this.renderer.handler;
    let t2 = e4.programs.atmosphereBackground, i2 = t2._program, s2 = i2.uniforms, r2 = e4.gl;
    let n2 = this.renderer;
    let o2 = this.planet.camera;
    r2.disable(r2.DEPTH_TEST);
    t2.activate();
    r2.bindBuffer(r2.ARRAY_BUFFER, n2.screenFramePositionBuffer);
    r2.vertexAttribPointer(i2.attributes.corners, 2, r2.FLOAT, false, 0, 0);
    r2.activeTexture(r2.TEXTURE0);
    r2.bindTexture(r2.TEXTURE_2D, this._transmittanceBuffer.textures[0]);
    r2.uniform1i(s2.transmittanceTexture, 0);
    r2.activeTexture(r2.TEXTURE1);
    r2.bindTexture(r2.TEXTURE_2D, this._scatteringBuffer.textures[0]);
    r2.uniform1i(s2.scatteringTexture, 1);
    r2.uniformMatrix4fv(s2.viewMatrix, false, o2.getViewMatrix());
    let a2 = this.planet.sunPos;
    r2.uniform3fv(s2.sunPos, [a2.x, a2.y, a2.z]);
    r2.uniform3fv(s2.camPos, [o2.eye.x, o2.eye.y, o2.eye.z]);
    r2.uniform2fv(s2.iResolution, [n2.sceneFramebuffer.width, n2.sceneFramebuffer.height]);
    r2.uniform1f(s2.fov, o2.getViewAngle());
    r2.uniform1f(s2.opacity, this.opacity);
    r2.drawArrays(r2.TRIANGLE_STRIP, 0, 4);
    r2.enable(r2.DEPTH_TEST);
  }
}
function p_(e4) {
  return new Yr("atmosphereBackground", { uniforms: { iResolution: "vec2", fov: "float", camPos: "vec3", viewMatrix: "mat4", transmittanceTexture: "sampler2D", scatteringTexture: "sampler2D", sunPos: "vec3", opacity: "float" }, attributes: { corners: "vec3" }, vertexShader: __, fragmentShader: gt(f_, e4) });
}
const m_ = { DEGREES: "degrees", METERS: "m" };
let v_ = 0;
class y_ {
  constructor(e4) {
    this.id = v_++;
    this.code = e4.code;
    this.units = e4.units;
  }
  equal(e4) {
    return e4.id === this.id;
  }
}
const x_ = new y_({ code: "epsg:3857", units: m_.METERS });
class b_ {
  constructor(e4) {
    this.segment = e4;
    this.layers = [];
    this.tileOffsetArr = new Float32Array(e4.planet.SLICE_SIZE_4);
    this.layerOpacityArr = new Float32Array(e4.planet.SLICE_SIZE);
  }
  clear() {
    this.layers = null;
    this.tileOffsetArr = null;
    this.layerOpacityArr = null;
  }
  append(e4, t2) {
    let i2 = this.layers.length;
    this.layers.push(e4);
    this.layerOpacityArr[i2] = e4.screenOpacity;
    let s2 = i2 * 4;
    let r2 = e4.applyMaterial(t2);
    this.tileOffsetArr[s2] = r2[0];
    this.tileOffsetArr[s2 + 1] = r2[1];
    this.tileOffsetArr[s2 + 2] = r2[2];
    this.tileOffsetArr[s2 + 3] = r2[3];
  }
}
function w_(e4, t2, i2) {
  return Math.floor(Math.abs(i2 - e4) / t2);
}
function C_(e4, t2, i2, s2) {
  let r2 = 1 / (1 << i2);
  let n2 = s2.getWidth(), o2 = s2.getHeight();
  let a2 = n2 * r2, l2 = o2 * r2;
  let h2 = s2.southWest.lon + e4 * a2, c2 = s2.northEast.lat - t2 * l2;
  return new Ye(new be(h2, c2 - l2), new be(h2 + a2, c2));
}
const T_ = 0;
const E_ = 20;
const A_ = 300;
function L_(e4, t2 = Ge) {
  if (e4 > t2) {
    return E_;
  } else if (e4 < -t2) {
    return A_;
  }
  return T_;
}
let P_ = new Ke();
let S_ = new Ke();
let R_ = new Ke(), M_ = new Ke(), B_ = new Ke(), k_ = new Ke();
let I_ = new ar(), z_ = new ar();
const D_ = new Array(4);
D_[xs] = 0;
D_[bs] = 1;
D_[ws] = 1;
D_[Cs] = 0;
const F_ = new Array(4);
F_[xs] = false;
F_[bs] = true;
F_[ws] = false;
F_[Cs] = true;
class N_ {
  constructor(e4, t2, i2, s2) {
    this.isPole = false;
    this._tileGroup = T_;
    this._projection = x_;
    this.node = e4;
    this.planet = t2;
    this.handler = t2.renderer.handler;
    this.bsphere = new Zi();
    this._plainRadius = 0;
    this.bbox = new Xi();
    this._sw = new Ke();
    this._nw = new Ke();
    this._se = new Ke();
    this._ne = new Ke();
    this.centerNormal = new Ke();
    this._extent = this._extentMerc = s2;
    this._extentLonLat = new Ye();
    this.gridSize = t2.terrain.gridSizeByZoom[i2];
    this.fileGridSize = 0;
    this.tileZoom = i2;
    this.powTileZoom = 1 << i2;
    this.tileX = 0;
    this.tileXE = 0;
    this.tileXW = 0;
    this.tileYN = 0;
    this.tileYS = 0;
    this.tileY = 0;
    this.tileIndex = "";
    this.elevationData = null;
    this._assignTileIndexes();
    this.materials = [];
    this.plainReady = false;
    this.initialized = false;
    this.normalMapReady = false;
    this.terrainReady = false;
    this.terrainIsLoading = false;
    this.terrainExists = false;
    this.passReady = false;
    this.plainVertices = null;
    this.plainVerticesHigh = null;
    this.plainVerticesLow = null;
    this.plainNormals = null;
    this.terrainVertices = null;
    this.terrainVerticesHigh = null;
    this.terrainVerticesLow = null;
    this.noDataVertices = null;
    this.tempVertices = null;
    this.tempVerticesHigh = null;
    this.tempVerticesLow = null;
    this.normalMapTexture = null;
    this.normalMapTextureBias = new Float32Array(3);
    this.normalMapVertices = null;
    this.normalMapVerticesHigh = null;
    this.normalMapVerticesLow = null;
    this.normalMapNormals = null;
    this.vertexNormalBuffer = null;
    this.vertexPositionBuffer = null;
    this.vertexPositionBufferHigh = null;
    this.vertexPositionBufferLow = null;
    this.vertexTextureCoordBuffer = null;
    this._globalTextureCoordinates = new Float32Array(4);
    this._inTheQueue = false;
    this._appliedNeighborsZoom = [0, 0, 0, 0];
    this._slices = [];
    this._indexBuffer = null;
    this.readyToEngage = false;
    this.plainProcessing = false;
    this.normalMapTexturePtr = null;
    this._transitionOpacity = 1;
    this._transitionTimestamp = 0;
  }
  checkZoom() {
    return this.tileZoom < this.planet.terrain._maxNodeZoom;
  }
  getEntityTerrainPoint(e4, t2) {
    return this.getTerrainPoint(e4._cartesian, this.getInsideLonLat(e4), t2);
  }
  getInsideLonLat(e4) {
    return e4._lonLatMerc;
  }
  isEntityInside(e4) {
    return this._extentLonLat.isInside(e4._lonLat);
  }
  getTerrainPoint(e4, t2, i2) {
    let s2 = this.tempVertices;
    if (s2 && s2.length) {
      let r2 = this.planet.ellipsoid.getSurfaceNormal3v(e4);
      I_.set(e4, r2.negateTo());
      let n2 = this._extent.northEast, o2 = this._extent.southWest, a2 = Math.sqrt(s2.length / 3) - 1;
      let l2 = n2.lon, h2 = n2.lat, c2 = o2.lon, d2 = o2.lat, u2 = t2.lon, _2 = t2.lat;
      let f2 = l2 - c2, g2 = h2 - d2;
      let p2 = f2 / a2, m2 = g2 / a2;
      let v2 = u2 - c2, y2 = _2 - d2;
      let x2 = Math.floor(v2 / p2), b2 = Math.floor(a2 - y2 / m2);
      let w2 = ((a2 + 1) * b2 + x2) * 3;
      let C2 = ((a2 + 1) * (b2 + 1) + x2) * 3;
      R_.set(s2[w2], s2[w2 + 1], s2[w2 + 2]);
      M_.set(s2[w2 + 3], s2[w2 + 4], s2[w2 + 5]);
      B_.set(s2[C2], s2[C2 + 1], s2[C2 + 2]);
      let T2 = I_.hitTriangleRes(R_, M_, B_, i2);
      if (T2 === ar.INSIDE) {
        return e4.distance(i2);
      } else if (T2 === ar.AWAY) {
        z_.set(e4, r2);
        let t3 = z_.hitTriangleRes(R_, M_, B_, i2);
        if (t3 === ar.INSIDE) {
          return -e4.distance(i2);
        }
      }
      k_.set(s2[C2 + 3], s2[C2 + 4], s2[C2 + 5]);
      T2 = I_.hitTriangleRes(M_, k_, B_, i2);
      if (T2 === ar.INSIDE) {
        return e4.distance(i2);
      } else if (T2 === ar.AWAY) {
        z_.set(e4, r2);
        let t3 = z_.hitTriangleRes(M_, k_, B_, i2);
        if (t3 === ar.INSIDE) {
          return -e4.distance(i2);
        }
      }
      if (T2 === ar.AWAY) {
        return -e4.distance(i2);
      }
      return e4.distance(i2);
    } else {
      return e4.distance(this.planet.ellipsoid.hitRay(I_.origin, I_.direction));
    }
  }
  projectNative(e4) {
    return e4.forwardMercator();
  }
  loadTerrain(e4 = false) {
    if (this.tileZoom < this.planet.terrain.minZoom || this.planet.terrain.isEmpty) {
      this.terrainIsLoading = true;
      this.elevationsNotExists();
      if (!this._inTheQueue) {
        this.planet._normalMapCreator.queue(this);
      }
    } else {
      if (this.tileZoom > this.planet.terrain.maxZoom) {
        this.elevationsNotExists();
      } else if (!this.terrainIsLoading && !this.terrainReady) {
        this.planet.terrain.loadTerrain(this, e4);
      }
    }
  }
  elevationsExists(e4) {
    if (this.plainReady && this.terrainIsLoading) {
      let t2 = new Float32Array(e4.length);
      t2.set(e4);
      this.elevationData = new Float32Array(e4.length);
      this.elevationData.set(e4);
      this.planet._terrainWorker.make({ segment: this, elevations: t2 });
      this.plainVerticesHigh = null;
      this.plainVerticesLow = null;
      this.normalMapVerticesHigh = null;
      this.normalMapVerticesLow = null;
      if (!this.planet.terrain.equalizeVertices) {
        this.tempVerticesHigh = null;
        this.tempVerticesLow = null;
      }
    }
  }
  elevationsNotExists() {
    if (this.planet && this.tileZoom <= this.planet.terrain.maxNativeZoom) {
      if (this.plainReady && this.terrainIsLoading) {
        this.terrainIsLoading = false;
        let e4 = this.node;
        e4.appliedTerrainNodeId = this.node.nodeId;
        e4.equalizedSideWithNodeId[xs] = e4.equalizedSideWithNodeId[bs] = e4.equalizedSideWithNodeId[ws] = e4.equalizedSideWithNodeId[Cs] = e4.appliedTerrainNodeId;
        if (this.planet.lightEnabled && !this._inTheQueue) {
          this.planet._normalMapCreator.queue(this);
        }
        this.readyToEngage = true;
      }
      this.terrainVertices = this.plainVertices;
      this.terrainVerticesHigh = this.plainVerticesHigh;
      this.terrainVerticesLow = this.plainVerticesLow;
      this.tempVertices = this.terrainVertices;
      this.tempVerticesHigh = this.terrainVerticesHigh;
      this.tempVerticesLow = this.terrainVerticesLow;
      this.noDataVertices = null;
      this.fileGridSize = Math.sqrt(this.terrainVertices.length / 3) - 1;
      this.gridSize = this.fileGridSize;
      this.terrainReady = true;
      this.terrainExists = false;
    } else {
      if (this.plainReady && this.terrainIsLoading) {
        this.terrainIsLoading = false;
        let e4 = this.node;
        e4.appliedTerrainNodeId = this.node.nodeId;
        e4.equalizedSideWithNodeId[xs] = e4.equalizedSideWithNodeId[bs] = e4.equalizedSideWithNodeId[ws] = e4.equalizedSideWithNodeId[Cs] = e4.appliedTerrainNodeId;
        this.readyToEngage = true;
        this.terrainReady = true;
        this.passReady = true;
        this.terrainExists = false;
      }
    }
  }
  _checkEqualization(e4, t2) {
    return t2 && t2.segment && this.tileZoom >= t2.segment.tileZoom && this.node.equalizedSideWithNodeId[e4] !== t2.equalizedSideWithNodeId[Ls[e4]];
  }
  equalize() {
    if (this.tileZoom < 2 || this.gridSize < 2) {
      return;
    }
    this.readyToEngage = true;
    let e4 = this.node.neighbors;
    let t2 = this.tempVertices, i2 = this.tempVerticesHigh, s2 = this.tempVerticesLow;
    let r2 = this.gridSize, n2 = r2 + 1;
    let o2 = e4[xs][0];
    if (this._checkEqualization(xs, o2)) {
      this.node.equalizedSideWithNodeId[xs] = o2.equalizedSideWithNodeId[ws];
      this.readyToEngage = true;
      let e5 = this.node.getOffsetOppositeNeighbourSide(o2, xs);
      let a2 = o2.segment.tempVertices, l2 = o2.segment.tempVerticesHigh, h2 = o2.segment.tempVerticesLow;
      let c2 = o2.segment.gridSize, d2 = c2 + 1;
      let u2 = 1 / (1 << this.tileZoom - o2.segment.tileZoom);
      let _2 = Math.max(r2 / (c2 * u2), 1), f2 = Math.max(c2 * u2 / r2, 1), g2 = e5 * c2;
      for (let e6 = 0, r3 = g2; e6 < n2; e6 += _2, r3 += f2) {
        const n3 = e6 * 3;
        const o3 = (d2 * c2 + r3) * 3;
        t2[n3] = a2[o3];
        t2[n3 + 1] = a2[o3 + 1];
        t2[n3 + 2] = a2[o3 + 2];
        i2[n3] = l2[o3];
        i2[n3 + 1] = l2[o3 + 1];
        i2[n3 + 2] = l2[o3 + 2];
        s2[n3] = h2[o3];
        s2[n3 + 1] = h2[o3 + 1];
        s2[n3 + 2] = h2[o3 + 2];
      }
    }
    o2 = e4[bs][0];
    if (this._checkEqualization(bs, o2)) {
      this.node.equalizedSideWithNodeId[bs] = o2.equalizedSideWithNodeId[Cs];
      this.readyToEngage = true;
      let e5 = this.node.getOffsetOppositeNeighbourSide(o2, bs);
      let a2 = o2.segment.tempVertices, l2 = o2.segment.tempVerticesHigh, h2 = o2.segment.tempVerticesLow;
      let c2 = o2.segment.gridSize, d2 = c2 + 1;
      let u2 = 1 / (1 << this.tileZoom - o2.segment.tileZoom);
      let _2 = Math.max(r2 / (c2 * u2), 1), f2 = Math.max(c2 * u2 / r2, 1), g2 = e5 * c2;
      for (let e6 = 0, o3 = g2; e6 < n2; e6 += _2, o3 += f2) {
        const c3 = (n2 * e6 + r2) * 3;
        const u3 = d2 * o3 * 3;
        t2[c3] = a2[u3];
        t2[c3 + 1] = a2[u3 + 1];
        t2[c3 + 2] = a2[u3 + 2];
        i2[c3] = l2[u3];
        i2[c3 + 1] = l2[u3 + 1];
        i2[c3 + 2] = l2[u3 + 2];
        s2[c3] = h2[u3];
        s2[c3 + 1] = h2[u3 + 1];
        s2[c3 + 2] = h2[u3 + 2];
      }
    }
    o2 = e4[ws][0];
    if (this._checkEqualization(ws, o2)) {
      this.node.equalizedSideWithNodeId[ws] = o2.equalizedSideWithNodeId[xs];
      this.readyToEngage = true;
      let e5 = this.node.getOffsetOppositeNeighbourSide(o2, ws);
      let a2 = o2.segment.tempVertices, l2 = o2.segment.tempVerticesHigh, h2 = o2.segment.tempVerticesLow;
      let c2 = o2.segment.gridSize;
      let d2 = 1 / (1 << this.tileZoom - o2.segment.tileZoom);
      let u2 = Math.max(r2 / (c2 * d2), 1), _2 = Math.max(c2 * d2 / r2, 1), f2 = e5 * c2;
      for (let e6 = 0, o3 = f2; e6 < n2; e6 += u2, o3 += _2) {
        const c3 = (n2 * r2 + e6) * 3;
        const d3 = o3 * 3;
        t2[c3] = a2[d3];
        t2[c3 + 1] = a2[d3 + 1];
        t2[c3 + 2] = a2[d3 + 2];
        i2[c3] = l2[d3];
        i2[c3 + 1] = l2[d3 + 1];
        i2[c3 + 2] = l2[d3 + 2];
        s2[c3] = h2[d3];
        s2[c3 + 1] = h2[d3 + 1];
        s2[c3 + 2] = h2[d3 + 2];
      }
    }
    o2 = e4[Cs][0];
    if (this._checkEqualization(Cs, o2)) {
      this.node.equalizedSideWithNodeId[Cs] = o2.equalizedSideWithNodeId[bs];
      this.readyToEngage = true;
      let e5 = this.node.getOffsetOppositeNeighbourSide(o2, Cs);
      let a2 = o2.segment.tempVertices, l2 = o2.segment.tempVerticesHigh, h2 = o2.segment.tempVerticesLow;
      let c2 = o2.segment.gridSize, d2 = c2 + 1;
      let u2 = 1 / (1 << this.tileZoom - o2.segment.tileZoom);
      let _2 = Math.max(r2 / (c2 * u2), 1), f2 = Math.max(c2 * u2 / r2, 1), g2 = e5 * c2;
      for (let e6 = 0, r3 = g2; e6 < n2; e6 += _2, r3 += f2) {
        const o3 = n2 * e6 * 3;
        const u3 = (d2 * r3 + c2) * 3;
        t2[o3] = a2[u3];
        t2[o3 + 1] = a2[u3 + 1];
        t2[o3 + 2] = a2[u3 + 2];
        i2[o3] = l2[u3];
        i2[o3 + 1] = l2[u3 + 1];
        i2[o3 + 2] = l2[u3 + 2];
        s2[o3] = h2[u3];
        s2[o3 + 1] = h2[u3 + 1];
        s2[o3 + 2] = h2[u3 + 2];
      }
    }
  }
  engage() {
    this.readyToEngage = false;
    this.createCoordsBuffers(this.tempVerticesHigh, this.tempVerticesLow, this.gridSize);
  }
  _terrainWorkerCallback(e4) {
    if (this.plainReady) {
      this.readyToEngage = true;
      this.normalMapNormals = null;
      this.normalMapVertices = null;
      this.normalMapVerticesHigh = null;
      this.normalMapVerticesLow = null;
      this.terrainVertices = null;
      this.terrainVerticesHigh = null;
      this.terrainVerticesLow = null;
      this.noDataVertices = null;
      this.tempVertices = null;
      this.tempVerticesHigh = null;
      this.tempVerticesLow = null;
      this.normalMapNormals = e4.normalMapNormals;
      this.normalMapVertices = e4.normalMapVertices;
      this.normalMapVerticesHigh = e4.normalMapVerticesHigh;
      this.normalMapVerticesLow = e4.normalMapVerticesLow;
      this.terrainVertices = e4.terrainVertices;
      this.terrainVerticesHigh = e4.terrainVerticesHigh;
      this.terrainVerticesLow = e4.terrainVerticesLow;
      this.noDataVertices = e4.noDataVertices;
      this.tempVertices = this.terrainVertices;
      this.tempVerticesHigh = this.terrainVerticesHigh;
      this.tempVerticesLow = this.terrainVerticesLow;
      this.setBoundingVolumeArr(e4.bounds);
      this.gridSize = Math.sqrt(this.terrainVertices.length / 3) - 1;
      let t2 = this.node;
      t2.appliedTerrainNodeId = t2.nodeId;
      t2.equalizedSideWithNodeId[xs] = t2.equalizedSideWithNodeId[bs] = t2.equalizedSideWithNodeId[ws] = t2.equalizedSideWithNodeId[Cs] = t2.appliedTerrainNodeId;
      this.terrainReady = true;
      this.terrainIsLoading = false;
      this.terrainExists = true;
      if (!this.normalMapTexturePtr) {
        const e5 = this.planet._normalMapCreator;
        this.normalMapTexturePtr = this.planet.renderer.handler.createEmptyTexture_l(e5.width, e5.height);
      }
      if (this.planet.lightEnabled) {
        this.planet._normalMapCreator.queue(this);
      }
    }
  }
  _normalMapEdgeEqualize(e4) {
    let t2 = this.node.neighbors;
    let i2 = t2[e4];
    let s2 = i2 && i2[0];
    let r2 = this.planet.terrain.maxZoom;
    if (this.tileZoom === r2) {
      if (i2 && !(t2[0].length || t2[1].length || t2[2].length || t2[3].length)) {
        s2 = this.node.getEqualNeighbor(e4);
      }
    }
    let n2 = s2 && s2.segment, o2 = this;
    if (s2 && n2 && n2.terrainReady && n2.terrainExists && n2.tileZoom <= r2 && o2._appliedNeighborsZoom[e4] !== n2.tileZoom) {
      o2._appliedNeighborsZoom[e4] = n2.tileZoom;
      let t3 = o2.normalMapNormals, i3 = n2.normalMapNormals;
      if (!(t3 && i3)) return;
      let s3 = o2.normalMapNormals, r3 = n2.normalMapNormals;
      let a2 = Math.sqrt(t3.length / 3), l2 = a2 - 1;
      const h2 = l2 * D_[e4];
      let c2, d2, u2, _2;
      if (o2.tileZoom === n2.tileZoom) {
        const f2 = l2 - h2;
        if (F_[e4]) {
          for (let e5 = 0; e5 < a2; e5++) {
            let n3 = (e5 * a2 + h2) * 3, o3 = (e5 * a2 + f2) * 3;
            c2 = s3[n3] + r3[o3];
            d2 = s3[n3 + 1] + r3[o3 + 1];
            u2 = s3[n3 + 2] + r3[o3 + 2];
            _2 = 1 / Math.sqrt(c2 * c2 + d2 * d2 + u2 * u2);
            i3[o3] = t3[n3] = c2 * _2;
            i3[o3 + 1] = t3[n3 + 1] = d2 * _2;
            i3[o3 + 2] = t3[n3 + 2] = u2 * _2;
          }
        } else {
          for (let e5 = 0; e5 < a2; e5++) {
            let n3 = (h2 * a2 + e5) * 3, o3 = (f2 * a2 + e5) * 3;
            c2 = s3[n3] + r3[o3];
            d2 = s3[n3 + 1] + r3[o3 + 1];
            u2 = s3[n3 + 2] + r3[o3 + 2];
            _2 = 1 / Math.sqrt(c2 * c2 + d2 * d2 + u2 * u2);
            i3[o3] = t3[n3] = c2 * _2;
            i3[o3 + 1] = t3[n3 + 1] = d2 * _2;
            i3[o3 + 2] = t3[n3 + 2] = u2 * _2;
          }
        }
        if (!n2._inTheQueue && n2._appliedNeighborsZoom[Ls[e4]] !== o2.tileZoom) {
          n2._appliedNeighborsZoom[Ls[e4]] = o2.tileZoom;
          o2.planet._normalMapCreator.queue(n2);
        }
      }
    }
  }
  applyTerrain(e4) {
    if (e4) {
      this.elevationsExists(e4);
    } else {
      this.elevationsNotExists();
    }
  }
  deleteBuffers() {
    const e4 = this.handler.gl;
    e4.deleteBuffer(this.vertexNormalBuffer);
    e4.deleteBuffer(this.vertexPositionBuffer);
    e4.deleteBuffer(this.vertexPositionBufferHigh);
    e4.deleteBuffer(this.vertexPositionBufferLow);
    this.vertexNormalBuffer = null;
    this.vertexPositionBuffer = null;
    this.vertexPositionBufferHigh = null;
    this.vertexPositionBufferLow = null;
    this.vertexTextureCoordBuffer = null;
  }
  deleteMaterials() {
    let e4 = this.materials;
    for (let t2 = 0; t2 < e4.length; t2++) {
      let i2 = e4[t2];
      if (i2) {
        i2.clear();
      }
    }
    this.materials.length = 0;
  }
  deleteElevations() {
    this.terrainExists = false;
    this.terrainReady = false;
    this.terrainIsLoading = false;
    this.normalMapVertices = null;
    this.normalMapVerticesHigh = null;
    this.normalMapVerticesLow = null;
    this.normalMapNormals = null;
    this.tempVertices = null;
    this.tempVerticesHigh = null;
    this.tempVerticesLow = null;
    this.terrainVertices = null;
    this.terrainVerticesHigh = null;
    this.terrainVerticesLow = null;
    this.noDataVertices = null;
    this.plainVertices = null;
    this.plainVerticesHigh = null;
    this.plainVerticesLow = null;
    this.plainNormals = null;
    if (this.normalMapReady) {
      this.handler.gl.deleteTexture(this.normalMapTexture);
      this.normalMapReady = false;
    }
    this._appliedNeighborsZoom = [0, 0, 0, 0];
    this.normalMapTextureBias[0] = 0;
    this.normalMapTextureBias[1] = 0;
    this.normalMapTextureBias[2] = 1;
    this._inTheQueue = false;
  }
  clearSegment() {
    this.plainReady = false;
    this.initialized = false;
    this.deleteBuffers();
    this.deleteMaterials();
    this.deleteElevations();
  }
  childrenInitialized() {
    let e4 = this.node.nodes;
    return e4.length === 4 && e4[0].segment.initialized && e4[1].segment.initialized && e4[2].segment.initialized && e4[3].segment.initialized;
  }
  destroySegment() {
    this.clearSegment();
    let e4 = this._slices.length;
    while (e4--) {
      this._slices[e4].clear();
    }
    this._slices = null;
    this.node = null;
    this.planet = null;
    this.handler = null;
    this.bbox = null;
    this.bsphere = null;
    this._extent = null;
    this.materials = null;
    this.plainVertices = null;
    this.plainVerticesHigh = null;
    this.plainVerticesLow = null;
    this.plainNormals = null;
    this.terrainVertices = null;
    this.terrainVerticesHigh = null;
    this.terrainVerticesLow = null;
    this.noDataVertices = null;
    this.tempVertices = null;
    this.tempVerticesHigh = null;
    this.tempVerticesLow = null;
    this.normalMapTextureBias = null;
    this.normalMapTexture = null;
    this.normalMapVertices = null;
    this.normalMapVerticesHigh = null;
    this.normalMapVerticesLow = null;
    this.normalMapNormals = null;
    this.vertexNormalBuffer = null;
    this.vertexPositionBuffer = null;
    this.vertexPositionBufferHigh = null;
    this.vertexPositionBufferLow = null;
    this.vertexTextureCoordBuffer = null;
    this._projection = null;
    this._appliedNeighborsZoom = null;
    this._globalTextureCoordinates = null;
  }
  _setExtentLonLat() {
    this._extentLonLat = this._extent.inverseMercator();
  }
  _createExtentNormals() {
    const e4 = this.planet.ellipsoid;
    const t2 = this._extentLonLat;
    const i2 = e4.geodeticToCartesian(t2.southWest.lon, t2.southWest.lat);
    const s2 = e4.geodeticToCartesian(t2.northEast.lon, t2.northEast.lat);
    const r2 = e4.geodeticToCartesian(t2.southWest.lon, t2.northEast.lat);
    const n2 = e4.geodeticToCartesian(t2.northEast.lon, t2.southWest.lat);
    this._sw.copy(i2);
    this._nw.copy(r2);
    this._ne.copy(s2);
    this._se.copy(n2);
  }
  createBoundsByExtent() {
    this._createExtentNormals();
    this.setBoundingVolume3v(this._sw, this._ne);
  }
  createBoundsByParent() {
    let e4 = this.node;
    while (e4.parentNode && !e4.segment.terrainReady) {
      e4 = e4.parentNode;
    }
    let t2 = 1 << this.tileZoom - e4.segment.tileZoom;
    let i2 = this.tileX - e4.segment.tileX * t2, s2 = this.tileY - e4.segment.tileY * t2;
    if (e4.segment.terrainReady && e4.segment.tileZoom >= this.planet.terrain.minZoom) {
      let r2 = e4.segment.gridSize / t2;
      if (r2 >= 1) {
        this.bsphere.center.x = e4.segment.bsphere.center.x;
        this.bsphere.center.y = e4.segment.bsphere.center.y;
        this.bsphere.center.z = e4.segment.bsphere.center.z;
        this.bsphere.radius = e4.segment.bsphere.radius;
        let t3 = r2 * s2;
        let n2 = r2 * i2;
        let o2 = e4.segment.gridSize + 1;
        let a2 = 3 * ((t3 + r2) * o2 + n2), l2 = 3 * (t3 * o2 + n2), h2 = 3 * (t3 * o2 + n2 + r2), c2 = 3 * ((t3 + r2) * o2 + n2 + r2);
        let d2 = e4.segment.tempVertices;
        let u2 = new Ke(d2[a2], d2[a2 + 1], d2[a2 + 2]), _2 = new Ke(d2[h2], d2[h2 + 1], d2[h2 + 2]);
        let f2 = new Ke(d2[l2], d2[l2 + 1], d2[l2 + 2]), g2 = new Ke(d2[c2], d2[c2 + 1], d2[c2 + 2]);
        this._sw.copy(u2);
        this._nw.copy(f2);
        this._ne.copy(_2);
        this._se.copy(g2);
      } else {
        let t3 = e4.segment;
        let n2 = Math.floor(r2 * s2), o2 = Math.floor(r2 * i2);
        let a2 = 1 / r2;
        let l2 = s2 - a2 * n2, h2 = i2 - a2 * o2;
        let c2;
        if (t3.gridSize === 1) {
          c2 = t3.tempVertices;
        } else {
          c2 = Yt(t3.tempVertices, t3.gridSize, n2, o2, 1);
        }
        let d2 = new Ke(c2[0], c2[1], c2[2]), u2 = new Ke(c2[9], c2[10], c2[11]);
        let _2 = new Ke(c2[3] - c2[0], c2[4] - c2[1], c2[5] - c2[2]), f2 = new Ke(c2[6] - c2[0], c2[7] - c2[1], c2[8] - c2[2]), g2 = new Ke(c2[3] - c2[9], c2[4] - c2[10], c2[5] - c2[11]), p2 = new Ke(c2[6] - c2[9], c2[7] - c2[10], c2[8] - c2[11]);
        let m2 = l2, v2 = h2;
        let y2, x2;
        if (m2 + v2 < a2) {
          y2 = Ke.add(_2.scaleTo(v2 / a2), f2.scaleTo(m2 / a2)).addA(d2);
        } else {
          y2 = Ke.add(p2.scaleTo(1 - v2 / a2), g2.scaleTo(1 - m2 / a2)).addA(u2);
        }
        m2 = l2 + 1;
        v2 = h2 + 1;
        if (m2 + v2 < a2) {
          x2 = Ke.add(_2.scaleTo(v2 / a2), f2.scaleTo(m2 / a2)).addA(d2);
        } else {
          x2 = Ke.add(p2.scaleTo(1 - v2 / a2), g2.scaleTo(1 - m2 / a2)).addA(u2);
        }
        this._createExtentNormals();
        this.setBoundingVolume3v(y2, x2);
      }
    } else {
      this.createBoundsByExtent();
    }
  }
  setBoundingSphere(e4, t2, i2, s2) {
    this.bsphere.center.x = e4;
    this.bsphere.center.y = t2;
    this.bsphere.center.z = i2;
    this.bsphere.radius = this.bsphere.center.distance(s2);
  }
  setBoundingVolume(e4, t2, i2, s2, r2, n2) {
    this.bbox.setFromBoundsArr([e4, t2, i2, s2, r2, n2]);
    let o2 = e4 + (s2 - e4) * 0.5, a2 = t2 + (r2 - t2) * 0.5, l2 = i2 + (n2 - i2) * 0.5;
    this.bsphere.center.set(o2, a2, l2);
    this.bsphere.radius = this.bsphere.center.distance(new Ke(e4, t2, i2));
  }
  setBoundingVolume3v(e4, t2) {
    this.bbox.setFromBoundsArr([e4.x, e4.y, e4.z, t2.x, t2.y, t2.z]);
    let i2 = e4.x + (t2.x - e4.x) * 0.5, s2 = e4.y + (t2.y - e4.y) * 0.5, r2 = e4.z + (t2.z - e4.z) * 0.5;
    this.bsphere.center.set(i2, s2, r2);
    this.bsphere.radius = this.bsphere.center.distance(new Ke(e4.x, e4.y, e4.z));
  }
  setBoundingVolumeArr(e4) {
    this.bbox.setFromBoundsArr(e4);
    let t2 = e4[0] + (e4[3] - e4[0]) * 0.5, i2 = e4[1] + (e4[4] - e4[1]) * 0.5, s2 = e4[2] + (e4[5] - e4[2]) * 0.5;
    this.bsphere.center.set(t2, i2, s2);
    this.bsphere.radius = this.bsphere.center.distance(new Ke(e4[0], e4[1], e4[2]));
  }
  createCoordsBuffers(e4, t2, i2) {
    const s2 = (i2 + 1) * (i2 + 1);
    const r2 = this.handler;
    if (this.vertexPositionBufferHigh && this.vertexPositionBufferHigh.numItems === s2) {
      r2.setStreamArrayBuffer(this.vertexPositionBufferHigh, e4);
      r2.setStreamArrayBuffer(this.vertexPositionBufferLow, t2);
    } else {
      r2.gl.deleteBuffer(this.vertexPositionBufferHigh);
      r2.gl.deleteBuffer(this.vertexPositionBufferLow);
      this.vertexTextureCoordBuffer = this.planet._textureCoordsBufferCache[Math.log2(i2)];
      this.vertexPositionBufferHigh = r2.createArrayBuffer(e4, 3, s2);
      this.vertexPositionBufferLow = r2.createArrayBuffer(t2, 3, s2);
    }
  }
  _addViewExtent() {
    const e4 = this._extentLonLat;
    let t2 = this.planet._viewExtent;
    if (e4.southWest.lon < t2.southWest.lon) {
      t2.southWest.lon = e4.southWest.lon;
    }
    if (e4.northEast.lon > t2.northEast.lon) {
      t2.northEast.lon = e4.northEast.lon;
    }
    if (e4.southWest.lat < t2.southWest.lat) {
      t2.southWest.lat = e4.southWest.lat;
    }
    if (e4.northEast.lat > t2.northEast.lat) {
      t2.northEast.lat = e4.northEast.lat;
    }
  }
  _assignTileIndexes() {
    this._tileGroup = T_;
    const e4 = this.tileZoom;
    const t2 = this._extent;
    const i2 = we;
    this.tileX = w_(t2.getCenter().lon, t2.getWidth(), -2003750834e-2);
    this.tileY = w_(t2.getCenter().lat, t2.getHeight(), i2);
    const s2 = this.powTileZoom;
    this.tileXE = (this.tileX + 1) % s2;
    this.tileXW = (s2 + this.tileX - 1) % s2;
    this.tileYN = this.tileY - 1;
    this.tileYS = this.tileY + 1;
    this.tileIndex = ks.getTileIndex(this.tileX, this.tileY, e4, this._tileGroup);
  }
  initialize() {
    const e4 = this.planet;
    const t2 = this.node;
    this.gridSize = e4.terrain.gridSizeByZoom[this.tileZoom] || e4.terrain.plainGridSize;
    t2.sideSizeLog2[0] = t2.sideSizeLog2[1] = t2.sideSizeLog2[2] = t2.sideSizeLog2[3] = Math.log2(this.gridSize);
    if (this.tileZoom <= e4.terrain.maxZoom) {
      const t3 = this.planet._normalMapCreator;
      this.normalMapTexturePtr = e4.renderer.handler.createEmptyTexture_l(t3.width, t3.height);
    }
    this.normalMapTexture = this.planet.transparentTexture;
    this._assignGlobalTextureCoordinates();
    this.initialized = true;
  }
  _assignGlobalTextureCoordinates() {
    const e4 = this._extent;
    this._globalTextureCoordinates[0] = (e4.southWest.lon + we) * ke;
    this._globalTextureCoordinates[1] = (we - e4.northEast.lat) * ke;
    this._globalTextureCoordinates[2] = (e4.northEast.lon + we) * ke;
    this._globalTextureCoordinates[3] = (we - e4.southWest.lat) * ke;
  }
  createPlainSegmentAsync() {
    let e4 = this.planet, t2 = e4.terrain;
    if (t2.isReady() && !this.plainReady && this.tileZoom <= t2.maxZoom) {
      this.plainProcessing = true;
      e4._plainSegmentWorker.make(this);
    }
  }
  _plainSegmentWorkerCallback(e4) {
    this.plainProcessing = false;
    if (this.initialized && !this.terrainReady) {
      this.plainReady = true;
      this.plainVertices = e4.plainVertices;
      this.plainVerticesHigh = e4.plainVerticesHigh;
      this.plainVerticesLow = e4.plainVerticesLow;
      this.plainNormals = e4.plainNormals;
      this._plainRadius = e4.plainRadius;
      this.normalMapNormals = e4.normalMapNormals;
      this.normalMapVertices = e4.normalMapVertices;
      this.normalMapVerticesHigh = e4.normalMapVerticesHigh;
      this.normalMapVerticesLow = e4.normalMapVerticesLow;
      this.fileGridSize = Math.sqrt(e4.normalMapVertices.length / 3) - 1;
    }
  }
  createPlainSegment() {
    this.initialize();
    this._createPlainVertices();
    this.readyToEngage = true;
  }
  _projToDeg(e4, t2) {
    return be.inverseMercator(e4, t2);
  }
  _createPlainVertices() {
    const e4 = this.planet.terrain.gridSizeByZoom[this.tileZoom];
    const t2 = this.planet.terrain.plainGridSize;
    const i2 = Math.max(t2, e4);
    const s2 = this._extent;
    const r2 = s2.getWidth();
    const n2 = s2.getHeight();
    const o2 = r2 / i2;
    const a2 = n2 / i2;
    const l2 = s2.southWest.lon;
    const h2 = s2.northEast.lat;
    const c2 = Math.max(t2 / e4, 1);
    const d2 = i2 + 1;
    const u2 = this.planet.ellipsoid._invRadii2;
    const _2 = d2 * d2;
    const f2 = (e4 + 1) * (e4 + 1) * 3;
    let g2 = 0, p2 = 0;
    this.plainNormals = new Float32Array(f2);
    this.plainVertices = new Float64Array(f2);
    this.plainVerticesHigh = new Float32Array(f2);
    this.plainVerticesLow = new Float32Array(f2);
    this.normalMapNormals = new Float32Array(_2 * 3);
    this.normalMapVertices = new Float64Array(_2 * 3);
    this.normalMapVerticesHigh = new Float32Array(_2 * 3);
    this.normalMapVerticesLow = new Float32Array(_2 * 3);
    let m2 = this.plainVertices, v2 = this.plainVerticesHigh, y2 = this.plainVerticesLow, x2 = this.plainNormals, b2 = this.normalMapVertices, w2 = this.normalMapVerticesHigh, C2 = this.normalMapVerticesLow, T2 = this.normalMapNormals;
    for (let e5 = 0; e5 < _2; e5++) {
      let t3 = e5 % d2, i3 = ~~(e5 / d2);
      let s3 = this.planet.ellipsoid.lonLatToCartesian(this._projToDeg(l2 + t3 * o2, h2 - i3 * a2));
      let r3 = s3.x * u2.x, n3 = s3.y * u2.y, _3 = s3.z * u2.z;
      let f3 = 1 / Math.sqrt(r3 * r3 + n3 * n3 + _3 * _3);
      let E2 = r3 * f3, A2 = n3 * f3, L2 = _3 * f3;
      Ke.doubleToTwoFloats(s3, P_, S_);
      b2[p2] = s3.x;
      w2[p2] = P_.x;
      C2[p2] = S_.x;
      T2[p2++] = E2;
      b2[p2] = s3.y;
      w2[p2] = P_.y;
      C2[p2] = S_.y;
      T2[p2++] = A2;
      b2[p2] = s3.z;
      w2[p2] = P_.z;
      C2[p2] = S_.z;
      T2[p2++] = L2;
      if (i3 % c2 === 0 && t3 % c2 === 0) {
        m2[g2] = s3.x;
        v2[g2] = P_.x;
        y2[g2] = S_.x;
        x2[g2++] = E2;
        m2[g2] = s3.y;
        v2[g2] = P_.y;
        y2[g2] = S_.y;
        x2[g2++] = A2;
        m2[g2] = s3.z;
        v2[g2] = P_.z;
        y2[g2] = S_.z;
        x2[g2++] = L2;
      }
    }
    this.terrainVertices = m2;
    this.terrainVerticesHigh = v2;
    this.terrainVerticesLow = y2;
    this.plainReady = true;
  }
  getMaterialByLayer(e4) {
    return this.materials[e4.__id];
  }
  _getLayerExtentOffset(e4) {
    const t2 = e4._extentMerc;
    const i2 = this._extent;
    const s2 = t2.northEast.lon - t2.southWest.lon;
    const r2 = t2.northEast.lat - t2.southWest.lat;
    const n2 = (i2.southWest.lon - t2.southWest.lon) / s2;
    const o2 = (t2.northEast.lat - i2.northEast.lat) / r2;
    const a2 = (i2.northEast.lon - i2.southWest.lon) / s2;
    const l2 = (i2.northEast.lat - i2.southWest.lat) / r2;
    return [n2, o2, a2, l2];
  }
  initSlice(e4) {
    let t2 = this._slices[e4];
    if (!t2) {
      t2 = this._slices[e4] = new b_(this);
    } else {
      t2.layers = [];
    }
    return t2;
  }
  screenRendering(e4, t2, i2, s2, r2 = false, n2) {
    const o2 = this.handler.gl;
    const a2 = e4.attributes;
    const l2 = e4.uniforms;
    const h2 = this.materials;
    const c2 = this.planet;
    let d2, u2;
    if (t2 && t2.length) {
      u2 = t2[0];
      d2 = u2._height;
    } else {
      d2 = 0;
    }
    o2.activeTexture(o2.TEXTURE0 + c2.SLICE_SIZE + 2);
    o2.bindTexture(o2.TEXTURE_2D, s2 || this.getDefaultTexture());
    o2.uniform1i(l2.defaultTexture, c2.SLICE_SIZE + 2);
    let _2 = 0, f2 = 0;
    let g2 = false;
    let p2 = this.initSlice(i2);
    this._indexBuffer = this._getIndexBuffer();
    while (u2) {
      if (this.layerOverlap(u2) && (u2._fading && u2._fadingOpacity > 0 || (u2.minZoom >= c2.minCurrZoom || u2.maxZoom >= c2.minCurrZoom) && (u2.minZoom <= c2.maxCurrZoom || u2.maxZoom <= c2.maxCurrZoom))) {
        g2 = true;
        let e5 = h2[u2.__id];
        if (!e5) {
          e5 = h2[u2.__id] = u2.createMaterial(this);
        }
        if (!e5.isReady) {
          this.planet._renderCompleted = false;
        }
        p2.append(u2, e5);
        c2._samplerArr[_2] = _2;
        o2.activeTexture(o2.TEXTURE0 + _2);
        o2.bindTexture(o2.TEXTURE_2D, e5.texture || c2.transparentTexture);
        _2++;
      }
      f2++;
      u2 = t2[f2];
    }
    if (g2 || !r2) {
      o2.uniform1f(l2.transitionOpacity, n2 || this._transitionOpacity > 1 ? 1 : this._transitionOpacity);
      o2.uniform1i(l2.samplerCount, _2);
      o2.uniform1f(l2.height, d2);
      o2.uniform1iv(l2.samplerArr, c2._samplerArr);
      o2.uniform4fv(l2.tileOffsetArr, p2.tileOffsetArr);
      o2.uniform1fv(l2.layerOpacityArr, p2.layerOpacityArr);
      if (c2.lightEnabled) {
        o2.activeTexture(o2.TEXTURE0 + c2.SLICE_SIZE + 3);
        o2.bindTexture(o2.TEXTURE_2D, this.normalMapTexture || c2.transparentTexture);
        o2.uniform1i(l2.uNormalMap, c2.SLICE_SIZE + 3);
        o2.uniform3fv(l2.uNormalMapBias, this.normalMapTextureBias);
        o2.uniform4fv(l2.uGlobalTextureCoord, this._globalTextureCoordinates);
      }
      o2.bindBuffer(o2.ARRAY_BUFFER, this.vertexPositionBufferHigh);
      o2.vertexAttribPointer(a2.aVertexPositionHigh, this.vertexPositionBufferHigh.itemSize, o2.FLOAT, false, 0, 0);
      o2.bindBuffer(o2.ARRAY_BUFFER, this.vertexPositionBufferLow);
      o2.vertexAttribPointer(a2.aVertexPositionLow, this.vertexPositionBufferLow.itemSize, o2.FLOAT, false, 0, 0);
      o2.bindBuffer(o2.ARRAY_BUFFER, this.vertexTextureCoordBuffer);
      o2.vertexAttribPointer(a2.aTextureCoord, 2, o2.UNSIGNED_SHORT, true, 0, 0);
      o2.bindBuffer(o2.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
      o2.drawElements(c2.drawMode, this._indexBuffer.numItems, o2.UNSIGNED_INT, 0);
    }
  }
  heightPickingRendering(e4, t2) {
    const i2 = this.handler.gl;
    const s2 = e4.attributes;
    const r2 = e4.uniforms;
    let n2;
    if (t2 && t2.length) {
      n2 = t2[0]._height;
    } else {
      n2 = 0;
    }
    i2.uniform1f(r2.height, n2);
    i2.bindBuffer(i2.ARRAY_BUFFER, this.vertexPositionBufferHigh);
    i2.vertexAttribPointer(s2.aVertexPositionHigh, this.vertexPositionBufferHigh.itemSize, i2.FLOAT, false, 0, 0);
    i2.bindBuffer(i2.ARRAY_BUFFER, this.vertexPositionBufferLow);
    i2.vertexAttribPointer(s2.aVertexPositionLow, this.vertexPositionBufferLow.itemSize, i2.FLOAT, false, 0, 0);
    i2.bindBuffer(i2.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    i2.drawElements(i2.TRIANGLE_STRIP, this._indexBuffer.numItems, i2.UNSIGNED_INT, 0);
  }
  increaseTransitionOpacity() {
    this._transitionOpacity += (window.performance.now() - this._transitionTimestamp) / this.planet.transitionTime;
    this._transitionTimestamp = window.performance.now();
    if (this._transitionOpacity > 2) {
      this._transitionOpacity = 2;
    }
    let e4 = this.node._fadingNodes.length;
    while (e4--) {
      let t2 = this.node._fadingNodes[e4];
      if (t2.segment) {
        if (t2.segment._transitionOpacity > 0 && !this.planet._fadingNodes.has(t2.__id)) {
          this.planet._fadingNodes.set(t2.__id, t2);
          t2.segment._transitionOpacity = 2 - this._transitionOpacity;
          if (t2.segment._transitionOpacity === 0) {
            this.node._fadingNodes.splice(e4, 1);
          }
        }
      } else {
        this._transitionOpacity = 1;
        break;
      }
    }
  }
  fadingTransitionOpacity() {
    this._transitionOpacity -= 0.01;
    this._transitionTimestamp = window.performance.now();
    if (this._transitionOpacity < 0) {
      this._transitionOpacity = 0;
    }
  }
  colorPickingRendering(e4, t2, i2, s2, r2 = false) {
    const n2 = this.handler.gl;
    const o2 = e4.attributes;
    const a2 = e4.uniforms;
    let l2 = this.materials, h2 = this.planet;
    let c2;
    if (t2 && t2.length) {
      c2 = t2[0]._height;
    } else {
      c2 = 0;
    }
    let d2 = false;
    let u2 = this._slices[i2];
    let _2 = u2.layers.length;
    for (let e5 = 0; e5 < _2; e5++) {
      d2 = true;
      let t3 = u2.layers[e5];
      let i3 = e5 * 4;
      h2._pickingColorArr[i3] = t3._pickingColor.x / 255;
      h2._pickingColorArr[i3 + 1] = t3._pickingColor.y / 255;
      h2._pickingColorArr[i3 + 2] = t3._pickingColor.z / 255;
      h2._pickingColorArr[i3 + 3] = Number(t3._pickingEnabled);
      h2._samplerArr[e5] = e5;
      n2.activeTexture(n2.TEXTURE0 + e5);
      n2.bindTexture(n2.TEXTURE_2D, l2[t3.__id].texture || this.planet.transparentTexture);
      h2._pickingMaskArr[e5] = e5 + h2.SLICE_SIZE;
      n2.activeTexture(n2.TEXTURE0 + e5 + h2.SLICE_SIZE);
      n2.bindTexture(n2.TEXTURE_2D, l2[t3.__id].pickingMask || this.planet.transparentTexture);
    }
    if (d2 || !r2) {
      n2.uniform1i(a2.samplerCount, _2);
      n2.uniform1f(a2.height, c2);
      n2.uniform1iv(a2.samplerArr, h2._samplerArr);
      n2.uniform1iv(a2.pickingMaskArr, h2._pickingMaskArr);
      n2.uniform4fv(a2.pickingColorArr, h2._pickingColorArr);
      n2.uniform4fv(a2.tileOffsetArr, u2.tileOffsetArr);
      n2.uniform1fv(a2.layerOpacityArr, u2.layerOpacityArr);
      n2.bindBuffer(n2.ARRAY_BUFFER, this.vertexPositionBufferHigh);
      n2.vertexAttribPointer(o2.aVertexPositionHigh, this.vertexPositionBufferHigh.itemSize, n2.FLOAT, false, 0, 0);
      n2.bindBuffer(n2.ARRAY_BUFFER, this.vertexPositionBufferLow);
      n2.vertexAttribPointer(o2.aVertexPositionLow, this.vertexPositionBufferLow.itemSize, n2.FLOAT, false, 0, 0);
      n2.bindBuffer(n2.ARRAY_BUFFER, this.vertexTextureCoordBuffer);
      n2.vertexAttribPointer(o2.aTextureCoord, 2, n2.UNSIGNED_SHORT, true, 0, 0);
      n2.bindBuffer(n2.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
      n2.drawElements(n2.TRIANGLE_STRIP, this._indexBuffer.numItems, n2.UNSIGNED_INT, 0);
    }
  }
  depthRendering(e4, t2) {
    const i2 = this.handler.gl;
    const s2 = e4.attributes;
    const r2 = e4.uniforms;
    var n2;
    if (t2 && t2.length) {
      n2 = t2[0]._height;
    } else {
      n2 = 0;
    }
    i2.uniform1f(r2.height, n2);
    i2.bindBuffer(i2.ARRAY_BUFFER, this.vertexPositionBufferHigh);
    i2.vertexAttribPointer(s2.aVertexPositionHigh, this.vertexPositionBufferHigh.itemSize, i2.FLOAT, false, 0, 0);
    i2.bindBuffer(i2.ARRAY_BUFFER, this.vertexPositionBufferLow);
    i2.vertexAttribPointer(s2.aVertexPositionLow, this.vertexPositionBufferLow.itemSize, i2.FLOAT, false, 0, 0);
    i2.bindBuffer(i2.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    i2.drawElements(i2.TRIANGLE_STRIP, this._indexBuffer.numItems, i2.UNSIGNED_INT, 0);
  }
  _getIndexBuffer() {
    const e4 = this.node.sideSizeLog2;
    let t2 = this.planet._indexesCache[Math.log2(this.gridSize)][e4[0]][e4[1]][e4[2]][e4[3]];
    if (!t2.buffer) {
      let i2 = Fu().createSegmentIndexes(Math.log2(this.gridSize), [e4[0], e4[1], e4[2], e4[3]]);
      t2.buffer = this.planet.renderer.handler.createElementArrayBuffer(i2, 1);
      this.planet._indexesCacheToRemoveCounter++;
    }
    return t2.buffer;
  }
  layerOverlap(e4) {
    return this._extent.overlaps(e4._extentMerc);
  }
  getDefaultTexture() {
    return this.planet.solidTextureOne;
  }
  getExtentLonLat() {
    return this._extentLonLat;
  }
  getExtentMerc() {
    return this._extentMerc;
  }
  getExtent() {
    return this._extent;
  }
  getNeighborSide(e4) {
    if (this.tileY === e4.tileY) {
      if (this.tileX === e4.tileXE) {
        return Cs;
      } else if (this.tileX === e4.tileXW) {
        return bs;
      }
    } else if (this.tileX === e4.tileX) {
      if (this.tileY === e4.tileYS) {
        return xs;
      } else if (this.tileY === e4.tileYN) {
        return ws;
      }
    }
    return -1;
  }
}
let O_ = new Ke(), H_ = new Ke();
const V_ = [new Qe(0, 0), new Qe(1, 0), new Qe(0, 1), new Qe(1, 1)];
const U_ = Math.sqrt(V_.length) - 1;
let G_ = { xmin: 0, ymin: 0, zmin: 0, xmax: 0, ymax: 0, zmax: 0 };
let W_ = 0;
let j_ = class e3 {
  constructor(e4, t2, i2, s2, r2, n2) {
    t2._createdNodesCount++;
    this.__id = W_++;
    this.SegmentPrototype = e4;
    this.planet = t2;
    this.parentNode = s2;
    this.partId = i2;
    this.nodeId = i2 + (s2 ? s2.nodeId * 4 + 1 : 0);
    this.state = null;
    this.prevState = null;
    this.appliedTerrainNodeId = -1;
    this.sideSizeLog2 = [0, 0, 0, 0];
    this.ready = false;
    this.neighbors = [[], [], [], []];
    this.equalizedSideWithNodeId = [this.nodeId, this.nodeId, this.nodeId, this.nodeId];
    this.nodes = [];
    this.segment = new e4(this, t2, r2, n2);
    this._cameraInside = false;
    this.inFrustum = 0;
    this._fadingNodes = [];
    this.createBounds();
  }
  createChildNodes() {
    this.ready = true;
    const t2 = this.planet;
    const i2 = this.segment;
    const s2 = i2._extent;
    const r2 = i2.tileZoom + 1;
    const n2 = s2.getWidth() * 0.5;
    const o2 = s2.getHeight() * 0.5;
    const a2 = s2.northEast;
    const l2 = s2.southWest;
    const h2 = new be(l2.lon + n2, l2.lat + o2);
    const c2 = this.nodes;
    c2[ps] = new e3(this.SegmentPrototype, t2, ps, this, r2, new Ye(new be(l2.lon, l2.lat + o2), new be(l2.lon + n2, a2.lat)));
    c2[ms] = new e3(this.SegmentPrototype, t2, ms, this, r2, new Ye(h2, new be(a2.lon, a2.lat)));
    c2[vs] = new e3(this.SegmentPrototype, t2, vs, this, r2, new Ye(new be(l2.lon, l2.lat), h2));
    c2[ys] = new e3(this.SegmentPrototype, t2, ys, this, r2, new Ye(new be(l2.lon + n2, l2.lat), new be(a2.lon, l2.lat + o2)));
  }
  createBounds() {
    let e4 = this.segment;
    e4._setExtentLonLat();
    if (e4.tileZoom === 0) {
      e4.setBoundingSphere(0, 0, 0, new Ke(0, 0, e4.planet.ellipsoid.equatorialSize));
    } else if (e4.tileZoom < e4.planet.terrain.minZoom) {
      e4.createBoundsByExtent();
    } else {
      e4.createBoundsByParent();
    }
    let t2 = e4.bsphere.center.x, i2 = e4.bsphere.center.y, s2 = e4.bsphere.center.z;
    let r2 = 1 / Math.sqrt(t2 * t2 + i2 * i2 + s2 * s2);
    e4.centerNormal.x = t2 * r2;
    e4.centerNormal.y = i2 * r2;
    e4.centerNormal.z = s2 * r2;
  }
  getState() {
    if (this.state === -1) {
      return this.state;
    }
    let e4 = this.parentNode;
    while (e4) {
      if (e4.state !== As) {
        return Ts;
      }
      e4 = e4.parentNode;
    }
    return this.state;
  }
  getEqualNeighbor(e4) {
    let t2 = this;
    let i2 = Ps[e4][t2.partId];
    if (i2 !== -1) {
      return t2.parentNode.nodes[i2];
    } else {
      let s2 = [];
      while (t2.parentNode) {
        s2.push(t2.partId);
        i2 = Ps[e4][t2.partId];
        t2 = t2.parentNode;
        if (i2 !== -1) {
          let r2 = s2.length;
          e4 = Ls[e4];
          while (t2 && r2--) {
            i2 = Ss[e4][s2[r2]];
            t2 = t2.nodes[i2];
          }
          return t2;
        }
      }
    }
  }
  traverseNodes(e4, t2, i2, s2, r2) {
    if (!this.ready) {
      this.createChildNodes();
    }
    let n2 = this.nodes;
    n2[0].renderTree(e4, t2, i2, s2, r2);
    n2[1].renderTree(e4, t2, i2, s2, r2);
    n2[2].renderTree(e4, t2, i2, s2, r2);
    n2[3].renderTree(e4, t2, i2, s2, r2);
  }
  renderTree(e4, t2, i2, s2, r2) {
    if (this.planet._renderedNodes.length >= gs) {
      return;
    }
    if (!t2 || r2 && this.segment.tileZoom > r2.segment.tileZoom) {
      this.prevState = this.state;
    }
    this.state = As;
    this.clearNeighbors();
    let n2 = this.segment, o2 = this.planet;
    this._cameraInside = false;
    if (!this.parentNode || this.parentNode._cameraInside) {
      let t3;
      if (n2._projection.id === x_.id) {
        t3 = n2._extent.isInside(e4._lonLatMerc);
      } else {
        t3 = n2._extent.isInside(e4._lonLat);
      }
      if (t3) {
        e4._insideSegment = n2;
        this._cameraInside = true;
      }
    }
    this.inFrustum = 0;
    let a2 = e4.frustums, l2 = a2.length;
    if (n2.tileZoom < 6) {
      for (let e5 = 0; e5 < l2; e5++) {
        if (a2[e5].containsSphere(n2.bsphere)) {
          this.inFrustum |= 1 << e5;
        }
      }
    } else {
      for (let e5 = 0; e5 < l2; e5++) {
        if (n2.terrainReady) {
          if (a2[e5].containsBox(n2.bbox)) {
            this.inFrustum |= 1 << e5;
          }
        } else {
          if (a2[e5].containsSphere(n2.bsphere)) {
            this.inFrustum |= 1 << e5;
          }
        }
      }
    }
    if (this.inFrustum || this._cameraInside || n2.tileZoom < 3) {
      let a3 = Math.abs(e4._lonLat.height);
      let l3 = e4.eye.length2() - o2.ellipsoid.polarSizeSqr;
      l3 = l3 < 10687647287563281e-5 * o2._heightFactor ? 10687647287563281e-5 * o2._heightFactor : l3;
      let h2 = n2.tileZoom < 2 || n2.tileZoom > 19 || n2.tileZoom < 6 && !n2.terrainReady;
      h2 = h2 || e4.eye.distance2(n2._sw) < l3 || e4.eye.distance2(n2._nw) < l3 || e4.eye.distance2(n2._ne) < l3 || e4.eye.distance2(n2._se) < l3;
      if (this.inFrustum && (h2 || a3 > 1e4) || this._cameraInside) {
        o2.quadTreeStrategy.collectVisibleNode(this);
      }
      if (n2.tileZoom < 2) {
        this.traverseNodes(e4, t2, i2, s2, r2);
      } else if (n2.terrainReady && (!t2 && e4.projectedSize(n2.bsphere.center, n2._plainRadius) < o2.lodSize || t2 && (n2.tileZoom === t2 || !h2))) {
        if (h2) {
          n2.passReady = true;
          this.renderNode(this.inFrustum, !this.inFrustum, i2, s2);
        } else {
          this.state = Ts;
        }
      } else if (n2.terrainReady && n2.checkZoom() && (!t2 || e4.projectedSize(n2.bsphere.center, n2.bsphere.radius) > this.planet._maxLodSize)) {
        this.traverseNodes(e4, t2, n2, s2, r2);
      } else if (h2) {
        n2.passReady = t2 ? n2.terrainReady : false;
        this.renderNode(this.inFrustum, !this.inFrustum, i2, s2);
      } else {
        this.state = Ts;
      }
    } else {
      this.state = Ts;
    }
  }
  renderNode(e4, t2, i2, s2) {
    let r2 = this.segment;
    if (!r2.terrainReady) {
      if (!r2.initialized) {
        r2.initialize();
      }
      this.whileTerrainLoading(i2);
      if (!r2.plainProcessing) {
        r2.createPlainSegmentAsync();
      }
      if (r2.plainReady && !s2) {
        r2.loadTerrain();
      }
    }
    if (r2.planet.lightEnabled && !r2.normalMapReady) {
      this.whileNormalMapCreating();
    }
    if (t2) {
      this.state = -1;
      return;
    }
    if (!this._cameraInside && r2.tileZoom > this.planet.maxCurrZoom) {
      this.planet.maxCurrZoom = r2.tileZoom;
    }
    if (r2.tileZoom < this.planet.minCurrZoom) {
      this.planet.minCurrZoom = r2.tileZoom;
    }
    r2._addViewExtent();
    this.addToRender(e4);
  }
  childrenPrevStateEquals(e4) {
    let t2 = this.nodes;
    return t2.length === 4 && t2[0].prevState === e4 && t2[1].prevState === e4 && t2[2].prevState === e4 && t2[3].prevState === e4;
  }
  isFading() {
    let e4 = this.nodes;
    return this.state === As && this.segment._transitionOpacity > 0 && e4.length === 4 && (e4[0].state === Es && e4[1].state === Es && e4[2].state === Es && e4[3].state === Es);
  }
  _collectFadingNodes() {
    if (this.segment.tileZoom < 3) {
      this.segment._transitionOpacity = 1;
      return;
    }
    if (this.prevState !== Es) {
      this.segment._transitionOpacity = 0;
      this._fadingNodes = [];
      let e4 = window.performance.now();
      this.segment._transitionTimestamp = e4;
      if (this.parentNode) {
        if (this.parentNode.prevState === Es) {
          let t2 = this.parentNode.parentNode;
          while (t2) {
            if (t2.isFading()) {
              for (let e5 = 0; e5 < t2.nodes.length; e5++) {
                t2.nodes[e5].segment._transitionOpacity = 1;
                t2.nodes[e5]._fadingNodes = [];
              }
              t2.segment._transitionOpacity = 0;
              break;
            }
            t2 = t2.parentNode;
          }
          this.parentNode.whileTerrainLoading();
          this._fadingNodes.push(this.parentNode);
          this.parentNode.segment._transitionOpacity = 2;
          this.parentNode.segment._transitionTimestamp = e4;
        } else {
          if (this.segment.childrenInitialized() && this.childrenPrevStateEquals(Es)) {
            for (let t2 = 0; t2 < this.nodes.length; t2++) {
              let i2 = this.nodes[t2];
              i2.whileTerrainLoading();
              this._fadingNodes.push(i2);
              i2.segment._transitionOpacity = 2;
              i2.segment._transitionTimestamp = e4;
              i2.prevState = i2.state;
              i2.state = Ts;
            }
          }
        }
      }
    }
  }
  clearNeighbors() {
    if (this.neighbors) {
      this.neighbors[0] = this.neighbors[1] = this.neighbors[2] = this.neighbors[3] = null;
      this.neighbors[0] = [];
      this.neighbors[1] = [];
      this.neighbors[2] = [];
      this.neighbors[3] = [];
    }
  }
  _refreshTransitionOpacity() {
    if (this._fadingNodes.length === 0) {
      this.segment._transitionOpacity = 1;
    } else {
      if (this._fadingNodes.length === 4 && !this.childrenPrevStateEquals(Es)) {
        this.segment._transitionOpacity = 1;
        this._fadingNodes = [];
      } else {
        for (let e4 = 0; e4 < this._fadingNodes.length; e4++) {
          if (this.segment._transitionOpacity < 1 && this._fadingNodes[e4].segment._transitionOpacity === 0) {
            this._fadingNodes[e4].segment._transitionOpacity = 0;
            this.segment._transitionOpacity = 1;
          }
        }
        this.segment.increaseTransitionOpacity();
      }
    }
  }
  addToRender(e4) {
    this.state = Es;
    let t2 = this.planet._renderedNodes;
    if (!this.planet._transitionOpacityEnabled) {
      this.getRenderedNodesNeighbors(t2);
      t2.push(this);
    } else {
      St(t2, this, (e5, t3) => e5.segment.tileZoom - t3.segment.tileZoom);
    }
    if (!this.segment.terrainReady) {
      this.planet._renderCompleted = false;
      this.planet._terrainCompleted = false;
    }
    let i2 = 0, s2 = this.planet._renderedNodesInFrustum;
    while (e4) {
      if (e4 & 1) {
        s2[i2].push(this);
      }
      i2++;
      e4 >>= 1;
    }
  }
  applyNeighbor(e4, t2) {
    const i2 = Ls[t2];
    if (this.neighbors[t2].length === 0 || e4.neighbors[i2].length === 0) {
      const s2 = this.segment;
      const r2 = e4.segment;
      const n2 = s2.gridSize / (r2.gridSize * Math.pow(2, r2.tileZoom - s2.tileZoom));
      let o2 = s2.gridSize, a2 = r2.gridSize;
      if (n2 > 1) {
        o2 = Math.ceil(s2.gridSize / n2);
        a2 = r2.gridSize;
      } else if (n2 < 1) {
        o2 = s2.gridSize;
        a2 = Math.ceil(r2.gridSize * n2);
      }
      this.sideSizeLog2[t2] = Math.log2(o2);
      e4.sideSizeLog2[i2] = Math.log2(a2);
    }
    this.neighbors[t2].push(e4);
    e4.neighbors[i2].push(this);
  }
  getRenderedNodesNeighbors(e4) {
    for (let t2 = e4.length - 1; t2 >= 0; --t2) {
      let i2 = e4[t2];
      let s2 = this.getCommonSide(i2);
      if (s2 !== -1) {
        this.applyNeighbor(i2, s2);
      }
    }
  }
  getCommonSide(e4) {
    const t2 = this.segment;
    const i2 = e4.segment;
    if (t2.tileZoom === i2.tileZoom && t2._tileGroup === i2._tileGroup) {
      return t2.getNeighborSide(i2);
    } else {
      const e5 = t2._extentLonLat;
      const s2 = i2._extentLonLat;
      let r2 = e5.northEast, n2 = e5.southWest, o2 = s2.northEast, a2 = s2.southWest;
      let l2 = r2.lon, h2 = r2.lat, c2 = n2.lon, d2 = n2.lat, u2 = o2.lon, _2 = o2.lat, f2 = a2.lon, g2 = a2.lat;
      if (t2._tileGroup === i2._tileGroup) {
        if (l2 === f2 && (h2 <= _2 && d2 >= g2 || h2 >= _2 && d2 <= g2)) {
          return bs;
        } else if (c2 === u2 && (h2 <= _2 && d2 >= g2 || h2 >= _2 && d2 <= g2)) {
          return Cs;
        } else if (h2 === g2 && (c2 >= f2 && l2 <= u2 || c2 <= f2 && l2 >= u2)) {
          return xs;
        } else if (d2 === _2 && (c2 >= f2 && l2 <= u2 || c2 <= f2 && l2 >= u2)) {
          return ws;
        } else if (i2.tileX === 0 && f2 === -l2 && (h2 <= _2 && d2 >= g2 || h2 >= _2 && d2 <= g2)) {
          return bs;
        } else if (t2.tileX === 0 && c2 === -u2 && (h2 <= _2 && d2 >= g2 || h2 >= _2 && d2 <= g2)) {
          return Cs;
        }
      }
      if (t2._tileGroup === T_ && i2._tileGroup === E_ && t2.tileY === 0 && i2.tileY === i2.powTileZoom - 1 && (c2 >= f2 && l2 <= u2 || c2 <= f2 && l2 >= u2)) {
        return xs;
      } else if (t2._tileGroup === T_ && i2._tileGroup === A_ && t2.tileY === t2.powTileZoom - 1 && i2.tileY === 0 && (c2 >= f2 && l2 <= u2 || c2 <= f2 && l2 >= u2)) {
        return ws;
      } else if (t2._tileGroup === A_ && i2._tileGroup === T_ && t2.tileY === 0 && i2.tileY === i2.powTileZoom - 1 && (c2 >= f2 && l2 <= u2 || c2 <= f2 && l2 >= u2)) {
        return xs;
      } else if (t2._tileGroup === E_ && i2._tileGroup === T_ && t2.tileY === t2.powTileZoom - 1 && i2.tileY === 0 && (c2 >= f2 && l2 <= u2 || c2 <= f2 && l2 >= u2)) {
        return ws;
      }
    }
    return -1;
  }
  whileNormalMapCreating() {
    const e4 = this.segment;
    if (!e4.terrainIsLoading && e4.terrainExists && !e4._inTheQueue) {
      e4.planet._normalMapCreator.queue(e4);
    }
    let t2 = this;
    while (t2.parentNode && !t2.segment.normalMapReady) {
      t2 = t2.parentNode;
    }
    const i2 = 2 << e4.tileZoom - t2.segment.tileZoom - 1;
    e4.normalMapTexture = t2.segment.normalMapTexture;
    e4.normalMapTextureBias[0] = e4.tileX - t2.segment.tileX * i2;
    e4.normalMapTextureBias[1] = e4.tileY - t2.segment.tileY * i2;
    e4.normalMapTextureBias[2] = 1 / i2;
  }
  whileTerrainLoading(e4) {
    const t2 = this.segment;
    let i2 = this;
    if (e4 && e4.terrainReady) {
      i2 = e4.node;
    } else {
      while (i2.parentNode && !i2.segment.terrainReady) {
        i2 = i2.parentNode;
      }
    }
    if (i2.segment.terrainReady && this.appliedTerrainNodeId !== i2.nodeId) {
      let e5 = 2 << t2.tileZoom - i2.segment.tileZoom - 1, s2 = t2.tileX - i2.segment.tileX * e5, r2 = t2.tileY - i2.segment.tileY * e5;
      const n2 = i2.segment;
      let o2, a2, l2, d2;
      this.appliedTerrainNodeId = i2.nodeId;
      this.equalizedSideWithNodeId[xs] = this.equalizedSideWithNodeId[bs] = this.equalizedSideWithNodeId[ws] = this.equalizedSideWithNodeId[Cs] = this.appliedTerrainNodeId;
      let u2 = i2.segment.gridSize / e5, _2 = i2.segment.fileGridSize / e5;
      G_.xmin = h;
      G_.xmax = c;
      G_.ymin = h;
      G_.ymax = c;
      G_.zmin = h;
      G_.zmax = c;
      if (u2 >= 1) {
        t2.gridSize = u2;
        let e6 = (u2 + 1) * (u2 + 1) * 3;
        o2 = new Float64Array(e6);
        a2 = new Float32Array(e6);
        l2 = new Float32Array(e6);
        if (n2.noDataVertices) {
          d2 = new Uint8Array(e6 / 3);
        }
        $t(n2.terrainVertices, n2.terrainVerticesHigh, n2.terrainVerticesLow, n2.noDataVertices, n2.gridSize, u2 * r2, u2 * s2, u2, o2, a2, l2, G_, d2);
      } else if (_2 >= 1 && i2.segment.terrainExists) {
        t2.gridSize = _2;
        let e6 = (_2 + 1) * (_2 + 1) * 3;
        o2 = new Float64Array(e6);
        a2 = new Float32Array(e6);
        l2 = new Float32Array(e6);
        if (n2.noDataVertices) {
          d2 = new Uint8Array(e6 / 3);
        }
        $t(n2.normalMapVertices, n2.normalMapVerticesHigh, n2.normalMapVerticesLow, n2.noDataVertices, i2.segment.fileGridSize, _2 * r2, _2 * s2, _2, o2, a2, l2, G_, d2);
      } else {
        t2.gridSize = U_;
        let e6 = Math.floor(u2 * r2), i3 = Math.floor(u2 * s2);
        let h2;
        if (n2.gridSize === 1) {
          h2 = n2.terrainVertices;
        } else {
          h2 = Yt(n2.terrainVertices, n2.gridSize, e6, i3, 1);
        }
        let c2 = 1 / u2;
        let d3 = r2 - c2 * e6, _3 = s2 - c2 * i3;
        let f2 = new Ke(h2[0], h2[1], h2[2]), g2 = new Ke(h2[9], h2[10], h2[11]);
        let p2 = new Ke(h2[3] - h2[0], h2[4] - h2[1], h2[5] - h2[2]), m2 = new Ke(h2[6] - h2[0], h2[7] - h2[1], h2[8] - h2[2]), v2 = new Ke(h2[3] - h2[9], h2[4] - h2[10], h2[5] - h2[11]), y2 = new Ke(h2[6] - h2[9], h2[7] - h2[10], h2[8] - h2[11]);
        let x2 = new Ke();
        o2 = new Float64Array(3 * V_.length);
        a2 = new Float32Array(3 * V_.length);
        l2 = new Float32Array(3 * V_.length);
        for (let e7 = 0; e7 < V_.length; e7++) {
          let t3 = V_[e7].y + d3, i4 = V_[e7].x + _3;
          let s3 = i4 * u2, r3 = t3 * u2;
          if (t3 + i4 < c2) {
            x2 = p2.scaleTo(s3).addA(m2.scaleTo(r3)).addA(f2);
          } else {
            x2 = y2.scaleTo(1 - s3).addA(v2.scaleTo(1 - r3)).addA(g2);
          }
          Ke.doubleToTwoFloats(x2, O_, H_);
          let n3 = e7 * 3;
          o2[n3] = x2.x;
          o2[n3 + 1] = x2.y;
          o2[n3 + 2] = x2.z;
          a2[n3] = O_.x;
          a2[n3 + 1] = O_.y;
          a2[n3 + 2] = O_.z;
          l2[n3] = H_.x;
          l2[n3 + 1] = H_.y;
          l2[n3 + 2] = H_.z;
          if (x2.x < G_.xmin) G_.xmin = x2.x;
          if (x2.x > G_.xmax) G_.xmax = x2.x;
          if (x2.y < G_.ymin) G_.ymin = x2.y;
          if (x2.y > G_.ymax) G_.ymax = x2.y;
          if (x2.z < G_.zmin) G_.zmin = x2.z;
          if (x2.z > G_.zmax) G_.zmax = x2.z;
        }
      }
      t2.readyToEngage = true;
      t2.terrainVertices = o2;
      t2.terrainVerticesHigh = a2;
      t2.terrainVerticesLow = l2;
      t2.tempVertices = o2;
      t2.tempVerticesHigh = a2;
      t2.tempVerticesLow = l2;
      t2.noDataVertices = d2;
      t2.setBoundingVolume(G_.xmin, G_.ymin, G_.zmin, G_.xmax, G_.ymax, G_.zmax);
      if (t2.tileZoom > t2.planet.terrain.maxZoom) {
        if (i2.segment.tileZoom >= t2.planet.terrain.maxZoom) {
          t2._plainRadius = i2.segment._plainRadius / e5;
          t2.terrainReady = true;
          t2.terrainIsLoading = false;
          t2.terrainVertices = o2;
          t2.terrainVerticesHigh = a2;
          t2.terrainVerticesLow = l2;
          t2.passReady = true;
          this.appliedTerrainNodeId = this.nodeId;
          this.equalizedSideWithNodeId[xs] = this.equalizedSideWithNodeId[bs] = this.equalizedSideWithNodeId[ws] = this.equalizedSideWithNodeId[Cs] = this.appliedTerrainNodeId;
          if (i2.segment.terrainExists) {
            t2.normalMapVertices = o2;
            t2.fileGridSize = Math.sqrt(o2.length / 3) - 1;
            let i3 = Math.sqrt(n2.normalMapNormals.length / 3) - 1, a3 = i3 / e5;
            if (i3 > 1) {
              t2.normalMapNormals = qt(n2.normalMapNormals, i3, a3 * r2, a3 * s2, a3);
            } else {
              t2.normalMapNormals = n2.normalMapNormals;
            }
          }
        }
      }
    }
  }
  destroy() {
    this.prevState = this.state = Ts;
    this.segment.destroySegment();
    let e4 = this.neighbors;
    for (let t2 = 0, i2 = e4.length; t2 < i2; t2++) {
      let i3 = e4[t2];
      if (i3) {
        for (let e5 = 0; e5 < i3.length; e5++) {
          let t3 = i3[e5];
          if (t3 && t3.neighbors) {
            t3.clearNeighbors();
          }
        }
      }
    }
    this.neighbors = null;
    this.parentNode = null;
    this.sideSizeLog2 = null;
    this.segment = null;
  }
  clearTree() {
    const e4 = this.getState();
    if (e4 === Ts || e4 === Es) {
      this.destroyBranches();
    } else {
      for (let e5 = 0; e5 < this.nodes.length; e5++) {
        this.nodes[e5] && this.nodes[e5].clearTree();
      }
    }
  }
  clearBranches() {
    for (let e4 = 0; e4 < this.nodes.length; e4++) {
      this.nodes[e4].clearBranches();
      this.nodes[e4].segment.deleteMaterials();
    }
  }
  destroyBranches() {
    if (this.ready) {
      let e4 = [], t2;
      for (t2 = 0; t2 < this.nodes.length; t2++) {
        e4[t2] = this.nodes[t2];
      }
      this.ready = false;
      this.nodes = [];
      for (t2 = 0; t2 < e4.length; t2++) {
        e4[t2].destroyBranches();
        e4[t2].destroy();
        e4[t2] = null;
      }
      e4.length = 0;
      e4 = null;
    }
  }
  traverseTree(e4) {
    e4(this);
    if (this.ready) {
      for (let t2 = 0; t2 < this.nodes.length; t2++) {
        this.nodes[t2].traverseTree(e4);
      }
    }
  }
  getOffsetOppositeNeighbourSide(e4, t2) {
    let i2 = this, s2 = e4.segment.tileZoom, r2 = 0;
    while (i2.segment.tileZoom > s2) {
      r2 += Rs[i2.partId][t2] / (1 << i2.segment.tileZoom - s2);
      i2 = i2.parentNode;
    }
    return r2;
  }
};
class Y_ {
  constructor(e4 = 2048) {
    this._size = e4;
    this._array = new Array(this._size);
    this._popIndex = Math.floor(this._size * 0.5);
    this._shiftIndex = this._popIndex;
    this.length = 0;
  }
  reset() {
    this._popIndex = Math.floor(this._size * 0.5);
    this._shiftIndex = this._popIndex;
    this.length = 0;
  }
  clear() {
    this._array.length = 0;
    this._array = new Array(this._size);
    this._popIndex = Math.floor(this._size * 0.5);
    this._shiftIndex = this._popIndex;
    this.length = 0;
  }
  push(e4) {
    this.length++;
    this._array[this._popIndex++] = e4;
  }
  pop() {
    if (this.length) {
      this.length--;
      let e4 = this._array[--this._popIndex];
      this._array[this._popIndex] = null;
      if (!this._array[this._popIndex - 1]) {
        this._popIndex = Math.floor(this._size * 0.5);
        this._shiftIndex = this._popIndex;
      }
      return e4;
    }
    return void 0;
  }
  unshift(e4) {
    this.length++;
    this._array[--this._shiftIndex] = e4;
  }
  shift() {
    if (this.length) {
      this.length--;
      let e4 = this._array[this._shiftIndex];
      this._array[this._shiftIndex++] = null;
      if (!this._array[this._shiftIndex]) {
        this._popIndex = Math.floor(this._size * 0.5);
        this._shiftIndex = this._popIndex;
      }
      return e4;
    }
    return void 0;
  }
  forEach(e4) {
    for (let t2 = this._shiftIndex; t2 < this._popIndex; t2++) {
      e4(this._array[t2]);
    }
  }
}
class q_ {
  constructor(e4, t2) {
    this._layer = e4;
    this._nodeCapacity = t2;
    this._secondPASS = [];
    this._counter = 0;
    this._deferredEntitiesPendingQueue = new Y_();
    this._renderingNodes = {};
  }
  insertEntity(e4, t2 = false) {
  }
  setPickingEnabled(e4) {
  }
  dispose() {
  }
  insertEntities(e4) {
  }
  collectVisibleEntityCollections(e4) {
  }
  _queueDeferredNode(e4) {
    if (this._layer.getVisibility()) {
      e4._inTheQueue = true;
      if (this._counter >= 1) {
        this._deferredEntitiesPendingQueue.push(e4);
      } else {
        this._execDeferredNode(e4);
      }
    }
  }
  _execDeferredNode(e4) {
    this._counter++;
    requestAnimationFrame(() => {
      e4.applyCollection();
      this._counter--;
      if (this._deferredEntitiesPendingQueue.length && this._counter < 1) {
        while (this._deferredEntitiesPendingQueue.length) {
          let e5 = this._deferredEntitiesPendingQueue.pop();
          e5._inTheQueue = false;
          if (e5.isVisible()) {
            this._execDeferredNode(e5);
            return;
          }
        }
      }
    });
  }
}
class $_ {
  constructor(e4, t2 = "", i2 = x_) {
    this.name = t2;
    this.projection = i2;
    this._planet = e4;
    this._quadTreeList = [];
    this._visibleNodes = {};
  }
  createEntitiCollectionsTreeStrategy(e4, t2) {
    return new q_(e4, t2);
  }
  destroyBranches() {
    for (let e4 = 0, t2 = this._quadTreeList.length; e4 < t2; e4++) {
      this._quadTreeList[e4].destroyBranches();
    }
  }
  clearLayerMaterial(e4) {
    let t2 = e4.__id;
    for (let e5 = 0, i2 = this._quadTreeList.length; e5 < i2; e5++) {
      this._quadTreeList[e5].traverseTree(function(e6) {
        let i3 = e6.segment.materials;
        if (i3[t2]) {
          i3[t2].clear();
          i3[t2] = null;
        }
      });
    }
  }
  get planet() {
    return this._planet;
  }
  init() {
  }
  preRender() {
    for (let e4 = 0; e4 < this._quadTreeList.length; e4++) {
      let t2 = this._quadTreeList[e4];
      t2.createChildNodes();
      t2.segment.createPlainSegment();
      for (let e5 = 0; e5 < t2.nodes.length; e5++) {
        t2.nodes[e5].segment.createPlainSegment();
      }
    }
  }
  preLoad() {
    for (let e4 = 0; e4 < this._quadTreeList.length; e4++) {
      let t2 = this._quadTreeList[e4];
      t2.segment.passReady = true;
      t2.renderNode(1);
      this._planet.normalMapCreator.drawSingle(t2.segment);
      for (let e5 = 0; e5 < t2.nodes.length; e5++) {
        t2.nodes[e5].segment.passReady = true;
        t2.nodes[e5].renderNode(1);
        this._planet._normalMapCreator.drawSingle(t2.nodes[e5].segment);
      }
    }
  }
  _clearVisibleNodes() {
    this._visibleNodes = {};
  }
  collectRenderNodes() {
    this._clearVisibleNodes();
    for (let e4 = 0; e4 < this._quadTreeList.length; e4++) {
      this._quadTreeList[e4].renderTree(this._planet.camera, 0, null);
    }
  }
  clear() {
    for (let e4 = 0; e4 < this._quadTreeList.length; e4++) {
      this._quadTreeList[e4].clearTree();
    }
  }
  get quadTreeList() {
    return this._quadTreeList;
  }
  getTileXY(e4, t2) {
    let i2 = t2, s2 = -1, r2 = -1, n2 = 1 << i2;
    s2 = w_(e4.lon, 360 / n2, -180);
    r2 = w_(e4.lat, 180 / n2, 90);
    return [s2, r2, i2, T_];
  }
  getLonLatTileOffset(e4, t2, i2, s2, r2) {
    let n2 = e4;
    let o2 = new Ye();
    let a2 = Ye.createFromArray([-180, -90, 180, 90]);
    o2 = C_(t2, i2, s2, a2);
    let l2 = o2.getWidth() / (r2 - 1), h2 = o2.getHeight() / (r2 - 1);
    let c2 = r2 - Math.ceil((n2.lat - o2.southWest.lat) / h2) - 1, d2 = Math.floor((n2.lon - o2.southWest.lon) / l2);
    return [c2, d2];
  }
  collectVisibleNode(e4) {
    this._visibleNodes[e4.nodeId] = e4;
  }
}
const X_ = new y_({ code: "epsg:4326", units: m_.DEGREES });
const Z_ = 7;
const K_ = (90 - Ge) / Math.pow(2, Z_);
class Q_ extends N_ {
  constructor(e4, t2, i2, s2) {
    super(e4, t2, i2, s2);
    this._projection = X_;
    this._extentLonLat = this._extent;
    this._extentMerc = new Ye(s2.southWest.forwardMercatorEPS01(), s2.northEast.forwardMercatorEPS01());
    this._isNorth = this._extent.northEast.lat > 0;
    this.isPole = true;
  }
  _setExtentLonLat() {
    this._extentLonLat = this._extent;
  }
  projectNative(e4) {
    return e4;
  }
  getInsideLonLat(e4) {
    return e4._lonLat;
  }
  _getMaxZoom() {
    let e4 = 0;
    if (this._isNorth) {
      let t2 = Math.floor((90 - this._extent.northEast.lat) / K_);
      e4 = Math.floor(t2 / 16) + 7;
    } else {
      let t2 = Math.floor((We - this._extent.northEast.lat) / K_);
      e4 = 12 - Math.floor(t2 / 16);
    }
    return e4;
  }
  checkZoom() {
    return super.checkZoom() && this.tileZoom <= this._getMaxZoom();
  }
  _assignTileIndexes() {
    this._assignTileXIndexes(this._extent);
    this._assignTileYIndexes(this._extent);
    this.tileIndex = ks.getTileIndex(this.tileX, this.tileY, this.tileZoom, this._tileGroup);
  }
  _assignTileXIndexes(e4) {
    this.tileX = w_(e4.getCenter().lon, e4.getWidth(), -180);
    let t2 = 1 << this.tileZoom;
    this.tileXE = (this.tileX + 1) % t2;
    this.tileXW = (t2 + this.tileX - 1) % t2;
  }
  _assignTileYIndexes(e4) {
    const t2 = e4.getCenter().lat;
    if (t2 > 0) {
      this._tileGroup = E_;
      this.tileY = w_(t2, e4.getHeight(), 90);
    } else {
      this._tileGroup = A_;
      this.tileY = w_(t2, e4.getHeight(), We);
    }
    this.tileYN = this.tileY - 1;
    this.tileYS = this.tileY + 1;
  }
  _projToDeg(e4, t2) {
    return new be(e4, t2);
  }
  _assignGlobalTextureCoordinates() {
    const e4 = this._extent;
    this._globalTextureCoordinates[0] = (e4.southWest.lon + 180) / 360;
    this._globalTextureCoordinates[1] = (90 - e4.northEast.lat) / 180;
    this._globalTextureCoordinates[2] = (e4.northEast.lon + 180) / 360;
    this._globalTextureCoordinates[3] = (90 - e4.southWest.lat) / 180;
  }
  _getLayerExtentOffset(e4) {
    const t2 = e4._extent;
    const i2 = this._extent;
    const s2 = t2.northEast.lon - t2.southWest.lon;
    const r2 = t2.northEast.lat - t2.southWest.lat;
    const n2 = (i2.southWest.lon - t2.southWest.lon) / s2;
    const o2 = (t2.northEast.lat - i2.northEast.lat) / r2;
    const a2 = (i2.northEast.lon - i2.southWest.lon) / s2;
    const l2 = (i2.northEast.lat - i2.southWest.lat) / r2;
    return [n2, o2, a2, l2];
  }
  layerOverlap(e4) {
    return this._extent.overlaps(e4._extent);
  }
  getDefaultTexture() {
    return this._isNorth ? this.planet.solidTextureOne : this.planet.solidTextureTwo;
  }
  getExtentLonLat() {
    return this._extent;
  }
}
class J_ {
  constructor(e4, t2, i2, s2, r2, n2) {
    this.strategy = e4;
    this.layer = e4._layer;
    this.parentNode = i2;
    this.childNodes = [];
    this.partId = t2;
    this.nodeId = t2 + (i2 ? i2.nodeId * 4 + 1 : 0);
    this.state = null;
    this.extent = s2;
    this.count = 0;
    this.deferredEntities = [];
    this.entityCollection = null;
    this.zoom = n2;
    this._inTheQueue = false;
    this.bsphere = new Zi();
    r2 && this._setExtentBounds();
  }
  insertEntity(e4, t2 = false) {
    this.buildTree([e4], t2);
  }
  _addEntitiesToCollection(e4, t2 = false) {
    if (e4.length) {
      const i2 = this.layer;
      const s2 = i2._planet;
      let r2 = this.entityCollection;
      if (!r2) {
        r2 = new ko({ pickingEnabled: i2._pickingEnabled, labelMaxLetters: i2.labelMaxLetters });
        r2._layer = this.layer;
        r2.addTo(s2, true);
        r2._quadNode = this;
        i2._bindEventsDefault(r2);
        this.entityCollection = r2;
      }
      if (t2 || !i2.async) {
        this.entityCollection.addEntities(e4);
      } else {
        this.deferredEntities.push.apply(this.deferredEntities, e4);
      }
    }
  }
  _setExtentBounds() {
    if (!this.nodeId) {
      this.bsphere.radius = this.layer._planet.ellipsoid.equatorialSize;
      this.bsphere.center = new Ke();
    } else {
      this.bsphere.setFromExtent(this.layer._planet.ellipsoid, this.extent.inverseMercator());
    }
  }
  __setLonLat__(e4) {
    if (e4._lonLat.isZero() && !e4._cartesian.isZero()) {
      e4._lonLat = this.layer._planet.ellipsoid.cartesianToLonLat(e4._cartesian);
    }
    if (Math.abs(e4._lonLat.lat) < Ge) {
      e4._lonLatMerc = e4._lonLat.forwardMercator();
    } else {
      e4._lonLatMerc = new be();
    }
    return e4._lonLatMerc;
  }
  buildTree(e4, t2 = false) {
    this.count += e4.length;
    if (e4.length > this.layer._nodeCapacity) {
      const i2 = this.childNodes;
      if (!i2.length) {
        this.createChildNodes();
      }
      let s2 = [], r2 = [], n2 = [], o2 = [];
      let a2 = e4.length;
      while (a2--) {
        const t3 = e4[a2];
        if (i2[ps].isInside(t3)) {
          t3._nodePtr = i2[ps];
          s2.push(t3);
        } else if (i2[ms].isInside(t3)) {
          t3._nodePtr = i2[ms];
          r2.push(t3);
        } else if (i2[vs].isInside(t3)) {
          t3._nodePtr = i2[vs];
          n2.push(t3);
        } else if (i2[ys].isInside(t3)) {
          t3._nodePtr = i2[ys];
          o2.push(t3);
        }
      }
      s2.length && i2[ps].buildTree(s2, t2);
      r2.length && i2[ms].buildTree(r2, t2);
      n2.length && i2[vs].buildTree(n2, t2);
      o2.length && i2[ys].buildTree(o2, t2);
    } else {
      this._addEntitiesToCollection(e4, t2);
    }
  }
  isInside(e4) {
    if (e4._lonLatMerc) {
      return this.extent.isInside(e4._lonLatMerc);
    } else {
      return false;
    }
  }
  createChildNodes() {
    const e4 = this.strategy;
    const t2 = this.extent;
    const i2 = t2.getWidth() * 0.5;
    const s2 = t2.getHeight() * 0.5;
    const r2 = t2.northEast;
    const n2 = t2.southWest;
    const o2 = new be(n2.lon + i2, n2.lat + s2);
    const a2 = this.childNodes;
    const l2 = this.layer._planet;
    const h2 = this.zoom + 1;
    a2[ps] = new J_(e4, ps, this, new Ye(new be(n2.lon, n2.lat + s2), new be(n2.lon + i2, r2.lat)), l2, h2);
    a2[ms] = new J_(e4, ms, this, new Ye(o2, new be(r2.lon, r2.lat)), l2, h2);
    a2[vs] = new J_(e4, vs, this, new Ye(new be(n2.lon, n2.lat), o2), l2, h2);
    a2[ys] = new J_(e4, ys, this, new Ye(new be(n2.lon + i2, n2.lat), new be(r2.lon, n2.lat + s2)), l2, h2);
  }
  collectRenderCollectionsPASS1(e4, t2) {
    const i2 = e4[this.nodeId];
    if (i2) {
      const s2 = this.childNodes;
      if (this.entityCollection) {
        this.renderCollection(t2, e4);
      } else if (s2.length) {
        if (i2.state === Es) {
          this.strategy._secondPASS.push(this);
        } else {
          s2[ps].collectRenderCollectionsPASS1(e4, t2);
          s2[ms].collectRenderCollectionsPASS1(e4, t2);
          s2[vs].collectRenderCollectionsPASS1(e4, t2);
          s2[ys].collectRenderCollectionsPASS1(e4, t2);
        }
      }
    }
  }
  collectRenderCollectionsPASS2(e4, t2, i2) {
    const s2 = this.layer._planet;
    const r2 = s2.camera;
    const n2 = r2.eye.distance(this.bsphere.center) - this.bsphere.radius < fs * Math.sqrt(r2._lonLat.height) || r2._lonLat.height > 1e4;
    if (this.count > 0 && n2 && r2.containsSphere(this.bsphere)) {
      const s3 = this.childNodes;
      if (this.entityCollection) {
        this.renderCollection(t2, e4, i2);
      } else if (s3.length) {
        s3[ps].collectRenderCollectionsPASS2(e4, t2, i2);
        s3[ms].collectRenderCollectionsPASS2(e4, t2, i2);
        s3[vs].collectRenderCollectionsPASS2(e4, t2, i2);
        s3[ys].collectRenderCollectionsPASS2(e4, t2, i2);
      }
    }
  }
  applyCollection() {
    this.entityCollection.addEntities(this.deferredEntities);
    this.deferredEntities.length = 0;
    this.deferredEntities = [];
    this._inTheQueue = false;
  }
  traverseTree(e4) {
    const t2 = this.childNodes;
    if (this.entityCollection) {
      e4(this);
    } else if (t2.length) {
      t2[ps].traverseTree(e4);
      t2[ms].traverseTree(e4);
      t2[vs].traverseTree(e4);
      t2[ys].traverseTree(e4);
    }
  }
  renderCollection(e4, t2, i2) {
    const s2 = this.strategy;
    s2._renderingNodes[this.nodeId] = true;
    if (this.deferredEntities.length && !this._inTheQueue) {
      if (this.layer.async) {
        s2._queueDeferredNode(this);
      } else {
        this.applyCollection();
      }
    }
    let r2 = this.entityCollection;
    let n2 = this.layer;
    r2._fadingOpacity = n2._fadingOpacity;
    r2.scaleByDistance = n2.scaleByDistance;
    r2.pickingScale = n2.pickingScale;
    r2.polygonOffsetUnits = n2.polygonOffsetUnits;
    e4.push(r2);
    if (n2.clampToGround || n2.relativeToGround) {
      const e5 = r2._entities;
      let s3 = e5.length;
      if (t2[this.nodeId] && t2[this.nodeId].state === Es) {
        while (s3--) {
          let i3 = e5[s3];
          this.alignEntityToTheGround(i3, t2[this.nodeId].segment);
        }
      } else if (i2) {
        while (s3--) {
          let r3 = e5[s3];
          this.alignEntityToTheGround(r3, t2[i2].segment);
        }
      } else {
        const t3 = n2._planet._renderedNodes;
        while (s3--) {
          let i3 = e5[s3];
          let r3 = t3.length;
          while (r3--) {
            if (t3[r3].segment.isEntityInside(i3)) {
              this.alignEntityToTheGround(i3, t3[r3].segment);
              break;
            }
          }
        }
      }
    }
  }
  alignEntityToTheGround(e4, t2) {
    let i2 = new Ke();
    t2.getEntityTerrainPoint(e4, i2);
    let s2 = Number(this.layer.relativeToGround) && e4._altitude || 0;
    if (s2) {
      let t3 = this.layer._planet.ellipsoid.getSurfaceNormal3v(i2);
      e4._setCartesian3vSilent(i2.addA(t3.scale(s2)));
    } else {
      e4._setCartesian3vSilent(i2);
    }
  }
  isVisible() {
    if (this.strategy._renderingNodes[this.nodeId]) {
      return true;
    }
    return false;
  }
}
class ef extends J_ {
  constructor(e4, t2, i2, s2, r2, n2) {
    super(e4, t2, i2, s2, r2, n2);
    this.strategy = e4;
    this.isNorth = false;
  }
  createChildNodes() {
    const e4 = this.strategy;
    const t2 = this.extent;
    const i2 = t2.getWidth() * 0.5;
    const s2 = t2.getHeight() * 0.5;
    const r2 = t2.northEast;
    const n2 = t2.southWest;
    const o2 = new be(n2.lon + i2, n2.lat + s2);
    const a2 = this.childNodes;
    const l2 = this.layer._planet;
    const h2 = this.zoom + 1;
    a2[ps] = new ef(e4, ps, this, new Ye(new be(n2.lon, n2.lat + s2), new be(n2.lon + i2, r2.lat)), l2, h2);
    a2[ms] = new ef(e4, ms, this, new Ye(o2, new be(r2.lon, r2.lat)), l2, h2);
    a2[vs] = new ef(e4, vs, this, new Ye(new be(n2.lon, n2.lat), o2), l2, h2);
    a2[ys] = new ef(e4, ys, this, new Ye(new be(n2.lon + i2, n2.lat), new be(r2.lon, n2.lat + s2)), l2, h2);
  }
  _setExtentBounds() {
    if (this.extent.northEast.lat > 0) {
      this.isNorth = true;
    }
    this.bsphere.setFromExtent(this.layer._planet.ellipsoid, this.extent);
  }
  __setLonLat__(e4) {
    if (e4._lonLat.isZero()) {
      e4._lonLat = this.layer._planet.ellipsoid.cartesianToLonLat(e4._cartesian);
    }
    return e4._lonLat;
  }
  isVisible() {
    if (this.isNorth && this.strategy._renderingNodesNorth[this.nodeId]) {
      return true;
    } else if (this.strategy._renderingNodesSouth[this.nodeId]) {
      return true;
    }
    return false;
  }
  isInside(e4) {
    return this.extent.isInside(e4._lonLat);
  }
  renderCollection(e4, t2, i2) {
    if (this.isNorth) {
      this.strategy._renderingNodesNorth[this.nodeId] = true;
    } else {
      this.strategy._renderingNodesSouth[this.nodeId] = true;
    }
    if (this.deferredEntities.length && !this._inTheQueue) {
      if (this.layer.async) {
        this.strategy._queueDeferredNode(this);
      } else {
        this.applyCollection();
      }
    }
    const s2 = this.entityCollection;
    s2._fadingOpacity = this.layer._fadingOpacity;
    s2.scaleByDistance = this.layer.scaleByDistance;
    s2.pickingScale = this.layer.pickingScale;
    if (!s2.isEmpty()) {
      e4.push(s2);
    }
  }
}
class tf extends q_ {
  constructor(e4, t2) {
    super(e4, t2);
    let i2 = e4._planet;
    this._entityCollectionsTree = new J_(this, ps, null, Ye.createFromArray([-2003750834e-2, -2003750834e-2, 2003750834e-2, 2003750834e-2]), i2, 0);
    this._entityCollectionsTreeNorth = new ef(this, ps, null, Ye.createFromArray([-180, Ge, 180, 90]), i2, 0);
    this._entityCollectionsTreeSouth = new ef(this, ps, null, Ye.createFromArray([-180, -90, 180, We]), i2, 0);
    this._renderingNodes = {};
    this._renderingNodesNorth = {};
    this._renderingNodesSouth = {};
  }
  insertEntity(e4, t2 = false) {
    if (e4._lonLat.lat > Ge) {
      this._entityCollectionsTreeNorth.__setLonLat__(e4);
      this._entityCollectionsTreeNorth.insertEntity(e4, t2);
    } else if (e4._lonLat.lat < We) {
      this._entityCollectionsTreeSouth.__setLonLat__(e4);
      this._entityCollectionsTreeSouth.insertEntity(e4, t2);
    } else {
      this._entityCollectionsTree.__setLonLat__(e4);
      this._entityCollectionsTree.insertEntity(e4, t2);
    }
  }
  setPickingEnabled(e4) {
    this._entityCollectionsTree && this._entityCollectionsTree.traverseTree((t2) => {
      t2.entityCollection.setPickingEnabled(e4);
    });
    this._entityCollectionsTreeNorth && this._entityCollectionsTreeNorth.traverseTree((t2) => {
      t2.entityCollection.setPickingEnabled(e4);
    });
    this._entityCollectionsTreeSouth && this._entityCollectionsTreeSouth.traverseTree((t2) => {
      t2.entityCollection.setPickingEnabled(e4);
    });
  }
  dispose() {
    this._entityCollectionsTree = null;
    this._entityCollectionsTreeNorth = null;
    this._entityCollectionsTreeSouth = null;
    this._renderingNodes = {};
    this._renderingNodesNorth = {};
    this._renderingNodesSouth = {};
  }
  insertEntities(e4) {
    let t2 = [], i2 = [], s2 = [];
    for (let r2 = 0, n2 = e4.length; r2 < n2; r2++) {
      let n3 = e4[r2];
      if (n3._lonLat.lat > Ge) {
        t2.push(n3);
        this._entityCollectionsTreeNorth.__setLonLat__(n3);
      } else if (n3._lonLat.lat < We) {
        i2.push(n3);
        this._entityCollectionsTreeSouth.__setLonLat__(n3);
      } else {
        s2.push(n3);
        this._entityCollectionsTree.__setLonLat__(n3);
      }
    }
    this._entityCollectionsTree.buildTree(s2);
    this._entityCollectionsTreeNorth.buildTree(t2);
    this._entityCollectionsTreeSouth.buildTree(i2);
  }
  collectVisibleEntityCollections(e4) {
    this._renderingNodes = {};
    this._renderingNodesNorth = {};
    this._renderingNodesSouth = {};
    let t2 = this._layer._planet.quadTreeStrategy;
    this._secondPASS = [];
    this._entityCollectionsTree.collectRenderCollectionsPASS1(t2._visibleNodes, e4);
    let i2 = this._secondPASS.length;
    while (i2--) {
      this._secondPASS[i2].collectRenderCollectionsPASS2(t2._visibleNodes, e4, this._secondPASS[i2].nodeId);
    }
    this._secondPASS = [];
    this._entityCollectionsTreeNorth.collectRenderCollectionsPASS1(t2._visibleNodesNorth, e4);
    i2 = this._secondPASS.length;
    while (i2--) {
      this._secondPASS[i2].collectRenderCollectionsPASS2(t2._visibleNodesNorth, e4, this._secondPASS[i2].nodeId);
    }
    this._secondPASS = [];
    this._entityCollectionsTreeSouth.collectRenderCollectionsPASS1(t2._visibleNodesSouth, e4);
    i2 = this._secondPASS.length;
    while (i2--) {
      this._secondPASS[i2].collectRenderCollectionsPASS2(t2._visibleNodesSouth, e4, this._secondPASS[i2].nodeId);
    }
  }
}
class sf extends $_ {
  constructor(e4) {
    super(e4, "Earth");
    this._visibleNodesNorth = {};
    this._visibleNodesSouth = {};
  }
  collectVisibleNode(e4) {
    let t2 = e4.segment._tileGroup;
    if (t2 === E_) {
      this._visibleNodesNorth[e4.nodeId] = e4;
    } else if (t2 === A_) {
      this._visibleNodesSouth[e4.nodeId] = e4;
    } else {
      this._visibleNodes[e4.nodeId] = e4;
    }
  }
  _clearVisibleNodes() {
    super._clearVisibleNodes();
    this._visibleNodesNorth = {};
    this._visibleNodesSouth = {};
  }
  createEntitiCollectionsTreeStrategy(e4, t2) {
    return new tf(e4, t2);
  }
  init() {
    this._quadTreeList = [new j_(N_, this.planet, 0, null, 0, Ye.createFromArray([-2003750834e-2, -2003750834e-2, 2003750834e-2, 2003750834e-2])), new j_(Q_, this.planet, 0, null, 0, Ye.createFromArray([-180, Ge, 180, 90])), new j_(Q_, this.planet, 0, null, 0, Ye.createFromArray([-180, -90, 180, We]))];
  }
  getTileXY(e4, t2) {
    let i2 = L_(e4.lat, Ge), s2 = t2, r2 = -1, n2 = -1, o2 = 1 << s2;
    if (i2 === E_) {
      r2 = w_(e4.lon, 360 / o2, -180);
      n2 = w_(e4.lat, (90 - Ge) / o2, 90);
    } else if (i2 === A_) {
      r2 = w_(e4.lon, 360 / o2, -180);
      n2 = w_(e4.lat, (90 - Ge) / o2, We);
    } else {
      let t3 = Ie(e4);
      r2 = w_(t3.lon, Ce / o2, -2003750834e-2);
      n2 = w_(t3.lat, Ce / o2, we);
    }
    return [r2, n2, s2, i2];
  }
  getLonLatTileOffset(e4, t2, i2, s2, r2) {
    let n2 = e4;
    let o2 = new Ye();
    if (e4.lat > Ge) {
      let e5 = Ye.createFromArray([-180, Ge, 180, 90]);
      o2 = C_(t2, i2, s2, e5);
    } else if (e4.lat < We) {
      let e5 = Ye.createFromArray([-180, -90, 180, We]);
      o2 = C_(t2, i2, s2, e5);
    } else {
      n2 = Ie(e4);
      o2 = Ue(t2, i2, s2);
    }
    let a2 = o2.getWidth() / (r2 - 1), l2 = o2.getHeight() / (r2 - 1);
    let h2 = r2 - Math.ceil((n2.lat - o2.southWest.lat) / l2) - 1, c2 = Math.floor((n2.lon - o2.southWest.lon) / a2);
    return [h2, c2];
  }
}
class rf {
  constructor(e4 = {}) {
    this.model = e4.model || null;
    this.src = e4.src || null;
    this._cached_ix = 0;
    this._cached_iy = 0;
    this._v00 = 0;
    this._v01 = 0;
    this._v10 = 0;
    this._v11 = 0;
    this._t = 0;
  }
  static loadModel(e4) {
    if (!e4) {
      return new Promise((e5) => {
        e5(null);
      });
    } else return fetch(e4, {}).then((e5) => {
      if (!e5.ok) {
        throw Error("Geoid model file: HTTP error " + e5.status);
      }
      return e5.arrayBuffer();
    }).then((t2) => {
      if (t2) {
        return new Uint8Array(t2);
      } else {
        throw Error("Geoid model file: no data from " + e4);
      }
    }).then(function(e5) {
      if (!(e5[0] === 80 && e5[1] === 53 && (e5[2] === 13 && e5[3] === 10 || e5[2] === 10))) {
        throw new Error("Geoid model file: no PGM header");
      }
      var t2 = e5[2] === 13 ? 4 : 3;
      var i2 = null;
      var s2 = null;
      function r2() {
        let i3 = t2;
        for (var s3 = t2; ; s3++) {
          if (s3 >= e5.length) {
            throw new Error("Geoid model file: missing newline in header");
          }
          if (e5[s3] === 10) {
            t2 = s3 + 1;
            break;
          }
        }
        if (s3 > i3 && e5[s3 - 1] === 13) s3--;
        return String.fromCharCode.apply(null, e5.slice(i3, s3));
      }
      var n2, o2;
      for (; ; ) {
        o2 = r2();
        if (o2[0] !== "#") break;
        n2 = o2.match(/^# Offset (.*)$/);
        if (n2) {
          i2 = parseInt(n2[1], 10);
          if (!isFinite(i2)) {
            throw new Error("Geoid model file: bad offset " + n2[1]);
          }
        } else {
          n2 = o2.match(/^# Scale (.*)$/);
          if (n2) {
            s2 = parseFloat(n2[1]);
            if (!isFinite(s2)) {
              throw new Error("Geoid model file: bad scale " + n2[1]);
            }
          }
        }
      }
      n2 = o2.match(/^\s*(\d+)\s+(\d+)\s*$/);
      let a2 = 0;
      let l2 = 0;
      if (n2) {
        a2 = parseInt(n2[1], 10);
        l2 = parseInt(n2[2], 10);
      }
      if (!(n2 && a2 >= 0 && l2 >= 0)) {
        throw new Error("Geoid model file: bad PGM width&height line");
      }
      let h2 = parseInt(r2());
      if (h2 != 65535) {
        throw new Error("Geoid model file: PGM file must have 65535 gray levels");
      }
      if (i2 === null) {
        throw new Error("Geoid model file: PGM file does not contain offset");
      }
      if (s2 === null) {
        throw new Error("Geoid model file: PGM file does not contain scale");
      }
      if (a2 < 2 || l2 < 2) {
        throw new Error("Geoid model file: Raster size too small");
      }
      let c2 = e5.length - t2;
      if (c2 !== a2 * l2 * 2) {
        throw new Error("Geoid model file: File has the wrong length");
      }
      return { scale: s2, offset: i2, width: a2, height: l2, rlonres: a2 / 360, rlatres: (l2 - 1) / 180, i: t2, rawfile: e5 };
    });
  }
  setModel(e4) {
    this.model = e4;
  }
  _rawval(e4, t2) {
    let i2 = this.model;
    if (t2 < 0) {
      t2 = -t2;
      e4 += i2.width / 2;
    } else if (t2 >= i2.height) {
      t2 = 2 * (i2.height - 1) - t2;
      e4 += i2.width / 2;
    }
    if (e4 < 0) {
      e4 += i2.width;
    } else if (e4 >= i2.width) {
      e4 -= i2.width;
    }
    let s2 = (t2 * i2.width + e4) * 2 + i2.i;
    return i2.rawfile[s2] << 8 | i2.rawfile[s2 + 1];
  }
  getHeightLonLat(e4) {
    return this.getHeight(e4.lon, e4.lat);
  }
  getHeight(e4, t2) {
    if (!this.model) return 0;
    let i2 = this.model;
    if (e4 < 0) e4 += 360;
    let s2 = (90 - t2) * i2.rlatres;
    let r2 = e4 * i2.rlonres;
    let n2 = Math.floor(s2);
    let o2 = Math.floor(r2);
    r2 -= o2;
    s2 -= n2;
    if (n2 === i2.height - 1) {
      n2--;
    }
    if (this._cached_ix !== o2 || this._cached_iy !== n2) {
      this._cached_ix = o2;
      this._cached_iy = n2;
      this._v00 = this._rawval(o2, n2);
      this._v01 = this._rawval(o2 + 1, n2);
      this._v10 = this._rawval(o2, n2 + 1);
      this._v11 = this._rawval(o2 + 1, n2 + 1);
    }
    let a2 = (1 - r2) * this._v00 + r2 * this._v01;
    let l2 = (1 - r2) * this._v10 + r2 * this._v11;
    let h2 = (1 - s2) * a2 + s2 * l2;
    return i2.offset + i2.scale * h2;
  }
}
class nf {
  constructor(e4, t2 = 5) {
    this.MAX_FRAMES = t2;
    this._gridSize = 64;
    this._planet = e4;
    this._framebuffer = null;
    this._framebufferMercProj = null;
    this._texCoordsBuffer = null;
    this._indexBuffer = null;
    this._currentFrame = 0;
    this._queue = [];
    this._animate = [];
    this._quadTexCoordsBuffer = null;
    this._quadVertexBuffer = null;
  }
  init() {
    this._initShaders();
    this._initBuffers();
  }
  createGridBuffer(e4, t2 = false) {
    let i2 = this._gridSize;
    let s2 = new be((e4[3].lon - e4[0].lon) / i2, (e4[3].lat - e4[0].lat) / i2), r2 = new be((e4[2].lon - e4[1].lon) / i2, (e4[2].lat - e4[1].lat) / i2), n2 = new be((e4[1].lon - e4[0].lon) / i2, (e4[1].lat - e4[0].lat) / i2), o2 = new be((e4[2].lon - e4[3].lon) / i2, (e4[2].lat - e4[3].lat) / i2);
    const a2 = (i2 + 1) * (i2 + 1) * 2, l2 = a2 / 2;
    let h2 = new Float32Array(a2), c2 = new Float32Array(a2);
    let d2 = new Array(l2);
    let u2 = 0, _2 = 0, f2 = 0;
    let g2 = new Float32Array(2);
    for (let t3 = 0; t3 <= i2; t3++) {
      let a3 = new be(e4[0].lon + t3 * s2.lon, e4[0].lat + t3 * s2.lat), l3 = new be(e4[1].lon + t3 * r2.lon, e4[1].lat + t3 * r2.lat);
      for (let t4 = 0; t4 <= i2; t4++) {
        let i3 = new be(e4[0].lon + t4 * n2.lon, e4[0].lat + t4 * n2.lat), s3 = new be(e4[3].lon + t4 * o2.lon, e4[3].lat + t4 * o2.lat);
        let r3 = Mt(a3, l3, i3, s3);
        zo(r3.lon, g2);
        h2[u2++] = g2[0];
        c2[_2++] = g2[1];
        zo(r3.lat, g2);
        h2[u2++] = g2[0];
        c2[_2++] = g2[1];
        d2[f2++] = r3;
      }
    }
    if (t2) {
      for (let e5 = 0; e5 < l2; e5++) {
        let t3 = d2[e5].forwardMercator();
        zo(t3.lon, g2);
        h2[e5 * 2] = g2[0];
        c2[e5 * 2] = g2[1];
        zo(t3.lat, g2);
        h2[e5 * 2 + 1] = g2[0];
        c2[e5 * 2 + 1] = g2[1];
      }
    }
    return [this._planet.renderer.handler.createArrayBuffer(h2, 2, l2), this._planet.renderer.handler.createArrayBuffer(c2, 2, l2)];
  }
  frame() {
    let e4 = this.MAX_FRAMES;
    while (e4-- && this._queue.length) {
      const e5 = this._queue.shift();
      e5._isRendering = false;
      e5.rendering();
      e5.events.dispatch(e5.events.loadend);
    }
    e4 = this._animate.length;
    while (e4--) {
      this._animate[e4].rendering();
    }
  }
  add(e4) {
    if (!e4._isRendering) {
      e4._isRendering = true;
      if (e4._animate) {
        this._animate.push(e4);
      } else {
        this._queue.push(e4);
      }
    }
  }
  remove(e4) {
    if (e4._isRendering) {
      e4._creationProceeding = false;
      e4._isRendering = false;
      let t2;
      if (e4._animate) {
        t2 = this._animate;
      } else {
        t2 = this._queue;
      }
      for (let i2 = 0; i2 < t2.length; i2++) {
        if (t2[i2].isEqual(e4)) {
          t2.splice(i2, 1);
          return;
        }
      }
    }
  }
  _initBuffers() {
    let e4 = this._planet.renderer.handler;
    this._framebuffer = new u_(e4, { width: 2, height: 2, useDepth: false });
    this._framebuffer.init();
    this._framebufferMercProj = new u_(e4, { width: 2, height: 2, useDepth: false });
    this._framebufferMercProj.init();
    let t2 = Math.log2(this._gridSize);
    this._texCoordsBuffer = this._planet._textureCoordsBufferCache[t2];
    this._indexBuffer = this._planet._indexesCache[t2][t2][t2][t2][t2].buffer;
    this._quadTexCoordsBuffer = e4.createArrayBuffer(new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]), 2, 4);
    this._quadVertexBuffer = e4.createArrayBuffer(new Float32Array([-1, 1, 1, 1, -1, -1, 1, -1]), 2, 4);
  }
  _initShaders() {
    this._planet.renderer.handler.addProgram(new Yr("geoImageTransform", { uniforms: { sourceTexture: "sampler2d", extentParamsHigh: "vec4", extentParamsLow: "vec4", isFullExtent: "bool" }, attributes: { cornersHigh: "vec2", cornersLow: "vec2", texCoords: "vec2" }, vertexShader: `attribute vec2 cornersHigh; 
                     attribute vec2 cornersLow;
                      attribute vec2 texCoords; 
                      uniform vec4 extentParamsHigh; 
                      uniform vec4 extentParamsLow; 
                      varying vec2 v_texCoords;
                      void main() {                                                             
                          v_texCoords = texCoords; 
                          vec2 highDiff = cornersHigh - extentParamsHigh.xy;
                          vec2 lowDiff = cornersLow - extentParamsLow.xy;                                        
                          gl_Position = vec4((-1.0 + (highDiff * step(1.0, length(highDiff)) + lowDiff) * extentParamsHigh.zw) * vec2(1.0, -1.0), 0.0, 1.0); 
                      }`, fragmentShader: `precision highp float;
                        uniform sampler2D sourceTexture;
                        uniform bool isFullExtent;
                        varying vec2 v_texCoords;
                        void main () {
                            if(!isFullExtent && (v_texCoords.x <= 0.001 || v_texCoords.x >= 0.999 ||
                                v_texCoords.y <= 0.001 || v_texCoords.y >= 0.999)) {
                                discard;
                            }
                            gl_FragColor = texture2D(sourceTexture, v_texCoords);
                        }` }));
  }
}
const of = ["loadend", "layerloadend"];
class af {
  constructor(e4 = 24) {
    this.MAX_REQUESTS = e4;
    this.events = Qi(of);
    this._loading = 0;
    this._queue = [];
    this._senderRequestCounter = [];
    this._promises = { json: (e5) => e5.json(), blob: (e5) => e5.blob(), arrayBuffer: (e5) => e5.arrayBuffer(), imageBitmap: (e5) => e5.blob().then((e6) => createImageBitmap(e6, { premultiplyAlpha: "premultiply" })), text: (e5) => e5.text() };
  }
  load(e4, t2) {
    if (e4.sender) {
      if (!this._senderRequestCounter[e4.sender.__id]) {
        this._senderRequestCounter[e4.sender.__id] = { sender: e4.sender, counter: 0, __requestCounterFrame__: 0 };
      }
      this._senderRequestCounter[e4.sender.__id].counter++;
    }
    this._queue.push({ params: e4, callback: t2 });
    this._exec();
  }
  fetch(e4) {
    return fetch(e4.src, e4.options || {}).then((t2) => {
      if (!t2.ok) {
        throw Error(`Unable to load '${e4.src}'`);
      }
      return this._promises[e4.type || "blob"](t2);
    }).then((e5) => ({ status: "ready", data: e5 })).catch((e5) => ({ status: "error", msg: e5.toString() }));
  }
  getRequestCounter(e4) {
    if (e4) {
      let t2 = this._senderRequestCounter[e4.__id];
      if (t2) {
        return t2.counter;
      }
    }
    return 0;
  }
  isIdle(e4) {
    return e4.isIdle;
  }
  _checkLoadend(e4, t2) {
    if (e4.counter === 0 && (!t2._planet || t2._planet._terrainCompletedActivated)) {
      t2.events.dispatch(t2.events.loadend, t2);
      this.events.dispatch(this.events.layerloadend, t2);
      e4.__requestCounterFrame__ = 0;
    } else {
      e4.__requestCounterFrame__ = requestAnimationFrame(() => {
        this._checkLoadend(e4, t2);
      });
    }
  }
  _handleResponse(e4, t2) {
    e4.callback(t2);
    let i2 = e4.params.sender;
    if (i2 && (i2.events.loadend.handlers.length || this.events.layerloadend.handlers.length)) {
      let e5 = this._senderRequestCounter[i2.__id];
      if (e5 && e5.counter > 0) {
        e5.counter--;
        cancelAnimationFrame(e5.__requestCounterFrame__);
        e5.__requestCounterFrame__ = requestAnimationFrame(() => {
          this._checkLoadend(e5, i2);
        });
      }
    }
    this._exec();
  }
  _exec() {
    if (this._queue.length > 0 && this._loading < this.MAX_REQUESTS) {
      let e4 = this._queue.pop();
      if (!e4) return;
      let t2 = e4.params;
      if (!t2.filter || t2.filter(t2)) {
        this._loading++;
        return fetch(t2.src, t2.options || {}).then((e5) => {
          if (!e5.ok) {
            throw Error(`Unable to load '${t2.src}'`);
          }
          return this._promises[t2.type || "blob"](e5);
        }).then((t3) => {
          this._loading--;
          this._handleResponse(e4, { status: "ready", data: t3 });
        }).catch((t3) => {
          this._loading--;
          this._handleResponse(e4, { status: "error", msg: t3.toString() });
        });
      } else {
        this._handleResponse(e4, { status: "abort" });
      }
    } else if (this._loading === 0) {
      this.events.dispatch(this.events.loadend);
    }
  }
  abort(e4) {
    if (this._senderRequestCounter[e4.__id]) {
      this._senderRequestCounter[e4.__id].counter = 0;
      cancelAnimationFrame(this._senderRequestCounter[e4.__id].__requestCounterFrame__);
      this._senderRequestCounter[e4.__id].__requestCounterFrame__ = 0;
    }
    for (let t2 = 0, i2 = this._queue.length; t2 < i2; t2++) {
      let i3 = this._queue[t2];
      if (i3 && i3.params.sender && e4.isEqual(i3.params.sender)) {
        i3.callback({ status: "abort" });
        this._queue[t2] = null;
      }
    }
  }
  abortAll() {
    for (let e4 = 0, t2 = this._queue.length; e4 < t2; e4++) {
      let t3 = this._queue[e4];
      if (t3) {
        let i2 = t3.params.sender;
        if (i2 && this._senderRequestCounter[i2.__id]) {
          this._senderRequestCounter[i2.__id].counter = 0;
          cancelAnimationFrame(this._senderRequestCounter[i2.__id].__requestCounterFrame__);
          this._senderRequestCounter[i2.__id].__requestCounterFrame__ = 0;
        }
        t3.callback({ status: "abort" });
        this._queue[e4] = null;
      }
    }
    this._queue = [];
  }
  get loading() {
    return this._loading;
  }
  get queue() {
    return this._queue;
  }
}
class lf {
  constructor(e4, t2 = {}) {
    this._minTabelSize = t2.minTableSize || 1;
    this._maxTableSize = t2.maxTableSize || 8;
    this._planet = e4;
    this._handler = null;
    this._verticesBufferArray = [];
    this._indexBufferArray = [];
    this._positionBuffer = null;
    this._framebuffer = null;
    this._normalMapVerticesTexture = null;
    this._width = t2.width || 128;
    this._height = t2.height || 128;
    this._queue = new Y_(1024);
    this._lock = new nh();
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  init() {
    this._maxTableSize = this._planet.maxGridSize || 8;
    this._handler = this._planet.renderer.handler;
    const e4 = new Yr("normalMapBlur", { attributes: { a_position: "vec2" }, uniforms: { s_texture: "sampler2d" }, vertexShader: `attribute vec2 a_position;
                       attribute vec2 a_texCoord;

                      varying vec2 blurCoordinates[5];

                      void main() {
                          vec2 vt = a_position * 0.5 + 0.5; 
                          ${" "}
                          gl_Position = vec4(a_position, 0.0, 1.0);
                          blurCoordinates[0] = vt;
                          blurCoordinates[1] = vt + ${1 / this._width * 1.407333};
                          blurCoordinates[2] = vt - ${1 / this._height * 1.407333};
                          blurCoordinates[3] = vt + ${1 / this._width * 3.294215};
                          blurCoordinates[4] = vt - ${1 / this._height * 3.294215};
                }`, fragmentShader: `precision lowp float;
                        uniform sampler2D s_texture;                        
                        varying vec2 blurCoordinates[5];                        

                        void main() {
                            lowp vec4 sum = vec4(0.0);
                            //if(blurCoordinates[0].x <= 0.01 || blurCoordinates[0].x >= 0.99 ||
                            //    blurCoordinates[0].y <= 0.01 || blurCoordinates[0].y >= 0.99){
                            //    sum = texture2D(s_texture, blurCoordinates[0]);
                            //} else {
                                sum += texture2D(s_texture, blurCoordinates[0]) * 0.204164;
                                sum += texture2D(s_texture, blurCoordinates[1]) * 0.304005;
                                sum += texture2D(s_texture, blurCoordinates[2]) * 0.304005;
                                sum += texture2D(s_texture, blurCoordinates[3]) * 0.093913;
                                sum += texture2D(s_texture, blurCoordinates[4]) * 0.093913;
                            //}
                            gl_FragColor = sum;
                        }` });
    const t2 = new Yr("normalMap", { attributes: { a_position: "vec2", a_normal: "vec3" }, uniforms: {}, vertexShader: `attribute vec2 a_position;
                      attribute vec3 a_normal;
                      
                      varying vec3 v_color;
                      
                      void main() {
                          gl_Position = vec4(a_position, 0, 1);
                          v_color = normalize(a_normal) * 0.5 + 0.5;
                      }`, fragmentShader: `precision highp float;
                        
                        varying vec3 v_color;
                        
                        void main () {
                            gl_FragColor = vec4(v_color, 1.0);
                        }` });
    this._handler.addProgram(e4);
    this._handler.addProgram(t2);
    this._framebuffer = new u_(this._handler, { width: this._width, height: this._height, useDepth: false });
    this._framebuffer.init();
    this._normalMapVerticesTexture = this._handler.createEmptyTexture_l(this._width, this._height);
    for (let e5 = this._minTabelSize; e5 <= this._maxTableSize; e5++) {
      const t3 = 1 << e5;
      const i3 = t3 / 2;
      let s2 = new Float32Array((t3 + 1) * (t3 + 1) * 2);
      for (let e6 = 0; e6 <= t3; e6++) {
        for (let r2 = 0; r2 <= t3; r2++) {
          let n2 = (e6 * (t3 + 1) + r2) * 2;
          s2[n2] = -1 + r2 / i3;
          s2[n2 + 1] = -1 + e6 / i3;
        }
      }
      this._verticesBufferArray[t3] = this._handler.createArrayBuffer(s2, 2, s2.length / 2);
      this._indexBufferArray[t3] = this._planet._indexesCache[Math.log2(t3)][Math.log2(t3)][Math.log2(t3)][Math.log2(t3)][Math.log2(t3)].buffer;
    }
    const i2 = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    this._positionBuffer = this._handler.createArrayBuffer(i2, 2, i2.length / 2);
  }
  _drawNormalMapBlur(e4) {
    let t2 = e4.normalMapNormals;
    if (e4.node && e4.node.getState() !== Ts && t2 && t2.length) {
      const i2 = t2.length / 3;
      const s2 = Math.sqrt(i2) - 1;
      let r2 = this._verticesBufferArray[s2];
      if (r2) {
        if (e4.planet.terrain.equalizeNormals) {
          e4._normalMapEdgeEqualize(xs);
          e4._normalMapEdgeEqualize(ws);
          e4._normalMapEdgeEqualize(Cs);
          e4._normalMapEdgeEqualize(bs);
        }
        let n2 = e4.normalMapTexturePtr;
        const o2 = this._handler;
        const a2 = o2.gl;
        let l2 = o2.createArrayBuffer(t2, 3, i2, a2.DYNAMIC_DRAW);
        const h2 = this._framebuffer;
        let c2 = o2.programs.normalMap;
        let d2 = c2._program.attributes;
        h2.bindOutputTexture(this._normalMapVerticesTexture);
        c2.activate();
        a2.bindBuffer(a2.ARRAY_BUFFER, r2);
        a2.vertexAttribPointer(d2.a_position, r2.itemSize, a2.FLOAT, false, 0, 0);
        a2.bindBuffer(a2.ARRAY_BUFFER, l2);
        a2.vertexAttribPointer(d2.a_normal, l2.itemSize, a2.FLOAT, false, 0, 0);
        a2.bindBuffer(a2.ELEMENT_ARRAY_BUFFER, this._indexBufferArray[s2]);
        a2.drawElements(a2.TRIANGLE_STRIP, this._indexBufferArray[s2].numItems, a2.UNSIGNED_INT, 0);
        a2.deleteBuffer(l2);
        h2.bindOutputTexture(n2);
        c2 = o2.programs.normalMapBlur;
        c2.activate();
        a2.bindBuffer(a2.ARRAY_BUFFER, this._positionBuffer);
        a2.vertexAttribPointer(c2._program.attributes.a_position, this._positionBuffer.itemSize, a2.FLOAT, false, 0, 0);
        a2.activeTexture(a2.TEXTURE0);
        a2.bindTexture(a2.TEXTURE_2D, this._normalMapVerticesTexture);
        a2.uniform1i(c2._program.uniforms.s_texture, 0);
        a2.drawArrays(a2.TRIANGLE_STRIP, 0, this._positionBuffer.numItems);
        return true;
      } else {
        return true;
      }
    }
    return false;
  }
  _drawNormalMapNoBlur(e4) {
    let t2 = e4.normalMapNormals;
    if (e4.node && e4.node.getState() !== Ts && t2 && t2.length) {
      const i2 = t2.length / 3;
      const s2 = Math.sqrt(i2) - 1;
      let r2 = this._verticesBufferArray[s2];
      if (r2) {
        if (e4.planet.terrain.equalizeNormals) {
          e4._normalMapEdgeEqualize(xs);
          e4._normalMapEdgeEqualize(ws);
          e4._normalMapEdgeEqualize(Cs);
          e4._normalMapEdgeEqualize(bs);
        }
        let n2 = e4.normalMapTexturePtr;
        const o2 = this._handler;
        const a2 = o2.gl;
        let l2 = o2.createArrayBuffer(t2, 3, i2, a2.DYNAMIC_DRAW);
        const h2 = this._framebuffer;
        const c2 = o2.programs.normalMap;
        const d2 = c2._program.attributes;
        h2.bindOutputTexture(n2);
        c2.activate();
        a2.bindBuffer(a2.ARRAY_BUFFER, r2);
        a2.vertexAttribPointer(d2.a_position, r2.itemSize, a2.FLOAT, false, 0, 0);
        a2.bindBuffer(a2.ARRAY_BUFFER, l2);
        a2.vertexAttribPointer(d2.a_normal, l2.itemSize, a2.FLOAT, false, 0, 0);
        a2.bindBuffer(a2.ELEMENT_ARRAY_BUFFER, this._indexBufferArray[s2]);
        a2.drawElements(a2.TRIANGLE_STRIP, this._indexBufferArray[s2].numItems, a2.UNSIGNED_INT, 0);
        a2.deleteBuffer(l2);
        return true;
      } else {
        return true;
      }
    }
    return false;
  }
  _drawNormalMap(e4) {
    if (e4.planet.terrain.isBlur(e4)) {
      return this._drawNormalMapBlur(e4);
    } else {
      return this._drawNormalMapNoBlur(e4);
    }
  }
  drawSingle(e4) {
    const t2 = this._handler;
    const i2 = t2.gl;
    this._framebuffer.activate();
    i2.disable(i2.CULL_FACE);
    i2.disable(i2.DEPTH_TEST);
    i2.disable(i2.BLEND);
    if (e4.terrainReady && this._drawNormalMap(e4)) {
      e4.normalMapReady = true;
      e4.normalMapTexture = e4.normalMapTexturePtr;
      e4.normalMapTextureBias[0] = 0;
      e4.normalMapTextureBias[1] = 0;
      e4.normalMapTextureBias[2] = 1;
    }
    e4._inTheQueue = false;
    i2.enable(i2.DEPTH_TEST);
    i2.enable(i2.CULL_FACE);
    i2.enable(i2.BLEND);
    this._framebuffer.deactivate();
  }
  frame() {
    if (this._queue.length) {
      const e4 = this._handler;
      const t2 = e4.gl;
      this._framebuffer.activate();
      t2.disable(t2.CULL_FACE);
      t2.disable(t2.DEPTH_TEST);
      t2.disable(t2.BLEND);
      let i2 = 0, s2 = window.performance.now();
      while (this._lock.isFree() && this._queue.length && i2 < 0.25) {
        const e5 = this._queue.shift();
        if (e5.terrainReady && this._drawNormalMap(e5)) {
          e5.normalMapReady = true;
          e5.normalMapTexture = e5.normalMapTexturePtr;
          e5.normalMapTextureBias[0] = 0;
          e5.normalMapTextureBias[1] = 0;
          e5.normalMapTextureBias[2] = 1;
        }
        e5._inTheQueue = false;
        i2 = window.performance.now() - s2;
      }
      t2.enable(t2.BLEND);
      t2.enable(t2.DEPTH_TEST);
      t2.enable(t2.CULL_FACE);
      this._framebuffer.deactivate();
    }
  }
  get queueSize() {
    return this._queue.length;
  }
  queue(e4) {
    e4._inTheQueue = true;
    this._queue.push(e4);
  }
  unshift(e4) {
    e4._inTheQueue = true;
    this._queue.unshift(e4);
  }
  remove(e4) {
  }
  clear() {
    while (this._queue.length) {
      let e4 = this._queue.pop();
      e4._inTheQueue = false;
    }
  }
  lock(e4) {
    this._lock.lock(e4);
  }
  free(e4) {
    this._lock.free(e4);
  }
}
const hf = new y_({ code: "equi", units: m_.DEGREES });
const cf = '(function() {\n  "use strict";\n  let a = null;\n  let t = null;\n  let e = null;\n  let r = null;\n  let l = null;\n  let n = null;\n  let f = null;\n  function o(t2, e2) {\n    if (e2 < 0) {\n      e2 = -e2;\n      t2 += a.width / 2;\n    } else if (e2 >= a.height) {\n      e2 = 2 * (a.height - 1) - e2;\n      t2 += a.width / 2;\n    }\n    if (t2 < 0) {\n      t2 += a.width;\n    } else if (t2 >= a.width) {\n      t2 -= a.width;\n    }\n    var r2 = (e2 * a.width + t2) * 2 + a.i;\n    return a.rawfile[r2] << 8 | a.rawfile[r2 + 1];\n  }\n  function s(s2, i2) {\n    if (!a) return 0;\n    if (s2 < 0) s2 += 360;\n    var h2 = (90 - i2) * a.rlatres;\n    var d2 = s2 * a.rlonres;\n    var u2 = Math.floor(h2);\n    var M2 = Math.floor(d2);\n    d2 -= M2;\n    h2 -= u2;\n    if (u2 === a.height - 1) {\n      u2--;\n    }\n    if (t !== M2 || e !== u2) {\n      t = M2;\n      e = u2;\n      r = o(M2, u2);\n      l = o(M2 + 1, u2);\n      n = o(M2, u2 + 1);\n      f = o(M2 + 1, u2 + 1);\n    }\n    let c2 = null;\n    var m2 = (1 - d2) * r + d2 * l;\n    var p2 = (1 - d2) * n + d2 * f;\n    c2 = (1 - h2) * m2 + h2 * p2;\n    return a.offset + a.scale * c2;\n  }\n  const i = Math.PI * 0.5;\n  const h = 2003750834e-2;\n  const d = Math.PI / h;\n  const u = 180 / h;\n  const M = 180 / Math.PI;\n  const c = M * i;\n  const m = Math.PI / 180;\n  const p = M * 2;\n  let y = 0, w = 0;\n  let x = null;\n  const z = function(a2, t2, e2) {\n    this.x = a2;\n    this.y = t2;\n    this.z = e2;\n  };\n  var v = function(a2, t2, e2, r2) {\n    let l2 = s(a2, t2) * e2;\n    let n2 = m * t2, f2 = m * a2;\n    let o2 = Math.sin(n2);\n    let i2 = w / Math.sqrt(1 - y * o2 * o2);\n    let h2 = (i2 + l2) * Math.cos(n2);\n    r2.x = h2 * Math.cos(f2);\n    r2.y = h2 * Math.sin(f2);\n    r2.z = (i2 * (1 - y) + l2) * o2;\n  };\n  var b = function(a2, t2, e2, r2) {\n    v(a2 * u, p * Math.atan(Math.exp(t2 * d)) - c, e2, r2);\n  };\n  var A = new z(0, 0, 0);\n  var F = new z(0, 0, 0);\n  var g = new z(0, 0, 0);\n  var V = function(a2, t2, e2) {\n    let r2 = a2.x, l2 = a2.y, n2 = a2.z;\n    var f2;\n    if (r2 >= 0) {\n      f2 = Math.floor(r2 / 65536) * 65536;\n      t2.x = Math.fround(f2);\n      e2.x = Math.fround(r2 - f2);\n    } else {\n      f2 = Math.floor(-r2 / 65536) * 65536;\n      t2.x = Math.fround(-f2);\n      e2.x = Math.fround(r2 + f2);\n    }\n    if (l2 >= 0) {\n      f2 = Math.floor(l2 / 65536) * 65536;\n      t2.y = Math.fround(f2);\n      e2.y = Math.fround(l2 - f2);\n    } else {\n      f2 = Math.floor(-l2 / 65536) * 65536;\n      t2.y = Math.fround(-f2);\n      e2.y = Math.fround(l2 + f2);\n    }\n    if (n2 >= 0) {\n      f2 = Math.floor(n2 / 65536) * 65536;\n      t2.z = Math.fround(f2);\n      e2.z = Math.fround(n2 - f2);\n    } else {\n      f2 = Math.floor(-n2 / 65536) * 65536;\n      t2.z = Math.fround(-f2);\n      e2.z = Math.fround(n2 + f2);\n    }\n  };\n  self.onmessage = function(t2) {\n    if (t2.data.model) {\n      a = t2.data.model;\n      a.rawfile = t2.data.rawfile;\n    } else if (t2.data.params) {\n      let a2 = 549755748352, e2 = -549755748352, r2 = 549755748352, l2 = -549755748352, n2 = 549755748352, f2 = -549755748352;\n      y = t2.data.params[8];\n      w = t2.data.params[9];\n      let o2 = t2.data.params[2], s2 = t2.data.params[3], i2 = t2.data.params[10], h2 = t2.data.params[11], d2 = t2.data.params[12];\n      let u2 = t2.data.params[13];\n      if (t2.data.params[1] === 0) {\n        x = b;\n      } else {\n        x = v;\n      }\n      let M2 = Math.max(s2, o2);\n      let c2 = (t2.data.params[6] - t2.data.params[4]) / M2;\n      let m2 = (t2.data.params[7] - t2.data.params[5]) / M2;\n      let p2 = t2.data.params[4], z2 = t2.data.params[7];\n      let I = Math.max(s2 / o2, 1), P = M2 + 1;\n      const q = P * P;\n      const H = (o2 + 1) * (o2 + 1) * 3;\n      let L = new Float32Array(H);\n      let N = new Float64Array(H);\n      let R = new Float32Array(H);\n      let j = new Float32Array(H);\n      let k = new Float32Array(q * 3);\n      let B = new Float64Array(q * 3);\n      let C = new Float32Array(q * 3);\n      let D = new Float32Array(q * 3);\n      let E = 0, G = 0;\n      for (let t3 = 0; t3 < q; t3++) {\n        let o3 = t3 % P, s3 = ~~(t3 / P);\n        x(p2 + o3 * c2, z2 - s3 * m2, u2, A);\n        let M3 = A.x * i2, y2 = A.y * h2, w2 = A.z * d2;\n        let v2 = 1 / Math.sqrt(M3 * M3 + y2 * y2 + w2 * w2);\n        let b2 = M3 * v2, q2 = y2 * v2, H2 = w2 * v2;\n        V(A, F, g);\n        B[G] = A.x;\n        C[G] = F.x;\n        D[G] = g.x;\n        k[G++] = b2;\n        B[G] = A.y;\n        C[G] = F.y;\n        D[G] = g.y;\n        k[G++] = q2;\n        B[G] = A.z;\n        C[G] = F.z;\n        D[G] = g.z;\n        k[G++] = H2;\n        if (s3 % I === 0 && o3 % I === 0) {\n          N[E] = A.x;\n          R[E] = F.x;\n          j[E] = g.x;\n          L[E++] = b2;\n          N[E] = A.y;\n          R[E] = F.y;\n          j[E] = g.y;\n          L[E++] = q2;\n          N[E] = A.z;\n          R[E] = F.z;\n          j[E] = g.z;\n          L[E++] = H2;\n          if (A.x < a2) a2 = A.x;\n          if (A.x > e2) e2 = A.x;\n          if (A.y < r2) r2 = A.y;\n          if (A.y > l2) l2 = A.y;\n          if (A.z < n2) n2 = A.z;\n          if (A.z > f2) f2 = A.z;\n        }\n      }\n      let J = (e2 - a2) * 0.5, K = (l2 - r2) * 0.5, O = (f2 - n2) * 0.5;\n      let Q = Math.sqrt(J * J + K * K + O * O);\n      self.postMessage({ id: t2.data.params[0], plainVertices: N, plainVerticesHigh: R, plainVerticesLow: j, plainNormals: L, normalMapNormals: k, normalMapVertices: B, normalMapVerticesHigh: C, normalMapVerticesLow: D, plainRadius: Q }, [N.buffer, R.buffer, j.buffer, L.buffer, k.buffer, B.buffer, C.buffer, D.buffer]);\n    }\n  };\n})();\n//# sourceMappingURL=PlainSegmentWorker.worker-sWLoG2CP.js.map\n';
const df = typeof self !== "undefined" && self.Blob && new Blob([cf], { type: "text/javascript;charset=utf-8" });
function uf(e4) {
  let t2;
  try {
    t2 = df && (self.URL || self.webkitURL).createObjectURL(df);
    if (!t2) throw "";
    const i2 = new Worker(t2, { name: e4 == null ? void 0 : e4.name });
    i2.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(t2);
    });
    return i2;
  } catch (t3) {
    return new Worker("data:text/javascript;charset=utf-8," + encodeURIComponent(cf), { name: e4 == null ? void 0 : e4.name });
  } finally {
    t2 && (self.URL || self.webkitURL).revokeObjectURL(t2);
  }
}
class _f extends Gs {
  constructor(e4 = 2) {
    super(e4, uf);
  }
  _onMessage(e4) {
    this._source.get(e4.data.id)._plainSegmentWorkerCallback(e4.data);
    e4.data.plainVertices = null;
    e4.data.plainVerticesHigh = null;
    e4.data.plainVerticesLow = null;
    e4.data.plainNormals = null;
    e4.data.normalMapNormals = null;
    e4.data.normalMapVertices = null;
    e4.data.normalMapVerticesHigh = null;
    e4.data.normalMapVerticesLow = null;
    this._source.delete(e4.data.id);
  }
  setGeoid(e4) {
    if (e4.model) {
      let t2 = e4.model;
      let i2 = { scale: t2.scale, offset: t2.offset, width: t2.width, height: t2.height, rlonres: t2.rlonres, rlatres: t2.rlatres, i: t2.i };
      this._workerQueue.forEach((e5) => {
        let s2 = new Uint8Array(t2.rawfile.length);
        s2.set(t2.rawfile);
        e5.postMessage({ model: i2, rawfile: s2 }, [s2.buffer]);
      });
    } else {
      this._workerQueue.forEach((e5) => {
        e5.postMessage({ model: null });
      });
    }
  }
  make(e4) {
    if (e4.initialized) {
      if (this._workerQueue.length) {
        let t2 = this._workerQueue.pop();
        this._source.set(this._sourceId, e4);
        let i2 = e4._projection.id === X_.id || e4._projection.id === hf.id ? 1 : 0;
        let s2 = new Float64Array([this._sourceId, i2, e4.planet.terrain.gridSizeByZoom[e4.tileZoom], e4.planet.terrain.plainGridSize, e4._extent.southWest.lon, e4._extent.southWest.lat, e4._extent.northEast.lon, e4._extent.northEast.lat, e4.planet.ellipsoid._e2, e4.planet.ellipsoid.equatorialSize, e4.planet.ellipsoid._invRadii2.x, e4.planet.ellipsoid._invRadii2.y, e4.planet.ellipsoid._invRadii2.z, e4.planet._heightFactor]);
        this._sourceId++;
        t2.postMessage({ params: s2 }, [s2.buffer]);
      } else {
        this._pendingQueue.push(e4);
      }
    } else {
      this.check();
    }
  }
}
function ff(e4) {
  let t2 = 1 / Math.sqrt(e4[0] * e4[0] + e4[1] * e4[1] + e4[2] * e4[2]);
  e4[0] *= t2;
  e4[1] *= t2;
  e4[2] *= t2;
  e4[3] *= t2;
}
class gf {
  constructor(e4 = {}) {
    this._pickingColorU = new Float32Array([0, 0, 0]);
    this._f = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
    this.projectionMatrix = new Xe();
    this.inverseProjectionMatrix = new Xe();
    this.projectionViewMatrix = new Xe();
    this.projectionViewRTEMatrix = new Xe();
    this.inverseProjectionViewMatrix = new Xe();
    this.left = 0;
    this.right = 0;
    this.bottom = 0;
    this.top = 0;
    this.near = 0;
    this.far = 0;
    this.cameraFrustumIndex = e4.cameraFrustumIndex != void 0 ? e4.cameraFrustumIndex : -1;
    this.setProjectionMatrix(e4.fov || 30, e4.aspect || 1, e4.near || 1, e4.far || 1e3);
  }
  getRightPlane() {
    return this._f[0];
  }
  getLeftPlane() {
    return this._f[1];
  }
  getBottomPlane() {
    return this._f[2];
  }
  getTopPlane() {
    return this._f[3];
  }
  getBackwardPlane() {
    return this._f[4];
  }
  getForwardPlane() {
    return this._f[5];
  }
  getProjectionViewMatrix() {
    return this.projectionViewMatrix._m;
  }
  getProjectionViewRTEMatrix() {
    return this.projectionViewRTEMatrix._m;
  }
  getProjectionMatrix() {
    return this.projectionMatrix._m;
  }
  getInverseProjectionMatrix() {
    return this.inverseProjectionMatrix._m;
  }
  setProjectionMatrix(e4, t2, i2, s2) {
    this.top = i2 * Math.tan(e4 * f);
    this.bottom = -this.top;
    this.right = this.top * t2;
    this.left = -this.right;
    this.near = i2;
    this.far = s2;
    this.projectionMatrix.setPerspective(this.left, this.right, this.bottom, this.top, i2, s2);
    this.projectionMatrix.inverseTo(this.inverseProjectionMatrix);
  }
  setProjectionViewRTEMatrix(e4) {
    this.projectionViewRTEMatrix = this.projectionMatrix.mul(e4);
  }
  setViewMatrix(e4) {
    this.projectionViewMatrix = this.projectionMatrix.mul(e4);
    this.projectionViewMatrix.inverseTo(this.inverseProjectionViewMatrix);
    let t2 = this.projectionViewMatrix._m;
    this._f[0][0] = t2[3] - t2[0];
    this._f[0][1] = t2[7] - t2[4];
    this._f[0][2] = t2[11] - t2[8];
    this._f[0][3] = t2[15] - t2[12];
    ff(this._f[0]);
    this._f[1][0] = t2[3] + t2[0];
    this._f[1][1] = t2[7] + t2[4];
    this._f[1][2] = t2[11] + t2[8];
    this._f[1][3] = t2[15] + t2[12];
    ff(this._f[1]);
    this._f[2][0] = t2[3] + t2[1];
    this._f[2][1] = t2[7] + t2[5];
    this._f[2][2] = t2[11] + t2[9];
    this._f[2][3] = t2[15] + t2[13];
    ff(this._f[2]);
    this._f[3][0] = t2[3] - t2[1];
    this._f[3][1] = t2[7] - t2[5];
    this._f[3][2] = t2[11] - t2[9];
    this._f[3][3] = t2[15] - t2[13];
    ff(this._f[3]);
    this._f[4][0] = t2[3] - t2[2];
    this._f[4][1] = t2[7] - t2[6];
    this._f[4][2] = t2[11] - t2[10];
    this._f[4][3] = t2[15] - t2[14];
    ff(this._f[4]);
    this._f[5][0] = t2[3] + t2[2];
    this._f[5][1] = t2[7] + t2[6];
    this._f[5][2] = t2[11] + t2[10];
    this._f[5][3] = t2[15] + t2[14];
    ff(this._f[5]);
  }
  containsPoint(e4) {
    for (let t2 = 0; t2 < 6; t2++) {
      let i2 = e4.dotArr(this._f[t2]) + this._f[t2][3];
      if (i2 <= 0) {
        return false;
      }
    }
    return true;
  }
  containsSphereBottomExc(e4) {
    let t2 = -e4.radius, i2 = this._f;
    if (e4.center.dotArr(i2[0]) + i2[0][3] <= t2) return false;
    if (e4.center.dotArr(i2[1]) + i2[1][3] <= t2) return false;
    if (e4.center.dotArr(i2[3]) + i2[3][3] <= t2) return false;
    if (e4.center.dotArr(i2[4]) + i2[4][3] <= t2) return false;
    if (e4.center.dotArr(i2[5]) + i2[5][3] <= t2) return false;
    return true;
  }
  containsSphereButtom(e4) {
    let t2 = -e4.radius, i2 = this._f;
    if (e4.center.dotArr(i2[2]) + i2[2][3] <= t2) return false;
    return true;
  }
  containsSphere(e4) {
    let t2 = -e4.radius, i2 = this._f;
    if (e4.center.dotArr(i2[0]) + i2[0][3] <= t2) return false;
    if (e4.center.dotArr(i2[1]) + i2[1][3] <= t2) return false;
    if (e4.center.dotArr(i2[2]) + i2[2][3] <= t2) return false;
    if (e4.center.dotArr(i2[3]) + i2[3][3] <= t2) return false;
    if (e4.center.dotArr(i2[4]) + i2[4][3] <= t2) return false;
    if (e4.center.dotArr(i2[5]) + i2[5][3] <= t2) return false;
    return true;
  }
  containsSphere2(e4, t2) {
    let i2 = -t2;
    if (e4.dotArr(this._f[0]) + this._f[0][3] <= i2) return false;
    if (e4.dotArr(this._f[1]) + this._f[1][3] <= i2) return false;
    if (e4.dotArr(this._f[2]) + this._f[2][3] <= i2) return false;
    if (e4.dotArr(this._f[3]) + this._f[3][3] <= i2) return false;
    if (e4.dotArr(this._f[4]) + this._f[4][3] <= i2) return false;
    if (e4.dotArr(this._f[5]) + this._f[5][3] <= i2) return false;
    return true;
  }
  containsBox(e4) {
    let t2 = true, i2, s2;
    for (let r2 = 0; r2 < 6; r2++) {
      i2 = 0;
      s2 = 0;
      for (let t3 = 0; t3 < 8 && (s2 === 0 || i2 === 0); t3++) {
        let n2 = e4.vertices[t3].dotArr(this._f[r2]) + this._f[r2][3];
        if (n2 < 0) {
          i2++;
        } else {
          s2++;
        }
      }
      if (s2 === 0) {
        return false;
      } else if (i2 > 0) {
        t2 = true;
      }
    }
    return t2;
  }
}
const pf = ["viewchange", "moveend"];
const mf = (e4, t2) => _ * Math.atan(Math.tan(f * e4) * t2);
class vf {
  constructor(e4 = {}) {
    this.events = Qi(pf, this);
    this._width = e4.width || 1;
    this._height = e4.height || 1;
    this.eye = e4.eye || new Ke();
    this.eyeHigh = new Float32Array(3);
    this.eyeLow = new Float32Array(3);
    this._viewAngle = e4.viewAngle || 47;
    this._horizontalViewAngle = 0;
    this._viewMatrix = new Xe();
    this._viewMatrixRTE = new Xe();
    this._normalMatrix = new qe();
    this._r = new Ke(1, 0, 0);
    this._u = new Ke(0, 1, 0);
    this._b = new Ke(0, 0, 1);
    this._f = this._b.negateTo();
    this._pr = this._r.clone();
    this._pu = this._u.clone();
    this._pb = this._b.clone();
    this._peye = this.eye.clone();
    this.isMoving = false;
    this._tanViewAngle_hrad = 0;
    this._tanViewAngle_hradOneByHeight = 0;
    this.frustums = [];
    this.frustumColors = [];
    if (e4.frustums) {
      for (let t2 = 0, i2 = e4.frustums.length; t2 < i2; t2++) {
        let i3 = e4.frustums[t2];
        let s2 = new gf({ fov: this._viewAngle, aspect: this.getAspectRatio(), near: i3[0], far: i3[1] });
        s2.cameraFrustumIndex = this.frustums.length;
        this.frustums.push(s2);
        this.frustumColors.push(s2._pickingColorU[0], s2._pickingColorU[1], s2._pickingColorU[2]);
      }
    } else {
      let e5 = 0.1, t2 = 1e3;
      let i2 = new gf({ fov: this._viewAngle, aspect: this.getAspectRatio(), near: e5, far: t2 });
      i2.cameraFrustumIndex = this.frustums.length;
      this.frustums.push(i2);
      this.frustumColors.push(i2._pickingColorU[0], i2._pickingColorU[1], i2._pickingColorU[2]);
    }
    this.FARTHEST_FRUSTUM_INDEX = this.frustums.length - 1;
    this.currentFrustumIndex = 0;
    this.frustumColorIndex = 0;
    this.isFirstPass = false;
    this._projSizeConst = 0;
    this.set(e4.eye || new Ke(0, 0, 1), e4.look || new Ke(), e4.up || new Ke(0, 1, 0));
  }
  checkMoveEnd() {
    let e4 = this._r, t2 = this._u, i2 = this._b, s2 = this.eye;
    if (this._peye.equal(s2) && this._pr.equal(e4) && this._pu.equal(t2) && this._pb.equal(i2)) {
      if (this.isMoving) {
        this.events.dispatch(this.events.moveend, this);
      }
      this.isMoving = false;
    } else {
      this.isMoving = true;
    }
    this._pr.copy(e4);
    this._pu.copy(t2);
    this._pb.copy(i2);
    this._peye.copy(s2);
  }
  bindFrustumsPickingColors(e4) {
    for (let t2 = 0; t2 < this.frustums.length; t2++) {
      e4.assignPickingColor(this.frustums[t2]);
    }
  }
  _init(e4) {
    this._setProj(this._viewAngle, this.getAspectRatio());
    this.set(e4.eye || new Ke(0, 0, 1), e4.look || new Ke(), e4.up || new Ke(0, 1, 0));
  }
  getUp() {
    return this._u.clone();
  }
  getDown() {
    return this._u.negateTo();
  }
  getRight() {
    return this._r.clone();
  }
  getLeft() {
    return this._r.negateTo();
  }
  getForward() {
    return this._f.clone();
  }
  getBackward() {
    return this._b.clone();
  }
  update() {
    let e4 = this._r, t2 = this._u, i2 = this._b, s2 = this.eye;
    Ke.doubleToTwoFloat32Array(s2, this.eyeHigh, this.eyeLow);
    this._viewMatrix.set([e4.x, t2.x, i2.x, 0, e4.y, t2.y, i2.y, 0, e4.z, t2.z, i2.z, 0, -s2.dot(e4), -s2.dot(t2), -s2.dot(i2), 1]);
    this._viewMatrixRTE.set([e4.x, t2.x, i2.x, 0, e4.y, t2.y, i2.y, 0, e4.z, t2.z, i2.z, 0, 0, 0, 0, 1]);
    for (let e5 = 0, t3 = this.frustums.length; e5 < t3; e5++) {
      this.frustums[e5].setViewMatrix(this._viewMatrix);
      this.frustums[e5].setProjectionViewRTEMatrix(this._viewMatrixRTE);
    }
    this.events.dispatch(this.events.viewchange, this);
  }
  refresh() {
    this._setProj(this._viewAngle, this.getAspectRatio());
    this.update();
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  setViewportSize(e4, t2) {
    this._width = e4;
    this._height = t2;
    this.refresh();
  }
  getAspectRatio() {
    return this._width / this._height;
  }
  _setProj(e4, t2) {
    this._viewAngle = e4;
    for (let i2 = 0, s2 = this.frustums.length; i2 < s2; i2++) {
      this.frustums[i2].setProjectionMatrix(e4, t2, this.frustums[i2].near, this.frustums[i2].far);
    }
    this._horizontalViewAngle = mf(e4, t2);
    this._updateViewportParameters();
  }
  _updateViewportParameters() {
    this._tanViewAngle_hrad = Math.tan(this._viewAngle * f);
    this._tanViewAngle_hradOneByHeight = this._tanViewAngle_hrad * (1 / this._height);
    this._projSizeConst = Math.min(this._width < 512 ? 512 : this._width, this._height < 512 ? 512 : this._height) / (this._viewAngle * d);
  }
  setViewAngle(e4) {
    this._viewAngle = e4;
    this.refresh();
  }
  getViewAngle() {
    return this._viewAngle;
  }
  get viewAngle() {
    return this._viewAngle;
  }
  get verticalViewAngle() {
    return this._viewAngle;
  }
  get horizontalViewAngle() {
    return this._horizontalViewAngle;
  }
  set(e4, t2, i2) {
    this.eye.x = e4.x;
    this.eye.y = e4.y;
    this.eye.z = e4.z;
    t2 = t2 || this._b;
    i2 = i2 || this._u;
    this._b.x = e4.x - t2.x;
    this._b.y = e4.y - t2.y;
    this._b.z = e4.z - t2.z;
    this._r.copy(i2.cross(this._b));
    this._b.normalize();
    this._r.normalize();
    this._u.copy(this._b.cross(this._r));
    this._f.set(-this._b.x, -this._b.y, -this._b.z);
    return this;
  }
  look(e4, t2) {
    this._b.set(this.eye.x - e4.x, this.eye.y - e4.y, this.eye.z - e4.z);
    this._r.copy((t2 || this._u).cross(this._b));
    this._b.normalize();
    this._f.set(-this._b.x, -this._b.y, -this._b.z);
    this._r.normalize();
    this._u.copy(this._b.cross(this._r));
  }
  slide(e4, t2, i2) {
    this.eye.x += e4 * this._r.x + t2 * this._u.x + i2 * this._b.x;
    this.eye.y += e4 * this._r.y + t2 * this._u.y + i2 * this._b.y;
    this.eye.z += e4 * this._r.z + t2 * this._u.z + i2 * this._b.z;
  }
  setRoll(e4) {
    let t2 = Math.cos(e4);
    let i2 = Math.sin(e4);
    let s2 = this._r.clone();
    this._r.set(t2 * s2.x - i2 * this._u.x, t2 * s2.y - i2 * this._u.y, t2 * s2.z - i2 * this._u.z);
    this._u.set(i2 * s2.x + t2 * this._u.x, i2 * s2.y + t2 * this._u.y, i2 * s2.z + t2 * this._u.z);
  }
  setPitch(e4) {
    let t2 = Math.cos(e4);
    let i2 = Math.sin(e4);
    let s2 = this._b;
    this._b.set(t2 * s2.x - i2 * this._u.x, t2 * s2.y - i2 * this._u.y, t2 * s2.z - i2 * this._u.z);
    this._u.set(i2 * s2.x + t2 * this._u.x, i2 * s2.y + t2 * this._u.y, i2 * s2.z + t2 * this._u.z);
  }
  setYaw(e4) {
    let t2 = Math.cos(e4);
    let i2 = Math.sin(e4);
    let s2 = this._r;
    this._r.set(t2 * s2.x - i2 * this._b.x, t2 * s2.y - i2 * this._b.y, t2 * s2.z - i2 * this._b.z);
    this._b.set(i2 * s2.x + t2 * this._b.x, i2 * s2.y + t2 * this._b.y, i2 * s2.z + t2 * this._b.z);
  }
  setPitchYawRoll(e4, t2, i2) {
    let s2 = new Ze();
    s2.setPitchYawRoll(e4, t2, i2);
    this.setRotation(s2);
  }
  getPitch() {
    return this.getRotation().getPitch();
  }
  getYaw() {
    return this.getRotation().getYaw();
  }
  getRoll() {
    return this.getRotation().getRoll();
  }
  getRotation() {
    return Ze.getLookRotation(this._f, this._u).conjugate();
  }
  setRotation(e4, t2, i2, s2) {
    e4.mulVec3Res(t2 || new Ke(0, 1, 0), this._u);
    e4.mulVec3Res(i2 || new Ke(1, 0, 0), this._r);
    e4.mulVec3Res(s2 || new Ke(0, 0, 1), this._b);
    this._f.set(-this._b.x, -this._b.y, -this._b.z);
  }
  rotate(e4) {
    e4.mulVec3Res(this._u, this._u);
    e4.mulVec3Res(this._r, this._r);
    e4.mulVec3Res(this._b, this._b);
    this._f.set(-this._b.x, -this._b.y, -this._b.z);
  }
  unproject2v(e4) {
    return this.unproject(e4.x, e4.y);
  }
  unproject(e4, t2) {
    let i2 = this._width * 0.5, s2 = this._height * 0.5;
    let r2 = (e4 - i2) / i2, n2 = -(t2 - s2) / s2;
    let o2 = this.frustums[0].inverseProjectionViewMatrix.mulVec4(new $e(r2, n2, -1, 1)).affinity(), a2 = this.frustums[0].inverseProjectionViewMatrix.mulVec4(new $e(r2, n2, 0, 1)).affinity();
    return a2.subA(o2).toVec3().normalize();
  }
  project3v(e4) {
    return this.project(e4.x, e4.y, e4.z);
  }
  project(e4, t2, i2) {
    let s2 = this.frustums[0].projectionViewMatrix.mulVec4(new $e(e4, t2, i2, 1));
    return new Qe((1 + s2.x / s2.w) * this._width * 0.5, (1 - s2.y / s2.w) * this._height * 0.5);
  }
  rotateAround(e4, t2 = false, i2 = Ke.ZERO, s2 = Ke.UP) {
    s2 = t2 ? this._u : s2;
    let r2 = Xe.getRotation(e4, s2);
    let n2 = Xe.getRotationAroundPoint(e4, i2, s2);
    this.eye = n2.mulVec3(this.eye);
    this._u = r2.mulVec3(this._u).normalize();
    this._r = r2.mulVec3(this._r).normalize();
    this._b = r2.mulVec3(this._b).normalize();
    this._f.set(-this._b.x, -this._b.y, -this._b.z);
  }
  rotateHorizontal(e4, t2, i2, s2) {
    this.rotateAround(e4, t2, i2, s2);
  }
  rotateVertical(e4, t2) {
    this.rotateAround(e4, false, t2, this._r);
  }
  projectedSize(e4, t2) {
    return Math.atan(t2 / this.eye.distance(e4)) * this._projSizeConst;
  }
  getViewMatrix() {
    return this._viewMatrix._m;
  }
  getNormalMatrix() {
    return this._normalMatrix._m;
  }
  setCurrentFrustum(e4) {
    this.currentFrustumIndex = e4;
    this.frustumColorIndex = (e4 + 1) * 10 / 255;
    this.isFirstPass = e4 === this.FARTHEST_FRUSTUM_INDEX;
  }
  getCurrentFrustum() {
    return this.currentFrustumIndex;
  }
  containsSphere(e4) {
    for (let t2 = 0; t2 < this.frustums.length; t2++) {
      if (this.frustums[t2].containsSphere(e4)) {
        return true;
      }
    }
    return false;
  }
  get frustum() {
    return this.frustums[this.currentFrustumIndex];
  }
  getProjectionMatrix() {
    return this.frustum.projectionMatrix._m;
  }
  getProjectionViewMatrix() {
    return this.frustum.projectionViewMatrix._m;
  }
  getProjectionViewRTEMatrix() {
    return this.frustum.projectionViewRTEMatrix._m;
  }
  getInverseProjectionViewMatrix() {
    return this.frustum.inverseProjectionViewMatrix._m;
  }
  getInverseProjectionMatrix() {
    return this.frustum.inverseProjectionMatrix._m;
  }
  viewDistance(e4, t2 = 1e4) {
    let i2 = this.eye.add(this.getForward().scaleTo(t2));
    Ze.getRotationBetweenVectors(i2.getNormal(), e4.getNormal());
    let s2 = e4.add(this.getBackward().scaleTo(t2));
    this.set(s2, e4);
    this.update();
  }
  copy(e4) {
    this.eye.copy(e4.eye);
    this._r.copy(e4._r);
    this._u.copy(e4._u);
    this._b.copy(e4._b);
    this._f.copy(e4._f);
    this._width = e4.width;
    this._height = e4.height;
    this.setViewAngle(e4.viewAngle);
    this.update();
  }
  getAltitude() {
    return this.eye.y;
  }
}
class yf extends vf {
  constructor(e4, t2 = {}) {
    super({ ...t2, frustums: t2.frustums || [[1, 100 + 0.075], [100, 1e3 + 0.075], [1e3, 1e6 + 1e4], [1e6, 1e9]] });
    this.planet = e4;
    this.minAltitude = t2.minAltitude || 1;
    this.maxAltitude = t2.maxAltitude || 2e7;
    this._lonLat = this.planet.ellipsoid.cartesianToLonLat(this.eye);
    this._lonLatMerc = this._lonLat.forwardMercator();
    this._terrainAltitude = this._lonLat.height;
    this._terrainPoint = new Ke();
    this._insideSegment = null;
    this.slope = 0;
    this._keyLock = new oh();
    this._framesArr = [];
    this._framesCounter = 0;
    this._numFrames = 50;
    this._completeCallback = null;
    this._frameCallback = null;
    this._flying = false;
    this._checkTerrainCollision = true;
    this.eyeNorm = this.eye.getNormal();
  }
  setTerrainCollisionActivity(e4) {
    this._checkTerrainCollision = e4;
  }
  update() {
    this.events.stopPropagation();
    let e4 = this.maxAltitude + this.planet.ellipsoid.getEquatorialSize();
    if (this.eye.length() > e4) {
      this.eye.copy(this.eye.getNormal().scale(e4));
    }
    super.update();
    this.updateGeodeticPosition();
    this.eyeNorm = this.eye.getNormal();
    this.slope = this._b.dot(this.eyeNorm);
    this.events.dispatch(this.events.viewchange, this);
  }
  updateGeodeticPosition() {
    this.planet.ellipsoid.cartesianToLonLatRes(this.eye, this._lonLat);
    if (Math.abs(this._lonLat.lat) <= Ge) {
      be.forwardMercatorRes(this._lonLat, this._lonLatMerc);
    }
  }
  setAltitude(e4) {
    let t2 = this._terrainPoint;
    let i2 = this.planet.ellipsoid.getSurfaceNormal3v(this.eye);
    this.eye.x = i2.x * e4 + t2.x;
    this.eye.y = i2.y * e4 + t2.y;
    this.eye.z = i2.z * e4 + t2.z;
    this._terrainAltitude = e4;
  }
  getAltitude() {
    return this._terrainAltitude;
  }
  setLonLat(e4, t2, i2) {
    this.stopFlying();
    this._lonLat.set(e4.lon, e4.lat, e4.height || this._lonLat.height);
    let s2 = this.planet.ellipsoid;
    let r2 = s2.lonLatToCartesian(this._lonLat);
    let n2 = t2 ? s2.lonLatToCartesian(t2) : Ke.ZERO;
    this.set(r2, n2, i2 || r2.getNormal());
    this.update();
  }
  getLonLat() {
    return this._lonLat;
  }
  getHeight() {
    return this._lonLat.height;
  }
  getExtentPosition(e4, t2) {
    t2 = t2 || 0;
    let i2 = e4.getNorth();
    let s2 = e4.getSouth();
    let r2 = e4.getEast();
    let n2 = e4.getWest();
    if (n2 > r2) {
      r2 += 360;
    }
    let o2 = this.planet.ellipsoid;
    let a2 = new be(r2, i2);
    let l2 = o2.lonLatToCartesian(a2);
    a2.lat = s2;
    let h2 = o2.lonLatToCartesian(a2);
    a2.lon = n2;
    let c2 = o2.lonLatToCartesian(a2);
    a2.lat = i2;
    let u2 = o2.lonLatToCartesian(a2);
    let _2 = Ke.sub(l2, c2).scale(0.5).addA(c2);
    let f2 = _2.length();
    if (f2 < 1e-6) {
      a2.lon = (r2 + n2) * 0.5;
      a2.lat = (i2 + s2) * 0.5;
      _2 = o2.lonLatToCartesian(a2);
    }
    u2.subA(_2);
    h2.subA(_2);
    l2.subA(_2);
    c2.subA(_2);
    let g2 = _2.getNormal();
    let p2 = g2.cross(Ke.NORTH).normalize();
    let m2 = p2.cross(g2).normalize();
    let v2 = Math.max(Math.abs(m2.dot(u2)), Math.abs(m2.dot(h2)), Math.abs(m2.dot(l2)), Math.abs(m2.dot(c2)));
    let y2 = Math.max(Math.abs(p2.dot(u2)), Math.abs(p2.dot(h2)), Math.abs(p2.dot(l2)), Math.abs(p2.dot(c2)));
    let x2 = Math.tan(this._viewAngle * d * 0.5);
    let b2 = this.getAspectRatio() * x2;
    let w2 = Math.max(y2 / b2, v2 / x2);
    _2.normalize();
    _2.scale(f2 + w2 + t2);
    return _2;
  }
  viewExtent(e4, t2) {
    this.stopFlying();
    this.set(this.getExtentPosition(e4, t2), Ke.ZERO, Ke.NORTH);
    this.update();
  }
  flyExtent(e4, t2, i2, s2, r2, n2, o2) {
    this.flyCartesian(this.getExtentPosition(e4, t2), Ke.ZERO, i2, s2 == null ? 1 : s2, r2, n2, o2);
  }
  viewDistance(e4, t2 = 1e4) {
    let i2 = this.eye.add(this.getForward().scaleTo(t2));
    let s2 = Ze.getRotationBetweenVectors(i2.getNormal(), e4.getNormal());
    if (s2.isZero()) {
      let i3 = e4.add(this.getBackward().scaleTo(t2));
      this.set(i3, e4);
    } else {
      let i3 = e4.add(s2.mulVec3(this.getBackward()).scale(t2)), r2 = s2.mulVec3(this.getUp());
      this.set(i3, e4, r2);
    }
    this.update();
  }
  flyDistance(e4, t2 = 1e4, i2 = 0, s2, r2, n2) {
    let o2 = this.eye.add(this.getForward().scaleTo(t2));
    let a2 = Ze.getRotationBetweenVectors(o2.getNormal(), e4.getNormal());
    if (a2.isZero()) {
      let i3 = e4.add(this.getBackward().scaleTo(t2));
      this.set(i3, e4);
    } else {
      let o3 = e4.add(a2.mulVec3(this.getBackward()).scale(t2)), l2 = a2.mulVec3(this.getUp());
      this.flyCartesian(o3, e4, l2, i2, s2, r2, n2);
    }
  }
  flyCartesian(e4, t2 = Ke.ZERO, i2 = Ke.NORTH, s2 = 1, r2 = () => {
  }, n2 = () => {
  }, o2 = () => {
  }) {
    this.stopFlying();
    t2 = t2 || Ke.ZERO;
    i2 = i2 || Ke.NORTH;
    this._completeCallback = r2;
    this._frameCallback = o2;
    if (n2) {
      n2.call(this);
    }
    if (t2 instanceof be) {
      t2 = this.planet.ellipsoid.lonLatToCartesian(t2);
    }
    let a2 = this.planet.ellipsoid.lonLatToCartesian(new be(this._lonLat.lon, this._lonLat.lat));
    let l2 = this._u, h2 = this._b;
    let c2 = this.planet.ellipsoid.cartesianToLonLat(e4);
    let d2 = i2;
    let u2 = this.planet.ellipsoid.lonLatToCartesian(new be(c2.lon, c2.lat, 0));
    let _2 = Ke.sub(e4, t2);
    let f2 = d2.cross(_2);
    _2.normalize();
    f2.normalize();
    let g2 = _2.cross(f2);
    let p2 = a2.getNormal();
    let m2 = u2.getNormal();
    let v2 = 1 - p2.dot(m2);
    let y2 = s2 * x * Math.sqrt(v2 > 0 ? v2 : 0);
    let b2 = 6639613;
    let w2 = Math.max(this._lonLat.height, c2.height);
    if (w2 > b2) {
      b2 = w2;
    }
    let C2 = w2 + 2.5 * y2 * (b2 - w2);
    let T2 = Ke.ZERO;
    for (let e5 = 0; e5 <= this._numFrames; e5++) {
      let t3 = 1 - e5 / this._numFrames;
      t3 = t3 * t3 * (3 - 2 * t3);
      t3 *= t3;
      let i3 = a2.smerp(u2, t3).normalize();
      let s3 = this.planet.getRayIntersectionEllipsoid(new ar(T2, i3));
      let r3 = 1 - t3;
      let n3 = this._lonLat.height * t3 * t3 * t3 + C2 * 3 * t3 * t3 * r3 + C2 * 3 * t3 * r3 * r3 + c2.height * r3 * r3 * r3;
      let o3 = s3.addA(i3.scale(n3));
      let d3 = l2.smerp(g2, t3);
      let f3 = Ke.add(o3, h2.smerp(_2, t3).negateTo());
      let p3 = new Ke(o3.x - f3.x, o3.y - f3.y, o3.z - f3.z);
      let m3 = d3.cross(p3);
      p3.normalize();
      m3.normalize();
      let v3 = p3.cross(m3);
      this._framesArr[e5] = { eye: o3, n: p3, u: m3, v: v3 };
    }
    this._framesCounter = this._numFrames;
    this._flying = true;
  }
  flyLonLat(e4, t2, i2, s2, r2, n2, o2) {
    let a2 = new be(e4.lon, e4.lat, e4.height || this._lonLat.height);
    this.flyCartesian(this.planet.ellipsoid.lonLatToCartesian(a2), t2, i2, s2, r2, n2, o2);
  }
  stopFlying() {
    this.planet.layerLock.free(this._keyLock);
    this.planet.terrainLock.free(this._keyLock);
    this.planet.normalMapCreator.free(this._keyLock);
    this._flying = false;
    this._framesArr.length = 0;
    this._framesArr = [];
    this._framesCounter = -1;
    this._frameCallback = null;
    this.planet.stopDragging();
  }
  isFlying() {
    return this._flying;
  }
  rotateLeft(e4, t2) {
    this.rotateHorizontal(e4, t2 !== true, Ke.ZERO);
    this.update();
  }
  rotateRight(e4, t2) {
    this.rotateHorizontal(-e4, t2 !== true, Ke.ZERO);
    this.update();
  }
  rotateUp(e4) {
    this.rotateVertical(e4, Ke.ZERO);
    this.update();
  }
  rotateDown(e4) {
    this.rotateVertical(-e4, Ke.ZERO);
    this.update();
  }
  rotateVertical(e4, t2, i2 = 0) {
    let s2 = new Xe().setRotation(this._r, e4);
    let r2 = new Xe().setIdentity().translate(t2);
    let n2 = new Xe().setIdentity().translate(t2.negateTo());
    let o2 = r2.mul(s2).mul(n2);
    let a2 = o2.mulVec3(this.eye);
    let l2 = s2.mulVec3(this._u).normalize();
    let h2 = s2.mulVec3(this._r).normalize();
    let c2 = s2.mulVec3(this._b).normalize();
    let d2 = a2.getNormal();
    let u2 = c2.dot(d2);
    if (i2) {
      let e5 = u2 - this.slope;
      if (u2 < i2 && e5 < 0) return;
      if (u2 > 0.1 && l2.dot(d2) > 0 || this.slope <= 0.1 || this._u.dot(this.eye.getNormal()) <= 0) {
        this.eye = a2;
        this._u = l2;
        this._r = h2;
        this._b = c2;
        this._f.set(-c2.x, -c2.y, -c2.z);
      }
    } else {
      this.eye = a2;
      this._u = l2;
      this._r = h2;
      this._b = c2;
      this._f.set(-c2.x, -c2.y, -c2.z);
    }
  }
  checkFly() {
    if (this._flying) {
      let e4 = this._numFrames - this._framesCounter;
      this.planet.layerLock.lock(this._keyLock);
      this.planet.terrainLock.lock(this._keyLock);
      this.planet.normalMapCreator.lock(this._keyLock);
      this.eye = this._framesArr[e4].eye;
      this._r = this._framesArr[e4].u;
      this._u = this._framesArr[e4].v;
      this._b = this._framesArr[e4].n;
      this._f.set(-this._b.x, -this._b.y, -this._b.z);
      if (this._frameCallback) {
        this._frameCallback();
      }
      this.update();
      this._framesCounter--;
      if (this._framesCounter < 0) {
        this.stopFlying();
        if (this._completeCallback) {
          this._completeCallback();
          this._completeCallback = null;
        }
      }
    }
  }
  checkTerrainCollision() {
    this._terrainAltitude = this._lonLat.height;
    if (this._insideSegment && this._insideSegment.planet) {
      this._terrainAltitude = this._insideSegment.getTerrainPoint(this.eye, this._insideSegment.getInsideLonLat(this), this._terrainPoint);
      if (this._terrainAltitude < this.minAltitude && this._checkTerrainCollision) {
        this.setAltitude(this.minAltitude);
      }
      return this._terrainPoint;
    }
  }
  getSurfaceVisibleDistance(e4) {
    let t2 = this.planet.ellipsoid.equatorialSize;
    return t2 * Math.acos(t2 / (t2 + this._lonLat.height + e4));
  }
  getHeading() {
    let e4 = this.eye.getNormal();
    let t2 = Ke.proj_b_to_plane(this.slope >= 0.97 ? this.getUp() : this.getForward(), e4).normalize(), i2 = Ke.proj_b_to_plane(Ke.NORTH, e4).normalize();
    let s2 = Math.sign(e4.dot(t2.cross(i2))) * Math.acos(t2.dot(i2)) * u;
    if (s2 < 0) {
      return 360 + s2;
    }
    return s2;
  }
  isVisible(e4) {
    let t2 = this.eye.length();
    return this.eye.distance(e4) < Math.sqrt(t2 * t2 - this.planet.ellipsoid.equatorialSizeSqr);
  }
  getPitch() {
    let e4 = this.planet.getFrameRotation(this.eye);
    return e4.conjugate().inverse().mul(this.getRotation()).getPitch();
  }
  getYaw() {
    let e4 = this.planet.getFrameRotation(this.eye);
    return e4.conjugate().inverse().mul(this.getRotation()).getYaw();
  }
  getRoll() {
    let e4 = this.planet.getFrameRotation(this.eye);
    return e4.conjugate().inverse().mul(this.getRotation()).getRoll();
  }
  setPitch(e4) {
    let t2 = this.planet.getFrameRotation(this.eye);
    let i2 = new Ze();
    i2.setPitchYawRoll(e4, this.getYaw(), this.getRoll(), t2);
    this.setRotation(i2);
  }
  setYaw(e4) {
    let t2 = this.planet.getFrameRotation(this.eye);
    let i2 = new Ze();
    i2.setPitchYawRoll(this.getPitch(), e4, this.getRoll(), t2);
    this.setRotation(i2);
  }
  setRoll(e4) {
    let t2 = this.planet.getFrameRotation(this.eye);
    let i2 = new Ze();
    i2.setPitchYawRoll(this.getPitch(), this.getYaw(), e4, t2);
    this.setRotation(i2);
  }
  setPitchYawRoll(e4, t2, i2) {
    let s2 = this.planet.getFrameRotation(this.eye);
    let r2 = new Ze();
    r2.setPitchYawRoll(e4, t2, i2, s2).conjugate();
    this.setRotation(r2);
  }
}
const xf = '(function() {\n  "use strict";\n  function t(t2, r2) {\n    let a2 = 0, e2 = t2.length - 1;\n    while (a2 <= e2) {\n      let n2 = Math.floor((a2 + e2) * 0.5);\n      if (Math.abs(t2[n2] - r2) < 1e-3) return n2;\n      else if (t2[n2] < r2) a2 = n2 + 1;\n      else e2 = n2 - 1;\n    }\n    return -1;\n  }\n  function r(r2, a2) {\n    return t(r2, a2) !== -1;\n  }\n  var a = function(t2, r2, a2) {\n    this.x = t2;\n    this.y = r2;\n    this.z = a2;\n  };\n  var e = function(t2, r2, a2) {\n    let e2 = t2.x, n2 = t2.y, i2 = t2.z;\n    var o2;\n    if (e2 >= 0) {\n      o2 = Math.floor(e2 / 65536) * 65536;\n      r2.x = Math.fround(o2);\n      a2.x = Math.fround(e2 - o2);\n    } else {\n      o2 = Math.floor(-e2 / 65536) * 65536;\n      r2.x = Math.fround(-o2);\n      a2.x = Math.fround(e2 + o2);\n    }\n    if (n2 >= 0) {\n      o2 = Math.floor(n2 / 65536) * 65536;\n      r2.y = Math.fround(o2);\n      a2.y = Math.fround(n2 - o2);\n    } else {\n      o2 = Math.floor(-n2 / 65536) * 65536;\n      r2.y = Math.fround(-o2);\n      a2.y = Math.fround(n2 + o2);\n    }\n    if (i2 >= 0) {\n      o2 = Math.floor(i2 / 65536) * 65536;\n      r2.z = Math.fround(o2);\n      a2.z = Math.fround(i2 - o2);\n    } else {\n      o2 = Math.floor(-i2 / 65536) * 65536;\n      r2.z = Math.fround(-o2);\n      a2.z = Math.fround(i2 + o2);\n    }\n  };\n  a.prototype.sub = function(t2) {\n    return new a(this.x - t2.x, this.y - t2.y, this.z - t2.z);\n  };\n  a.prototype.add = function(t2) {\n    return new a(this.x + t2.x, this.y + t2.y, this.z + t2.z);\n  };\n  a.prototype.cross = function(t2) {\n    return new a(this.y * t2.z - this.z * t2.y, this.z * t2.x - this.x * t2.z, this.x * t2.y - this.y * t2.x);\n  };\n  a.prototype.normalize = function(t2) {\n    var r2 = this.x, a2 = this.y, e2 = this.z;\n    var n2 = 1 / Math.sqrt(r2 * r2 + a2 * a2 + e2 * e2);\n    this.x = r2 * n2;\n    this.y = a2 * n2;\n    this.z = e2 * n2;\n    return this;\n  };\n  a.prototype.distance = function(t2) {\n    return this.sub(t2).length();\n  };\n  a.prototype.length = function() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n  };\n  var n = function(t2, r2, a2, e2, n2, i2) {\n    return a2 * (1 - t2) * (1 - r2) + e2 * t2 * (1 - r2) + n2 * (1 - t2) * r2 + i2 * t2 * r2;\n  };\n  var i = new a(0, 0, 0);\n  var o = new a(0, 0, 0), s = new a(0, 0, 0);\n  self.onmessage = function(t2) {\n    var f = t2.data.elevations, l = t2.data.this_plainVertices, y = t2.data.this_plainNormals, h = t2.data.this_normalMapVertices, z = t2.data.this_normalMapNormals, u = t2.data.heightFactor, x = t2.data.gridSize, v = t2.data.noDataValues, c = t2.data.id;\n    var M = 549755748352, d = -549755748352, w = 549755748352, p = -549755748352, m = 549755748352, b = -549755748352;\n    const A = Math.sqrt(f.length) - 1;\n    const F = A + 1;\n    const g = F * F;\n    const V = x;\n    const _ = A / V;\n    const q = V + 1;\n    const N = u;\n    var D = 0, H = 0;\n    var L = q * q * 3;\n    var S = new Float64Array(L), U = new Float32Array(L), j = new Float32Array(L), k = new Uint8Array(q * q);\n    var B, C, E, G;\n    var I = h, J = z;\n    if (A >= V) {\n      B = new Float32Array(g * 3);\n      C = new Float64Array(g * 3);\n      E = new Float32Array(g * 3);\n      G = new Float32Array(g * 3);\n      for (let t3 = 0; t3 < g; t3++) {\n        var K = t3 % F, O = ~~(t3 / F);\n        var P = t3;\n        var Q = P * 3;\n        var R = f[P];\n        if (r(v, R)) {\n          R = 0;\n        }\n        var T = N * R;\n        var W = new a(I[Q] + T * J[Q], I[Q + 1] + T * J[Q + 1], I[Q + 2] + T * J[Q + 2]);\n        e(W, o, s);\n        C[Q] = W.x;\n        C[Q + 1] = W.y;\n        C[Q + 2] = W.z;\n        E[Q] = o.x;\n        E[Q + 1] = o.y;\n        E[Q + 2] = o.z;\n        G[Q] = s.x;\n        G[Q + 1] = s.y;\n        G[Q + 2] = s.z;\n        if (O % _ === 0 && K % _ === 0) {\n          let t4 = new a(I[Q], I[Q + 1], I[Q + 2]);\n          let e2 = new a(I[Q + 3], I[Q + 4], I[Q + 5]);\n          let n2 = f[P + 1];\n          if (r(v, n2)) {\n            n2 = 0;\n          }\n          let i2 = false;\n          if (v.length === 0) {\n            let r2 = t4.distance(e2);\n            let a2 = Math.abs(R - n2);\n            i2 = a2 / r2 > 10 || R < -5e3;\n          }\n          if (i2) {\n            k[H] = 1;\n          } else {\n            k[H] = 0;\n            if (W.x < M) M = W.x;\n            if (W.x > d) d = W.x;\n            if (W.y < w) w = W.y;\n            if (W.y > p) p = W.y;\n            if (W.z < m) m = W.z;\n            if (W.z > b) b = W.z;\n          }\n          U[D] = o.x;\n          j[D] = s.x;\n          S[D++] = W.x;\n          U[D] = o.y;\n          j[D] = s.y;\n          S[D++] = W.y;\n          U[D] = o.z;\n          j[D] = s.z;\n          S[D++] = W.z;\n          H++;\n        }\n        if (O !== A && K !== A) {\n          var X = t3 + 1;\n          var Y = X * 3;\n          var Z = f[X];\n          if (r(v, Z)) {\n            Z = 0;\n          }\n          var $ = N * Z;\n          var tt = new a(I[Y] + $ * J[Y], I[Y + 1] + $ * J[Y + 1], I[Y + 2] + $ * J[Y + 2]);\n          e(tt, o, s);\n          C[Y] = tt.x;\n          C[Y + 1] = tt.y;\n          C[Y + 2] = tt.z;\n          E[Y] = o.x;\n          E[Y + 1] = o.y;\n          E[Y + 2] = o.z;\n          G[Y] = s.x;\n          G[Y + 1] = s.y;\n          G[Y + 2] = s.z;\n          var rt = t3 + F;\n          var at = rt * 3;\n          Z = f[rt];\n          if (r(v, Z)) {\n            Z = 0;\n          }\n          var et = N * Z;\n          var nt = new a(I[at] + et * J[at], I[at + 1] + et * J[at + 1], I[at + 2] + et * J[at + 2]);\n          e(nt, o, s);\n          C[at] = nt.x;\n          C[at + 1] = nt.y;\n          C[at + 2] = nt.z;\n          E[at] = o.x;\n          E[at + 1] = o.y;\n          E[at + 2] = o.z;\n          G[at] = s.x;\n          G[at + 1] = s.y;\n          G[at + 2] = s.z;\n          var it = t3 + F + 1;\n          var ot = it * 3;\n          Z = f[it];\n          if (r(v, Z)) {\n            Z = 0;\n          }\n          var st = N * Z;\n          var ft = new a(I[ot] + st * J[ot], I[ot + 1] + st * J[ot + 1], I[ot + 2] + st * J[ot + 2]);\n          e(ft, o, s);\n          C[ot] = ft.x;\n          C[ot + 1] = ft.y;\n          C[ot + 2] = ft.z;\n          E[ot] = o.x;\n          E[ot + 1] = o.y;\n          E[ot + 2] = o.z;\n          G[ot] = s.x;\n          G[ot + 1] = s.y;\n          G[ot + 2] = s.z;\n          var lt = tt.sub(W), yt = nt.sub(W), ht = ft.sub(W);\n          var zt = yt.cross(ht).normalize();\n          var ut = ht.cross(lt).normalize();\n          var xt = ut.add(zt).normalize();\n          B[Q] += xt.x;\n          B[Q + 1] += xt.y;\n          B[Q + 2] += xt.z;\n          B[Y] += ut.x;\n          B[Y + 1] += ut.y;\n          B[Y + 2] += ut.z;\n          B[at] += zt.x;\n          B[at + 1] += zt.y;\n          B[at + 2] += zt.z;\n          B[ot] += xt.x;\n          B[ot + 1] += xt.y;\n          B[ot + 2] += xt.z;\n        }\n      }\n    } else {\n      B = new Float32Array(L);\n      C = new Float64Array(L);\n      E = new Float32Array(L);\n      G = new Float32Array(L);\n      B = new Float32Array(L);\n      var vt = V / A;\n      var ct = L / 3;\n      var Mt = A + 1;\n      for (let t3 = 0; t3 < ct; t3++) {\n        let a2 = Math.floor(t3 / q), h2 = t3 % q;\n        let z2 = a2 % vt, u2 = h2 % vt;\n        let x2 = Math.floor(a2 / vt) * Mt + Math.floor(h2 / vt);\n        if (h2 === V) {\n          x2 -= 1;\n          u2 = vt;\n        }\n        if (a2 === V) {\n          x2 -= Mt;\n          z2 = vt;\n        }\n        let c2 = x2 + 1, A2 = x2 + Mt, F2 = A2 + 1;\n        let g2 = f[x2], _2 = f[c2], N2 = f[A2], D2 = f[F2];\n        if (r(v, g2)) {\n          g2 = 0;\n        }\n        if (r(v, _2)) {\n          _2 = 0;\n        }\n        if (r(v, N2)) {\n          N2 = 0;\n        }\n        if (r(v, D2)) {\n          D2 = 0;\n        }\n        let H2 = n(u2 / vt, z2 / vt, g2, _2, N2, D2);\n        let L2 = t3 * 3;\n        i.x = l[L2] + H2 * y[L2], i.y = l[L2 + 1] + H2 * y[L2 + 1], i.z = l[L2 + 2] + H2 * y[L2 + 2];\n        e(i, o, s);\n        S[L2] = i.x;\n        S[L2 + 1] = i.y;\n        S[L2 + 2] = i.z;\n        U[L2] = o.x;\n        U[L2 + 1] = o.y;\n        U[L2 + 2] = o.z;\n        j[L2] = s.x;\n        j[L2 + 1] = s.y;\n        j[L2 + 2] = s.z;\n        if (i.x < M) M = i.x;\n        if (i.x > d) d = i.x;\n        if (i.y < w) w = i.y;\n        if (i.y > p) p = i.y;\n        if (i.z < m) m = i.z;\n        if (i.z > b) b = i.z;\n      }\n      C.set(S);\n      E.set(U);\n      G.set(j);\n      for (let t3 = 0; t3 < ct; t3++) {\n        let r2 = t3 % q, e2 = ~~(t3 / q);\n        if (e2 !== V && r2 !== V) {\n          let r3 = t3 * 3, e3 = r3 + 3, n2 = r3 + q * 3, i2 = n2 + 3;\n          let o2 = new a(S[r3], S[r3 + 1], S[r3 + 2]), s2 = new a(S[e3], S[e3 + 1], S[e3 + 2]), f2 = new a(S[n2], S[n2 + 1], S[n2 + 2]), l2 = new a(S[i2], S[i2 + 1], S[i2 + 2]);\n          let y2 = s2.sub(o2).normalize(), h2 = f2.sub(o2).normalize(), z2 = l2.sub(o2).normalize();\n          let u2 = h2.cross(z2).normalize();\n          let x2 = z2.cross(y2).normalize();\n          let v2 = x2.add(u2).normalize();\n          B[r3] += v2.x;\n          B[r3 + 1] += v2.y;\n          B[r3 + 2] += v2.z;\n          B[e3] += x2.x;\n          B[e3 + 1] += x2.y;\n          B[e3 + 2] += x2.z;\n          B[n2] += u2.x;\n          B[n2 + 1] += u2.y;\n          B[n2 + 2] += u2.z;\n          B[i2] += v2.x;\n          B[i2 + 1] += v2.y;\n          B[i2 + 2] += v2.z;\n        }\n      }\n    }\n    self.postMessage({ id: c, normalMapNormals: B, normalMapVertices: C, normalMapVerticesHigh: E, normalMapVerticesLow: G, terrainVertices: S, terrainVerticesHigh: U, terrainVerticesLow: j, noDataVertices: k, bounds: [M, w, m, d, p, b] }, [B.buffer, C.buffer, E.buffer, G.buffer, S.buffer, U.buffer, j.buffer, k.buffer]);\n  };\n})();\n//# sourceMappingURL=TerrainWorker.worker-BlWH6Fsw.js.map\n';
const bf = typeof self !== "undefined" && self.Blob && new Blob([xf], { type: "text/javascript;charset=utf-8" });
function wf(e4) {
  let t2;
  try {
    t2 = bf && (self.URL || self.webkitURL).createObjectURL(bf);
    if (!t2) throw "";
    const i2 = new Worker(t2, { name: e4 == null ? void 0 : e4.name });
    i2.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(t2);
    });
    return i2;
  } catch (t3) {
    return new Worker("data:text/javascript;charset=utf-8," + encodeURIComponent(xf), { name: e4 == null ? void 0 : e4.name });
  } finally {
    t2 && (self.URL || self.webkitURL).revokeObjectURL(t2);
  }
}
class Cf extends Gs {
  constructor(e4 = 2) {
    super(e4, wf);
  }
  _onMessage(e4) {
    this._source.get(e4.data.id).segment._terrainWorkerCallback(e4.data);
    this._source.delete(e4.data.id);
    e4.data.normalMapNormals = null;
    e4.data.normalMapVertices = null;
    e4.data.normalMapVerticesHigh = null;
    e4.data.normalMapVerticesLow = null;
    e4.data.terrainVertices = null;
    e4.data.terrainVerticesHigh = null;
    e4.data.terrainVerticesLow = null;
  }
  make(e4) {
    if (e4.segment.plainReady && e4.segment.terrainIsLoading) {
      if (this._workerQueue.length) {
        const t2 = this._workerQueue.pop();
        this._source.set(this._sourceId, e4);
        let i2 = e4.segment;
        t2.postMessage({ elevations: e4.elevations, this_plainVertices: i2.plainVertices, this_plainNormals: i2.plainNormals, this_normalMapVertices: i2.normalMapVertices, this_normalMapNormals: i2.normalMapNormals, heightFactor: i2.planet._heightFactor, gridSize: i2.planet.terrain.gridSizeByZoom[i2.tileZoom], noDataValues: i2.planet.terrain.noDataValues, id: this._sourceId }, [e4.elevations.buffer, i2.plainVertices.buffer, i2.plainNormals.buffer, i2.normalMapVertices.buffer, i2.normalMapNormals.buffer]);
        this._sourceId++;
      } else {
        this._pendingQueue.push(e4);
      }
    } else {
      this.check();
    }
  }
}
let Tf = new Float32Array(2);
const Ef = 25;
class Af {
  constructor(e4, t2 = 512, i2 = 512) {
    this._width = t2;
    this._height = i2;
    this._planet = e4;
    this._framebuffer = null;
    this._queue = [];
    this._handler = null;
  }
  init() {
    this._handler = this._planet.renderer.handler;
    if (!this._handler.programs.vectorTileLineRasterization) {
      this._handler.addProgram(new Yr("vectorTileLineRasterization", { uniforms: { viewport: "vec2", thicknessOutline: "float", alpha: "float", extentParamsHigh: "vec4", extentParamsLow: "vec4" }, attributes: { prevHigh: "vec2", currentHigh: "vec2", nextHigh: "vec2", prevLow: "vec2", currentLow: "vec2", nextLow: "vec2", order: "float", color: "vec4", thickness: "float" }, vertexShader: `attribute vec2 prevHigh;
                attribute vec2 currentHigh;
                attribute vec2 nextHigh;

                attribute vec2 prevLow;
                attribute vec2 currentLow;
                attribute vec2 nextLow;

                attribute float order;
                attribute float thickness;
                attribute vec4 color;
                uniform float thicknessOutline;
                uniform vec2 viewport;
                uniform vec4 extentParamsHigh;
                uniform vec4 extentParamsLow;
                varying vec4 vColor;
                
                vec2 proj(vec2 coordHigh, vec2 coordLow) {
                    vec2 highDiff = coordHigh - extentParamsHigh.xy;
                    vec2 lowDiff = coordLow - extentParamsLow.xy;                    
                    return vec2(-1.0 + (highDiff * step(1.0, length(highDiff)) + lowDiff) * extentParamsHigh.zw) * vec2(1.0, -1.0);
                }
                
                void main(){
                    vColor = color;

                    vec2 vNext = proj(nextHigh, nextLow),
                         vCurrent = proj(currentHigh, currentLow),
                         vPrev = proj(prevHigh, prevLow);

                    vec2 _next = vNext;
                    vec2 _prev = vPrev;
                    vec2 _current = vCurrent;

                    if(_prev == _current){
                        if(_next == _current){
                            _next = _current + vec2(1.0, 0.0);
                            _prev = _current - _next;
                        }else{
                            _prev = _current + normalize(_current - _next);
                        }
                    }

                    if(_next == _current){
                        _next = _current + normalize(_current - _prev);
                    }

                    vec2 sNext = _next;
                    vec2 sCurrent = _current;
                    vec2 sPrev = _prev;
                    
                    vec2 dirNext = normalize(sNext - sCurrent);
                    vec2 dirPrev = normalize(sPrev - sCurrent);
                    float dotNP = dot(dirNext, dirPrev);
                    
                    vec2 normalNext = normalize(vec2(-dirNext.y, dirNext.x));
                    vec2 normalPrev = normalize(vec2(dirPrev.y, -dirPrev.x));
                    vec2 d = (thickness + thicknessOutline) * 0.5 * sign(order) / viewport;
                    
                    vec2 m;
                    if(dotNP >= 0.99991){
                        m = sCurrent - normalPrev * d;
                    }else{
                        vec2 dir = normalPrev + normalNext;
                        m = sCurrent + dir * d / (dirNext.x * dir.y - dirNext.y * dir.x);
                        
                        if( dotNP > 0.5 && dot(dirNext + dirPrev, m - sCurrent) < 0.0 ){
                            float occw = order * sign(dirNext.x * dirPrev.y - dirNext.y * dirPrev.x);
                            if(occw == -1.0){
                                m = sCurrent + normalPrev * d;
                            }else if(occw == 1.0){
                                m = sCurrent + normalNext * d;
                            }else if(occw == -2.0){
                                m = sCurrent + normalNext * d;
                            }else if(occw == 2.0){
                                m = sCurrent + normalPrev * d;
                            }
                        }else if(distance(sCurrent, m) > min(distance(sCurrent, sNext), distance(sCurrent, sPrev))){
                            m = sCurrent + normalNext * d;
                        }
                    }
                    gl_Position = vec4(m.x, m.y, 0.0, 1.0);
                }`, fragmentShader: `precision highp float;
                uniform float alpha;
                varying vec4 vColor;
                void main() {
                    gl_FragColor = vec4(vColor.rgb, alpha * vColor.a);
                }` }));
    }
    if (!this._handler.programs.vectorTilePolygonRasterization) {
      this._handler.addProgram(new Yr("vectorTilePolygonRasterization", { uniforms: { extentParamsHigh: "vec4", extentParamsLow: "vec4" }, attributes: { coordinatesHigh: "vec2", coordinatesLow: "vec2", colors: "vec4" }, vertexShader: `attribute vec2 coordinatesHigh;
                attribute vec2 coordinatesLow; 
                attribute vec4 colors; 
                uniform vec4 extentParamsHigh; 
                uniform vec4 extentParamsLow; 
                varying vec4 color;

                vec2 proj(vec2 coordHigh, vec2 coordLow) {
                    vec2 highDiff = coordHigh - extentParamsHigh.xy;
                    vec2 lowDiff = coordLow - extentParamsLow.xy;
                    return vec2(-1.0 + (highDiff * step(1.0, length(highDiff)) + lowDiff) * extentParamsHigh.zw) * vec2(1.0, -1.0);
                }

                void main() { 
                    color = colors;
                    gl_Position = vec4(proj(coordinatesHigh, coordinatesLow), 0.0, 1.0); 
                }`, fragmentShader: `precision highp float;
                varying vec4 color;
                void main () {  
                    gl_FragColor = color; 
                }` }));
    }
    this._framebuffer = new u_(this._handler, { width: this._width, height: this._height, useDepth: false });
    this._framebuffer.init();
  }
  frame() {
    if (this._planet.layerLock.isFree() && this._queue.length) {
      let e4 = this._handler, t2 = e4.gl;
      t2.disable(t2.CULL_FACE);
      t2.disable(t2.DEPTH_TEST);
      let i2 = e4.programs.vectorTileLineRasterization, s2 = e4.programs.vectorTilePolygonRasterization;
      let r2 = this._width, n2 = this._height, o2 = r2, a2 = n2, l2 = o2 << 1, h2 = a2 << 1;
      let c2 = new Float32Array(4);
      let d2 = new Float32Array(4);
      let u2 = this._framebuffer.activate();
      let _2 = 0, f2 = window.performance.now();
      while (this._queue.length && _2 < Ef) {
        let g2 = this._queue.shift();
        if (g2.isLoading && g2.segment.node.getState() === Es) {
          let _3 = g2.layer._pickingEnabled;
          if (g2.segment.tileZoom < 4) {
            o2 = l2;
            a2 = h2;
          } else {
            o2 = r2;
            a2 = n2;
          }
          let f3 = g2._updateTexture || e4.createEmptyTexture_l(o2, a2);
          let p2 = _3 ? g2._updatePickingMask || e4.createEmptyTexture_n(o2, a2) : null;
          g2.applyTexture(f3, p2);
          u2.setSize(o2, a2);
          u2.bindOutputTexture(f3);
          t2.clearColor(0, 0, 0, 0);
          t2.clear(t2.COLOR_BUFFER_BIT);
          let m2 = g2.segment.getExtentMerc();
          zo(m2.southWest.lon, Tf);
          c2[0] = Tf[0];
          d2[0] = Tf[1];
          zo(m2.southWest.lat, Tf);
          c2[1] = Tf[0];
          d2[1] = Tf[1];
          c2[2] = 2 / m2.getWidth();
          c2[3] = 2 / m2.getHeight();
          s2.activate();
          let v2 = s2._program;
          let y2 = v2.attributes, x2 = v2.uniforms;
          let b2 = g2.layer._geometryHandler;
          t2.uniform4fv(x2.extentParamsHigh, c2);
          t2.uniform4fv(x2.extentParamsLow, d2);
          t2.bindBuffer(t2.ARRAY_BUFFER, b2._polyVerticesHighBufferMerc);
          t2.vertexAttribPointer(y2.coordinatesHigh, b2._polyVerticesHighBufferMerc.itemSize, t2.FLOAT, false, 0, 0);
          t2.bindBuffer(t2.ARRAY_BUFFER, b2._polyVerticesLowBufferMerc);
          t2.vertexAttribPointer(y2.coordinatesLow, b2._polyVerticesLowBufferMerc.itemSize, t2.FLOAT, false, 0, 0);
          t2.bindBuffer(t2.ARRAY_BUFFER, b2._polyColorsBuffer);
          t2.vertexAttribPointer(y2.colors, b2._polyColorsBuffer.itemSize, t2.FLOAT, false, 0, 0);
          t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, b2._polyIndexesBuffer);
          t2.drawElements(t2.TRIANGLES, b2._polyIndexesBuffer.numItems, t2.UNSIGNED_INT, 0);
          if (_3) {
            u2.bindOutputTexture(p2);
            t2.clearColor(0, 0, 0, 0);
            t2.clear(t2.COLOR_BUFFER_BIT);
            t2.bindBuffer(t2.ARRAY_BUFFER, b2._polyPickingColorsBuffer);
            t2.vertexAttribPointer(y2.colors, b2._polyPickingColorsBuffer.itemSize, t2.FLOAT, false, 0, 0);
            t2.drawElements(t2.TRIANGLES, b2._polyIndexesBuffer.numItems, t2.UNSIGNED_INT, 0);
          }
          u2.bindOutputTexture(f3);
          i2.activate();
          v2 = i2._program;
          y2 = v2.attributes;
          x2 = v2.uniforms;
          t2.uniform2fv(x2.viewport, [o2, a2]);
          t2.uniform4fv(x2.extentParamsHigh, c2);
          t2.uniform4fv(x2.extentParamsLow, d2);
          let w2 = b2._lineVerticesHighBufferMerc;
          t2.bindBuffer(t2.ARRAY_BUFFER, w2);
          t2.vertexAttribPointer(y2.prevHigh, w2.itemSize, t2.FLOAT, false, 8, 0);
          t2.vertexAttribPointer(y2.currentHigh, w2.itemSize, t2.FLOAT, false, 8, 32);
          t2.vertexAttribPointer(y2.nextHigh, w2.itemSize, t2.FLOAT, false, 8, 64);
          w2 = b2._lineVerticesLowBufferMerc;
          t2.bindBuffer(t2.ARRAY_BUFFER, w2);
          t2.vertexAttribPointer(y2.prevLow, w2.itemSize, t2.FLOAT, false, 8, 0);
          t2.vertexAttribPointer(y2.currentLow, w2.itemSize, t2.FLOAT, false, 8, 32);
          t2.vertexAttribPointer(y2.nextLow, w2.itemSize, t2.FLOAT, false, 8, 64);
          t2.bindBuffer(t2.ARRAY_BUFFER, b2._lineOrdersBuffer);
          t2.vertexAttribPointer(y2.order, b2._lineOrdersBuffer.itemSize, t2.FLOAT, false, 4, 0);
          t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, b2._lineIndexesBuffer);
          t2.bindBuffer(t2.ARRAY_BUFFER, b2._lineStrokesBuffer);
          t2.vertexAttribPointer(y2.thickness, b2._lineStrokesBuffer.itemSize, t2.FLOAT, false, 0, 0);
          t2.bindBuffer(t2.ARRAY_BUFFER, b2._lineStrokeColorsBuffer);
          t2.vertexAttribPointer(y2.color, b2._lineStrokeColorsBuffer.itemSize, t2.FLOAT, false, 0, 0);
          t2.uniform1f(x2.thicknessOutline, 2);
          t2.uniform1f(x2.alpha, 0.54);
          t2.drawElements(t2.TRIANGLE_STRIP, b2._lineIndexesBuffer.numItems, t2.UNSIGNED_INT, 0);
          t2.uniform1f(x2.thicknessOutline, 1);
          t2.uniform1f(x2.alpha, 1);
          t2.drawElements(t2.TRIANGLE_STRIP, b2._lineIndexesBuffer.numItems, t2.UNSIGNED_INT, 0);
          t2.bindBuffer(t2.ARRAY_BUFFER, b2._lineThicknessBuffer);
          t2.vertexAttribPointer(y2.thickness, b2._lineThicknessBuffer.itemSize, t2.FLOAT, false, 0, 0);
          t2.bindBuffer(t2.ARRAY_BUFFER, b2._lineColorsBuffer);
          t2.vertexAttribPointer(y2.color, b2._lineColorsBuffer.itemSize, t2.FLOAT, false, 0, 0);
          t2.uniform1f(x2.thicknessOutline, 2);
          t2.uniform1f(x2.alpha, 0.54);
          t2.drawElements(t2.TRIANGLE_STRIP, b2._lineIndexesBuffer.numItems, t2.UNSIGNED_INT, 0);
          t2.uniform1f(x2.thicknessOutline, 1);
          t2.uniform1f(x2.alpha, 1);
          t2.drawElements(t2.TRIANGLE_STRIP, b2._lineIndexesBuffer.numItems, t2.UNSIGNED_INT, 0);
          if (_3) {
            u2.bindOutputTexture(p2);
            t2.uniform1f(x2.thicknessOutline, 8);
            t2.bindBuffer(t2.ARRAY_BUFFER, b2._linePickingColorsBuffer);
            t2.vertexAttribPointer(y2.color, b2._linePickingColorsBuffer.itemSize, t2.FLOAT, false, 0, 0);
            t2.drawElements(t2.TRIANGLE_STRIP, b2._lineIndexesBuffer.numItems, t2.UNSIGNED_INT, 0);
          }
        } else {
          g2.isLoading = false;
        }
        _2 = window.performance.now() - f2;
      }
      t2.enable(t2.DEPTH_TEST);
      t2.enable(t2.CULL_FACE);
      u2.deactivate();
    }
  }
  add(e4) {
    this._queue.push(e4);
  }
  remove(e4) {
  }
  get queueSize() {
    return this._queue.length;
  }
}
const Lf = 256;
const Pf = 512;
const Sf = 256;
const Rf = 200;
const Mf = 0.81;
class Bf extends Fr {
  constructor(e4 = {}) {
    super(e4.name);
    this._renderingFadingNodes = (e5, t3, i3, s3, r3, n2, o2) => {
      let a2 = r3 === 0;
      let l2 = this.terrain.equalizeVertices;
      for (let h2 = 0, c2 = i3._fadingNodes.length; h2 < c2; h2++) {
        let c3 = i3._fadingNodes[h2].segment;
        if (this._fadingNodes.has(i3._fadingNodes[0].__id) && !e5.has(c3.node.__id)) {
          e5.set(c3.node.__id, true);
          if (c3._transitionOpacity < 1) {
            n2.push(c3);
          } else {
            if (a2) {
              l2 && c3.equalize();
              c3.readyToEngage && c3.engage();
              c3.screenRendering(t3, s3, r3);
              o2.push(c3);
            } else {
              c3.screenRendering(t3, s3, r3, this.transparentTexture, true);
            }
          }
        }
      }
    };
    this._renderingFadingNodesNoDepth = (e5, t3, i3, s3, r3, n2) => {
      let o2 = r3 === 0;
      let a2 = this.terrain.equalizeVertices;
      let l2 = t3.gl;
      l2.disable(l2.DEPTH_TEST);
      for (let l3 = 0, h2 = i3._fadingNodes.length; l3 < h2; l3++) {
        let h3 = i3._fadingNodes[l3].segment;
        if (this._fadingNodes.has(i3._fadingNodes[0].__id) && !e5.has(h3.node.__id)) {
          e5.set(h3.node.__id, true);
          if (o2) {
            a2 && h3.equalize();
            h3.readyToEngage && h3.engage();
            h3.screenRendering(t3, s3, r3);
            n2.push(h3);
          } else {
            h3.screenRendering(t3, s3, r3, this.transparentTexture, true);
          }
        }
      }
      l2.enable(l2.DEPTH_TEST);
    };
    this._atmosphere = new g_(e4.atmosphereParameters);
    this._prevNodes = /* @__PURE__ */ new Map();
    this._currNodes = /* @__PURE__ */ new Map();
    this.transitionTime = 580;
    this.ellipsoid = e4.ellipsoid || tt;
    this.lightEnabled = true;
    this._planetRadius2 = (this.ellipsoid.getPolarSize() - 1e4) * (this.ellipsoid.getPolarSize() - 1e4);
    this._layers = [];
    this._updateLayer = false;
    this.visibleTileLayers = [];
    this.visibleVectorLayers = [];
    this._visibleVectorLayersByDepthOrder = [];
    this._visibleTileLayerSlices = [];
    this._visibleEntityCollections = [[]];
    this.baseLayer = null;
    this.terrain = null;
    this.camera = new yf(this, { frustums: e4.frustums, eye: new Ke(25e6, 0, 0), look: Ke.ZERO, up: Ke.NORTH, minAltitude: e4.minAltitude, maxAltitude: e4.maxAltitude });
    this.maxEqualZoomAltitude = e4.maxEqualZoomAltitude || 15e6;
    this.minEqualZoomAltitude = e4.minEqualZoomAltitude || 1e4;
    this.minEqualZoomCameraSlope = e4.minEqualZoomCameraSlope || 0.8;
    this.mousePositionOnEarth = new Ke();
    this.emptyTexture = null;
    this.transparentTexture = null;
    this.defaultTexture = null;
    this.minCurrZoom = h;
    this.maxCurrZoom = c;
    this._viewExtent = new Ye(new be(180, 180), new be(-180, -180));
    this._skipPreRender = false;
    this._initialViewExtent = null;
    this._createdNodesCount = 0;
    this._renderedNodes = [];
    this._renderedNodesInFrustum = [];
    this._fadingNodes = /* @__PURE__ */ new Map();
    this._fadingNodesInFrustum = [];
    this._fadingOpaqueSegments = [];
    this.layerLock = new nh();
    this.terrainLock = new nh();
    this._heightFactor = 1;
    this._indexesCache = [];
    this._indexesCacheToRemove = [];
    this._indexesCacheToRemoveCounter = 0;
    this._textureCoordsBufferCache = [];
    this.quadTreeStrategy = e4.quadTreeStrategyPrototype ? new e4.quadTreeStrategyPrototype(this) : new sf(this);
    this._nightTexture = null;
    this._specularTexture = null;
    let t2 = Tt(e4.ambient, new Ke(0.2, 0.2, 0.3));
    let i2 = Tt(e4.diffuse, new Ke(1, 1, 1));
    let s2 = Tt(e4.specular, new Ke(63e-5, 55e-5, 32e-5));
    let r2 = e4.shininess || 18;
    this._ambient = new Float32Array([t2.x, t2.y, t2.z]);
    this._diffuse = new Float32Array([i2.x, i2.y, i2.z]);
    this._specular = new Float32Array([s2.x, s2.y, s2.z, r2]);
    this._maxGridSize = Math.log2(e4.maxGridSize || 256);
    this.SLICE_SIZE = 4;
    this.SLICE_SIZE_4 = this.SLICE_SIZE * 4;
    this.SLICE_SIZE_3 = this.SLICE_SIZE * 3;
    this._lodSize = Lf;
    this._curLodSize = Lf;
    this._minLodSize = Pf;
    this._maxLodSize = Sf;
    this._pickingColorArr = new Float32Array(this.SLICE_SIZE_4);
    this._samplerArr = new Int32Array(this.SLICE_SIZE);
    this._pickingMaskArr = new Int32Array(this.SLICE_SIZE);
    this._geoImageCreator = new nf(this);
    this._vectorTileCreator = new Af(this);
    this._normalMapCreator = new lf(this);
    this._terrainWorker = new Cf(3);
    this._plainSegmentWorker = new _f(3);
    this._tileLoader = new af(e4.maxLoadingRequests || 12);
    this._memKey = new oh();
    this.events = Qi(kf);
    this._distBeforeMemClear = 0;
    this._prevCamEye = new Ke();
    this._initialized = false;
    this.always = [];
    this._renderCompleted = false;
    this._renderCompletedActivated = false;
    this._terrainCompleted = false;
    this._terrainCompletedActivated = false;
    this._collectRenderNodesIsActive = true;
    this.nightTextureCoefficient = 2;
    this._renderScreenNodesPASS = this._renderScreenNodesPASSNoAtmos;
    this._renderScreenNodesWithHeightPASS = this._renderScreenNodesWithHeightPASSNoAtmos;
    this._atmosphereEnabled = e4.atmosphereEnabled || false;
    this._atmosphereMaxMinOpacity = new Float32Array([0.95, 0.28]);
    this.solidTextureOne = null;
    this.solidTextureTwo = null;
    this._nightTextureSrc = e4.nightTextureSrc || null;
    this._specularTextureSrc = e4.specularTextureSrc || null;
    this._transitionOpacityEnabled = e4.transitionOpacityEnabled != void 0 ? e4.transitionOpacityEnabled : true;
  }
  get terrainReady() {
    return this._terrainCompleted && this._terrainCompletedActivated;
  }
  get maxGridSize() {
    return this._maxGridSize;
  }
  getNorthFrameRotation(e4) {
    return this.getFrameRotation(e4);
  }
  getFrameRotation(e4) {
    return this.ellipsoid.getNorthFrameRotation(e4);
  }
  set atmosphereMaxOpacity(e4) {
    this._atmosphereMaxMinOpacity[0] = e4;
  }
  get atmosphereMaxOpacity() {
    return this._atmosphereMaxMinOpacity[0];
  }
  set atmosphereMinOpacity(e4) {
    this._atmosphereMaxMinOpacity[1] = e4;
  }
  get atmosphereMinOpacity() {
    return this._atmosphereMaxMinOpacity[1];
  }
  set atmosphereEnabled(e4) {
    if (e4 != this._atmosphereEnabled) {
      this._atmosphereEnabled = e4;
      this._initializeAtmosphere();
    }
  }
  get atmosphereEnabled() {
    return this._atmosphereEnabled;
  }
  set diffuse(e4) {
    let t2 = Tt(e4);
    this._diffuse = new Float32Array(t2.toArray());
  }
  set ambient(e4) {
    let t2 = Tt(e4);
    this._ambient = new Float32Array(t2.toArray());
  }
  set specular(e4) {
    let t2 = Tt(e4);
    this._specular = new Float32Array([t2.x, t2.y, t2.y, this._specular[3]]);
  }
  set shininess(e4) {
    this._specular[3] = e4;
  }
  get normalMapCreator() {
    return this._normalMapCreator;
  }
  get layers() {
    return [...this._layers];
  }
  getLayers() {
    return this.layers;
  }
  get sun() {
    if (this.renderer && this.renderer.controls.sun) return this.renderer.controls.sun;
  }
  get sunPos() {
    return this.sun.sunlight.getPosition();
  }
  addControl(e4) {
    e4.planet = this;
    e4.addTo(this.renderer);
  }
  get lodSize() {
    return this._lodSize;
  }
  setLodSize(e4, t2, i2) {
    this._maxLodSize = i2 || this._maxLodSize;
    this._minLodSize = t2 || this._minLodSize;
    this._curLodSize = e4;
    this._renderCompletedActivated = false;
    this._terrainCompletedActivated = false;
  }
  addControls(e4) {
    for (let t2 = 0; t2 < e4.length; t2++) {
      this.addControl(e4[t2]);
    }
  }
  getLayerByName(e4) {
    for (let t2 = 0, i2 = this._layers.length; t2 < i2; t2++) {
      if (e4 === this._layers[t2].name) {
        return this._layers[t2];
      }
    }
  }
  addLayer(e4) {
    e4.addTo(this);
  }
  _onLayerVisibilityChanged(e4) {
    this.events.dispatch(this.events.layervisibilitychange, e4);
  }
  addLayers(e4) {
    for (let t2 = 0, i2 = e4.length; t2 < i2; t2++) {
      this.addLayer(e4[t2]);
    }
  }
  removeLayer(e4) {
    e4.remove();
  }
  _clearLayerMaterial(e4) {
    this.quadTreeStrategy.clearLayerMaterial(e4);
  }
  setBaseLayer(e4) {
    if (this.baseLayer) {
      if (!this.baseLayer.isEqual(e4)) {
        this.baseLayer.setVisibility(false);
        this.baseLayer = e4;
        e4.setVisibility(true);
        this.events.dispatch(this.events.baselayerchange, e4);
      }
    } else {
      this.baseLayer = e4;
      this.baseLayer.setVisibility(true);
      this.events.dispatch(this.events.baselayerchange, e4);
    }
  }
  setHeightFactor(e4) {
    this._renderCompletedActivated = false;
    this._terrainCompletedActivated = false;
    if (this._heightFactor !== e4) {
      this._heightFactor = e4;
      this.quadTreeStrategy.destroyBranches();
      this._clearRenderedNodeList();
      this._clearRenderNodesInFrustum();
    }
  }
  getHeightFactor() {
    return this._heightFactor;
  }
  setTerrain(e4) {
    this._renderCompletedActivated = false;
    this._terrainCompletedActivated = false;
    if (this._initialized) {
      this.memClear();
    }
    if (this.terrain) {
      this.terrain.abortLoading();
      this.terrain.clearCache();
      this.terrain._planet = null;
    }
    this.terrain = e4;
    this.terrain._planet = this;
    this.quadTreeStrategy.destroyBranches();
    if (e4._geoid.model) {
      this._plainSegmentWorker.setGeoid(e4.getGeoid());
      e4._isReady = true;
    } else {
      rf.loadModel(e4.geoid.src).then((t2) => {
        e4.geoid.setModel(t2);
        this._plainSegmentWorker.setGeoid(e4.getGeoid());
        e4._isReady = true;
      }).catch((e5) => {
        console.warn(e5);
      });
    }
  }
  initAtmosphereShader(e4) {
    if (this.renderer && this.renderer.handler && this._atmosphereEnabled) {
      let t2 = this.renderer.handler;
      if (t2.isWebGl2()) {
        t2.removeProgram("drawnode_screen_wl");
        t2.addProgram(Ju(e4), true);
      } else {
        console.warn("Atmosphere WebGL2 only");
      }
    }
  }
  get atmosphereControl() {
    return this._atmosphere;
  }
  _initializeAtmosphere() {
    if (!this.renderer) return;
    let e4 = this.renderer.handler;
    e4.removeProgram("drawnode_screen_wl");
    if (this._atmosphereEnabled) {
      this._renderScreenNodesPASS = this._renderScreenNodesPASSAtmos;
      this._renderScreenNodesWithHeightPASS = this._renderScreenNodesWithHeightPASSAtmos;
      if (!this.renderer.controls.Atmosphere) {
        this.addControl(this._atmosphere);
      }
      this._atmosphere.activate();
      if (e4.isWebGl2()) {
        e4.addProgram(Ju(this._atmosphere.parameters), true);
      } else {
        e4.addProgram(Ku(), true);
      }
      if (this.renderer.controls.SimpleSkyBackground) {
        this.renderer.controls.SimpleSkyBackground.deactivate();
      }
    } else {
      this._renderScreenNodesPASS = this._renderScreenNodesPASSNoAtmos;
      this._renderScreenNodesWithHeightPASS = this._renderScreenNodesWithHeightPASSNoAtmos;
      this._atmosphere.deactivate();
      if (!this.renderer.controls.SimpleSkyBackground) {
        this.addControl(new Bh());
      } else {
        this.renderer.controls.SimpleSkyBackground.activate();
      }
      if (e4.isWebGl2()) {
        e4.addProgram(Qu(), true);
      } else {
        e4.addProgram(Ku(), true);
      }
    }
  }
  _initializeShaders() {
    let e4 = this.renderer.handler;
    e4.addProgram(Zu(), true);
    e4.addProgram(e_(), true);
    e4.addProgram(t_(), true);
    this.renderer.addPickingCallback(this, this._renderColorPickingFramebufferPASS);
    this.renderer.addDepthCallback(this, this._renderDepthFramebufferPASS);
  }
  _onLayerLoadend(e4) {
    this.events.dispatch(this.events.layerloadend, e4);
  }
  init() {
    this._tileLoader.events.on("layerloadend", this._onLayerLoadend, this);
    Fu().setMaxGridSize(this._maxGridSize);
    const e4 = this._maxGridSize;
    let t2 = 0;
    for (let i3 = 0; i3 <= e4; i3++) {
      !this._indexesCache[i3] && (this._indexesCache[i3] = new Array(e4));
      for (let s2 = 0; s2 <= e4; s2++) {
        !this._indexesCache[i3][s2] && (this._indexesCache[i3][s2] = new Array(e4));
        for (let r2 = 0; r2 <= e4; r2++) {
          !this._indexesCache[i3][s2][r2] && (this._indexesCache[i3][s2][r2] = new Array(e4));
          for (let n2 = 0; n2 <= e4; n2++) {
            !this._indexesCache[i3][s2][r2][n2] && (this._indexesCache[i3][s2][r2][n2] = new Array(e4));
            for (let o2 = 0; o2 <= e4; o2++) {
              let e5 = { buffer: null };
              if (i3 >= 1 && i3 === s2 && i3 === r2 && i3 === n2 && i3 === o2) {
                let t3 = Fu().createSegmentIndexes(i3, [s2, r2, n2, o2]);
                e5.buffer = this.renderer.handler.createElementArrayBuffer(t3, 1);
              } else {
                this._indexesCacheToRemove[t2++] = e5;
              }
              this._indexesCache[i3][s2][r2][n2][o2] = e5;
            }
          }
        }
      }
    }
    this.renderer.events.on("resize", () => {
      this._renderCompletedActivated = false;
      this._terrainCompletedActivated = false;
    });
    this.renderer.events.on("drawtransparent", () => {
      this._renderScreenNodesWithHeightPASS();
    });
    this._textureCoordsBufferCache = [];
    let i2 = Fu().initTextureCoordsTable(e4 + 1);
    for (let t3 = 0; t3 <= e4; t3++) {
      this._textureCoordsBufferCache[t3] = this.renderer.handler.createArrayBuffer(i2[t3], 2, ((1 << t3) + 1) * ((1 << t3) + 1));
    }
    this.renderer.handler.createDefaultTexture(null, (e5) => {
      this.solidTextureOne = e5;
      this.solidTextureTwo = e5;
    });
    this.transparentTexture = this.renderer.handler.transparentTexture;
    this._renderedNodesInFrustum = new Array(this.camera.frustums.length);
    for (let e5 = 0, t3 = this._renderedNodesInFrustum.length; e5 < t3; e5++) {
      this._renderedNodesInFrustum[e5] = [];
    }
    this.quadTreeStrategy.init();
    this.drawMode = this.renderer.handler.gl.TRIANGLE_STRIP;
    this._initializeShaders();
    this._initializeAtmosphere();
    this._updateVisibleLayers();
    if (this._nightTextureSrc) {
      let e5 = new Image();
      e5.crossOrigin = "Anonymous";
      e5.onload = () => {
        this._nightTexture = this.renderer.handler.createTextureDefault(e5);
        this._nightTexture.default = true;
      };
      e5.src = this._nightTextureSrc;
    }
    if (this._specularTextureSrc) {
      let e5 = new Image();
      e5.crossOrigin = "Anonymous";
      e5.onload = () => {
        this._specularTexture = this.renderer.handler.createTextureDefault(e5);
        this._specularTexture.default = true;
      };
      e5.src = this._specularTextureSrc;
    }
    this._geoImageCreator.init();
    this._vectorTileCreator.init();
    this._normalMapCreator.init();
    this.renderer.events.on("draw", this._globalPreDraw, this, -100);
    this._preRender();
    this.renderer.events.on("postdraw", () => {
      this._checkRendercompleted();
    });
    this.initLayers();
    this._initialized = true;
    if (this._initialViewExtent) {
      this.viewExtent(this._initialViewExtent);
    }
    this.renderer.activeCamera = this.camera;
    this.camera.bindFrustumsPickingColors(this.renderer);
    this.camera.update();
  }
  initLayers() {
    let e4 = [...this._layers];
    for (let t2 = 0; t2 < e4.length; t2++) {
      this.removeLayer(e4[t2]);
      this.addLayer(e4[t2]);
    }
  }
  _clearIndexesCache() {
    this._indexesCacheToRemoveCounter = 0;
    let e4 = this._indexesCacheToRemove, t2 = this.renderer.handler.gl;
    for (let i2 = 0, s2 = e4.length; i2 < s2; i2++) {
      let s3 = e4[i2];
      t2.deleteBuffer(s3.buffer);
      s3.buffer = null;
    }
  }
  _preRender() {
    this.quadTreeStrategy.preRender();
    this._preLoad();
  }
  _preLoad() {
    this._clearRenderedNodeList();
    this._skipPreRender = false;
    this.quadTreeStrategy.preLoad();
  }
  createDefaultTextures(e4, t2) {
    this.renderer.handler.gl.deleteTexture(this.solidTextureOne);
    this.renderer.handler.gl.deleteTexture(this.solidTextureTwo);
    this.renderer.handler.createDefaultTexture(e4, (e5) => {
      this.solidTextureOne = e5;
    });
    this.renderer.handler.createDefaultTexture(t2, (e5) => {
      this.solidTextureTwo = e5;
    });
  }
  _getLayerAttributionHTML(e4) {
    return `<div class="og-attribution__layer">${e4.getAttribution()}</div>`;
  }
  updateAttributionsList() {
    let e4 = "";
    for (let t2 = 0, i2 = this._layers.length; t2 < i2; t2++) {
      let i3 = this._layers[t2];
      if (i3.getVisibility()) {
        if (i3.getAttribution().length) {
          e4 += this._getLayerAttributionHTML(i3);
        }
      }
    }
    this._applyAttribution(e4);
  }
  updateVisibleLayers() {
    this._updateLayer = true;
  }
  _updateVisibleLayers() {
    this.visibleTileLayers = [];
    this.visibleTileLayers.length = 0;
    this.visibleVectorLayers = [];
    this.visibleVectorLayers.length = 0;
    let e4 = "";
    for (let t2 = 0, i2 = this._layers.length; t2 < i2; t2++) {
      let i3 = this._layers[t2];
      if (i3.getVisibility()) {
        if (i3.isBaseLayer()) {
          this.createDefaultTextures(i3._defaultTextures[0], i3._defaultTextures[1]);
          this.baseLayer = i3;
        }
        if (i3.hasImageryTiles()) {
          this.visibleTileLayers.push(i3);
        }
        if (i3.isVector) {
          this.visibleVectorLayers.push(i3);
        }
        if (i3.getAttribution().length) {
          e4 += this._getLayerAttributionHTML(i3);
        }
      } else if (i3._fading && i3._fadingOpacity > 0) {
        if (i3.hasImageryTiles()) {
          this.visibleTileLayers.push(i3);
        }
        if (i3.isVector) {
          this.visibleVectorLayers.push(i3);
        }
      }
    }
    this._applyAttribution(e4);
    this._sortLayers();
  }
  _applyAttribution(e4) {
    if (this.renderer && this.renderer.div) {
      if (e4.length) {
        if (this.renderer.div.attributions.innerHTML !== e4) {
          this.renderer.div.attributions.innerHTML = e4;
        }
      } else {
        this.renderer.div.attributions.innerHTML = "";
      }
    }
  }
  _sortLayers() {
    this.visibleVectorLayers.sort((e5, t2) => e5.getZIndex() - t2.getZIndex() || e5.getHeight() - t2.getHeight());
    let e4 = { 0: [] };
    for (const t2 of this.visibleVectorLayers) {
      if (!e4[t2.depthOrder]) {
        e4[t2.depthOrder] = [];
      }
      e4[t2.depthOrder].push(t2);
    }
    this._visibleVectorLayersByDepthOrder.length = 0;
    this._visibleVectorLayersByDepthOrder = [];
    this._visibleVectorLayersByDepthOrder = Object.keys(e4).sort((e5, t2) => Number(e5) - Number(t2)).map((t2) => e4[Number(t2)]);
    this._visibleTileLayerSlices = [];
    this._visibleTileLayerSlices.length = 0;
    if (this.visibleTileLayers.length) {
      this.visibleTileLayers.sort((e6, t3) => e6.getHeight() - t3.getHeight() || e6.getZIndex() - t3.getZIndex());
      let e5 = -1;
      let t2 = this.visibleTileLayers[0].getHeight();
      for (let i2 = 0, s2 = this.visibleTileLayers.length; i2 < s2; i2++) {
        if (i2 % this.SLICE_SIZE === 0 || this.visibleTileLayers[i2].getHeight() !== t2) {
          e5++;
          this._visibleTileLayerSlices[e5] = [];
          t2 = this.visibleTileLayers[i2].getHeight();
        }
        this._visibleTileLayerSlices[e5].push(this.visibleTileLayers[i2]);
      }
    }
  }
  _clearRenderedNodeList() {
    this._renderedNodes.length = 0;
    this._renderedNodes = [];
  }
  _clearRenderNodesInFrustum() {
    for (let e4 = 0, t2 = this._renderedNodesInFrustum.length; e4 < t2; e4++) {
      this._renderedNodesInFrustum[e4].length = 0;
      this._renderedNodesInFrustum[e4] = [];
    }
  }
  _collectRenderedNodesMaxZoom(e4) {
    if (e4.slope > this.minEqualZoomCameraSlope && e4._lonLat.height < this.maxEqualZoomAltitude && e4._lonLat.height > this.minEqualZoomAltitude) {
      this.minCurrZoom = this.maxCurrZoom;
      let t2 = this._renderedNodes, i2 = this._renderedNodesInFrustum, s2 = [];
      this._clearRenderNodesInFrustum();
      this._renderedNodes = [];
      for (let r2 = 0, n2 = t2.length; r2 < n2; r2++) {
        let n3 = t2[r2];
        let o2 = n3.segment.centerNormal.dot(e4.getBackward());
        if (n3.segment.tileZoom === this.maxCurrZoom || o2 < Mf) {
          this._renderedNodes.push(n3);
          let e5 = 0, t3 = n3.inFrustum;
          while (t3) {
            if (t3 & 1) {
              i2[e5].push(n3);
            }
            e5++;
            t3 >>= 1;
          }
        } else {
          s2.push(n3);
        }
      }
      for (let t3 = 0, i3 = s2.length; t3 < i3; t3++) {
        s2[t3].renderTree(e4, this.maxCurrZoom, null, false, s2[t3]);
      }
    }
  }
  set transitionOpacityEnabled(e4) {
    this._transitionOpacityEnabled = e4;
  }
  get transitionOpacityEnabled() {
    return this._transitionOpacityEnabled;
  }
  _collectRenderNodes(e4) {
    this._lodSize = re(e4.slope < 0 ? 0 : e4.slope, this._curLodSize, this._minLodSize);
    e4._insideSegment = null;
    this._clearRenderedNodeList();
    this._clearRenderNodesInFrustum();
    this._viewExtent.southWest.set(180, 180);
    this._viewExtent.northEast.set(-180, -180);
    this.minCurrZoom = h;
    this.maxCurrZoom = c;
    this.quadTreeStrategy.collectRenderNodes();
    this._collectRenderedNodesMaxZoom(e4);
    this._fadingNodes.clear();
    if (this._transitionOpacityEnabled) {
      let e5 = [];
      for (let t2 = 0; t2 < this._renderedNodes.length; t2++) {
        let i2 = this._renderedNodes[t2];
        i2._collectFadingNodes();
        i2._refreshTransitionOpacity();
        if (i2.segment._transitionOpacity >= 1) {
          i2.clearNeighbors();
          i2.getRenderedNodesNeighbors(e5);
          e5.push(i2);
        } else {
          for (let t3 = 0; t3 < i2._fadingNodes.length; t3++) {
            let s2 = i2._fadingNodes[t3];
            if (s2.segment && s2.segment._transitionOpacity >= 1) {
              s2.clearNeighbors();
              s2.getRenderedNodesNeighbors(e5);
              e5.push(s2);
            }
          }
        }
      }
    }
  }
  _renderScreenNodesPASSNoAtmos() {
    let e4 = this.renderer.activeCamera;
    let t2 = this._setUniformsNoAtmos(e4);
    this._renderingScreenNodes(t2, e4, this._renderedNodesInFrustum[e4.currentFrustumIndex]);
  }
  _renderScreenNodesPASSAtmos() {
    let e4 = this.renderer.activeCamera;
    let t2 = this._setUniformsAtmos(e4);
    this._renderingScreenNodes(t2, e4, this._renderedNodesInFrustum[e4.currentFrustumIndex]);
  }
  _renderScreenNodesWithHeightPASSNoAtmos() {
    let e4 = this.renderer.activeCamera;
    let t2 = this._setUniformsNoAtmos(e4);
    this._renderingScreenNodesWithHeight(t2, e4, this._renderedNodesInFrustum[e4.currentFrustumIndex]);
  }
  _renderScreenNodesWithHeightPASSAtmos() {
    let e4 = this.renderer.activeCamera;
    let t2 = this._setUniformsAtmos(e4);
    this._renderingScreenNodesWithHeight(t2, e4, this._renderedNodesInFrustum[e4.currentFrustumIndex]);
  }
  _globalPreDraw() {
    let e4 = this.camera;
    this._distBeforeMemClear += this._prevCamEye.distance(e4.eye);
    this._prevCamEye.copy(e4.eye);
    e4.checkFly();
    if (this._createdNodesCount > Rf && this._distBeforeMemClear > 1e3) {
      this.terrain.clearCache();
      this.memClear();
    }
    if (this._indexesCacheToRemoveCounter > 600) {
      this._clearIndexesCache();
    }
  }
  preFrame() {
    if (this._updateLayer) {
      this._updateLayer = false;
      this._updateVisibleLayers();
    }
    if (this.camera.isFirstPass) {
      this.camera.update();
      if (this._skipPreRender && this._collectRenderNodesIsActive) {
        this._collectRenderNodes(this.camera);
      }
      this._skipPreRender = true;
      this._normalMapCreator.frame();
      this._geoImageCreator.frame();
      this._vectorTileCreator.frame();
      this.camera.checkTerrainCollision();
      this.camera.update();
      this.events.dispatch(this.events.draw, this);
      this._collectVectorLayerCollections();
    }
    for (let e4 = 0; e4 < this._visibleEntityCollections.length; e4++) {
      this.drawEntityCollections(this._visibleEntityCollections[e4], e4);
    }
  }
  frame() {
    this._renderScreenNodesPASS();
  }
  _checkRendercompleted() {
    if (this._renderCompleted) {
      if (!this._renderCompletedActivated) {
        this._renderCompletedActivated = true;
        this.events.dispatch(this.events.rendercompleted, true);
      }
    } else {
      this._renderCompletedActivated = false;
    }
    this._renderCompleted = true;
    if (this._terrainCompleted) {
      if (!this._terrainCompletedActivated) {
        this._terrainCompletedActivated = true;
        this.events.dispatch(this.events.terraincompleted, true);
      }
    } else {
      this._terrainCompletedActivated = false;
    }
    this._terrainCompleted = true;
  }
  lockQuadTree() {
    this._collectRenderNodesIsActive = false;
    this.camera.setTerrainCollisionActivity(false);
  }
  unlockQuadTree() {
    this._collectRenderNodesIsActive = true;
    this.camera.setTerrainCollisionActivity(true);
  }
  _setUniformsNoAtmos(e4) {
    let t2, i2;
    let s2 = this.renderer;
    let r2 = s2.handler;
    let n2 = r2.gl;
    n2.enable(n2.CULL_FACE);
    s2.enableBlendOneSrcAlpha();
    if (this.lightEnabled) {
      r2.programs.drawnode_screen_wl.activate();
      t2 = r2.programs.drawnode_screen_wl._program;
      i2 = t2.uniforms;
      n2.uniform3fv(i2.lightPosition, this._lightPosition);
      n2.uniformMatrix4fv(i2.viewMatrix, false, e4.getViewMatrix());
      n2.uniformMatrix4fv(i2.projectionMatrix, false, e4.getProjectionMatrix());
      if (this.baseLayer) {
        n2.uniform3fv(i2.diffuse, this.baseLayer._diffuse || this._diffuse);
        n2.uniform3fv(i2.ambient, this.baseLayer._ambient || this._ambient);
        n2.uniform4fv(i2.specular, this.baseLayer._specular || this._specular);
        n2.uniform1f(i2.nightTextureCoefficient, this.baseLayer.nightTextureCoefficient || this.nightTextureCoefficient);
      } else {
        n2.uniform3fv(i2.diffuse, this._diffuse);
        n2.uniform3fv(i2.ambient, this._ambient);
        n2.uniform4fv(i2.specular, this._specular);
        n2.uniform1f(i2.nightTextureCoefficient, this.nightTextureCoefficient);
      }
      n2.activeTexture(n2.TEXTURE0 + this.SLICE_SIZE);
      n2.bindTexture(n2.TEXTURE_2D, this._nightTexture || this.transparentTexture);
      n2.uniform1i(i2.nightTexture, this.SLICE_SIZE);
      n2.activeTexture(n2.TEXTURE0 + this.SLICE_SIZE + 1);
      n2.bindTexture(n2.TEXTURE_2D, this._specularTexture || this.transparentTexture);
      n2.uniform1i(i2.specularTexture, this.SLICE_SIZE + 1);
      n2.uniform1f(i2.camHeight, e4.getHeight());
    } else {
      r2.programs.drawnode_screen_nl.activate();
      t2 = r2.programs.drawnode_screen_nl._program;
      i2 = t2.uniforms;
      n2.uniformMatrix4fv(i2.viewMatrix, false, e4.getViewMatrix());
      n2.uniformMatrix4fv(i2.projectionMatrix, false, e4.getProjectionMatrix());
    }
    n2.uniform3fv(i2.eyePositionHigh, e4.eyeHigh);
    n2.uniform3fv(i2.eyePositionLow, e4.eyeLow);
    return t2;
  }
  _setUniformsAtmos(e4) {
    let t2, i2;
    let s2 = this.renderer;
    let r2 = s2.handler;
    let n2 = r2.gl;
    n2.enable(n2.CULL_FACE);
    s2.enableBlendOneSrcAlpha();
    if (this.lightEnabled) {
      r2.programs.drawnode_screen_wl.activate();
      t2 = r2.programs.drawnode_screen_wl._program;
      i2 = t2.uniforms;
      n2.uniform3fv(i2.lightPosition, this._lightPosition);
      n2.uniformMatrix4fv(i2.viewMatrix, false, e4.getViewMatrix());
      n2.uniformMatrix4fv(i2.projectionMatrix, false, e4.getProjectionMatrix());
      if (this.baseLayer) {
        n2.uniform3fv(i2.diffuse, this.baseLayer._diffuse || this._diffuse);
        n2.uniform3fv(i2.ambient, this.baseLayer._ambient || this._ambient);
        n2.uniform4fv(i2.specular, this.baseLayer._specular || this._specular);
        n2.uniform1f(i2.nightTextureCoefficient, this.baseLayer.nightTextureCoefficient || this.nightTextureCoefficient);
      } else {
        n2.uniform3fv(i2.diffuse, this._diffuse);
        n2.uniform3fv(i2.ambient, this._ambient);
        n2.uniform4fv(i2.specular, this._specular);
        n2.uniform1f(i2.nightTextureCoefficient, this.nightTextureCoefficient);
      }
      n2.uniform2fv(i2.maxMinOpacity, this._atmosphereMaxMinOpacity);
      n2.activeTexture(n2.TEXTURE0 + this.SLICE_SIZE);
      n2.bindTexture(n2.TEXTURE_2D, this._nightTexture || this.transparentTexture);
      n2.uniform1i(i2.nightTexture, this.SLICE_SIZE);
      n2.activeTexture(n2.TEXTURE0 + this.SLICE_SIZE + 1);
      n2.bindTexture(n2.TEXTURE_2D, this._specularTexture || this.transparentTexture);
      n2.uniform1i(i2.specularTexture, this.SLICE_SIZE + 1);
      n2.activeTexture(n2.TEXTURE0 + this.SLICE_SIZE + 4);
      n2.bindTexture(n2.TEXTURE_2D, s2.controls.Atmosphere._transmittanceBuffer.textures[0]);
      n2.uniform1i(i2.transmittanceTexture, this.SLICE_SIZE + 4);
      n2.activeTexture(n2.TEXTURE0 + this.SLICE_SIZE + 5);
      n2.bindTexture(n2.TEXTURE_2D, s2.controls.Atmosphere._scatteringBuffer.textures[0]);
      n2.uniform1i(i2.scatteringTexture, this.SLICE_SIZE + 5);
      n2.uniform1f(i2.camHeight, e4.getHeight());
    } else {
      r2.programs.drawnode_screen_nl.activate();
      t2 = r2.programs.drawnode_screen_nl._program;
      i2 = t2.uniforms;
      n2.uniformMatrix4fv(i2.viewMatrix, false, e4.getViewMatrix());
      n2.uniformMatrix4fv(i2.projectionMatrix, false, e4.getProjectionMatrix());
    }
    n2.uniform3fv(i2.eyePositionHigh, e4.eyeHigh);
    n2.uniform3fv(i2.eyePositionLow, e4.eyeLow);
    return t2;
  }
  _renderingScreenNodes(e4, t2, i2) {
    let s2 = t2.isFirstPass;
    let r2 = this._visibleTileLayerSlices;
    if (r2.length) {
      let e5 = r2[0];
      for (let t3 = e5.length - 1; t3 >= 0; --t3) {
        let i3 = e5[t3];
        if (i3._fading && s2 && i3._refreshFadingOpacity()) {
          e5.splice(t3, 1);
        }
      }
    }
    let n2 = /* @__PURE__ */ new Map();
    let o2 = [];
    let a2 = this.terrain.equalizeVertices;
    let l2 = i2.length;
    this._fadingOpaqueSegments = [];
    if (t2.slope > 0.8 || !this.terrain || this.terrain.isEmpty) {
      while (l2--) {
        let t3 = i2[l2];
        let s3 = t3.segment;
        this._renderingFadingNodesNoDepth(n2, e4, t3, r2[0], 0, this._fadingOpaqueSegments);
        a2 && s3.equalize();
        s3.readyToEngage && s3.engage();
        s3.screenRendering(e4, r2[0], 0);
      }
    } else {
      while (l2--) {
        let t3 = i2[l2];
        let s3 = t3.segment;
        this._renderingFadingNodes(n2, e4, t3, r2[0], 0, o2, this._fadingOpaqueSegments);
        if (s3._transitionOpacity < 1) {
          o2.push(s3);
        } else {
          a2 && s3.equalize();
          s3.readyToEngage && s3.engage();
          s3.screenRendering(e4, r2[0], 0);
        }
      }
      for (let t3 = 0; t3 < o2.length; t3++) {
        let i3 = o2[t3];
        a2 && i3.equalize();
        i3.readyToEngage && i3.engage();
        i3.screenRendering(e4, r2[0], 0);
      }
    }
  }
  _renderingScreenNodesWithHeight(e4, t2, i2) {
    let s2 = this.renderer.handler.gl;
    let r2 = t2.isFirstPass;
    let n2 = this._visibleTileLayerSlices;
    s2.enable(s2.POLYGON_OFFSET_FILL);
    s2.disable(s2.CULL_FACE);
    let o2 = /* @__PURE__ */ new Map();
    let a2 = [];
    for (let t3 = 1, l2 = n2.length; t3 < l2; t3++) {
      let l3 = n2[t3];
      for (let e5 = l3.length - 1; e5 >= 0; --e5) {
        let t4 = l3[e5];
        if (t4._fading && r2 && t4._refreshFadingOpacity()) {
          l3.splice(e5, 1);
        }
      }
      s2.polygonOffset(0, -t3);
      let h2 = i2.length;
      while (h2--) {
        let s3 = i2[h2];
        this._renderingFadingNodes(o2, e4, s3, n2[t3], t3, a2);
        if (s3.segment._transitionOpacity < 1) {
          s3.segment.initSlice(t3);
        } else {
          s3.segment.screenRendering(e4, n2[t3], t3, this.transparentTexture, true);
        }
      }
    }
    s2.disable(s2.POLYGON_OFFSET_FILL);
    s2.enable(s2.CULL_FACE);
  }
  _renderColorPickingFramebufferPASS() {
    let e4;
    let t2 = this.renderer;
    let i2 = t2.handler;
    let s2 = i2.gl;
    i2.programs.drawnode_colorPicking.activate();
    e4 = i2.programs.drawnode_colorPicking._program;
    let r2 = e4.uniforms;
    let n2 = t2.activeCamera;
    s2.enable(s2.CULL_FACE);
    s2.uniformMatrix4fv(r2.viewMatrix, false, n2.getViewMatrix());
    s2.uniformMatrix4fv(r2.projectionMatrix, false, n2.getProjectionMatrix());
    s2.uniform3fv(r2.eyePositionHigh, n2.eyeHigh);
    s2.uniform3fv(r2.eyePositionLow, n2.eyeLow);
    let o2 = this._renderedNodesInFrustum[n2.getCurrentFrustum()];
    let a2 = this._visibleTileLayerSlices;
    let l2 = o2.length;
    while (l2--) {
      if (o2[l2].segment._transitionOpacity >= 1) {
        o2[l2].segment.colorPickingRendering(e4, a2[0], 0);
      }
    }
    for (let t3 = 0; t3 < this._fadingOpaqueSegments.length; ++t3) {
      this._fadingOpaqueSegments[t3].colorPickingRendering(e4, a2[0], 0);
    }
    t2.enableBlendDefault();
    s2.enable(s2.POLYGON_OFFSET_FILL);
    for (let t3 = 1, i3 = a2.length; t3 < i3; t3++) {
      l2 = o2.length;
      s2.polygonOffset(0, -t3);
      while (l2--) {
        o2[l2].segment.colorPickingRendering(e4, a2[t3], t3, this.transparentTexture, true);
      }
    }
    s2.disable(s2.POLYGON_OFFSET_FILL);
  }
  _renderDepthFramebufferPASS() {
    let e4;
    let t2 = this.renderer;
    let i2 = t2.handler;
    let s2 = i2.gl;
    i2.programs.drawnode_depth.activate();
    e4 = i2.programs.drawnode_depth._program;
    let r2 = e4.uniforms;
    let n2 = t2.activeCamera;
    s2.disable(s2.BLEND);
    s2.disable(s2.POLYGON_OFFSET_FILL);
    s2.uniformMatrix4fv(r2.viewMatrix, false, n2.getViewMatrix());
    s2.uniformMatrix4fv(r2.projectionMatrix, false, n2.getProjectionMatrix());
    s2.uniform3fv(r2.eyePositionHigh, n2.eyeHigh);
    s2.uniform3fv(r2.eyePositionLow, n2.eyeLow);
    s2.uniform1f(r2.frustumPickingColor, n2.frustumColorIndex);
    let o2 = this._renderedNodesInFrustum[n2.getCurrentFrustum()], a2 = this._visibleTileLayerSlices;
    let l2 = o2.length;
    while (l2--) {
      if (o2[l2].segment._transitionOpacity >= 1) {
        o2[l2].segment.depthRendering(e4, a2[0]);
      }
    }
    for (let t3 = 0; t3 < this._fadingOpaqueSegments.length; ++t3) {
      this._fadingOpaqueSegments[t3].depthRendering(e4, a2[0]);
    }
    s2.enable(s2.BLEND);
  }
  _collectVectorLayerCollections() {
    let e4 = this._visibleVectorLayersByDepthOrder.length;
    this._visibleEntityCollections.length = 0;
    this._visibleEntityCollections = new Array(e4);
    for (let e5 = 0; e5 < this._visibleEntityCollections.length; e5++) {
      this._visibleEntityCollections[e5] = [];
    }
    while (e4--) {
      let t2 = this._visibleVectorLayersByDepthOrder[e4];
      let i2 = t2.length;
      while (i2--) {
        let s2 = t2[i2];
        if (s2._fading && s2._refreshFadingOpacity()) {
          t2.splice(i2, 1);
          if (t2.length === 0) {
            this._visibleVectorLayersByDepthOrder.splice(e4, 1);
          }
        }
        s2.collectVisibleCollections(this._visibleEntityCollections[e4]);
        s2.update();
      }
    }
  }
  memClear() {
    this._distBeforeMemClear = 0;
    this.camera._insideSegment = null;
    this.layerLock.lock(this._memKey);
    this.terrainLock.lock(this._memKey);
    this._normalMapCreator.lock(this._memKey);
    this._normalMapCreator.clear();
    this.terrain.abortLoading();
    this._tileLoader.abortAll();
    this.quadTreeStrategy.clear();
    this.layerLock.free(this._memKey);
    this.terrainLock.free(this._memKey);
    this._normalMapCreator.free(this._memKey);
    this._createdNodesCount = 0;
  }
  getRayIntersectionEllipsoid(e4) {
    return this.ellipsoid.hitRay(e4.origin, e4.direction);
  }
  getCartesianFromPixelEllipsoid(e4) {
    let t2 = this.renderer.activeCamera;
    return this.ellipsoid.hitRay(t2.eye, t2.unproject(e4.x, e4.y));
  }
  getLonLatFromPixelEllipsoid(e4) {
    let t2 = this.getCartesianFromPixelEllipsoid(e4);
    if (t2) {
      return this.ellipsoid.cartesianToLonLat(t2);
    }
  }
  getCartesianFromMouseTerrain() {
    let e4 = this.renderer.events.mouseState;
    let t2 = this.getDistanceFromPixel(e4);
    if (t2) {
      return e4.direction.scaleTo(t2).addA(this.renderer.activeCamera.eye);
    }
  }
  getCartesianFromPixelTerrain(e4) {
    let t2 = this.getDistanceFromPixel(e4);
    if (t2) {
      let i2 = e4.direction || this.renderer.activeCamera.unproject(e4.x, e4.y);
      return i2.scaleTo(t2).addA(this.renderer.activeCamera.eye);
    }
  }
  getLonLatFromPixelTerrain(e4) {
    let t2 = this.getCartesianFromPixelTerrain(e4);
    if (t2) {
      return this.ellipsoid.cartesianToLonLat(t2);
    }
  }
  getPixelFromCartesian(e4) {
    return this.renderer.activeCamera.project3v(e4);
  }
  getPixelFromLonLat(e4) {
    let t2 = this.ellipsoid.lonLatToCartesian(e4);
    if (t2) {
      return this.renderer.activeCamera.project3v(t2);
    }
  }
  getDistanceFromPixelEllipsoid(e4) {
    let t2 = this.getCartesianFromPixelEllipsoid(e4);
    if (t2) {
      return t2.distance(this.renderer.activeCamera.eye);
    }
  }
  getDistanceFromPixel(e4) {
    return this.renderer.getDistanceFromPixel(e4) || this.getDistanceFromPixelEllipsoid(e4) || 0;
  }
  viewExtent(e4) {
    if (this.camera) {
      this.camera.viewExtent(e4);
    } else {
      this._initialViewExtent = e4;
    }
  }
  viewExtentArr(e4) {
    this.viewExtent(new Ye(new be(e4[0], e4[1]), new be(e4[2], e4[3])));
  }
  getExtent() {
    if (this.renderer) {
      let e4 = this.renderer.handler.getWidth(), t2 = this.renderer.handler.getHeight();
      let i2 = [this.getLonLatFromPixelTerrain(new Qe(0, 0)), this.getLonLatFromPixelTerrain(new Qe(e4, 0)), this.getLonLatFromPixelTerrain(new Qe(e4, t2)), this.getLonLatFromPixelTerrain(new Qe(0, t2))];
      if (i2[0] && i2[1] && i2[2] && i2[3]) {
        let e5 = i2[0].lon, t3 = i2[2].lat, s2 = i2[1].lon, r2 = i2[0].lat;
        for (let n2 = 0; n2 < i2.length; n2++) {
          if (i2[n2].lon > s2) s2 = i2[n2].lon;
          if (i2[n2].lat > r2) r2 = i2[n2].lat;
          if (i2[n2].lon < e5) e5 = i2[n2].lon;
          if (i2[n2].lat < t3) t3 = i2[n2].lat;
        }
        return new Ye(new be(e5, t3), new be(s2, r2));
      }
    }
    return this._viewExtent;
  }
  getViewExtent() {
    return this._viewExtent;
  }
  viewLonLat(e4, t2, i2) {
    this.camera.setLonLat(e4, t2, i2);
  }
  flyExtent(e4, t2, i2, s2, r2, n2) {
    this.camera.flyExtent(e4, t2, i2, s2, r2, n2);
  }
  flyCartesian(e4, t2, i2, s2, r2, n2, o2) {
    this.camera.flyCartesian(e4, t2, i2, s2, r2, n2, o2);
  }
  flyLonLat(e4, t2, i2, s2, r2, n2, o2) {
    this.camera.flyLonLat(e4, t2, i2, s2, r2, n2, o2);
  }
  stopFlying() {
    this.camera.stopFlying();
  }
  updateBillboardsTexCoords() {
    for (let e5 = 0; e5 < this.entityCollections.length; e5++) {
      this.entityCollections[e5].billboardHandler.refreshTexCoordsArr();
    }
    let e4 = {};
    for (let t2 = 0; t2 < this._layers.length; t2++) {
      let i2 = this._layers[t2];
      if (i2 instanceof Ma) {
        i2.each(function(t3) {
          if (t3._entityCollection && !e4[t3._entityCollection.id]) {
            t3._entityCollection.billboardHandler.refreshTexCoordsArr();
            e4[t3._entityCollection.id] = true;
          }
        });
      }
    }
  }
  getEntityTerrainPoint(e4, t2) {
    let i2 = this._renderedNodes, s2 = i2.length;
    while (s2--) {
      if (i2[s2].segment.isEntityInside(e4)) {
        return i2[s2].segment.getEntityTerrainPoint(e4, t2);
      }
    }
  }
  async getHeightDefault(e4) {
    return new Promise((t2) => {
      if (this.terrain) {
        this.terrain.getHeightAsync(e4.clone(), (e5) => {
          t2(e5);
        });
      } else {
        t2(0);
      }
    });
  }
  async getHeightAboveELL(e4) {
    return new Promise((t2) => {
      if (this.terrain) {
        this.terrain.getHeightAsync(e4.clone(), (i2) => {
          t2(i2 + this.terrain.geoid.getHeightLonLat(e4));
        });
      } else {
        t2(0);
      }
    });
  }
  onremove() {
    this.memClear();
    this.quadTreeStrategy.destroyBranches();
    this._renderedNodes = [];
  }
  stopDragging() {
    if (this.renderer && this.renderer.controls.EarthNavigation) {
      this.renderer.controls.EarthNavigation.stop();
    }
  }
}
const kf = ["draw", "layeradd", "baselayerchange", "layerremove", "layervisibilitychange", "rendercompleted", "terraincompleted", "layerloadend"];
function If() {
  return new Yr("skybox", { uniforms: { projectionViewMatrix: { type: Vr.MAT4 }, uSampler: { type: Vr.SAMPLERCUBE }, pos: { type: Vr.VEC3 } }, attributes: { aVertexPosition: { type: Vr.VEC3, enableArray: true } }, vertexShader: `attribute vec3 aVertexPosition;
            uniform mat4 projectionViewMatrix;
            uniform vec3 pos;
            varying vec3 vTextureCoord;
            void main(void) {
                vTextureCoord = aVertexPosition;
                gl_Position = projectionViewMatrix * vec4(aVertexPosition + pos, 1.0);
            }`, fragmentShader: `precision lowp float;
            varying vec3 vTextureCoord;
            uniform samplerCube uSampler;
            void main(void) {
                gl_FragColor = textureCube(uSampler, vTextureCoord);
            }` });
}
class zf extends Fr {
  constructor(e4) {
    super("skybox");
    this.params = e4;
    this.vertexPositionBuffer = null;
    this.texture = null;
  }
  static createDefault(e4) {
    return new zf({ nx: e4 + "skybox/gal/_nx.jpg", px: e4 + "skybox/gal/_px.jpg", py: e4 + "skybox/gal/_py.jpg", ny: e4 + "skybox/gal/_ny.jpg", pz: e4 + "skybox/gal/_pz.jpg", nz: e4 + "skybox/gal/_nz.jpg" });
  }
  init() {
    this.renderer.handler.addProgram(If(), true);
    this.texture = this.renderer.handler.loadCubeMapTexture(this.params);
    this._createBuffers();
    this.drawMode = this.renderer.handler.gl.TRIANGLES;
  }
  frame() {
    let e4 = this.renderer.handler;
    let t2 = e4.gl;
    let i2 = this.renderer.activeCamera;
    t2.disable(t2.DEPTH_TEST);
    e4.programs.skybox.activate();
    let s2 = e4.programs.skybox._program;
    let r2 = s2.uniforms;
    t2.uniformMatrix4fv(r2.projectionViewMatrix, false, i2.getProjectionViewMatrix());
    t2.uniform3fv(r2.pos, i2.eye.toArray());
    t2.activeTexture(t2.TEXTURE0);
    t2.bindTexture(t2.TEXTURE_CUBE_MAP, this.texture);
    t2.uniform1i(r2.uSampler, 0);
    let n2 = this.vertexPositionBuffer;
    t2.bindBuffer(t2.ARRAY_BUFFER, n2);
    t2.vertexAttribPointer(s2.attributes.aVertexPosition, n2.itemSize, t2.FLOAT, false, 0, 0);
    t2.drawArrays(this.drawMode, 0, n2.numItems);
    t2.enable(t2.DEPTH_TEST);
  }
  _createBuffers() {
    const e4 = new Float32Array([-1e8, 1e8, -1e8, -1e8, -1e8, -1e8, 1e8, -1e8, -1e8, 1e8, -1e8, -1e8, 1e8, 1e8, -1e8, -1e8, 1e8, -1e8, -1e8, -1e8, 1e8, -1e8, -1e8, -1e8, -1e8, 1e8, -1e8, -1e8, 1e8, -1e8, -1e8, 1e8, 1e8, -1e8, -1e8, 1e8, 1e8, -1e8, -1e8, 1e8, -1e8, 1e8, 1e8, 1e8, 1e8, 1e8, 1e8, 1e8, 1e8, 1e8, -1e8, 1e8, -1e8, -1e8, -1e8, -1e8, 1e8, -1e8, 1e8, 1e8, 1e8, 1e8, 1e8, 1e8, 1e8, 1e8, 1e8, -1e8, 1e8, -1e8, -1e8, 1e8, -1e8, 1e8, -1e8, 1e8, 1e8, -1e8, 1e8, 1e8, 1e8, 1e8, 1e8, 1e8, -1e8, 1e8, 1e8, -1e8, 1e8, -1e8, -1e8, -1e8, -1e8, -1e8, -1e8, 1e8, 1e8, -1e8, -1e8, 1e8, -1e8, -1e8, -1e8, -1e8, 1e8, 1e8, -1e8, 1e8]);
    this.vertexPositionBuffer = this.renderer.handler.createArrayBuffer(e4, 3, e4.length / 3);
  }
}
const Df = Object.freeze(Object.defineProperty({ __proto__: null, Axes: Tu, Planet: Bf, RenderNode: Fr, SkyBox: zf }, Symbol.toStringTag, { value: "Module" }));
const _Ff = class _Ff {
  constructor(e4 = {}) {
    this.__id = _Ff.__counter__++;
    this.equalizeVertices = e4.equalizeVertices || false;
    this.equalizeNormals = false;
    this.isEmpty = true;
    this.name = e4.name || "empty";
    this.minZoom = e4.minZoom || 2;
    this.maxZoom = e4.maxZoom || 19;
    this.maxNativeZoom = e4.maxNativeZoom || this.maxZoom;
    this.gridSizeByZoom = e4.gridSizeByZoom || [64, 32, 16, 8, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2];
    this._maxNodeZoom = this.gridSizeByZoom.length - 1;
    this.plainGridSize = 2;
    this.noDataValues = [];
    this._planet = null;
    this._geoid = e4.geoid || new rf({ src: e4.geoidSrc || null });
    this._isReady = false;
  }
  setUrlRewriteCallback(e4) {
  }
  get isIdle() {
    return true;
  }
  isEqual(e4) {
    return e4.__id === this.__id;
  }
  static checkNoDataValue(e4, t2) {
    return Lt(e4, t2) !== -1;
  }
  isBlur(e4) {
    return false;
  }
  set maxNodeZoom(e4) {
    if (e4 > this.gridSizeByZoom.length - 1) {
      e4 = this.gridSizeByZoom.length - 1;
    }
    this._maxNodeZoom = e4;
  }
  get maxNodeZoom() {
    return this._maxNodeZoom;
  }
  set geoid(e4) {
    this._geoid = e4;
  }
  get geoid() {
    return this._geoid;
  }
  getGeoid() {
    return this._geoid;
  }
  handleSegmentTerrain(e4) {
    e4.terrainIsLoading = false;
    e4.terrainReady = true;
    e4.terrainExists = true;
  }
  isReady() {
    return this._isReady;
  }
  abortLoading() {
  }
  clearCache() {
  }
  getHeightAsync(e4, t2) {
    t2(0);
    return true;
  }
  loadTerrain(e4, t2 = false) {
  }
};
_Ff.__counter__ = 0;
let Ff = _Ff;
class Nf extends Ff {
  constructor(e4 = "", t2 = {}) {
    super({ geoidSrc: "https://openglobus.org/geoid/egm84-30.pgm", maxNativeZoom: t2.maxNativeZoom || 14, ...t2 });
    this._s = t2.subdomains || ["a", "b", "c"];
    this.events = Qi(Of, this);
    this._requestCount = 0;
    this._requestsPeerSubdomain = 4;
    this.isEmpty = false;
    this.equalizeNormals = true;
    this.name = e4 || "openglobus";
    this.url = t2.url || "https://{s}.srtm3.openglobus.org/{z}/{y}/{x}.ddm";
    this.gridSizeByZoom = t2.gridSizeByZoom || [64, 32, 32, 16, 16, 8, 8, 8, 16, 16, 16, 32, 32, 32, 32, 16, 8, 4, 2, 2, 2, 2, 2, 2];
    this._heightFactor = t2.heightFactor != void 0 ? t2.heightFactor : 1;
    this.noDataValues = t2.noDataValues || [];
    for (let e5 = 0; e5 < this.noDataValues.length; e5++) {
      this.noDataValues[e5] *= this._heightFactor;
    }
    this.plainGridSize = t2.plainGridSize || 32;
    this._extent = Et(t2.extent, new Ye(new be(-180, -90), new be(180, 90)));
    this._dataType = "arrayBuffer";
    this._maxNodeZoom = this.gridSizeByZoom.length - 1;
    this._elevationCache = {};
    this._fetchCache = {};
    this._loader = new af();
    this._urlRewriteCallback = t2.urlRewrite || null;
  }
  get loader() {
    return this._loader;
  }
  clearCache() {
    for (let e4 in this._elevationCache) {
      this._elevationCache[e4].heights = null;
      this._elevationCache[e4].extent = null;
      delete this._elevationCache[e4];
    }
    this._elevationCache = null;
    this._elevationCache = {};
    for (let e4 in this._fetchCache) {
      this._fetchCache[e4] = null;
      delete this._fetchCache[e4];
    }
    this._fetchCache = null;
    this._fetchCache = {};
  }
  isBlur(e4) {
    return e4.tileZoom >= 6;
  }
  setElevationCache(e4, t2) {
    this._elevationCache[e4] = t2;
  }
  getElevationCache(e4) {
    return this._elevationCache[e4];
  }
  getHeightAsync(e4, t2, i2, s2) {
    if (!e4 || e4.lat > Ge || e4.lat < We) {
      t2(0);
      return true;
    }
    s2 = s2 != void 0 ? s2 : true;
    const [r2, n2, o2, a2] = this._planet.quadTreeStrategy.getTileXY(e4, i2 || this.maxZoom);
    let l2 = ks.getTileIndex(r2, n2, o2, a2);
    let h2 = this.getElevationCache(l2);
    let c2 = Ie(e4);
    if (h2) {
      if (h2.heights) {
        t2(this._getGroundHeightMerc(c2, h2));
      } else {
        t2(0);
      }
      return true;
    } else {
      let i3 = this._fetchCache[l2];
      if (!i3) {
        i3 = this._loader.fetch({ src: this.buildURL(r2, n2, o2, a2), type: this._dataType });
        this._fetchCache[l2] = i3;
      }
      i3.then((i4) => {
        let h3 = Ue(r2, n2, o2);
        if (i4.status === "ready") {
          let e5 = { heights: this._createHeights(i4.data, null, a2, r2, n2, o2, h3), extent: h3 };
          this.setElevationCache(l2, e5);
          t2(this._getGroundHeightMerc(c2, e5));
        } else if (i4.status === "error") {
          if (s2 && o2 > this.maxNativeZoom) {
            s2 = false;
            this.getHeightAsync(e4, t2, this.maxNativeZoom, false);
            return;
          }
          this.setElevationCache(l2, { heights: null, extent: h3 });
          t2(0);
        } else {
          this._fetchCache[l2] = null;
          delete this._fetchCache[l2];
        }
      });
    }
    return false;
  }
  _getGroundHeightMerc(e4, t2) {
    if (!(t2.extent && t2.heights)) {
      return 0;
    }
    let i2 = t2.extent.getWidth(), s2 = Math.sqrt(t2.heights.length);
    let r2 = i2 / (s2 - 1);
    let n2 = s2 - Math.ceil((e4.lat - t2.extent.southWest.lat) / r2) - 1, o2 = Math.floor((e4.lon - t2.extent.southWest.lon) / r2);
    let a2 = (n2 + 1) * s2 + o2, l2 = a2 + 1, h2 = n2 * s2 + o2, c2 = h2 + 1;
    let d2 = t2.heights[a2], u2 = t2.heights[l2], _2 = t2.heights[h2], f2 = t2.heights[c2];
    let g2 = new Ke(t2.extent.southWest.lon + r2 * o2, d2, t2.extent.northEast.lat - r2 * n2 - r2), p2 = new Ke(g2.x + r2, u2, g2.z), m2 = new Ke(g2.x, _2, g2.z + r2), v2 = new Ke(g2.x + r2, f2, g2.z + r2);
    let y2 = new Ke(e4.lon, 1e5, e4.lat), x2 = new ar(y2, new Ke(0, -1, 0));
    let b2 = new Ke();
    let w2 = x2.hitTriangleRes(g2, p2, m2, b2);
    if (w2 === ar.INSIDE) {
      return b2.y;
    }
    w2 = x2.hitTriangleRes(p2, v2, m2, b2);
    if (w2 === ar.INSIDE) {
      return b2.y;
    }
    return 0;
  }
  abortLoading() {
    this._loader.abortAll();
  }
  setUrl(e4) {
    this.url = e4;
  }
  setName(e4) {
    this.name = e4;
  }
  isReadyToLoad(e4) {
    return e4._tileGroup === T_ && this._extent.overlaps(e4.getExtentLonLat());
  }
  loadTerrain(e4, t2 = false) {
    if (this._planet.terrainLock.isFree()) {
      e4.terrainReady = false;
      e4.terrainIsLoading = true;
      if (this.isReadyToLoad(e4)) {
        let i2 = this.getElevationCache(e4.tileIndex);
        if (i2) {
          this._applyElevationsData(e4, i2.heights);
        } else {
          this._loader.load({ sender: this, src: this._getHTTPRequestString(e4), segment: e4, type: this._dataType, filter: () => e4.plainReady && e4.node.getState() !== Ts || t2 }, (t3) => {
            if (t3.status === "ready") {
              let i3 = this._createHeights(t3.data, e4, e4._tileGroup, e4.tileX, e4.tileY, e4.tileZoom, e4.getExtent(), e4.tileZoom === this.maxZoom);
              this.setElevationCache(e4.tileIndex, { heights: i3, extent: e4.getExtent() });
              this._applyElevationsData(e4, i3);
            } else if (t3.status === "abort") {
              e4.terrainIsLoading = false;
            } else if (t3.status === "error") {
              this._applyElevationsData(e4, null);
            } else {
              e4.terrainIsLoading = false;
            }
          });
        }
      } else {
        e4.elevationsNotExists();
      }
    } else {
      e4.terrainIsLoading = false;
    }
  }
  _getSubdomain() {
    this._requestCount++;
    return this._s[Math.floor(this._requestCount % (this._requestsPeerSubdomain * this._s.length) / this._requestsPeerSubdomain)];
  }
  buildURL(e4, t2, i2, s2) {
    return ft(this.url, { s: this._getSubdomain(), x: e4.toString(), y: t2.toString(), z: i2.toString() });
  }
  _createUrl(e4) {
    return this.buildURL(e4.tileX, e4.tileY, e4.tileZoom, e4._tileGroup);
  }
  _getHTTPRequestString(e4) {
    if (this._urlRewriteCallback) {
      return this._urlRewriteCallback(e4.tileX, e4.tileY, e4.tileZoom, e4._tileGroup) || this._createUrl(e4);
    } else {
      return this._createUrl(e4);
    }
  }
  setUrlRewriteCallback(e4) {
    this._urlRewriteCallback = e4;
  }
  _createHeights(e4, t2, i2, s2, r2, n2, o2, a2) {
    if (this._heightFactor !== 1) {
      let t3 = new Float32Array(e4);
      for (let e5 = 0, i3 = t3.length; e5 < i3; e5++) {
        t3[e5] = t3[e5] * this._heightFactor;
      }
      return t3;
    }
    return new Float32Array(e4);
  }
  _applyElevationsData(e4, t2) {
    if (e4) {
      let i2 = this.events.load;
      if (i2.handlers.length) {
        this.events.dispatch(i2, { elevations: t2, segment: e4 });
      }
      e4.applyTerrain(t2);
    }
  }
}
const Of = ["load", "loadend"];
class Hf extends ks {
  constructor(e4, t2 = {}) {
    super(e4, t2);
    this.events = this.events.registerNames(Vf);
    this.url = t2.url || "";
    this._s = t2.subdomains || ["a", "b", "c"];
    this.minNativeZoom = t2.minNativeZoom || 0;
    this.maxNativeZoom = t2.maxNativeZoom || 19;
    this._urlRewriteCallback = t2.urlRewrite || null;
    this._requestsPeerSubdomains = 4;
    this._requestCount = 0;
  }
  get isIdle() {
    return super.isIdle && this._planet._tileLoader.getRequestCounter(this) === 0;
  }
  get instanceName() {
    return "XYZ";
  }
  abortLoading() {
    if (this._planet) {
      this._planet._tileLoader.abort(this);
    }
  }
  setVisibility(e4) {
    if (e4 !== this._visibility) {
      super.setVisibility(e4);
      if (!e4) {
        this.abortLoading();
      }
    }
  }
  remove() {
    this.abortLoading();
    super.remove();
    return this;
  }
  setUrl(e4) {
    this.url = e4;
  }
  _checkSegment(e4) {
    return e4._projection.id === this._planet.quadTreeStrategy.projection.id;
  }
  loadMaterial(e4, t2 = false) {
    let i2 = e4.segment;
    if (this._isBaseLayer) {
      e4.texture = i2.getDefaultTexture();
    } else {
      e4.texture = i2.planet.transparentTexture;
    }
    if (this._planet.layerLock.isFree() || e4.segment.tileZoom < 2) {
      e4.isReady = false;
      e4.isLoading = true;
      if (this._checkSegment(i2)) {
        e4.loadingAttempts++;
        this._planet._tileLoader.load({ sender: this, src: this._getHTTPRequestString(e4.segment), type: "imageBitmap", filter: () => i2.initialized && i2.node.getState() === Es || t2, options: {} }, (t3) => {
          if (t3.status === "ready") {
            if (e4.isLoading) {
              let i3 = this.events.load;
              if (i3.handlers.length) {
                this.events.dispatch(i3, e4);
              }
              e4.applyImage(t3.data);
              t3.data = null;
            }
          } else if (t3.status === "abort") {
            e4.isLoading = false;
          } else if (t3.status === "error") {
            if (e4.isLoading) {
              e4.textureNotExists();
            }
          }
        });
      } else {
        e4.textureNotExists();
      }
    }
  }
  _createUrl(e4) {
    return ft(this.url, { s: this._getSubdomain(), x: e4.tileX.toString(), y: e4.tileY.toString(), z: e4.tileZoom.toString() });
  }
  _getSubdomain() {
    this._requestCount++;
    return this._s[Math.floor(this._requestCount % (this._requestsPeerSubdomains * this._s.length) / this._requestsPeerSubdomains)];
  }
  _getHTTPRequestString(e4) {
    return this._urlRewriteCallback ? this._urlRewriteCallback(e4, this.url) : this._createUrl(e4);
  }
  setUrlRewriteCallback(e4) {
    this._urlRewriteCallback = e4;
  }
  applyMaterial(e4, t2 = false) {
    if (e4.isReady) {
      return e4.texOffset;
    } else if (e4.segment.tileZoom < this.minNativeZoom) {
      e4.textureNotExists();
    } else {
      let i2 = e4.segment, s2 = i2.node, r2 = false;
      let n2 = this.__id;
      let o2 = e4;
      while (s2.parentNode) {
        s2 = s2.parentNode;
        o2 = s2.segment.materials[n2];
        if (o2 && o2.textureExists) {
          r2 = true;
          break;
        }
      }
      if (i2.passReady) {
        let r3 = e4.layer.maxNativeZoom;
        if (s2.segment.tileZoom === r3) {
          e4.textureNotExists();
        } else if (e4.segment.tileZoom <= r3) {
          !e4.isLoading && !e4.isReady && this.loadMaterial(e4, t2);
        } else {
          let t3 = i2.node;
          while (t3.segment.tileZoom > e4.layer.maxNativeZoom) {
            t3 = t3.parentNode;
          }
          let s3 = t3.segment.materials[e4.layer.__id];
          if (s3) {
            !s3.isLoading && !s3.isReady && this.loadMaterial(s3, true);
          } else {
            s3 = t3.segment.materials[e4.layer.__id] = e4.layer.createMaterial(t3.segment);
            this.loadMaterial(s3, true);
          }
        }
      }
      if (r2) {
        e4.appliedNode = s2;
        e4.appliedNodeId = s2.nodeId;
        e4.texture = o2.texture;
        let t3 = 1 / (2 << i2.tileZoom - s2.segment.tileZoom - 1);
        e4.texOffset[0] = i2.tileX * t3 - s2.segment.tileX;
        e4.texOffset[1] = i2.tileY * t3 - s2.segment.tileY;
        e4.texOffset[2] = t3;
        e4.texOffset[3] = t3;
      } else {
        e4.texture = i2.planet.transparentTexture;
        e4.texOffset[0] = 0;
        e4.texOffset[1] = 0;
        e4.texOffset[2] = 1;
        e4.texOffset[3] = 1;
      }
    }
    return e4.texOffset;
  }
  clearMaterial(e4) {
    if (e4.isReady && e4.textureExists) {
      !e4.texture.default && e4.segment.handler.gl.deleteTexture(e4.texture);
      e4.texture = null;
    }
    e4.isReady = false;
    e4.textureExists = false;
    e4.isLoading = false;
  }
  _correctFullExtent() {
    let e4 = this._extent, t2 = this._extentMerc;
    let i2 = we + 5e4;
    let s2 = we + 5e4;
    if (e4.northEast.lat === 90) {
      t2.northEast.lat = s2;
    }
    if (e4.northEast.lon === 180) {
      t2.northEast.lon = i2;
    }
    if (e4.southWest.lat === -90) {
      t2.southWest.lat = -2008750834e-2;
    }
    if (e4.southWest.lon === -180) {
      t2.southWest.lon = -2008750834e-2;
    }
  }
}
const Vf = ["load", "loadend"];
class Uf extends Hf {
  constructor(e4, t2) {
    super(e4, t2);
    this._extra = new URLSearchParams(t2.extra).toString();
    if (!t2.extent) {
      this.setExtent(new Ye(new be(-180, -90), new be(180, 90)));
    }
    this.layers = t2.layers;
    this.imageWidth = t2.imageWidth || 256;
    this.imageHeight = t2.imageHeight || 256;
    this._getBbox = Uf.get_bbox_v1_1_1;
    this._version = "";
    this.setVersion(t2.version);
  }
  static createRequestUrl(e4, t2, i2 = "image/png", s2 = "1.1.1", r2 = "GetMap", n2, o2, a2 = 256, l2 = 256, h2) {
    return `${e4}/?LAYERS=${t2}&FORMAT=${i2}&SERVICE=WMS&VERSION=${s2}&REQUEST=${r2}&SRS=${n2}&BBOX=${o2}&WIDTH=${a2}&HEIGHT=${l2}` + (h2 ? `&${h2}` : "");
  }
  static get_bbox_v1_1_1(e4) {
    return `${e4.getWest()},${e4.getSouth()},${e4.getEast()},${e4.getNorth()}`;
  }
  static get_bbox_v1_3_0(e4) {
    return `${e4.getSouth()},${e4.getWest()},${e4.getNorth()},${e4.getEast()}`;
  }
  _checkSegment(e4) {
    return true;
  }
  get instanceName() {
    return "WMS";
  }
  _createUrl(e4) {
    return Uf.createRequestUrl(this.url, this.layers, "image/png", this._version, "GetMap", e4._projection.code, this._getBbox(e4.getExtent()), this.imageWidth, this.imageHeight, this._extra);
  }
  setVersion(e4) {
    if (e4) {
      this._version = e4;
    } else {
      this._version = "1.1.1";
    }
    if (this._version === "1.1.1") {
      this._getBbox = Uf.get_bbox_v1_1_1;
    } else if (e4 === "1.3.0") {
      this._getBbox = Uf.get_bbox_v1_3_0;
    }
  }
  _correctFullExtent() {
    const e4 = this._extent;
    const t2 = this._extentMerc;
    const i2 = we + 5e4;
    const s2 = we + 5e4;
    if (e4.northEast.lat === 90) {
      t2.northEast.lat = s2;
    }
    if (e4.northEast.lon === 180) {
      t2.northEast.lon = i2;
    }
    if (e4.southWest.lat === -90) {
      t2.southWest.lat = -2008750834e-2;
    }
    if (e4.southWest.lon === -180) {
      t2.southWest.lon = -2008750834e-2;
    }
  }
}
class Gf extends Nf {
  constructor(e4 = {}) {
    super("BilTerrain", e4);
    this.equalizeVertices = true;
    this.equalizeNormals = true;
    this.minZoom = e4.minZoom || 2;
    this.maxZoom = e4.maxZoom || 14;
    this.noDataValues = e4.noDataValues || [-9999, 32767];
    this.url = e4.url || "";
    this._format = "application/bil16";
    this._layers = e4.layers || "";
    this._imageSize = e4.imageSize || 256;
    this.plainGridSize = e4.plainGridSize != void 0 ? e4.plainGridSize : j(this._imageSize) ? this._imageSize / 2 : Y(this._imageSize) / 2;
    this._dataType = "arrayBuffer";
  }
  isBlur(e4) {
    return e4.tileZoom >= 18;
  }
  _createUrl(e4) {
    return Uf.createRequestUrl(this.url, this._layers, this._format, "1.1.1", "GetMap", e4._projection.code, Uf.get_bbox_v1_1_1(e4.getExtent()), this._imageSize, this._imageSize);
  }
  _createHeights(e4, t2, i2, s2, r2, n2, o2, a2) {
    let l2 = new Int16Array(e4);
    if (!j(this._imageSize)) {
      let e5 = new Float32Array(l2.length);
      Wf(l2, e5);
      return e5;
    }
    let h2 = (this.plainGridSize + 1) * (this.plainGridSize + 1);
    let c2 = 4;
    let d2 = new Array(c2);
    for (let e5 = 0; e5 < c2; e5++) {
      d2[e5] = [];
      for (let t3 = 0; t3 < c2; t3++) {
        d2[e5][t3] = new Float32Array(h2);
      }
    }
    let u2 = new Float32Array(h2);
    jf(l2, this.noDataValues, u2, d2);
    let _2 = ks.getTileIndex(s2, r2, n2, i2);
    this.setElevationCache(_2, { heights: u2, extent: o2 });
    let f2 = this._imageSize / this.plainGridSize;
    for (let e5 = 0; e5 < f2; e5++) {
      for (let t3 = 0; t3 < f2; t3++) {
        let o3 = s2 * 2 + t3, a3 = r2 * 2 + e5, l3 = n2 + 1;
        let h3 = ks.getTileIndex(o3, a3, l3, i2);
        this.setElevationCache(h3, { heights: d2[e5][t3], extent: Ue(o3, a3, l3) });
      }
    }
    return u2;
  }
}
function Wf(e4, t2) {
  for (let i2 = 0, s2 = t2.length; i2 < s2; i2++) {
    t2[i2] = e4[i2];
  }
}
function jf(e4, t2, i2, s2) {
  let r2 = Math.sqrt(i2.length) - 1;
  let n2 = r2 + 1;
  let o2 = Math.sqrt(e4.length);
  let a2 = o2 / r2;
  let l2 = 0, h2 = 0;
  for (let c2 = 0, d2 = 0, u2 = e4.length; c2 < u2; c2++) {
    let u3 = e4[c2];
    let _2 = Gf.checkNoDataValue(t2, u3), f2 = false, g2 = false;
    let p2 = Math.floor(c2 / o2), m2 = c2 % o2;
    let v2 = Math.floor(m2 / r2), y2 = Math.floor(p2 / r2);
    let x2 = s2[y2][v2];
    let b2 = p2 % r2, w2 = m2 % r2;
    let C2 = (b2 + y2) * n2 + w2 + v2;
    x2[C2] = u3;
    if ((p2 + y2) % a2 === 0 && (m2 + v2) % a2 === 0) {
      i2[d2++] = u3;
    }
    if ((m2 + 1) % r2 === 0 && m2 !== o2 - 1) {
      l2 = e4[c2];
      f2 = Gf.checkNoDataValue(t2, l2);
      let o3 = u3;
      if (!(_2 || f2)) {
        o3 = (u3 + l2) * 0.5;
      }
      C2 = (b2 + y2) * n2 + w2 + 1;
      x2[C2] = o3;
      if ((p2 + y2) % a2 === 0) {
        i2[d2++] = o3;
      }
      let h3 = (b2 + y2) * n2 + (w2 + 1) % r2;
      s2[y2][v2 + 1][h3] = o3;
    }
    if ((p2 + 1) % r2 === 0 && p2 !== o2 - 1) {
      h2 = e4[c2 + o2];
      g2 = Gf.checkNoDataValue(t2, h2);
      let l3 = u3;
      if (!(_2 || g2)) {
        l3 = (u3 + h2) * 0.5;
      }
      C2 = (b2 + 1) * n2 + w2 + v2;
      x2[C2] = l3;
      if ((m2 + v2) % a2 === 0) {
        i2[d2++] = l3;
      }
      let f3 = (b2 + 1) % r2 * n2 + w2 + v2;
      s2[y2 + 1][v2][f3] = l3;
    }
    if ((m2 + 1) % r2 === 0 && m2 !== o2 - 1 && (p2 + 1) % r2 === 0 && p2 !== o2 - 1) {
      let a3 = e4[c2 + o2 + 1];
      let p3 = Gf.checkNoDataValue(t2, a3);
      let m3 = u3;
      if (!(_2 || f2 || g2 || p3)) {
        m3 = (u3 + l2 + h2 + a3) * 0.25;
      }
      C2 = (b2 + 1) * n2 + (w2 + 1);
      x2[C2] = m3;
      i2[d2++] = m3;
      let T2 = (b2 + 1) * n2;
      s2[y2][v2 + 1][T2] = m3;
      let E2 = r2;
      s2[y2 + 1][v2][E2] = m3;
      let A2 = 0;
      s2[y2 + 1][v2 + 1][A2] = m3;
    }
  }
}
class Yf extends Nf {
  constructor(e4, t2 = {}) {
    super(e4 || "RgbTerrain", { equalizeVertices: t2.equalizeVertices != void 0 ? t2.equalizeVertices : true, maxZoom: t2.maxZoom || 17, noDataValues: t2.noDataValues || [t2.minHeight != void 0 ? t2.minHeight : -1e4], plainGridSize: t2.plainGridSize || 128, url: t2.url != void 0 ? t2.url : `//api.mapbox.com/v4/mapbox.terrain-rgb/{z}/{x}/{y}.pngraw?access_token=${t2.key || "<key>"}`, gridSizeByZoom: t2.gridSizeByZoom || [64, 32, 16, 8, 8, 8, 16, 16, 16, 32, 32, 32, 32, 32, 32, 64, 64, 64, 32, 32, 16, 8], ...t2 });
    this.equalizeNormals = t2.equalizeNormals || false;
    this._dataType = "imageBitmap";
    this._imageSize = t2.imageSize || 256;
    this._ctx = this._createTemporalCanvas(this._imageSize);
    this._imageDataCache = {};
    this._minHeight = t2.minHeight || -1e4;
    this._resolution = t2.resolution || 0.1;
  }
  static checkNoDataValue(e4, t2) {
    if (t2 > 5e4) {
      return true;
    }
    return Lt(e4, t2) !== -1;
  }
  rgb2Height(e4, t2, i2) {
    if (e4 === 255) {
      return this._minHeight;
    }
    return this._minHeight + this._resolution * (e4 * 256 * 256 + t2 * 256 + i2);
  }
  isBlur(e4) {
    return e4.tileZoom >= 16;
  }
  _createTemporalCanvas(e4) {
    let t2 = document.createElement("canvas");
    t2.width = e4;
    t2.height = e4;
    return t2.getContext("2d", { willReadFrequently: true });
  }
  _createHeights(e4, t2, i2, s2, r2, n2, o2, a2) {
    this._ctx.clearRect(0, 0, this._imageSize, this._imageSize);
    this._ctx.drawImage(e4, 0, 0);
    let l2 = this._ctx.getImageData(0, 0, this._imageSize, this._imageSize).data;
    const h2 = e4.width;
    let c2 = 0, d2 = 0, u2 = 0, _2 = null, f2 = false;
    if (t2) {
      if (t2.tileZoom > this.maxNativeZoom) {
        let e5 = t2.node;
        while (e5 && !e5.segment.terrainExists) {
          e5 = e5.parentNode;
        }
        if (e5) {
          c2 = e5.segment.tileX;
          d2 = e5.segment.tileY;
          u2 = e5.segment.tileZoom;
          _2 = e5.segment.elevationData;
          f2 = u2 <= 8;
        }
      }
    }
    if (!j(this._imageSize) && h2 === this._imageSize) {
      let e5 = new Float32Array(h2 * h2);
      this.extractElevationTilesRgbNonPowerOfTwo(l2, e5, this._heightFactor);
      return e5;
    }
    if (this._imageSize === this.plainGridSize) {
      let e5 = (this.plainGridSize + 1) * (this.plainGridSize + 1);
      let i3 = new Float32Array(e5);
      let [s3, r3, n3] = t2 ? qf(t2.tileX, t2.tileY, t2.tileZoom, c2, d2, u2) : [0, 0, 0];
      this.extractElevationSimple(l2, this.noDataValues, _2, s3, r3, n3, f2, i3, this._heightFactor, this._imageSize);
      return i3;
    }
    let g2 = (this.plainGridSize + 1) * (this.plainGridSize + 1);
    let p2 = h2 / this.plainGridSize;
    let m2 = new Float32Array(g2);
    let v2 = new Array(p2);
    for (let e5 = 0; e5 < p2; e5++) {
      v2[e5] = [];
      for (let t3 = 0; t3 < p2; t3++) {
        v2[e5][t3] = new Float32Array(g2);
      }
    }
    if (!a2) {
      this.extractElevationTilesRgb(l2, this._heightFactor, this.noDataValues, _2, c2, d2, u2, t2 ? t2.tileX : 0, t2 ? t2.tileY : 0, t2 ? t2.tileZoom : 0, f2, m2, v2);
      for (let e5 = 0; e5 < p2; e5++) {
        for (let t3 = 0; t3 < p2; t3++) {
          let [o3, a3, l3] = $f(s2, r2, n2, t3, e5);
          let h3 = ks.getTileIndex(o3, a3, l3, i2);
          this.setElevationCache(h3, { heights: v2[e5][t3], extent: Ue(o3, a3, l3) });
        }
      }
    } else {
      this.extractElevationTilesRgbNoChildren(l2, this._heightFactor, this.noDataValues, _2, c2, d2, u2, t2 ? t2.tileX : 0, t2 ? t2.tileY : 0, t2 ? t2.tileZoom : 0, f2, m2);
    }
    let y2 = ks.getTileIndex(s2, r2, n2, i2);
    this.setElevationCache(y2, { heights: m2, extent: o2 });
    return m2;
  }
  getHeightAsync(e4, t2, i2) {
    i2 = i2 != void 0 ? i2 : this.maxZoom;
    if (i2 === 0) {
      t2(0);
      return true;
    }
    const s2 = this._planet.quadTreeStrategy;
    const [r2, n2, o2, a2] = s2.getTileXY(e4, i2);
    const [l2, h2] = s2.getLonLatTileOffset(e4, r2, n2, o2, this._imageSize);
    const c2 = (l2 * this._imageSize + h2) * 4;
    const d2 = ks.getTileIndex(r2, n2, o2, a2);
    if (this._imageDataCache[d2]) {
      let s3 = this._imageDataCache[d2];
      let r3 = this._heightFactor * this.rgb2Height(s3[c2], s3[c2 + 1], s3[c2 + 2]);
      let n3 = Yf.checkNoDataValue(this.noDataValues, r3);
      if (n3) {
        return this.getHeightAsync(e4, t2, i2 - 1);
      } else {
        t2(this._heightFactor * this.rgb2Height(s3[c2], s3[c2 + 1], s3[c2 + 2]));
        return true;
      }
    }
    let u2 = this._fetchCache[d2];
    if (!u2) {
      u2 = this._loader.fetch({ src: this._urlRewriteCallback && this._urlRewriteCallback(r2, n2, o2, a2) || this.buildURL(r2, n2, o2, a2), type: this._dataType });
      this._fetchCache[d2] = u2;
    }
    u2.then((s3) => {
      if (s3.status === "ready") {
        this._ctx.clearRect(0, 0, this._imageSize, this._imageSize);
        this._ctx.drawImage(s3.data, 0, 0);
        let r3 = this._ctx.getImageData(0, 0, 256, 256).data;
        this._imageDataCache[d2] = r3;
        let n3 = this._heightFactor * this.rgb2Height(r3[c2], r3[c2 + 1], r3[c2 + 2]);
        let o3 = Yf.checkNoDataValue(this.noDataValues, n3);
        if (o3) {
          return this.getHeightAsync(e4, t2, i2 - 1);
        } else {
          t2(this._heightFactor * this.rgb2Height(r3[c2], r3[c2 + 1], r3[c2 + 2]));
        }
      } else if (s3.status === "error") {
        return this.getHeightAsync(e4, t2, i2 - 1);
      } else {
        this._fetchCache[d2] = null;
        delete this._fetchCache[d2];
      }
    });
    return false;
  }
  extractElevationSimple(e4, t2, i2 = null, s2, r2, n2, o2, a2, l2 = 1, h2) {
    for (let c3 = 0, d3 = h2 * h2; c3 < d3; c3++) {
      let d4 = c3 % h2, u2 = Math.floor(c3 / h2);
      let _2 = c3 * 4;
      let f2 = l2 * this.rgb2Height(e4[_2], e4[_2 + 1], e4[_2 + 2]);
      let g2 = Yf.checkNoDataValue(t2, f2);
      if ((g2 || f2 === 0) && i2) {
        f2 = Xf(n2, s2, r2, i2, u2, d4, o2);
      }
      a2[u2 * (h2 + 1) + d4] = f2;
    }
    for (let c3 = 0, d3 = h2; c3 < d3; c3++) {
      let d4 = h2 - 1;
      let u2 = (c3 * h2 + d4) * 4;
      let _2 = l2 * this.rgb2Height(e4[u2], e4[u2 + 1], e4[u2 + 2]);
      let f2 = Yf.checkNoDataValue(t2, _2);
      if ((f2 || _2 === 0) && i2) {
        _2 = Xf(n2, s2, r2, i2, c3, d4, o2);
      }
      a2[c3 * (h2 + 1) + h2] = _2;
    }
    for (let c3 = 0, d3 = h2; c3 < d3; c3++) {
      let d4 = h2 - 1;
      let u2 = (d4 * h2 + c3) * 4;
      let _2 = l2 * this.rgb2Height(e4[u2], e4[u2 + 1], e4[u2 + 2]);
      let f2 = Yf.checkNoDataValue(t2, _2);
      if ((f2 || _2 === 0) && i2) {
        _2 = Xf(n2, s2, r2, i2, d4, c3, o2);
      }
      a2[h2 * (h2 + 1) + c3] = _2;
    }
    let c2 = l2 * this.rgb2Height(e4[e4.length - 4], e4[e4.length - 3], e4[e4.length - 2]);
    let d2 = Yf.checkNoDataValue(t2, c2);
    if ((d2 || c2 === 0) && i2) {
      c2 = Xf(n2, s2, r2, i2, h2 - 1, h2 - 1, o2);
    }
    a2[a2.length - 1] = c2;
  }
  extractElevationTilesRgbNonPowerOfTwo(e4, t2, i2 = 1) {
    for (let s2 = 0, r2 = t2.length; s2 < r2; s2++) {
      let r3 = s2 * 4;
      t2[s2] = i2 * this.rgb2Height(e4[r3], e4[r3 + 1], e4[r3 + 2]);
    }
  }
  extractElevationTilesRgb(e4, t2, i2, s2 = null, r2, n2, o2, a2, l2, h2, c2, d2, u2) {
    let _2 = Math.sqrt(d2.length) - 1;
    let f2 = _2 + 1;
    let g2 = Math.sqrt(e4.length / 4);
    let p2 = g2 / _2;
    let m2 = 0, v2 = 0, y2 = 0;
    let [x2, b2, w2] = qf(a2, l2, h2, r2, n2, o2);
    for (let r3 = 0, n3 = 0, o3 = e4.length / 4; r3 < o3; r3++) {
      let o4 = r3 * 4;
      let a3 = t2 * this.rgb2Height(e4[o4], e4[o4 + 1], e4[o4 + 2]);
      let l3 = Yf.checkNoDataValue(i2, a3), h3 = false, C2 = false;
      let T2 = Math.floor(r3 / g2), E2 = r3 % g2;
      if ((l3 || a3 === 0) && s2) {
        a3 = Xf(w2, x2, b2, s2, Math.floor(T2 / p2), Math.floor(E2 / p2), c2);
      }
      let A2 = Math.floor(E2 / _2), L2 = Math.floor(T2 / _2);
      let P2 = u2[L2][A2];
      let S2 = T2 % _2, R2 = E2 % _2;
      let M2 = (S2 + L2) * f2 + R2 + A2;
      P2[M2] = a3;
      if ((T2 + L2) % p2 === 0 && (E2 + A2) % p2 === 0) {
        d2[n3++] = a3;
      }
      if ((E2 + 1) % _2 === 0 && E2 !== g2 - 1) {
        m2 = t2 * this.rgb2Height(e4[o4 + 4], e4[o4 + 5], e4[o4 + 6]);
        h3 = Yf.checkNoDataValue(i2, m2);
        if ((h3 || m2 === 0) && s2) {
          m2 = Xf(w2, x2, b2, s2, Math.floor(T2 / p2), Math.floor((E2 + 1) / p2), c2);
        }
        let r4 = a3;
        if (!(l3 || h3)) {
          r4 = (a3 + m2) * 0.5;
        }
        M2 = (S2 + L2) * f2 + R2 + 1;
        P2[M2] = r4;
        if ((T2 + L2) % p2 === 0) {
          d2[n3++] = r4;
        }
        let g3 = (S2 + L2) * f2 + (R2 + 1) % _2;
        u2[L2][A2 + 1][g3] = r4;
      }
      if ((T2 + 1) % _2 === 0 && T2 !== g2 - 1) {
        y2 = g2 * 4;
        v2 = t2 * this.rgb2Height(e4[o4 + y2], e4[o4 + y2 + 1], e4[o4 + y2 + 2]);
        C2 = Yf.checkNoDataValue(i2, v2);
        if ((C2 || v2 === 0) && s2) {
          v2 = Xf(w2, x2, b2, s2, Math.floor((T2 + 1) / p2), Math.floor(E2 / p2), c2);
        }
        let r4 = (a3 + v2) * 0.5;
        if (!(l3 || C2)) {
          r4 = (a3 + v2) * 0.5;
        }
        M2 = (S2 + 1) * f2 + R2 + A2;
        P2[M2] = r4;
        if ((E2 + A2) % p2 === 0) {
          d2[n3++] = r4;
        }
        let h4 = (S2 + 1) % _2 * f2 + R2 + A2;
        u2[L2 + 1][A2][h4] = r4;
      }
      if ((E2 + 1) % _2 === 0 && E2 !== g2 - 1 && (T2 + 1) % _2 === 0 && T2 !== g2 - 1) {
        let r4 = t2 * this.rgb2Height(e4[o4 + y2 + 4], e4[o4 + y2 + 5], e4[o4 + y2 + 6]);
        let g3 = Yf.checkNoDataValue(i2, r4);
        if ((g3 || r4 === 0) && s2) {
          r4 = Xf(w2, x2, b2, s2, Math.floor((T2 + 1) / p2), Math.floor((E2 + 1) / p2), c2);
        }
        let B2 = a3;
        if (!(l3 || h3 || C2 || g3)) {
          B2 = (a3 + m2 + v2 + r4) * 0.25;
        }
        M2 = (S2 + 1) * f2 + (R2 + 1);
        P2[M2] = B2;
        d2[n3++] = B2;
        let k2 = (S2 + 1) * f2;
        u2[L2][A2 + 1][k2] = B2;
        let I2 = _2;
        u2[L2 + 1][A2][I2] = B2;
        let z2 = 0;
        u2[L2 + 1][A2 + 1][z2] = B2;
      }
    }
  }
  extractElevationTilesRgbNoChildren(e4, t2, i2, s2 = null, r2, n2, o2, a2, l2, h2, c2, d2) {
    let u2 = Math.sqrt(d2.length) - 1;
    let _2 = u2 + 1;
    let f2 = Math.sqrt(e4.length / 4);
    let g2 = f2 / u2;
    let p2 = 0, m2 = 0, v2 = 0;
    let [y2, x2, b2] = qf(a2, l2, h2, r2, n2, o2);
    for (let r3 = 0, n3 = 0, o3 = e4.length / 4; r3 < o3; r3++) {
      let o4 = r3 * 4;
      let a3 = t2 * this.rgb2Height(e4[o4], e4[o4 + 1], e4[o4 + 2]);
      let l3 = Yf.checkNoDataValue(i2, a3), h3 = false, w2 = false;
      let C2 = Math.floor(r3 / f2), T2 = r3 % f2;
      if ((l3 || a3 === 0) && s2) {
        a3 = Xf(b2, y2, x2, s2, Math.floor(n3 / _2), n3 % _2, c2);
      }
      let E2 = Math.floor(T2 / u2), A2 = Math.floor(C2 / u2);
      if ((C2 + A2) % g2 === 0 && (T2 + E2) % g2 === 0) {
        d2[n3++] = a3;
      }
      if ((T2 + 1) % u2 === 0 && T2 !== f2 - 1) {
        p2 = t2 * this.rgb2Height(e4[o4 + 4], e4[o4 + 5], e4[o4 + 6]);
        h3 = Yf.checkNoDataValue(i2, p2);
        if ((h3 || p2 === 0) && s2) {
          p2 = Xf(b2, y2, x2, s2, Math.floor(n3 / _2), n3 % _2, c2);
        }
        let r4 = a3;
        if (!(l3 || h3)) {
          r4 = (a3 + p2) * 0.5;
        }
        if ((C2 + A2) % g2 === 0) {
          d2[n3++] = r4;
        }
      }
      if ((C2 + 1) % u2 === 0 && C2 !== f2 - 1) {
        v2 = f2 * 4;
        m2 = t2 * this.rgb2Height(e4[o4 + v2], e4[o4 + v2 + 1], e4[o4 + v2 + 2]);
        w2 = Yf.checkNoDataValue(i2, m2);
        if ((w2 || m2 === 0) && s2) {
          m2 = Xf(b2, y2, x2, s2, Math.floor(n3 / _2), n3 % _2, c2);
        }
        let r4 = (a3 + m2) * 0.5;
        if (!(l3 || w2)) {
          r4 = (a3 + m2) * 0.5;
        }
        if ((T2 + E2) % g2 === 0) {
          d2[n3++] = r4;
        }
      }
      if ((T2 + 1) % u2 === 0 && T2 !== f2 - 1 && (C2 + 1) % u2 === 0 && C2 !== f2 - 1) {
        let r4 = t2 * this.rgb2Height(e4[o4 + v2 + 4], e4[o4 + v2 + 5], e4[o4 + v2 + 6]);
        let u3 = Yf.checkNoDataValue(i2, r4);
        if ((u3 || r4 === 0) && s2) {
          r4 = Xf(b2, y2, x2, s2, Math.floor(n3 / _2), n3 % _2, c2);
        }
        let f3 = a3;
        if (!(l3 || h3 || w2 || u3)) {
          f3 = (a3 + p2 + m2 + r4) * 0.25;
        }
        d2[n3++] = f3;
      }
    }
  }
}
function qf(e4, t2, i2, s2, r2, n2) {
  let o2 = 2 << i2 - n2 - 1;
  return [e4 - o2 * s2, t2 - o2 * r2, 1 / o2];
}
function $f(e4, t2, i2, s2, r2) {
  return [e4 * 2 + s2, t2 * 2 + r2, i2 + 1];
}
function Xf(e4, t2, i2, s2, r2, n2, o2) {
  let a2 = Math.sqrt(s2.length);
  let l2 = Math.floor(i2 * e4 * a2 + r2 * e4), h2 = Math.floor(t2 * e4 * a2 + n2 * e4);
  let c2 = s2[l2 * a2 + h2];
  return o2 ? c2 > 0 ? 0 : c2 : c2;
}
const Zf = { [E_]: "north", [A_]: "south" };
const Kf = (e4, t2, i2, s2) => {
  let r2 = Zf[s2];
  if (r2) return `https://terrain.openglobus.org/poles/${r2}/${i2}/${e4}/${t2}.png`;
};
class Qf extends Yf {
  constructor(e4, t2) {
    super(e4 || "GlobusEarthRgb", { maxNativeZoom: 6, maxZoom: 17, url: "https://{s}.terrain.openglobus.org/all/{z}/{x}/{y}.png", urlRewrite: Kf, ...t2 });
  }
  isReadyToLoad(e4) {
    return this._extent.overlaps(e4.getExtentLonLat());
  }
}
const Jf = Object.freeze(Object.defineProperty({ __proto__: null, BilTerrain: Gf, EmptyTerrain: Ff, GlobusRgbTerrain: Qf, GlobusTerrain: Nf, RgbTerrain: Yf }, Symbol.toStringTag, { value: "Module" }));
class eg extends Bl {
  constructor(e4, t2 = {}) {
    super(e4, t2);
    this._image = t2.image || null;
    this._src = t2.src || null;
    this._onLoad_ = null;
  }
  get instanceName() {
    return "GeoImage";
  }
  abortLoading() {
    if (this._image instanceof HTMLImageElement) {
      this._image.src = "";
    }
  }
  setSrc(e4) {
    this._planet && this._planet._geoImageCreator.remove(this);
    this._src = e4;
    this._sourceReady = false;
    this._sourceCreated = false;
    this._image = new Image();
    this._image.crossOrigin = "Anonymous";
    this._onLoad_ = this._onLoad.bind(this);
    this._image.addEventListener("load", this._onLoad_);
    this._image.src = e4;
  }
  setImage(e4) {
    this._planet && this._planet._geoImageCreator.remove(this);
    this._sourceCreated = false;
    this._sourceReady = false;
    this._image = e4;
    this._image.crossOrigin = "Anonymous";
    this._src = e4.src;
    if (Kt(this._image)) {
      this._applyImage(this._image);
    } else {
      this._onLoad_ = this._onLoad.bind(this);
      this._image.addEventListener("load", this._onLoad_);
    }
  }
  _createSourceTexture() {
    if (!this._sourceCreated && this._image) {
      this._sourceTexture = this._planet.renderer.handler.createTexture_l(this._image);
      this._sourceCreated = true;
    }
  }
  _onLoad(e4) {
    this._applyImage(this._image);
    if (this._image instanceof HTMLImageElement) {
      this._image.removeEventListener("load", this._onLoad_);
    }
    this._onLoad_ = null;
  }
  _applyImage(e4) {
    if (e4) {
      this._frameWidth = Y(e4.width * 2, 4096);
      this._frameHeight = Y(e4.height * 3, 4096);
      this._sourceReady = true;
      if (this._planet) {
        this._planet._geoImageCreator.add(this);
      }
    }
  }
  loadMaterial(e4) {
    e4.isLoading = true;
    this._creationProceeding = true;
    if (!this._sourceReady && this._src) {
      if (this._image) {
        if (this._image instanceof HTMLImageElement) {
          if (Kt(this._image)) {
            this._applyImage(this._image);
          } else {
            this._onLoad_ = this._onLoad.bind(this);
            this._image.addEventListener("load", this._onLoad_);
          }
        }
      } else {
        this._image = new Image();
        this._image.crossOrigin = "Anonymous";
        this._onLoad_ = this._onLoad.bind(this);
        this._image.addEventListener("load", this._onLoad_);
        this._image.src = this._src;
      }
    } else if (this._planet) {
      this._planet._geoImageCreator.add(this);
    }
  }
  abortMaterialLoading(e4) {
    if (this._image && this._image instanceof HTMLImageElement) {
      this._image.src = "";
    }
    this._creationProceeding = false;
    e4.isLoading = false;
    e4.isReady = false;
  }
}
class tg extends Bl {
  constructor(e4, t2 = {}) {
    super(e4, t2);
    this._sourceTexture = t2.texture || null;
    if (t2.texture) {
      this._sourceReady = true;
      this._sourceCreated = true;
    }
    this._frameWidth = t2.frameWidth != void 0 ? Y(t2.frameWidth) : 256;
    this._frameHeight = t2.frameHeight != void 0 ? Y(t2.frameHeight) : 256;
    this._animate = true;
  }
  get instanceName() {
    return "GeoTexture2d";
  }
  loadMaterial(e4) {
    this._planet._geoImageCreator.add(this);
  }
  bindTexture(e4) {
    this._sourceReady = true;
    this._sourceCreated = true;
    this._sourceTexture = e4;
  }
  setSize(e4, t2) {
    this._frameWidth = e4;
    this._frameHeight = t2;
    this._frameCreated = false;
  }
  abortMaterialLoading(e4) {
    this._creationProceeding = false;
    e4.isLoading = false;
    e4.isReady = false;
  }
}
class ig extends Bl {
  constructor(e4, t2 = {}) {
    super(e4, t2);
    this._animate = true;
    this._video = t2.videoElement || null;
    this._src = t2.src || null;
  }
  get instanceName() {
    return "GeoVideo";
  }
  setSrc(e4) {
    this._planet && this._planet._geoImageCreator.remove(this);
    this._src = e4;
    this._sourceReady = false;
  }
  setVideoElement(e4) {
    this._planet && this._planet._geoImageCreator.remove(this);
    this._video = e4;
    this._src = e4.src;
    this._sourceReady = false;
  }
  setVisibility(e4) {
    if (e4 != this._visibility) {
      super.setVisibility(e4);
      if (this._planet) {
        if (e4) {
          this._sourceReady && this._planet._geoImageCreator.add(this);
          this._video && this._video.play();
        } else {
          this._sourceReady && this._planet._geoImageCreator.remove(this);
          this._video && this._video.pause();
        }
      }
    }
  }
  _createSourceTexture() {
    let e4 = this._planet.renderer.handler.gl;
    if (this._sourceCreated) {
      e4.bindTexture(e4.TEXTURE_2D, this._sourceTexture);
      e4.texImage2D(e4.TEXTURE_2D, 0, e4.RGBA, e4.RGBA, e4.UNSIGNED_BYTE, this._video);
    } else {
      this._sourceTexture = this._planet.renderer.handler.createTexture_n_webgl1(this._video);
      this._sourceCreated = true;
    }
  }
  _onCanPlay(e4) {
    this._frameWidth = e4.videoWidth;
    this._frameHeight = e4.videoHeight;
    e4.width = e4.videoWidth;
    e4.height = e4.videoHeight;
    e4.play();
    this._sourceReady = true;
    this._planet._geoImageCreator.add(this);
  }
  _onError(e4) {
    let t2 = "unknown error";
    switch (e4.error.code) {
      case 1:
        t2 = "video loading aborted";
        break;
      case 2:
        t2 = "network loading error";
        break;
      case 3:
        t2 = "video decoding failed / corrupted data or unsupported codec";
        break;
      case 4:
        t2 = "video not supported";
        break;
    }
    console.warn(`Error: ${t2} error-code=${e4.error.code})`);
  }
  loadMaterial(e4) {
    e4.isLoading = true;
    this._creationProceeding = true;
    if (!this._sourceReady && this._src) {
      if (this._video) {
        if (this._video.readyState === this._video.HAVE_ENOUGH_DATA) {
          this._onCanPlay(this._video);
        } else if (this._video.src) {
          let e5 = this;
          this._video.addEventListener("canplay", function(t2) {
            e5._onCanPlay(this);
          });
        }
      } else {
        this._video = document.createElement("video");
        this._video.crossOrigin = "Anonymous";
        let e5 = this;
        this._video.addEventListener("canplay", function() {
          e5._onCanPlay(this);
        });
        this._video.addEventListener("error", function() {
          e5._onError(this);
        });
      }
      this._video.autoplay = true;
      this._video.loop = true;
      this._video.src = this._src;
      this._video.muted = true;
      this._video.setAttribute("playsinline", "true");
      this._video.setAttribute("webkit-playsinline", "true");
    } else {
      this._planet._geoImageCreator.add(this);
    }
  }
  abortMaterialLoading(e4) {
    this._video && (this._video.src = "");
    this._creationProceeding = false;
    e4.isLoading = false;
    e4.isReady = false;
  }
}
class sg extends Ma {
  constructor(e4, t2 = {}) {
    super(e4, t2);
    this._billboard = t2.billboard || { src: "https://openglobus.org/examples/billboards/carrot.png" };
    this._color = t2.color || "#6689db";
  }
  get instanceName() {
    return "KML";
  }
  _extractCoordonatesFromKml(e4) {
    const t2 = Array.from(e4.getElementsByTagName("coordinates"));
    const i2 = t2.map((e5) => e5.textContent.trim());
    const s2 = i2.map((e5) => e5.replace(/\n/g, " ").replace(/\t/g, " ").replace(/ +/g, " ").split(" ").map((e6) => e6.split(",").map(parseFloat)));
    return s2;
  }
  _AGBRtoRGBA(e4) {
    if (!e4 || e4.length != 8) return;
    const t2 = parseInt(e4.slice(0, 2), 16) / 255;
    const i2 = parseInt(e4.slice(2, 4), 16);
    const s2 = parseInt(e4.slice(4, 6), 16);
    const r2 = parseInt(e4.slice(6, 8), 16);
    return `rgba(${r2},${s2},${i2},${t2})`;
  }
  _parseKMLcoordinates(e4) {
    const t2 = e4.innerHTML.trim().replace(/\n/g, " ").replace(/\t/g, " ").replace(/ +/g, " ").split(" ").map((e5) => e5.split(",").map(parseFloat));
    return t2;
  }
  _kmlPlacemarkToEntity(e4, t2) {
    if (!e4) return;
    const i2 = Array.from(e4.getElementsByTagName("name"));
    const s2 = i2 && i2.length > 0 ? i2[0].innerHTML.trim() : "";
    const { iconHeading: r2, iconURL: n2, iconColor: o2, lineWidth: a2, lineColor: l2 } = this._extractStyle(e4);
    const h2 = [];
    for (const i3 of e4.getElementsByTagName("coordinates")) {
      const e5 = this._parseKMLcoordinates(i3) || [[0, 0, 0]];
      for (const i4 of e5) {
        const [e6, s3, r3] = i4;
        h2.push(new be(e6, s3, r3));
        if (e6 < t2.southWest.lon) t2.southWest.lon = e6;
        if (s3 < t2.southWest.lat) t2.southWest.lat = s3;
        if (e6 > t2.northEast.lon) t2.northEast.lon = e6;
        if (s3 > t2.northEast.lat) t2.northEast.lat = s3;
      }
    }
    if (h2.length === 1) {
      const e5 = r2 * 0.01745329;
      return new zr({ name: s2, lonlat: h2[0], billboard: { src: n2, size: [24, 24], color: o2, rotation: e5 }, properties: { color: o2, heading: r2 } });
    } else {
      return new zr({ polyline: { pathLonLat: [h2], thickness: a2, color: l2, isClosed: false } });
    }
  }
  _extractStyle(e4) {
    let t2;
    let i2;
    let s2;
    let r2;
    let n2;
    const o2 = e4.getElementsByTagName("Style")[0];
    if (o2) {
      let e5 = o2.getElementsByTagName("IconStyle")[0];
      if (e5) {
        let r3 = e5.getElementsByTagName("color")[0];
        if (r3) t2 = this._AGBRtoRGBA(r3.innerHTML.trim());
        let n3 = e5.getElementsByTagName("heading")[0];
        if (n3) {
          const e6 = parseFloat(n3.innerHTML.trim());
          if (e6 >= 0 && e6 <= 360) i2 = e6 % 360;
        }
        let o3 = e5.getElementsByTagName("Icon")[0];
        if (o3) {
          let e6 = o3.getElementsByTagName("href")[0];
          if (e6) {
            s2 = e6.innerHTML.trim();
          }
        }
      }
      let a2 = o2.getElementsByTagName("LineStyle")[0];
      if (a2) {
        let e6 = a2.getElementsByTagName("color")[0];
        if (e6) r2 = this._AGBRtoRGBA(e6.innerHTML.trim());
        let t3 = a2.getElementsByTagName("width")[0];
        if (t3 !== void 0) n2 = parseFloat(t3.innerHTML.trim());
      }
    }
    if (!t2) t2 = "#FFFFFF";
    if (!i2) i2 = 0;
    if (!s2) s2 = "https://openglobus.org/examples/billboards/carrot.png";
    if (!r2) r2 = "#FFFFFF";
    if (!n2) n2 = 1;
    return { iconHeading: i2, iconURL: s2, iconColor: t2, lineWidth: n2, lineColor: r2 };
  }
  _parseKML(e4, t2, i2) {
    if (!i2) i2 = [];
    if (e4.documentElement.nodeName !== "kml") return i2;
    for (const s2 of e4.getElementsByTagName("Placemark")) {
      const e5 = this._kmlPlacemarkToEntity(s2, t2);
      if (e5) i2.push(e5);
    }
    return i2;
  }
  _convertKMLintoEntities(e4) {
    const t2 = new Ye(new be(180, 90), new be(-180, -90));
    const i2 = this._parseKML(e4, t2);
    return { entities: i2, extent: t2 };
  }
  _convertCoordonatesIntoEntities(e4, t2, i2) {
    const s2 = new Ye(new be(180, 90), new be(-180, -90));
    const r2 = (e5) => {
      const t3 = e5[0], i3 = e5[1];
      if (t3 < s2.southWest.lon) s2.southWest.lon = t3;
      if (i3 < s2.southWest.lat) s2.southWest.lat = i3;
      if (t3 > s2.northEast.lon) s2.northEast.lon = t3;
      if (i3 > s2.northEast.lat) s2.northEast.lat = i3;
    };
    const n2 = [];
    e4.forEach((e5) => e5.forEach((e6) => n2.push(e6)));
    const o2 = n2.map((e5) => {
      if (e5.length === 1) {
        const t3 = e5[0];
        const s3 = new zr({ lonlat: t3, billboard: i2 });
        r2(t3);
        return s3;
      } else if (e5.length > 1) {
        const i3 = e5.map((e6) => {
          r2(e6);
          return new be(e6[0], e6[1], e6[2]);
        });
        const s3 = new zr({ polyline: { pathLonLat: [i3], thickness: 3, color: t2, isClosed: false } });
        return s3;
      }
    });
    return { entities: o2, extent: s2 };
  }
  _getXmlContent(e4) {
    return new Promise((t2) => {
      const i2 = new FileReader();
      i2.onload = async (e5) => t2(new DOMParser().parseFromString(e5.target.result, "text/xml"));
      i2.readAsText(e4);
    });
  }
  _expandExtents(e4, t2) {
    if (!e4) return t2;
    if (t2.southWest.lon < e4.southWest.lon) e4.southWest.lon = t2.southWest.lon;
    if (t2.southWest.lat < e4.southWest.lat) e4.southWest.lat = t2.southWest.lat;
    if (t2.northEast.lon > e4.northEast.lon) e4.northEast.lon = t2.northEast.lon;
    if (t2.northEast.lat > e4.northEast.lat) e4.northEast.lat = t2.northEast.lat;
    return e4;
  }
  async addKmlFromFiles(e4, t2, i2) {
    if (!Array.isArray(e4)) return null;
    const s2 = await Promise.all(e4.map(this._getXmlContent));
    const r2 = s2.map(this._extractCoordonatesFromKml);
    const { entities: n2, extent: o2 } = this._convertCoordonatesIntoEntities(r2, t2 || this._color, i2 || this._billboard);
    this._extent = this._expandExtents(this._extent, o2);
    n2.forEach(this.add.bind(this));
    return { entities: n2, extent: o2 };
  }
  setColor(e4) {
    this._color = e4;
    this._billboard.color = e4;
  }
  _getKmlFromUrl(e4) {
    return new Promise((t2, i2) => {
      const s2 = new XMLHttpRequest();
      s2.open("GET", e4, true);
      s2.responseType = "document";
      s2.overrideMimeType("text/xml");
      s2.onload = () => {
        if (s2.readyState === s2.DONE && s2.status === 200) {
          t2(s2.responseXML);
        } else {
          i2(new Error("no valid kml file"));
        }
      };
      s2.send();
    });
  }
  async addKmlFromUrl(e4, t2, i2) {
    const s2 = await this._getKmlFromUrl(e4);
    const { entities: r2, extent: n2 } = this._convertKMLintoEntities(s2);
    this._extent = this._expandExtents(this._extent, n2);
    r2.forEach(this.add.bind(this));
    return { entities: r2, extent: n2 };
  }
}
class rg extends Hf {
  constructor(e4, t2 = {}) {
    super(e4 || "OpenStreetMap", { iconSrc: "https://tile.openstreetmap.org/8/138/95.png", url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", attribution: "Data @ OpenStreetMap contributors, ODbL", isBaseLayer: true, maxNativeZoom: 19, defaultTextures: [{ color: "#AAD3DF" }, { color: "#F2EFE9" }], isSRGB: false, shininess: 18, specular: [63e-5, 55e-5, 32e-5], ambient: [0.2, 0.2, 0.3], diffuse: [0.9, 0.9, 0.7], ...t2 });
  }
}
function ng(e4, t2, i2) {
  var s2 = "";
  for (let o2 = i2; o2 > 0; o2--) {
    var r2 = 0;
    var n2 = 1 << o2 - 1;
    if ((e4 & n2) !== 0) r2++;
    if ((t2 & n2) !== 0) r2 += 2;
    s2 += r2.toString();
  }
  return s2;
}
class og extends Hf {
  constructor(e4, t2 = {}) {
    super(e4 || "Bing", { iconSrc: "https://ecn.t0.tiles.virtualearth.net/tiles/a120.jpeg?n=z&g=7146", subdomains: ["t0", "t1", "t2", "t3"], url: "https://ecn.{s}.tiles.virtualearth.net/tiles/a{quad}.jpeg?n=z&g=7146", isBaseLayer: true, textureFilter: "LINEAR", maxNativeZoom: 17, defaultTextures: [{ color: "#001522" }, { color: "#E4E6F3" }], attribution: `<div style="transform: scale(0.8); margin-top:-2px;"><a href="https://www.bing.com" target="_blank"><img style="position: relative; top: 2px;" title="Bing Imagery" src="https://sandcastle.cesium.com/CesiumUnminified/Assets/Images/bing_maps_credit.png"></a> © 2021 Microsoft Corporation</div>`, urlRewrite: (e5, t3) => ft(t3, { s: this._getSubdomain(), quad: ng(e5.tileX, e5.tileY, e5.tileZoom) }), specular: [63e-5, 55e-5, 32e-5], ambient: [0.35, 0.35, 0.35], diffuse: [1.5, 1.5, 1.5], shininess: 20, nightTextureCoefficient: 2.7, ...t2 });
  }
}
const ag = Object.freeze(Object.defineProperty({ __proto__: null, Bing: og, CanvasTiles: Ds, GeoImage: eg, GeoTexture2d: tg, GeoVideo: ig, KML: sg, LAYER_EVENTS: Is, Layer: ks, Material: Ms, OpenStreetMap: rg, Vector: Ma, WMS: Uf, XYZ: Hf }, Symbol.toStringTag, { value: "Module" }));
const lg = ["tick", "end", "start", "stop"];
const _hg = class _hg {
  constructor(e4 = {}) {
    this.__handler = null;
    this.active = true;
    this.__id = _hg.__counter__++;
    this.events = Qi(lg, this);
    this.name = e4.name || "";
    this.startDate = e4.startDate || 0;
    this.endDate = e4.endDate || 0;
    let t2 = e4.currentDate || Li(/* @__PURE__ */ new Date());
    if (e4.startDate && t2 < e4.startDate) {
      t2 = e4.startDate;
    }
    if (e4.endDate && t2 > e4.endDate) {
      t2 = e4.endDate;
    }
    this.currentDate = t2;
    this._multiplier = e4.multiplier !== void 0 ? e4.multiplier : 1;
    this._running = 1;
    this.deltaTicks = 0;
    this.active = true;
    this._intervalDelay = 0;
    this._intervalStart = 0;
    this._intervalCallback = null;
  }
  clearInterval() {
    this._intervalDelay = 0;
    this._intervalStart = 0;
    this._intervalCallback = null;
  }
  setInterval(e4, t2) {
    this._intervalStart = this.currentDate;
    this._intervalDelay = e4 * vi;
    this._intervalCallback = t2;
  }
  setDate(e4) {
    let t2 = Li(e4);
    if (this.startDate && t2 < this.startDate) {
      t2 = this.startDate;
    }
    if (this.endDate && t2 > this.endDate) {
      t2 = this.endDate;
    }
    this.currentDate = t2;
  }
  getDate() {
    return Mi(this.currentDate);
  }
  reset() {
    if (this.startDate) {
      this.currentDate = this.startDate;
    }
  }
  tick(e4) {
    let t2 = this._multiplier * this._running;
    this.deltaTicks = e4 * t2;
    if (this.active) {
      let e5 = ki(this.currentDate, this.deltaTicks);
      if (t2 > 0) {
        if (this.endDate && e5 > this.endDate) {
          this.currentDate = this.startDate;
          this.events.dispatch(this.events.end, this);
        } else {
          this.currentDate = e5;
        }
      } else {
        if (this.startDate && e5 < this.startDate) {
          this.currentDate = this.endDate;
          this.events.dispatch(this.events.end, this);
        } else {
          this.currentDate = e5;
        }
      }
      if (this._intervalCallback) {
        if (this.currentDate - this._intervalStart >= this._intervalDelay) {
          this._intervalStart = this.currentDate;
          this._intervalCallback(this);
        }
      }
      this.events.dispatch(this.events.tick, this);
    }
  }
  isEqual(e4) {
    return this.__id === e4.__id;
  }
  start() {
    if (this._running === 0) {
      this._running = 1;
      this.events.dispatch(this.events.start, this);
    }
  }
  get multiplier() {
    return this._multiplier;
  }
  set multiplier(e4) {
    this._multiplier = e4;
  }
  stop() {
    if (this._running === 1) {
      this._running = 0;
      this.events.dispatch(this.events.stop, this);
    }
  }
};
_hg.__counter__ = 0;
let hg = _hg;
class cg {
  constructor(e4, t2) {
    this._program = t2;
    this._handler = e4;
    this._activated = false;
  }
  initialize() {
    if (this._handler.gl) {
      this._program.createProgram(this._handler.gl);
    }
  }
  getProgram() {
    return this._program;
  }
  activate() {
    if (!this._activated) {
      this._handler.activeProgram.deactivate();
      this._handler.activeProgram = this;
      let e4 = this._program;
      this._activated = true;
      e4.enableAttribArrays();
      e4.use();
    }
    return this;
  }
  remove() {
    let e4 = this._handler.programs;
    if (e4[this._program.name]) {
      if (this._activated) {
        this.deactivate();
      }
      this._program.delete();
      delete e4[this._program.name];
    }
  }
  deactivate() {
    this._program.disableAttribArrays();
    this._activated = false;
  }
  isActive() {
    return this._activated;
  }
  set(e4) {
    this.activate();
    this._program.set(e4);
    return this;
  }
  drawIndexBuffer(e4, t2) {
    this._program.drawIndexBuffer(e4, t2);
    return this;
  }
  drawArrays(e4, t2) {
    this._program.drawArrays(e4, t2);
    return this;
  }
}
class dg {
  constructor() {
    this.next = null;
    this.prev = null;
    this.data = null;
  }
}
class ug {
  constructor(e4 = 256) {
    this._current = new dg();
    this._head = this._current;
    for (let t2 = 0; t2 < e4; t2++) {
      let e5 = new dg();
      e5.prev = this._current;
      this._current.next = e5;
      this._current = e5;
    }
    this._current = this._head;
  }
  current() {
    return this._current;
  }
  push(e4) {
    this._current = this._current.next;
    this._current.data = e4;
  }
  pop() {
    let e4 = this._current.data;
    this._current = this._current.prev;
    return e4;
  }
  popPrev() {
    this._current = this._current.prev;
    return this._current.data;
  }
}
const _g = ["", "WEBKIT_", "MOZ_"];
const fg = ["webgl2", "webgl"];
const gg = 2;
class pg {
  constructor(e4, t2 = {}) {
    this.framebufferStack = new ug();
    this._requestAnimationFrameId = 0;
    this.drawFrame = () => {
      let e5 = window.performance.now();
      let t3 = this.deltaTime;
      this.deltaTime = (e5 - this._lastAnimationFrameTime + this.prevDeltaTime) * 0.5;
      if (this.deltaTime > 3) {
        this.deltaTime = 3;
      } else if (this.deltaTime < 1) {
        this.deltaTime = 1;
      }
      this.prevDeltaTime = t3;
      this._lastAnimationFrameTime = e5;
      this.defaultClock.tick(this.deltaTime);
      for (let e6 = 0; e6 < this._clocks.length; e6++) {
        this._clocks[e6].tick(this.deltaTime);
      }
      let i2 = this.canvas;
      if (Math.floor(i2.clientWidth * this._params.pixelRatio) !== i2.width || Math.floor(i2.clientHeight * this._params.pixelRatio) !== i2.height) {
        if (i2.clientWidth === 0 || i2.clientHeight === 0) {
          this.stop();
        } else if (!document.hidden) {
          this.start();
          this.setSize(i2.clientWidth, i2.clientHeight);
        }
      }
      this._frameCallback();
    };
    this.events = Qi(["visibilitychange", "resize"]);
    this._throttledDrawFrame = this.drawFrame;
    this.defaultClock = new hg();
    this._clocks = [];
    this.prevDeltaTime = 0;
    this.deltaTime = 0;
    this.canvas = null;
    this.gl = null;
    this.programs = {};
    this.activeProgram = null;
    this._canvasSize = [0, 0];
    this._params = { anisotropy: t2.anisotropy || 4, width: t2.width || 256, height: t2.height || 256, pixelRatio: ei("og_dpi") || t2.pixelRatio || 1, extensions: t2.extensions || [], context: t2.context || {} };
    this.extensions = {};
    this._canvasTarget = e4;
    this._lastAnimationFrameTime = 0;
    this._initialized = false;
    this._frameCallback = function() {
    };
    this.transparentTexture = null;
    this.defaultTexture = null;
    this.framebufferStack = new ug();
    this.createTexture_n = this.createTexture_n_webgl2.bind(this);
    this.createTexture_l = this.createTexture_l_webgl2.bind(this);
    this.createTexture_mm = this.createTexture_mm_webgl2.bind(this);
    this.createTexture_a = this.createTexture_a_webgl2.bind(this);
    this.createTexture = { NEAREST: this.createTexture_n, LINEAR: this.createTexture_l, MIPMAP: this.createTexture_mm, ANISOTROPIC: this.createTexture_a };
    this.createTextureDefault = this.createTexture_n;
    this.ONCANVASRESIZE = null;
    this._createCanvas();
    if (t2.autoActivate || st(t2.autoActivate)) {
      this.initialize();
    }
  }
  set frameDelay(e4) {
    if (e4 === 0) {
      this._throttledDrawFrame = this.drawFrame;
    } else {
      this._throttledDrawFrame = Dt(this.drawFrame, e4);
    }
  }
  isInitialized() {
    return this._initialized;
  }
  _createCanvas() {
    if (this._canvasTarget) {
      if (this._canvasTarget instanceof HTMLElement) {
        this.canvas = this._canvasTarget;
      } else {
        this.canvas = document.getElementById(this._canvasTarget) || document.querySelector(this._canvasTarget);
      }
    } else {
      this.canvas = document.createElement("canvas");
      this.canvas.width = this._params.width;
      this.canvas.height = this._params.height;
    }
  }
  static getExtension(e4, t2) {
    if (!e4) return;
    let i2, s2;
    for (i2 in _g) {
      s2 = e4.getExtension(_g[i2] + t2);
      if (s2) {
        return s2;
      }
    }
  }
  static getContext(e4, t2) {
    let i2 = null;
    try {
      let s2 = new URLSearchParams(location.search);
      let r2 = s2.get("og_ver");
      if (r2) {
        i2 = e4.getContext(r2, t2);
        if (i2) {
          i2.type = r2;
        }
      } else {
        for (let s3 = 0; s3 < fg.length; s3++) {
          i2 = e4.getContext(fg[s3], t2);
          if (i2) {
            i2.type = fg[s3];
            break;
          }
        }
      }
    } catch (e5) {
      Or.logErr("exception during the GL context initialization");
    }
    if (!i2) {
      Or.logErr("could not initialise WebGL");
    }
    return i2;
  }
  setFrameCallback(e4) {
    e4 && (this._frameCallback = e4);
  }
  createEmptyTexture2DExt(e4 = 1, t2 = 1, i2 = "NEAREST", s2 = "RGBA", r2 = "RGBA", n2 = "UNSIGNED_BYTE", o2 = "CLAMP_TO_EDGE", a2 = 0) {
    let l2 = this.gl;
    let h2 = l2.createTexture();
    l2.bindTexture(l2.TEXTURE_2D, h2);
    l2.texImage2D(l2.TEXTURE_2D, a2, l2[s2.toUpperCase()], e4, t2, 0, l2[r2.toUpperCase()], l2[n2.toUpperCase()], null);
    l2.texParameteri(l2.TEXTURE_2D, l2.TEXTURE_MIN_FILTER, l2[i2.toUpperCase()]);
    l2.texParameteri(l2.TEXTURE_2D, l2.TEXTURE_MAG_FILTER, l2[i2.toUpperCase()]);
    l2.texParameteri(l2.TEXTURE_2D, l2.TEXTURE_WRAP_S, l2[o2.toUpperCase()]);
    l2.texParameteri(l2.TEXTURE_2D, l2.TEXTURE_WRAP_T, l2[o2.toUpperCase()]);
    l2.bindTexture(l2.TEXTURE_2D, null);
    return h2;
  }
  createEmptyTexture_n(e4, t2, i2, s2) {
    let r2 = this.gl;
    let n2 = r2.createTexture();
    r2.bindTexture(r2.TEXTURE_2D, n2);
    r2.texImage2D(r2.TEXTURE_2D, 0, i2 || r2.RGBA, e4, t2, 0, r2.RGBA, r2.UNSIGNED_BYTE, null);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MIN_FILTER, r2.NEAREST);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MAG_FILTER, r2.NEAREST);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_S, s2 || r2.CLAMP_TO_EDGE);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_T, s2 || r2.CLAMP_TO_EDGE);
    r2.bindTexture(r2.TEXTURE_2D, null);
    return n2;
  }
  createEmptyTexture_l(e4, t2, i2, s2) {
    let r2 = this.gl;
    let n2 = r2.createTexture();
    r2.bindTexture(r2.TEXTURE_2D, n2);
    r2.texImage2D(r2.TEXTURE_2D, 0, i2 || r2.RGBA, e4, t2, 0, r2.RGBA, r2.UNSIGNED_BYTE, null);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MAG_FILTER, r2.LINEAR);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MIN_FILTER, r2.LINEAR);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_S, s2 || r2.CLAMP_TO_EDGE);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_T, s2 || r2.CLAMP_TO_EDGE);
    r2.bindTexture(r2.TEXTURE_2D, null);
    return n2;
  }
  createTexture_n_webgl1(e4, t2, i2, s2 = null) {
    let r2 = this.gl;
    s2 = s2 || r2.createTexture();
    r2.bindTexture(r2.TEXTURE_2D, s2);
    r2.texImage2D(r2.TEXTURE_2D, 0, t2 || r2.RGBA, r2.RGBA, r2.UNSIGNED_BYTE, e4);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MIN_FILTER, r2.NEAREST);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MAG_FILTER, r2.NEAREST);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_S, i2 || r2.CLAMP_TO_EDGE);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_T, i2 || r2.CLAMP_TO_EDGE);
    r2.bindTexture(r2.TEXTURE_2D, null);
    return s2;
  }
  createTexture_l_webgl1(e4, t2, i2, s2 = null) {
    let r2 = this.gl;
    s2 = s2 || r2.createTexture();
    r2.bindTexture(r2.TEXTURE_2D, s2);
    r2.texImage2D(r2.TEXTURE_2D, 0, t2 || r2.RGBA, r2.RGBA, r2.UNSIGNED_BYTE, e4);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MAG_FILTER, r2.LINEAR);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MIN_FILTER, r2.LINEAR);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_S, i2 || r2.CLAMP_TO_EDGE);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_T, i2 || r2.CLAMP_TO_EDGE);
    r2.bindTexture(r2.TEXTURE_2D, null);
    return s2;
  }
  createTexture_mm_webgl1(e4, t2, i2, s2 = null) {
    let r2 = this.gl;
    s2 = s2 || r2.createTexture();
    r2.bindTexture(r2.TEXTURE_2D, s2);
    r2.texImage2D(r2.TEXTURE_2D, 0, t2 || r2.RGBA, r2.RGBA, r2.UNSIGNED_BYTE, e4);
    r2.generateMipmap(r2.TEXTURE_2D);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MIN_FILTER, r2.LINEAR_MIPMAP_LINEAR);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_S, i2 || r2.CLAMP_TO_EDGE);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_T, i2 || r2.CLAMP_TO_EDGE);
    r2.bindTexture(r2.TEXTURE_2D, null);
    return s2;
  }
  createTexture_a_webgl1(e4, t2, i2, s2 = null) {
    let r2 = this.gl;
    s2 = s2 || r2.createTexture();
    r2.bindTexture(r2.TEXTURE_2D, s2);
    r2.texImage2D(r2.TEXTURE_2D, 0, t2 || r2.RGBA, r2.RGBA, r2.UNSIGNED_BYTE, e4);
    r2.generateMipmap(r2.TEXTURE_2D);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MIN_FILTER, r2.LINEAR_MIPMAP_LINEAR);
    r2.texParameterf(r2.TEXTURE_2D, this.extensions.EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._params.anisotropy);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_S, i2 || r2.CLAMP_TO_EDGE);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_T, i2 || r2.CLAMP_TO_EDGE);
    r2.bindTexture(r2.TEXTURE_2D, null);
    return s2;
  }
  createTexture_n_webgl2(e4, t2, i2, s2 = null) {
    let r2 = this.gl;
    s2 = s2 || r2.createTexture();
    r2.bindTexture(r2.TEXTURE_2D, s2);
    r2.texStorage2D(r2.TEXTURE_2D, 1, t2 || r2.RGBA8, e4.width, e4.height);
    r2.texSubImage2D(r2.TEXTURE_2D, 0, 0, 0, e4.width, e4.height, r2.RGBA, r2.UNSIGNED_BYTE, e4);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MIN_FILTER, r2.NEAREST);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MAG_FILTER, r2.NEAREST);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_S, i2 || r2.CLAMP_TO_EDGE);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_T, i2 || r2.CLAMP_TO_EDGE);
    r2.bindTexture(r2.TEXTURE_2D, null);
    return s2;
  }
  createTexture_l_webgl2(e4, t2, i2, s2 = null) {
    let r2 = this.gl;
    s2 = s2 || r2.createTexture();
    r2.bindTexture(r2.TEXTURE_2D, s2);
    r2.texStorage2D(r2.TEXTURE_2D, 1, t2 || r2.RGBA8, e4.width, e4.height);
    r2.texSubImage2D(r2.TEXTURE_2D, 0, 0, 0, e4.width, e4.height, r2.RGBA, r2.UNSIGNED_BYTE, e4);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MAG_FILTER, r2.LINEAR);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MIN_FILTER, r2.LINEAR);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_S, i2 || r2.CLAMP_TO_EDGE);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_T, i2 || r2.CLAMP_TO_EDGE);
    r2.bindTexture(r2.TEXTURE_2D, null);
    return s2;
  }
  createTexture_mm_webgl2(e4, t2, i2, s2 = null) {
    let r2 = this.gl;
    s2 = s2 || r2.createTexture();
    r2.bindTexture(r2.TEXTURE_2D, s2);
    r2.texStorage2D(r2.TEXTURE_2D, gg, t2 || r2.RGBA8, e4.width, e4.height);
    r2.texSubImage2D(r2.TEXTURE_2D, 0, 0, 0, e4.width, e4.height, r2.RGBA, r2.UNSIGNED_BYTE, e4);
    r2.generateMipmap(r2.TEXTURE_2D);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MIN_FILTER, r2.LINEAR_MIPMAP_LINEAR);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_S, i2 || r2.CLAMP_TO_EDGE);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_T, i2 || r2.CLAMP_TO_EDGE);
    r2.bindTexture(r2.TEXTURE_2D, null);
    return s2;
  }
  createTexture_a_webgl2(e4, t2, i2, s2 = null) {
    let r2 = this.gl;
    s2 = s2 || r2.createTexture();
    r2.bindTexture(r2.TEXTURE_2D, s2);
    r2.texStorage2D(r2.TEXTURE_2D, gg, t2 || r2.RGBA8, e4.width, e4.height);
    r2.texSubImage2D(r2.TEXTURE_2D, 0, 0, 0, e4.width, e4.height, r2.RGBA, r2.UNSIGNED_BYTE, e4);
    r2.generateMipmap(r2.TEXTURE_2D);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MIN_FILTER, r2.LINEAR_MIPMAP_LINEAR);
    r2.texParameterf(r2.TEXTURE_2D, this.extensions.EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._params.anisotropy);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_S, i2 || r2.CLAMP_TO_EDGE);
    r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_T, i2 || r2.CLAMP_TO_EDGE);
    r2.bindTexture(r2.TEXTURE_2D, null);
    return s2;
  }
  loadCubeMapTexture(e4) {
    let t2 = this.gl;
    let i2 = t2.createTexture();
    t2.bindTexture(t2.TEXTURE_CUBE_MAP, i2);
    t2.texParameteri(t2.TEXTURE_CUBE_MAP, t2.TEXTURE_WRAP_S, t2.CLAMP_TO_EDGE);
    t2.texParameteri(t2.TEXTURE_CUBE_MAP, t2.TEXTURE_WRAP_T, t2.CLAMP_TO_EDGE);
    t2.texParameteri(t2.TEXTURE_CUBE_MAP, t2.TEXTURE_MIN_FILTER, t2.LINEAR);
    t2.texParameteri(t2.TEXTURE_CUBE_MAP, t2.TEXTURE_MAG_FILTER, t2.LINEAR);
    let s2 = [[e4.px, t2.TEXTURE_CUBE_MAP_POSITIVE_X], [e4.nx, t2.TEXTURE_CUBE_MAP_NEGATIVE_X], [e4.py, t2.TEXTURE_CUBE_MAP_POSITIVE_Y], [e4.ny, t2.TEXTURE_CUBE_MAP_NEGATIVE_Y], [e4.pz, t2.TEXTURE_CUBE_MAP_POSITIVE_Z], [e4.nz, t2.TEXTURE_CUBE_MAP_NEGATIVE_Z]];
    let r2 = new h_();
    r2.fillEmpty();
    let n2 = r2.getImage();
    for (let e5 = 0; e5 < s2.length; e5++) {
      let r3 = s2[e5][1];
      t2.bindTexture(t2.TEXTURE_CUBE_MAP, i2);
      t2.texImage2D(r3, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, n2);
    }
    for (let e5 = 0; e5 < s2.length; e5++) {
      let r3 = s2[e5][1];
      let n3 = new Image();
      n3.crossOrigin = "";
      n3.onload = /* @__PURE__ */ function(e6, i3, s3) {
        return function() {
          if (t2 && e6) {
            t2.bindTexture(t2.TEXTURE_CUBE_MAP, e6);
            t2.texImage2D(i3, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, s3);
          }
        };
      }(i2, r3, n3);
      n3.src = s2[e5][0];
    }
    return i2;
  }
  addProgram(e4, t2 = false) {
    if (!this.programs[e4.name]) {
      let i2 = new cg(this, e4);
      this.programs[e4.name] = i2;
      this._initProgramController(i2);
      if (t2) {
        i2._activated = false;
      }
    } else {
      console.warn(`Shader program: "${e4.name}" already exists.`);
    }
    return e4;
  }
  removeProgram(e4) {
    this.programs[e4] && this.programs[e4].remove();
  }
  addPrograms(e4) {
    for (let t2 = 0; t2 < e4.length; t2++) {
      this.addProgram(e4[t2]);
    }
  }
  _initProgramController(e4) {
    if (this._initialized) {
      e4.initialize();
      if (!this.activeProgram) {
        this.activeProgram = e4;
        e4.activate();
      } else {
        e4.deactivate();
        this.activeProgram._program.enableAttribArrays();
        this.activeProgram._program.use();
      }
    }
  }
  _initPrograms() {
    for (let e4 in this.programs) {
      this._initProgramController(this.programs[e4]);
    }
  }
  initializeExtension(e4, t2 = false) {
    if (!(this.extensions && this.extensions[e4])) {
      let i2 = pg.getExtension(this.gl, e4);
      if (i2) {
        this.extensions[e4] = i2;
      } else if (t2) {
        console.warn("og.webgl.Handler: extension '" + e4 + "' doesn't initialize.");
      }
    }
    return this.extensions && this.extensions[e4];
  }
  initialize() {
    if (this._initialized) return;
    if (!this.canvas) return;
    this.gl = pg.getContext(this.canvas, this._params.context);
    if (!this.gl) return;
    this._initialized = true;
    this._params.extensions.push("EXT_texture_filter_anisotropic");
    if (this.gl.type === "webgl") {
      this._params.extensions.push("OES_standard_derivatives");
      this._params.extensions.push("OES_element_index_uint");
      this._params.extensions.push("WEBGL_depth_texture");
      this._params.extensions.push("ANGLE_instanced_arrays");
    } else {
      this._params.extensions.push("EXT_color_buffer_float");
      this._params.extensions.push("OES_texture_float_linear");
    }
    let e4 = this._params.extensions.length;
    while (e4--) {
      this.initializeExtension(this._params.extensions[e4], true);
    }
    if (this.gl.type === "webgl") {
      this.createTexture_n = this.createTexture_n_webgl1.bind(this);
      this.createTexture_l = this.createTexture_l_webgl1.bind(this);
      this.createTexture_mm = this.createTexture_mm_webgl1.bind(this);
      this.createTexture_a = this.createTexture_a_webgl1.bind(this);
    } else {
      this.createTexture_n = this.createTexture_n_webgl2.bind(this);
      this.createTexture_l = this.createTexture_l_webgl2.bind(this);
      this.createTexture_mm = this.createTexture_mm_webgl2.bind(this);
      this.createTexture_a = this.createTexture_a_webgl2.bind(this);
    }
    this.createTexture["NEAREST"] = this.createTexture_n;
    this.createTexture["LINEAR"] = this.createTexture_l;
    this.createTexture["MIPMAP"] = this.createTexture_mm;
    this.createTexture["ANISOTROPIC"] = this.createTexture_a;
    if (!this.extensions.EXT_texture_filter_anisotropic) {
      this.createTextureDefault = this.createTexture_mm;
    } else {
      this.createTextureDefault = this.createTexture_a;
    }
    this._initPrograms();
    this._setDefaults();
    this.intersectionObserver = new IntersectionObserver((e5) => {
      this._toggleVisibilityChange(e5[e5.length - 1].isIntersecting);
    }, { threshold: 0 });
    this.intersectionObserver.observe(this.canvas);
    this.resizeObserver = new ResizeObserver((e5) => {
      this._toggleVisibilityChange(e5[0].contentRect.width !== 0 && e5[0].contentRect.height !== 0);
    });
    this.resizeObserver.observe(this.canvas);
    document.addEventListener("visibilitychange", () => {
      this._toggleVisibilityChange(document.visibilityState === "visible");
    });
  }
  _toggleVisibilityChange(e4) {
    if (e4) {
      this.start();
      this.ONCANVASRESIZE && this.ONCANVASRESIZE();
      this.events.dispatch(this.events.visibilitychange, true);
    } else {
      this.events.dispatch(this.events.visibilitychange, false);
      this.stop();
    }
  }
  _setDefaults() {
    let e4 = this.gl;
    if (!e4) return;
    if (!this.canvas) return;
    e4.depthFunc(e4.LESS);
    e4.enable(e4.DEPTH_TEST);
    this.setSize(this.canvas.clientWidth || this._params.width, this.canvas.clientHeight || this._params.height);
    e4.frontFace(e4.CCW);
    e4.cullFace(e4.BACK);
    e4.enable(e4.CULL_FACE);
    e4.disable(e4.BLEND);
    this.createDefaultTexture({ color: "rgba(0,0,0,0.0)" }, (e5) => {
      this.transparentTexture = e5;
    });
    this.createDefaultTexture({ color: "rgba(255, 255, 255, 1.0)" }, (e5) => {
      this.defaultTexture = e5;
    });
  }
  getCanvasSize() {
    return this._canvasSize;
  }
  createStreamArrayBuffer(e4, t2, i2, s2 = 4) {
    let r2 = this.gl;
    let n2 = r2.createBuffer();
    r2.bindBuffer(r2.ARRAY_BUFFER, n2);
    r2.bufferData(r2.ARRAY_BUFFER, t2 * e4 * s2, i2 || r2.STREAM_DRAW);
    r2.bindBuffer(r2.ARRAY_BUFFER, null);
    n2.itemSize = e4;
    n2.numItems = t2;
    return n2;
  }
  setStreamArrayBuffer(e4, t2, i2 = 0) {
    let s2 = this.gl;
    s2.bindBuffer(s2.ARRAY_BUFFER, e4);
    s2.bufferSubData(s2.ARRAY_BUFFER, i2, t2);
    s2.bindBuffer(s2.ARRAY_BUFFER, null);
    return e4;
  }
  createArrayBuffer(e4, t2, i2, s2) {
    let r2 = this.gl;
    let n2 = r2.createBuffer();
    r2.bindBuffer(r2.ARRAY_BUFFER, n2);
    r2.bufferData(r2.ARRAY_BUFFER, e4, s2 || r2.STATIC_DRAW);
    r2.bindBuffer(r2.ARRAY_BUFFER, null);
    n2.itemSize = t2;
    n2.numItems = i2;
    return n2;
  }
  createArrayBufferLength(e4, t2) {
    let i2 = this.gl;
    let s2 = i2.createBuffer();
    i2.bindBuffer(i2.ARRAY_BUFFER, s2);
    i2.bufferData(i2.ARRAY_BUFFER, e4, t2 || i2.STATIC_DRAW);
    i2.bindBuffer(i2.ARRAY_BUFFER, null);
    s2.itemSize = 1;
    s2.numItems = e4;
    return s2;
  }
  createElementArrayBuffer(e4, t2, i2, s2) {
    let r2 = this.gl;
    let n2 = r2.createBuffer();
    r2.bindBuffer(r2.ELEMENT_ARRAY_BUFFER, n2);
    r2.bufferData(r2.ELEMENT_ARRAY_BUFFER, e4, s2 || r2.STATIC_DRAW);
    r2.bindBuffer(r2.ELEMENT_ARRAY_BUFFER, null);
    n2.itemSize = t2;
    n2.numItems = i2 || e4.length;
    return n2;
  }
  setSize(e4, t2) {
    this._params.width = e4;
    this._params.height = t2;
    if (this.canvas) {
      this.canvas.width = e4 * this._params.pixelRatio;
      this.canvas.height = t2 * this._params.pixelRatio;
      this._canvasSize[0] = this.canvas.width;
      this._canvasSize[1] = this.canvas.height;
      this.gl && this.gl.viewport(0, 0, e4, t2);
      this.ONCANVASRESIZE && this.ONCANVASRESIZE(this.canvas);
      this.events.dispatch(this.events.resize, this);
    }
  }
  get pixelRatio() {
    return this._params.pixelRatio;
  }
  set pixelRatio(e4) {
    this._params.pixelRatio = e4;
    this.setSize(this._params.width, this._params.height);
  }
  getWidth() {
    return this.canvas ? this.canvas.width : 0;
  }
  getHeight() {
    return this.canvas ? this.canvas.height : 0;
  }
  getClientAspect() {
    return this.canvas ? this.canvas.clientWidth / this.canvas.clientHeight : 0;
  }
  getCenter() {
    let e4 = this.canvas;
    return e4 ? new Qe(Math.round(e4.width * 0.5), Math.round(e4.height * 0.5)) : new Qe();
  }
  clearFrame() {
    let e4 = this.gl;
    e4.clearColor(0, 0, 0, 1);
    e4.clear(e4.COLOR_BUFFER_BIT | e4.DEPTH_BUFFER_BIT);
  }
  start() {
    if (!this._requestAnimationFrameId && this._initialized) {
      this._animationFrameCallback();
    }
  }
  stop() {
    if (this._requestAnimationFrameId) {
      window.cancelAnimationFrame(this._requestAnimationFrameId);
      this._requestAnimationFrameId = 0;
    }
  }
  isStopped() {
    return !this._requestAnimationFrameId;
  }
  isWebGl2() {
    return this.gl ? this.gl.type === "webgl2" : false;
  }
  _animationFrameCallback() {
    this._requestAnimationFrameId = window.requestAnimationFrame(() => {
      this._throttledDrawFrame();
      this._requestAnimationFrameId && this._animationFrameCallback();
    });
  }
  createDefaultTexture(e4, t2) {
    let i2;
    let s2;
    if (e4 && e4.color) {
      i2 = new h_(2, 2);
      i2.fillColor(e4.color);
      s2 = this.createTexture_n(i2.getCanvas());
      s2.default = true;
      t2(s2);
    } else if (e4 && e4.url) {
      let i3 = new Image();
      let r2 = this;
      i3.onload = function() {
        s2 = r2.createTextureDefault(i3);
        s2.default = true;
        t2(s2);
      };
      i3.src = e4.url;
    } else {
      i2 = new h_(2, 2);
      i2.fillColor("#C5C5C5");
      s2 = this.createTexture_n(i2.getCanvas());
      s2.default = true;
      t2(s2);
    }
  }
  deleteTexture(e4) {
    if (e4 && !e4.default) {
      this.gl.deleteTexture(e4);
    }
  }
  destroy() {
    var _a2, _b;
    (_a2 = this.resizeObserver) == null ? void 0 : _a2.disconnect();
    (_b = this.intersectionObserver) == null ? void 0 : _b.disconnect();
    this.stop();
    for (let e5 in this.programs) {
      this.removeProgram(e5);
    }
    let e4 = this.gl;
    if (e4) {
      e4.deleteTexture(this.transparentTexture);
      this.transparentTexture = null;
      e4.deleteTexture(this.defaultTexture);
      this.defaultTexture = null;
      this.framebufferStack = new ug();
      let t2 = e4.getParameter(e4.MAX_VERTEX_ATTRIBS);
      let i2 = e4.createBuffer();
      e4.bindBuffer(e4.ARRAY_BUFFER, i2);
      for (let i3 = 0; i3 < t2; ++i3) {
        e4.disableVertexAttribArray(i3);
        e4.vertexAttribPointer(i3, 4, e4.FLOAT, false, 0, 0);
        e4.vertexAttrib1f(i3, 0);
      }
      e4.deleteBuffer(i2);
      let s2 = e4.getParameter(e4.MAX_TEXTURE_IMAGE_UNITS);
      for (let t3 = 0; t3 < s2; ++t3) {
        e4.activeTexture(e4.TEXTURE0 + t3);
        e4.bindTexture(e4.TEXTURE_CUBE_MAP, null);
        e4.bindTexture(e4.TEXTURE_2D, null);
      }
      e4.activeTexture(e4.TEXTURE0);
      e4.useProgram(null);
      e4.bindBuffer(e4.ARRAY_BUFFER, null);
      e4.bindBuffer(e4.ELEMENT_ARRAY_BUFFER, null);
      e4.bindFramebuffer(e4.FRAMEBUFFER, null);
      e4.bindRenderbuffer(e4.RENDERBUFFER, null);
      e4.disable(e4.BLEND);
      e4.disable(e4.CULL_FACE);
      e4.disable(e4.DEPTH_TEST);
      e4.disable(e4.DITHER);
      e4.disable(e4.SCISSOR_TEST);
      e4.blendColor(0, 0, 0, 0);
      e4.blendEquation(e4.FUNC_ADD);
      e4.blendFunc(e4.ONE, e4.ZERO);
      e4.clearColor(0, 0, 0, 0);
      e4.clearDepth(1);
      e4.clearStencil(-1);
    }
    if (this.canvas) {
      if (this.canvas.parentNode) {
        this.canvas.parentNode.removeChild(this.canvas);
      }
      this.canvas.width = 1;
      this.canvas.height = 1;
      this.canvas = null;
    }
    this.gl = null;
    this._initialized = false;
  }
  addClock(e4) {
    if (!e4.__handler) {
      e4.__handler = this;
      this._clocks.push(e4);
    }
  }
  addClocks(e4) {
    for (let t2 = 0; t2 < e4.length; t2++) {
      this.addClock(e4[t2]);
    }
  }
  removeClock(e4) {
    if (e4.__handler) {
      let t2 = this._clocks;
      let i2 = t2.length;
      while (i2--) {
        if (t2[i2].isEqual(e4)) {
          e4.__handler = null;
          t2.splice(i2, 1);
          break;
        }
      }
    }
  }
}
class mg extends l_ {
  constructor(e4, t2 = {}) {
    super(e4, t2);
    this._internalFormat = t2.internalFormat ? t2.internalFormat.toUpperCase() : "RGBA8";
    this._msaa = t2.msaa != void 0 ? t2.msaa : 4;
    this._glFilter = 0;
    this.renderbuffers = new Array(this._size);
  }
  destroy() {
    let e4 = this.handler.gl;
    if (!e4) return;
    for (let t2 = 0; t2 < this.renderbuffers.length; t2++) {
      e4.deleteRenderbuffer(this.renderbuffers[t2]);
    }
    this.renderbuffers = new Array(this._size);
    e4.deleteFramebuffer(this._fbo);
    e4.deleteRenderbuffer(this._depthRenderbuffer);
    this._depthRenderbuffer = null;
    this._fbo = null;
    this._active = false;
  }
  init() {
    let e4 = this.handler.gl;
    if (!e4) return;
    this._glFilter = e4[this._filter];
    this._fbo = e4.createFramebuffer();
    e4.bindFramebuffer(e4.FRAMEBUFFER, this._fbo);
    let t2 = [];
    for (let i2 = 0; i2 < this.renderbuffers.length; i2++) {
      let s2 = e4.createRenderbuffer();
      e4.bindRenderbuffer(e4.RENDERBUFFER, s2);
      if (this._msaa > 0) {
        e4.renderbufferStorageMultisample(e4.RENDERBUFFER, this._msaa, e4[this._internalFormat], this._width, this._height);
      } else {
        e4.renderbufferStorage(e4.RENDERBUFFER, e4[this._internalFormat], this._width, this._height);
      }
      e4.framebufferRenderbuffer(e4.FRAMEBUFFER, e4.COLOR_ATTACHMENT0 + i2, e4.RENDERBUFFER, s2);
      t2.push(e4.COLOR_ATTACHMENT0 + i2);
      this.renderbuffers[i2] = s2;
      e4.bindRenderbuffer(e4.RENDERBUFFER, null);
    }
    e4.drawBuffers(t2);
    if (this._useDepth) {
      this._depthRenderbuffer = e4.createRenderbuffer();
      e4.bindRenderbuffer(e4.RENDERBUFFER, this._depthRenderbuffer);
      e4.renderbufferStorageMultisample(e4.RENDERBUFFER, this._msaa, e4[this._depthComponent], this._width, this._height);
      e4.framebufferRenderbuffer(e4.FRAMEBUFFER, e4.DEPTH_ATTACHMENT, e4.RENDERBUFFER, this._depthRenderbuffer);
      e4.bindRenderbuffer(e4.RENDERBUFFER, null);
    }
    e4.bindFramebuffer(e4.FRAMEBUFFER, null);
  }
  blitTo(e4, t2 = 0) {
    let i2 = this.handler.gl;
    i2.bindFramebuffer(i2.READ_FRAMEBUFFER, this._fbo);
    i2.bindFramebuffer(i2.DRAW_FRAMEBUFFER, e4._fbo);
    i2.readBuffer(i2.COLOR_ATTACHMENT0 + t2);
    i2.clearBufferfv(i2.COLOR, 0, [0, 0, 0, 1]);
    i2.blitFramebuffer(0, 0, this._width, this._height, 0, 0, e4._width, e4._height, i2.COLOR_BUFFER_BIT, this._glFilter);
    i2.bindFramebuffer(i2.FRAMEBUFFER, null);
    i2.bindFramebuffer(i2.READ_FRAMEBUFFER, null);
    i2.bindFramebuffer(i2.DRAW_FRAMEBUFFER, null);
  }
}
const vg = Object.freeze(Object.defineProperty({ __proto__: null, Framebuffer: u_, Handler: pg, Multisample: mg, Program: Yr, types: Vr }, Symbol.toStringTag, { value: "Module" }));
const yg = "_";
const xg = function(e4, t2) {
  return Number(e4.priority < t2.priority);
};
class bg {
  constructor() {
    this._currentlyPressedKeys = {};
    this._pressedKeysCallbacks = {};
    this._unpressedKeysCallbacks = {};
    this._charkeysCallbacks = {};
    this._anykeyCallback = null;
    this._event = null;
    this._active = true;
    this._stampCache = {};
    document.onkeydown = (e4) => {
      this._event = e4;
      this._active && this.handleKeyDown();
    };
    document.onkeyup = (e4) => {
      this._event = e4;
      this._active && this.handleKeyUp();
    };
  }
  getcurrentlyPressedKeys() {
    return this._currentlyPressedKeys;
  }
  getPressedKeysCallbacks() {
    return this._pressedKeysCallbacks;
  }
  getUnpressedKeysCallbacks() {
    return this._unpressedKeysCallbacks;
  }
  getCharkeysCallbacks() {
    return this._charkeysCallbacks;
  }
  removeEvent(e4, t2, i2) {
    let s2 = this._getStamp(e4, t2, i2._openglobus_id);
    if (i2._openglobus_id && this._stampCache[s2]) {
      delete this._stampCache[s2];
      if (e4 === "keypress") {
        this._removeCallback(this._pressedKeysCallbacks[t2], i2);
      } else if (e4 === "keyfree") {
        this._removeCallback(this._unpressedKeysCallbacks[t2], i2);
      } else if (e4 === "charkeypress") {
        this._removeCallback(this._charkeysCallbacks[t2], i2);
      }
    }
  }
  _removeCallback(e4, t2) {
    for (let i2 = 0; i2 < e4.length; i2++) {
      if (e4[i2].callback._openglobus_id === t2._openglobus_id) {
        e4.splice(i2, 1);
      }
    }
  }
  _getStamp(e4, t2, i2) {
    return `${e4}${yg}${t2}${yg}${i2}`;
  }
  _stamp(e4, t2, i2) {
    const s2 = at(i2);
    const r2 = this._getStamp(e4, t2, s2);
    if (!this._stampCache[r2]) {
      this._stampCache[r2] = s2;
      return true;
    }
    return false;
  }
  setActivity(e4) {
    this._active = e4;
  }
  releaseKeys() {
    this._currentlyPressedKeys = {};
  }
  addEvent(e4, t2, i2, s2, r2) {
    if (!this._stamp(e4, t2, i2)) return;
    if (r2 === void 0) {
      r2 = 1600;
    }
    switch (e4) {
      case "keyfree":
        if (!this._unpressedKeysCallbacks[t2]) {
          this._unpressedKeysCallbacks[t2] = [];
        }
        this._unpressedKeysCallbacks[t2].push({ callback: i2, sender: s2, priority: r2 });
        this._unpressedKeysCallbacks[t2].sort(xg);
        break;
      case "keypress":
        if (t2 == null) {
          this._anykeyCallback = { callback: i2, sender: s2 || this };
        } else {
          if (!this._pressedKeysCallbacks[t2]) {
            this._pressedKeysCallbacks[t2] = [];
          }
          this._pressedKeysCallbacks[t2].push({ callback: i2, sender: s2, priority: r2 });
          this._pressedKeysCallbacks[t2].sort(xg);
        }
        break;
      case "charkeypress":
        if (!this._charkeysCallbacks[t2]) {
          this._charkeysCallbacks[t2] = [];
        }
        this._charkeysCallbacks[t2].push({ callback: i2, sender: s2, priority: r2 });
        this._charkeysCallbacks[t2].sort(xg);
        break;
    }
  }
  isKeyPressed(e4) {
    return this._currentlyPressedKeys[e4];
  }
  handleKeyDown() {
    this._anykeyCallback && this._anykeyCallback.callback.call(this._anykeyCallback.sender, this._event);
    this._currentlyPressedKeys[this._event.keyCode] = true;
    for (let e4 in this._charkeysCallbacks) {
      if (String.fromCharCode(this._event.keyCode) === String.fromCharCode(Number(e4))) {
        let t2 = this._charkeysCallbacks[e4];
        for (let e5 = 0; e5 < t2.length; e5++) {
          t2[e5].callback.call(t2[e5].sender, this._event);
        }
      }
    }
    if (this._event.keyCode == zl.KEY_ALT || this._event.keyCode == zl.KEY_SHIFT) {
      this._event.preventDefault();
    }
  }
  handleKeyUp() {
    if (this._currentlyPressedKeys[this._event.keyCode] || this._event.keyCode === zl.KEY_PRINTSCREEN) {
      for (let e4 in this._unpressedKeysCallbacks) {
        if (this._currentlyPressedKeys[e4] || this._event.keyCode === zl.KEY_PRINTSCREEN && Number(e4) === zl.KEY_PRINTSCREEN) {
          let t2 = this._unpressedKeysCallbacks[e4];
          for (let e5 = 0; e5 < t2.length; e5++) {
            t2[e5].callback.call(t2[e5].sender, this._event);
          }
        }
      }
    }
    this._currentlyPressedKeys[this._event.keyCode] = false;
  }
  handleEvents() {
    for (let e4 in this._pressedKeysCallbacks) {
      if (this._currentlyPressedKeys[e4]) {
        let t2 = this._pressedKeysCallbacks[e4];
        for (let e5 = 0; e5 < t2.length; e5++) {
          t2[e5].callback.call(t2[e5].sender, this._event);
        }
      }
    }
  }
}
function wg(e4) {
  if (e4.deltaMode !== 0) {
    return false;
  }
  return Math.abs(e4.deltaY) < 50;
}
class Cg {
  constructor(e4) {
    this._htmlObject = e4;
  }
  setEvent(e4, t2, i2) {
    switch (e4) {
      case "mousewheel":
        this._htmlObject.addEventListener("wheel", (e5) => {
          let s2 = e5.deltaY || e5.detail || e5.wheelDelta || 0;
          if (e5.wheelDelta == void 0) {
            e5.wheelDelta = s2 * -120;
          }
          e5.isTouchPad = wg(e5);
          i2.call(t2, e5);
          e5.preventDefault();
        }, false);
        break;
      case "mousedown":
        this._htmlObject.addEventListener("mousedown", function(e5) {
          let s2 = this.getBoundingClientRect();
          i2.call(t2, e5, { button: e5.button, clientX: e5.clientX - s2.left, clientY: e5.clientY - s2.top });
        });
        this._htmlObject.addEventListener("contextmenu", function(e5) {
          e5.preventDefault();
          return false;
        });
        break;
      case "mouseup":
        this._htmlObject.addEventListener("mouseup", function(e5) {
          let s2 = this.getBoundingClientRect();
          i2.call(t2, e5, { button: e5.button, clientX: e5.clientX - s2.left, clientY: e5.clientY - s2.top });
        });
        break;
      case "mousemove":
        this._htmlObject.addEventListener("mousemove", function(e5) {
          let s2 = this.getBoundingClientRect();
          i2.call(t2, e5, { clientX: e5.clientX - s2.left, clientY: e5.clientY - s2.top });
        });
        break;
      case "mouseleave":
        this._htmlObject.addEventListener("mouseleave", function(e5) {
          i2.call(t2, e5);
        });
        break;
      case "mouseout":
        this._htmlObject.addEventListener("mouseout", function(e5) {
          i2.call(t2, e5);
        });
        break;
      case "mouseover":
        this._htmlObject.addEventListener("mouseover", function(e5) {
          i2.call(t2, e5);
        });
        break;
      case "mouseenter":
        this._htmlObject.addEventListener("mouseenter", function(e5) {
          i2.call(t2, e5);
        });
        break;
    }
  }
}
class Tg {
  constructor(e4) {
    this._htmlObject = e4;
  }
  setEvent(e4, t2, i2) {
    switch (e4) {
      case "touchcancel":
        this._htmlObject.addEventListener("touchcancel", function(e5) {
          e5.preventDefault();
          const s2 = this.getBoundingClientRect();
          const r2 = Object.assign(e5, { offsetLeft: s2.left, offsetTop: s2.top });
          i2.call(t2, r2);
        });
        break;
      case "touchstart":
        this._htmlObject.addEventListener("touchstart", function(e5) {
          e5.preventDefault();
          const s2 = this.getBoundingClientRect();
          const r2 = Object.assign(e5, { offsetLeft: s2.left, offsetTop: s2.top });
          i2.call(t2, r2);
        });
        break;
      case "touchend":
        this._htmlObject.addEventListener("touchend", function(e5) {
          e5.preventDefault();
          const s2 = this.getBoundingClientRect();
          const r2 = Object.assign(e5, { offsetLeft: s2.left, offsetTop: s2.top });
          i2.call(t2, r2);
        });
        break;
      case "touchmove":
        this._htmlObject.addEventListener("touchmove", function(e5) {
          e5.preventDefault();
          const s2 = this.getBoundingClientRect();
          const r2 = Object.assign(e5, { offsetLeft: s2.left, offsetTop: s2.top });
          i2.call(t2, r2);
        });
        break;
    }
  }
}
function Eg(e4) {
  return new Ig(e4);
}
const Ag = 1;
const Lg = 2;
const Pg = 4;
const Sg = (e4) => !(e4[0] || e4[1] || e4[2]);
const Rg = (e4) => !!(e4[0] || e4[1] || e4[2]);
let Mg = new Uint8Array(4);
let Bg = new Uint8Array(4);
let kg = new Uint8Array(4);
class Ig extends Ji {
  constructor(e4) {
    super(zg);
    this.renderer = e4;
    this._touchHandler = new Tg(e4.handler.canvas);
    this._mouseHandler = new Cg(e4.handler.canvas);
    this._keyboardHandler = new bg();
    this._active = true;
    this.clickRadius = 15;
    this.mouseState = { clientX: 0, clientY: 0, pos: new Qe(), x: 0, y: 0, nx: 0, ny: 0, prev_x: 0, prev_y: 0, direction: new Ke(), leftButtonUp: false, rightButtonUp: false, middleButtonUp: false, leftButtonDown: false, rightButtonDown: false, middleButtonDown: false, leftButtonHold: false, rightButtonHold: false, middleButtonHold: false, leftButtonDoubleClick: false, rightButtonDoubleClick: false, middleButtonDoubleClick: false, leftButtonClick: false, rightButtonClick: false, middleButtonClick: false, moving: false, justStopped: false, doubleClickDelay: 500, clickDelay: 200, wheelDelta: 0, sys: null, pickingObject: null, renderer: e4, isTouchPad: false };
    this.touchState = { moving: false, touchEnd: false, touchStart: false, touchCancel: false, doubleTouch: false, doubleTouchDelay: 550, doubleTouchRadius: 10, clientX: 0, clientY: 0, pos: new Qe(), x: 0, y: 0, nx: 0, ny: 0, prev_x: 0, prev_y: 0, direction: new Ke(), sys: null, pickingObject: null, renderer: e4 };
    this._isMouseInside = true;
    this._entityPickingEventsActive = true;
    this._dblTchCoords = new Qe();
    this._oneTouchStart = false;
    this._dblTchBegins = 0;
    this._mousestopThread = null;
    this._ldblClkBegins = 0;
    this._rdblClkBegins = 0;
    this._mdblClkBegins = 0;
    this._lClkBegins = 0;
    this._rClkBegins = 0;
    this._mClkBegins = 0;
    this._lclickX = 0;
    this._lclickY = 0;
    this._rclickX = 0;
    this._rclickY = 0;
    this._mclickX = 0;
    this._mclickY = 0;
  }
  pointerEvent() {
    let e4 = this.mouseState, t2 = this.touchState;
    return e4.moving || e4.justStopped || t2.moving || t2.touchStart || t2.touchEnd || e4.wheelDelta !== 0;
  }
  get active() {
    return this._active;
  }
  set active(e4) {
    this._active = e4;
    this._keyboardHandler.setActivity(e4);
  }
  handleEvents() {
    if (this._active) {
      this.mouseState.direction = this.renderer.activeCamera.unproject(this.mouseState.x, this.mouseState.y);
      this.touchState.direction = this.renderer.activeCamera.unproject(this.touchState.x, this.touchState.y);
      this._keyboardHandler.handleEvents();
      this.handleMouseEvents();
      this.handleTouchEvents();
      this.entityPickingEvents();
    }
  }
  on(e4, t2, i2, s2, r2) {
    if (e4 === "keypress" || e4 === "charkeypress" || e4 === "keyfree") {
      this._keyboardHandler.addEvent(e4, t2, i2, s2, r2);
    } else {
      super.on(e4, t2, i2, s2);
    }
  }
  off(e4, t2, i2) {
    if (e4 === "keypress" || e4 === "charkeypress" || e4 === "keyfree") {
      this._keyboardHandler.removeEvent(e4, t2, i2);
    } else {
      super.off(e4, t2);
    }
  }
  isKeyPressed(e4) {
    return this._keyboardHandler.isKeyPressed(e4);
  }
  releaseKeys() {
    this._keyboardHandler.releaseKeys();
  }
  initialize() {
    this._mouseHandler.setEvent("mouseup", this, this.onMouseUp);
    this._mouseHandler.setEvent("mousemove", this, this.onMouseMove);
    this._mouseHandler.setEvent("mousedown", this, this.onMouseDown);
    this._mouseHandler.setEvent("mousewheel", this, this.onMouseWheel);
    this._mouseHandler.setEvent("mouseleave", this, this.onMouseLeave);
    this._mouseHandler.setEvent("mouseenter", this, this.onMouseEnter);
    this._touchHandler.setEvent("touchstart", this, this.onTouchStart);
    this._touchHandler.setEvent("touchend", this, this.onTouchEnd);
    this._touchHandler.setEvent("touchcancel", this, this.onTouchCancel);
    this._touchHandler.setEvent("touchmove", this, this.onTouchMove);
  }
  onMouseWheel(e4) {
    this.mouseState.isTouchPad = e4.isTouchPad || false;
    this.mouseState.sys = e4;
    this.mouseState.wheelDelta = e4.wheelDelta || 0;
  }
  updateButtonsStates(e4) {
    let t2 = this.mouseState;
    if (e4 & Ag && t2.leftButtonDown) {
      t2.leftButtonDown = true;
    } else {
      t2.leftButtonHold = false;
      t2.leftButtonDown = false;
    }
    if (e4 & Lg && t2.rightButtonDown) {
      t2.rightButtonDown = true;
    } else {
      t2.rightButtonHold = false;
      t2.rightButtonDown = false;
    }
    if (e4 & Pg && t2.middleButtonDown) {
      t2.middleButtonDown = true;
    } else {
      t2.middleButtonHold = false;
      t2.middleButtonDown = false;
    }
  }
  onMouseMove(e4, t2) {
    let i2 = this.mouseState;
    this.updateButtonsStates(e4.buttons);
    i2.sys = e4;
    let s2 = t2.clientX, r2 = t2.clientY, n2 = this.clickRadius;
    if (Math.abs(this._lclickX - s2) >= n2 && Math.abs(this._lclickY - r2) >= n2) {
      this._ldblClkBegins = 0;
      this._lClkBegins = 0;
    }
    if (Math.abs(this._rclickX - s2) >= n2 && Math.abs(this._rclickY - r2) >= n2) {
      this._rdblClkBegins = 0;
      this._rClkBegins = 0;
    }
    if (Math.abs(this._mclickX - s2) >= n2 && Math.abs(this._mclickY - r2) >= n2) {
      this._mdblClkBegins = 0;
      this._mClkBegins = 0;
    }
    if (i2.clientX === t2.clientX && i2.clientY === t2.clientY) {
      return;
    }
    i2.clientX = t2.clientX;
    i2.clientY = t2.clientY;
    let o2 = this.renderer.handler;
    i2.pos.x = i2.x = t2.clientX * o2.pixelRatio;
    i2.pos.y = i2.y = t2.clientY * o2.pixelRatio;
    i2.nx = i2.x / o2.canvas.width;
    i2.ny = i2.y / o2.canvas.height;
    i2.moving = true;
    clearTimeout(this._mousestopThread);
    this._mousestopThread = setTimeout(function() {
      i2.justStopped = true;
    }, 100);
  }
  onMouseLeave(e4) {
    this._isMouseInside = false;
    this.mouseState.sys = e4;
    this.dispatch(this.mouseleave, this.mouseState);
  }
  onMouseEnter(e4) {
    this._isMouseInside = true;
    this.mouseState.sys = e4;
    this.dispatch(this.mouseenter, this.mouseState);
  }
  onMouseDown(e4, t2) {
    if (t2.button === zl.MB_LEFT) {
      this._lClkBegins = window.performance.now();
      this._lclickX = t2.clientX;
      this._lclickY = t2.clientY;
      this.mouseState.sys = e4;
      this.mouseState.leftButtonDown = true;
    } else if (t2.button === zl.MB_RIGHT) {
      this._rClkBegins = window.performance.now();
      this._rclickX = t2.clientX;
      this._rclickY = t2.clientY;
      this.mouseState.sys = e4;
      this.mouseState.rightButtonDown = true;
    } else if (t2.button === zl.MB_MIDDLE) {
      this._mClkBegins = window.performance.now();
      this._mclickX = t2.clientX;
      this._mclickY = t2.clientY;
      this.mouseState.sys = e4;
      this.mouseState.middleButtonDown = true;
    }
  }
  onMouseUp(e4, t2) {
    let i2 = this.mouseState;
    i2.sys = e4;
    let s2 = window.performance.now();
    if (t2.button === zl.MB_LEFT) {
      i2.leftButtonDown = false;
      i2.leftButtonUp = true;
      if (Math.abs(this._lclickX - t2.clientX) < this.clickRadius && Math.abs(this._lclickY - t2.clientY) < this.clickRadius && s2 - this._lClkBegins <= i2.clickDelay) {
        if (this._ldblClkBegins) {
          let e5 = window.performance.now() - this._ldblClkBegins;
          if (e5 <= i2.doubleClickDelay) {
            i2.leftButtonDoubleClick = true;
          }
          this._ldblClkBegins = 0;
        } else {
          this._ldblClkBegins = window.performance.now();
        }
        i2.leftButtonClick = true;
        this._lClkBegins = 0;
      }
    } else if (t2.button === zl.MB_RIGHT) {
      i2.rightButtonDown = false;
      i2.rightButtonUp = true;
      if (Math.abs(this._rclickX - t2.clientX) < this.clickRadius && Math.abs(this._rclickY - t2.clientY) < this.clickRadius && s2 - this._rClkBegins <= i2.clickDelay) {
        if (this._rdblClkBegins) {
          let e5 = window.performance.now() - this._rdblClkBegins;
          if (e5 <= i2.doubleClickDelay) {
            i2.rightButtonDoubleClick = true;
          }
          this._rdblClkBegins = 0;
        } else {
          this._rdblClkBegins = window.performance.now();
        }
        i2.rightButtonClick = true;
        this._rClkBegins = 0;
      }
    } else if (t2.button === zl.MB_MIDDLE) {
      i2.middleButtonDown = false;
      i2.middleButtonUp = true;
      if (Math.abs(this._mclickX - t2.clientX) < this.clickRadius && Math.abs(this._mclickY - t2.clientY) < this.clickRadius && s2 - this._mClkBegins <= i2.clickDelay) {
        if (this._mdblClkBegins) {
          let e5 = window.performance.now() - this._mdblClkBegins;
          if (e5 <= i2.doubleClickDelay) {
            i2.middleButtonDoubleClick = true;
          }
          this._mdblClkBegins = 0;
        } else {
          this._mdblClkBegins = window.performance.now();
        }
        i2.middleButtonClick = true;
        this._mClkBegins = 0;
      }
    }
  }
  onTouchStart(e4) {
    let t2 = this.touchState;
    t2.sys = e4;
    t2.clientX = e4.touches.item(0).clientX - e4.offsetLeft;
    t2.clientY = e4.touches.item(0).clientY - e4.offsetTop;
    let i2 = this.renderer.handler;
    t2.pos.x = t2.x = t2.clientX * i2.pixelRatio;
    t2.pos.y = t2.y = t2.clientY * i2.pixelRatio;
    t2.nx = t2.x / i2.canvas.width;
    t2.ny = t2.y / i2.canvas.height;
    t2.prev_x = t2.x;
    t2.prev_y = t2.y;
    t2.touchStart = true;
    if (e4.touches.length === 1) {
      this._dblTchCoords.x = t2.x;
      this._dblTchCoords.y = t2.y;
      this._oneTouchStart = true;
    } else {
      this._oneTouchStart = false;
    }
  }
  onTouchEnd(e4) {
    let t2 = this.touchState;
    t2.sys = e4;
    t2.touchEnd = true;
    if (e4.touches.length === 0) {
      t2.prev_x = t2.x;
      t2.prev_y = t2.y;
      if (this._oneTouchStart) {
        if (this._dblTchBegins) {
          let e5 = window.performance.now() - this._dblTchBegins;
          if (e5 <= t2.doubleTouchDelay) {
            t2.doubleTouch = true;
          }
          this._dblTchBegins = 0;
        }
        this._dblTchBegins = window.performance.now();
        this._oneTouchStart = false;
      }
    }
  }
  onTouchCancel(e4) {
    let t2 = this.touchState;
    t2.sys = e4;
    t2.touchCancel = true;
  }
  onTouchMove(e4) {
    let t2 = this.touchState;
    t2.clientX = e4.touches.item(0).clientX - e4.offsetLeft;
    t2.clientY = e4.touches.item(0).clientY - e4.offsetTop;
    let i2 = this.renderer.handler;
    t2.x = t2.clientX * i2.pixelRatio;
    t2.y = t2.clientY * i2.pixelRatio;
    t2.nx = t2.x / i2.canvas.width;
    t2.ny = t2.y / i2.canvas.height;
    t2.sys = e4;
    t2.moving = true;
    let s2 = t2.x - t2.prev_x;
    let r2 = t2.y - t2.prev_y;
    if (Math.abs(s2) > 9 || Math.abs(r2) > 9) {
      this._dblTchBegins = 0;
      this._oneTouchStart = false;
    }
  }
  entityPickingEvents() {
    let e4 = this.touchState, t2 = this.mouseState;
    if (this._isMouseInside !== this._entityPickingEventsActive) {
      this._entityPickingEventsActive = this._isMouseInside;
      if (!this._entityPickingEventsActive) {
        let i2 = this.renderer;
        let s2 = Mg;
        let r2 = i2.getPickingObjectArr(s2);
        if (r2) {
          let i3 = r2.rendererEvents;
          t2.pickingObject = r2;
          i3 && i3.dispatch(i3.mouseleave, t2);
          e4.pickingObject = r2;
          i3 && i3.dispatch(i3.touchleave, e4);
        }
        Mg[0] = Mg[1] = Mg[2] = Mg[3] = kg[0] = kg[1] = kg[2] = kg[3] = Bg[0] = Bg[1] = Bg[2] = Bg[3] = 0;
      }
    }
    if (this._isMouseInside && !(t2.leftButtonHold || t2.rightButtonHold || t2.middleButtonHold)) {
      let i2 = this.renderer;
      let s2 = Mg, r2 = kg, n2 = Bg;
      if (e4.x || e4.y) {
        i2.readPickingColor(e4.nx, 1 - e4.ny, n2);
      } else {
        i2.readPickingColor(t2.nx, 1 - t2.ny, n2);
      }
      r2[0] = s2[0];
      r2[1] = s2[1];
      r2[2] = s2[2];
      s2[0] = n2[0];
      s2[1] = n2[1];
      s2[2] = n2[2];
      t2.pickingObject = null;
      e4.pickingObject = null;
      let o2 = i2.getPickingObjectArr(s2);
      t2.pickingObject = o2;
      e4.pickingObject = o2;
      if (s2[0] !== r2[0] || s2[1] !== r2[1] || s2[2] !== r2[2]) {
        if (Sg(s2)) {
          let s3 = i2.getPickingObjectArr(r2);
          if (s3) {
            let i3 = s3.rendererEvents;
            t2.pickingObject = s3;
            i3 && i3.dispatch(i3.mouseleave, t2);
            e4.pickingObject = s3;
            i3 && i3.dispatch(i3.touchleave, e4);
          }
        } else {
          if (Rg(r2)) {
            let s3 = i2.getPickingObjectArr(r2);
            if (s3) {
              let i3 = s3.rendererEvents;
              t2.pickingObject = s3;
              i3 && i3.dispatch(i3.mouseleave, t2);
              e4.pickingObject = s3;
              i3 && i3.dispatch(i3.touchleave, e4);
            }
          }
          if (o2) {
            let i3 = o2.rendererEvents;
            t2.pickingObject = o2;
            i3 && i3.dispatch(i3.mouseenter, t2);
            e4.pickingObject = o2;
            i3 && i3.dispatch(i3.touchenter, e4);
          }
        }
      }
    }
  }
  handleMouseEvents() {
    let e4 = this;
    let t2 = this.mouseState;
    let i2 = t2.pickingObject, s2 = null;
    if (t2.leftButtonClick) {
      if (i2) {
        s2 = i2.rendererEvents;
        s2 && s2.dispatch(s2.lclick, t2);
      }
      this.dispatch(e4.lclick, t2);
      t2.leftButtonClick = false;
    }
    if (t2.rightButtonClick) {
      if (i2) {
        s2 = i2.rendererEvents;
        s2 && s2.dispatch(s2.rclick, t2);
      }
      this.dispatch(e4.rclick, t2);
      t2.rightButtonClick = false;
    }
    if (t2.middleButtonClick) {
      if (i2) {
        s2 = i2.rendererEvents;
        s2 && s2.dispatch(s2.mclick, t2);
      }
      this.dispatch(e4.mclick, t2);
      t2.middleButtonClick = false;
    }
    if (t2.leftButtonDown) {
      if (t2.leftButtonHold) {
        if (i2) {
          s2 = i2.rendererEvents;
          s2 && s2.dispatch(s2.lhold, t2);
        }
        this.dispatch(e4.lhold, t2);
      } else {
        t2.leftButtonHold = true;
        if (i2) {
          s2 = i2.rendererEvents;
          s2 && s2.dispatch(s2.ldown, t2);
        }
        this.dispatch(e4.ldown, t2);
      }
    }
    if (t2.rightButtonDown) {
      if (t2.rightButtonHold) {
        if (i2) {
          s2 = i2.rendererEvents;
          s2 && s2.dispatch(s2.rhold, t2);
        }
        this.dispatch(e4.rhold, t2);
      } else {
        t2.rightButtonHold = true;
        if (i2) {
          s2 = i2.rendererEvents;
          s2 && s2.dispatch(s2.rdown, t2);
        }
        this.dispatch(e4.rdown, t2);
      }
    }
    if (t2.middleButtonDown) {
      if (t2.middleButtonHold) {
        if (i2) {
          s2 = i2.rendererEvents;
          s2 && s2.dispatch(s2.mhold, t2);
        }
        this.dispatch(e4.mhold, t2);
      } else {
        t2.middleButtonHold = true;
        if (i2) {
          s2 = i2.rendererEvents;
          s2 && s2.dispatch(s2.mdown, t2);
        }
        this.dispatch(e4.mdown, t2);
      }
    }
    if (t2.leftButtonUp) {
      if (i2) {
        s2 = i2.rendererEvents;
        s2 && s2.dispatch(s2.lup, t2);
      }
      this.dispatch(e4.lup, t2);
      t2.leftButtonUp = false;
      t2.leftButtonHold = false;
    }
    if (t2.rightButtonUp) {
      if (i2) {
        s2 = i2.rendererEvents;
        s2 && s2.dispatch(s2.rup, t2);
      }
      this.dispatch(e4.rup, t2);
      t2.rightButtonUp = false;
      t2.rightButtonHold = false;
    }
    if (t2.middleButtonUp) {
      if (i2) {
        s2 = i2.rendererEvents;
        s2 && s2.dispatch(s2.mup, t2);
      }
      this.dispatch(e4.mup, t2);
      t2.middleButtonUp = false;
      t2.middleButtonHold = false;
    }
    if (t2.leftButtonDoubleClick) {
      if (i2) {
        s2 = i2.rendererEvents;
        s2 && s2.dispatch(s2.ldblclick, t2);
      }
      this.dispatch(e4.ldblclick, t2);
      t2.leftButtonDoubleClick = false;
    }
    if (t2.rightButtonDoubleClick) {
      if (i2) {
        s2 = i2.rendererEvents;
        s2 && s2.dispatch(s2.rdblclick, t2);
      }
      this.dispatch(e4.rdblclick, t2);
      t2.rightButtonDoubleClick = false;
    }
    if (t2.middleButtonDoubleClick) {
      if (i2) {
        s2 = i2.rendererEvents;
        s2 && s2.dispatch(s2.mdblclick, t2);
      }
      this.dispatch(e4.mdblclick, t2);
      t2.middleButtonDoubleClick = false;
    }
    if (t2.wheelDelta) {
      if (i2) {
        s2 = i2.rendererEvents;
        s2 && s2.dispatch(s2.mousewheel, t2);
      }
      this.dispatch(e4.mousewheel, t2);
    }
    if (t2.moving) {
      if (i2) {
        s2 = i2.rendererEvents;
        s2 && s2.dispatch(s2.mousemove, t2);
      }
      this.dispatch(e4.mousemove, t2);
      t2.prev_x = t2.x;
      t2.prev_y = t2.y;
    }
    if (t2.justStopped) {
      this.dispatch(e4.mousestop, t2);
    }
  }
  handleTouchEvents() {
    let e4 = this;
    let t2 = this.touchState;
    let i2 = t2.pickingObject, s2 = null;
    if (t2.touchCancel) {
      this.dispatch(e4.touchcancel, t2);
      t2.touchCancel = false;
    }
    if (t2.touchStart) {
      let r2 = this.renderer;
      r2.readPickingColor(t2.nx, 1 - t2.ny, Mg);
      let n2 = r2.getPickingObjectArr(Mg);
      i2 = t2.pickingObject = n2;
      if (i2) {
        s2 = i2.rendererEvents;
        s2 && s2.dispatch(s2.touchstart, t2);
      }
      this.dispatch(e4.touchstart, t2);
      t2.touchStart = false;
    }
    if (t2.doubleTouch) {
      if (i2) {
        s2 = i2.rendererEvents;
        s2 && s2.dispatch(s2.doubletouch, t2);
      }
      this.dispatch(e4.doubletouch, t2);
      t2.doubleTouch = false;
    }
    if (t2.touchEnd) {
      if (i2) {
        s2 = i2.rendererEvents;
        s2 && s2.dispatch(s2.touchend, t2);
      }
      this.dispatch(e4.touchend, t2);
      t2.x = 0;
      t2.y = 0;
      t2.touchEnd = false;
    }
    if (t2.moving) {
      if (i2) {
        s2 = i2.rendererEvents;
        s2 && s2.dispatch(s2.touchmove, t2);
      }
      this.dispatch(e4.touchmove, t2);
      t2.prev_x = t2.x;
      t2.prev_y = t2.y;
    }
  }
}
const zg = ["changerelativecenter", "draw", "drawtransparent", "postdraw", "resize", "resizeend", "mouseenter", "mouseleave", "mousemove", "mousestop", "lclick", "rclick", "mclick", "ldblclick", "rdblclick", "mdblclick", "lup", "rup", "mup", "ldown", "rdown", "mdown", "lhold", "rhold", "mhold", "mousewheel", "touchstart", "touchend", "touchcancel", "touchmove", "doubletouch", "touchleave", "touchenter"];
function Dg() {
  return new Yr("depth", { uniforms: { depthTexture: "sampler2D" }, attributes: { corners: "vec2" }, vertexShader: `#version 300 es
            
            in vec2 corners;
            
            out vec2 tc;

            void main(void) {
                gl_Position = vec4(corners, 0.0, 1.0);
                tc = corners * 0.5 + 0.5;
            }`, fragmentShader: `#version 300 es

            precision highp float;

            uniform sampler2D depthTexture;
           
            in vec2 tc;

            layout(location = 0) out vec4 fragColor;

            float LinearizeDepth(in vec2 uv)
            {
                return texture(depthTexture, tc).r;
            }
            
            void main(void) {
                float c = LinearizeDepth(tc);
                fragColor = vec4(c, c, c, 1.0);
            }` });
}
class Fg {
  constructor(e4 = 0, t2 = 0, i2 = 0, s2 = 0) {
    this.left = e4;
    this.right = i2;
    this.top = t2;
    this.bottom = s2;
  }
  set(e4 = 0, t2 = 0, i2 = 0, s2 = 0) {
    this.left = e4;
    this.right = i2;
    this.top = t2;
    this.bottom = s2;
  }
  clone() {
    return new Fg(this.left, this.top, this.right, this.bottom);
  }
  getWidth() {
    return Math.abs(this.right - this.left);
  }
  getHeight() {
    return Math.abs(this.bottom - this.top);
  }
  getSquare() {
    return this.getHeight() * this.getWidth();
  }
  getDiagonal() {
    let e4 = this.getWidth(), t2 = this.getHeight();
    return Math.sqrt(t2 * t2 + e4 * e4);
  }
  fit(e4, t2) {
    return this.getWidth() === e4 && this.getHeight() === t2;
  }
  isInside(e4, t2) {
    return e4 >= this.left && e4 <= this.right && t2 >= this.top && t2 <= this.bottom;
  }
}
class Ng {
  constructor() {
    this.imagesCache = {};
    this._counter = 0;
    this._pendingsQueue = new Y_();
    this._imageIndexCounter = 0;
  }
  load(e4, t2) {
    if (this.imagesCache[e4]) {
      t2(this.imagesCache[e4]);
    } else {
      let i2 = { src: e4, success: t2 };
      if (this._counter >= 1) {
        this._pendingsQueue.unshift(i2);
      } else {
        this._exec(i2);
      }
    }
  }
  _exec(e4) {
    this._counter++;
    const t2 = this;
    let i2 = new Image();
    i2.crossOrigin = "";
    i2.onload = function() {
      t2.imagesCache[e4.src] = i2;
      i2.__nodeIndex = t2._imageIndexCounter++;
      e4.success(i2);
      t2._dequeueRequest();
    };
    i2.onerror = function() {
      t2._dequeueRequest();
    };
    i2.src = e4.src;
  }
  _dequeueRequest() {
    this._counter--;
    if (this._pendingsQueue.length && this._counter < 1) {
      while (this._pendingsQueue.length) {
        let e4 = this._pendingsQueue.pop();
        if (e4) {
          if (this.imagesCache[e4.src]) {
            if (this._counter <= 0) {
              this._counter = 0;
            } else {
              this._counter--;
            }
            e4.success(this.imagesCache[e4.src]);
          } else {
            this._exec(e4);
            break;
          }
        }
      }
    }
  }
}
class Og {
  constructor(e4 = 1024, t2 = 1024) {
    this.nodes = /* @__PURE__ */ new Map();
    this.texture = null;
    this.canvas = new h_(e4, t2);
    this.clearCanvas();
    this._handler = null;
    this._images = [];
    this._btree = null;
    this._imagesCacheManager = new Ng();
    this.borderSize = 4;
  }
  getImage() {
    return this.canvas.getImage();
  }
  getCanvas() {
    return this.canvas.getCanvas();
  }
  clearCanvas() {
    this.canvas.fillEmpty();
  }
  assignHandler(e4) {
    this._handler = e4;
    this.createTexture();
  }
  getDiagonal(e4) {
    let t2 = e4.atlasWidth || e4.width, i2 = e4.atlasHeight || e4.height;
    return Math.sqrt(t2 * t2 + i2 * i2);
  }
  addImage(e4, t2 = false) {
    if (!(e4.width && e4.height)) {
      return;
    }
    this._images.push(e4);
    this._makeAtlas(t2);
    if (e4.__nodeIndex != void 0) {
      return this.get(e4.__nodeIndex);
    }
  }
  _completeNode(e4, t2) {
    if (t2) {
      let i2 = this.canvas.getWidth(), s2 = this.canvas.getHeight();
      let r2 = t2.image;
      let n2 = t2.rect;
      let o2 = Math.round(this.borderSize * 0.5);
      this.canvas.drawImage(r2, n2.left + o2, n2.top + o2, r2.atlasWidth || 0, r2.atlasHeight || 0);
      let a2 = t2.texCoords;
      a2[0] = (n2.left + o2) / i2;
      a2[1] = (n2.top + o2) / s2;
      a2[2] = (n2.left + o2) / i2;
      a2[3] = (n2.bottom - o2) / s2;
      a2[4] = (n2.right - o2) / i2;
      a2[5] = (n2.bottom - o2) / s2;
      a2[6] = (n2.right - o2) / i2;
      a2[7] = (n2.bottom - o2) / s2;
      a2[8] = (n2.right - o2) / i2;
      a2[9] = (n2.top + o2) / s2;
      a2[10] = (n2.left + o2) / i2;
      a2[11] = (n2.top + o2) / s2;
      e4.set(r2.__nodeIndex, t2);
    }
  }
  _makeAtlas(e4 = false) {
    if (e4 && this._btree) {
      let e5 = this._images[this._images.length - 1];
      this._completeNode(this.nodes, this._btree.insert(e5));
    } else {
      let e5 = this._images.slice(0);
      e5.sort(function(e6, t3) {
        return (t3.atlasWidth || t3.width) - (e6.atlasWidth || e6.width) || (t3.atlasHeight || t3.height) - (e6.atlasHeight || e6.height);
      });
      this._btree = new Hg(new Fg(0, 0, this.canvas.getWidth(), this.canvas.getHeight()));
      this._btree.atlas = this;
      this.clearCanvas();
      let t2 = /* @__PURE__ */ new Map();
      for (let i2 = 0; i2 < e5.length; i2++) {
        this._completeNode(t2, this._btree.insert(e5[i2]));
      }
      this.nodes = null;
      this.nodes = t2;
    }
  }
  get(e4) {
    return this.nodes.get(e4);
  }
  set(e4, t2) {
    this.nodes.set(e4, t2);
  }
  createTexture(e4, t2) {
    if (this._handler) {
      this._handler.gl.deleteTexture(this.texture);
      if (e4) {
        this.canvas.resize(e4.width, e4.height);
        this.canvas.drawImage(e4, 0, 0, e4.width, e4.height);
      }
      this.texture = this._handler.createTexture_l(this.canvas.getCanvas(), t2);
    }
  }
  loadImage(e4, t2) {
    this._imagesCacheManager.load(e4, t2);
  }
  getImageTexCoordinates(e4) {
    if (e4.__nodeIndex != null) {
      let t2 = this.get(e4.__nodeIndex);
      if (t2) {
        return t2.texCoords;
      }
    }
  }
}
class Hg {
  constructor(e4, t2) {
    this.childNodes = null;
    this.image = null;
    this.rect = e4 || new Fg();
    this.texCoords = t2 || [];
    this.atlas = null;
  }
  insert(e4) {
    if (this.childNodes) {
      let t2 = this.childNodes[0].insert(e4);
      if (t2) {
        return t2;
      }
      return this.childNodes[1].insert(e4);
    } else {
      if (this.image != null) {
        return;
      }
      let t2 = this.rect;
      const i2 = (e4.atlasWidth || e4.width) + this.atlas.borderSize;
      const s2 = (e4.atlasHeight || e4.height) + this.atlas.borderSize;
      if (i2 > t2.getWidth() || s2 > t2.getHeight()) {
        return;
      }
      if (t2.fit(i2, s2)) {
        this.image = e4;
        return this;
      }
      this.childNodes = new Array(2);
      this.childNodes[0] = new Hg();
      this.childNodes[0].atlas = this.atlas;
      this.childNodes[1] = new Hg();
      this.childNodes[1].atlas = this.atlas;
      const r2 = t2.getWidth() - i2;
      const n2 = t2.getHeight() - s2;
      if (r2 > n2) {
        this.childNodes[0].rect.set(t2.left, t2.top, t2.left + i2, t2.bottom);
        this.childNodes[1].rect.set(t2.left + i2, t2.top, t2.right, t2.bottom);
      } else {
        this.childNodes[0].rect.set(t2.left, t2.top, t2.right, t2.top + s2);
        this.childNodes[1].rect.set(t2.left, t2.top + s2, t2.right, t2.bottom);
      }
      return this.childNodes[0].insert(e4);
    }
  }
}
const Vg = 11;
class Ug extends Og {
  constructor(e4, t2) {
    super(e4, t2);
    this.width = 0;
    this.height = 0;
    this.gliphSize = 0;
    this.distanceRange = 0;
    this.nodes = /* @__PURE__ */ new Map();
    this.kernings = {};
  }
  get(e4) {
    return this.nodes.get(e4);
  }
}
class Gg extends Hg {
  constructor(e4, t2) {
    super(e4, t2);
    this.emptySize = 1;
    this.metrics = { id: 0, char: "", width: 0, height: 0, x: 0, y: 0, chnl: 0, index: 0, page: 0, xadvance: 0, xoffset: 0, yoffset: 0, nChar: "", nCode: 0, nWidth: 0, nHeight: 0, nAdvance: 0, nXOffset: 0, nYOffset: 0 };
  }
}
class Wg {
  constructor(e4) {
    this.atlasesArr = [];
    this.atlasIndexes = {};
    this.atlasIndexesDeferred = {};
    this.tokenImageSize = 64;
    this.samplerArr = new Uint32Array(Vg);
    this.sdfParamsArr = new Float32Array(Vg * 4);
    this._handler = null;
    this.catalogSrc = e4 || "./";
  }
  assignHandler(e4) {
    this._handler = e4;
  }
  getFontIndex(e4) {
    let t2 = this.getFullIndex(e4);
    if (!this.atlasIndexes[t2]) {
      this.loadFont(e4, this.catalogSrc, `${e4}.json`);
    }
    if (!this.atlasIndexesDeferred[t2]) {
      this.atlasIndexesDeferred[t2] = new bc();
    }
    return this.atlasIndexesDeferred[t2].promise;
  }
  getFullIndex(e4) {
    return e4.trim().toLowerCase();
  }
  _applyFontDataToAtlas(e4, t2, i2 = 0) {
    let s2 = t2.chars;
    e4.height = t2.common.scaleH;
    e4.width = t2.common.scaleW;
    e4.gliphSize = t2.info.size;
    e4.distanceRange = t2.distanceField.distanceRange;
    let r2 = e4.width, n2 = e4.height, o2 = e4.gliphSize;
    this.sdfParamsArr[i2 * 4] = r2;
    this.sdfParamsArr[i2 * 4 + 1] = n2;
    this.sdfParamsArr[i2 * 4 + 2] = o2;
    this.sdfParamsArr[i2 * 4 + 3] = e4.distanceRange;
    let a2 = {};
    for (let t3 = 0; t3 < s2.length; t3++) {
      let i3 = s2[t3];
      let l2 = i3.char;
      a2[i3.id] = l2;
      let h2 = new Fg(i3.x, i3.y, i3.x + i3.width, i3.y + i3.height);
      let c2 = new Array(12);
      c2[0] = h2.left / r2;
      c2[1] = h2.top / n2;
      c2[2] = h2.left / r2;
      c2[3] = h2.bottom / n2;
      c2[4] = h2.right / r2;
      c2[5] = h2.bottom / n2;
      c2[6] = h2.right / r2;
      c2[7] = h2.bottom / n2;
      c2[8] = h2.right / r2;
      c2[9] = h2.top / n2;
      c2[10] = h2.left / r2;
      c2[11] = h2.top / n2;
      let d2 = new Gg(h2, c2);
      let u2 = i3.char.normalize("NFKC");
      let _2 = u2.charCodeAt(0);
      let f2 = d2.metrics;
      f2.id = i3.id;
      f2.char = i3.char;
      f2.width = i3.width;
      f2.height = i3.height;
      f2.x = i3.x;
      f2.y = i3.y;
      f2.chnl = i3.chnl;
      f2.index = i3.index;
      f2.page = i3.page;
      f2.xadvance = i3.xadvance;
      f2.xoffset = i3.xoffset;
      f2.yoffset = i3.yoffset;
      f2.nChar = u2;
      f2.nCode = _2;
      f2.nWidth = d2.metrics.width / o2;
      f2.nHeight = d2.metrics.height / o2;
      f2.nAdvance = d2.metrics.xadvance / o2;
      f2.nXOffset = d2.metrics.xoffset / o2;
      f2.nYOffset = 1 - d2.metrics.yoffset / o2;
      d2.emptySize = 1;
      e4.nodes.set(u2.charCodeAt(0), d2);
    }
    e4.kernings = {};
    for (let i3 = 0; i3 < t2.kernings.length; i3++) {
      let s3 = t2.kernings[i3];
      let r3 = s3.first, n3 = s3.second;
      if (!e4.kernings[r3]) {
        e4.kernings[r3] = {};
      }
      e4.kernings[r3][n3] = s3.amount / o2;
    }
  }
  initFont(e4, t2, i2) {
    let s2 = this.atlasesArr.length;
    let r2 = this.getFullIndex(e4);
    this.atlasIndexes[r2] = s2;
    let n2 = this.atlasIndexesDeferred[r2];
    if (!n2) {
      n2 = this.atlasIndexesDeferred[r2] = new bc();
    }
    this.samplerArr[this.atlasesArr.length] = s2;
    let o2 = new Ug();
    o2.height = 0;
    o2.width = 0;
    o2.gliphSize = 0;
    o2.distanceRange = 0;
    o2.kernings = {};
    o2.assignHandler(this._handler);
    this.atlasesArr[s2] = o2;
    this._applyFontDataToAtlas(o2, t2, s2);
    let a2 = new Image();
    a2.onload = () => {
      this._createTexture(o2, a2);
      n2.resolve(s2);
    };
    a2.src = i2;
  }
  _createTexture(e4, t2) {
    e4.createTexture(t2);
  }
  loadFont(e4, t2, i2) {
    let s2 = this.atlasesArr.length;
    let r2 = this.getFullIndex(e4);
    this.atlasIndexes[r2] = s2;
    let n2 = this.atlasIndexesDeferred[r2];
    if (!n2) {
      n2 = this.atlasIndexesDeferred[r2] = new bc();
    }
    this.samplerArr[this.atlasesArr.length] = s2;
    let o2 = new Ug();
    o2.height = 0;
    o2.width = 0;
    o2.gliphSize = 0;
    o2.distanceRange = 0;
    o2.kernings = {};
    o2.assignHandler(this._handler);
    this.atlasesArr[s2] = o2;
    fetch(`${t2}/${i2}`).then((e5) => {
      if (!e5.ok) {
        throw Error(`Unable to load "${t2}/${i2}"`);
      }
      return e5.json();
    }).then((e5) => {
      this._applyFontDataToAtlas(o2, e5, s2);
      let i3 = new Image();
      i3.onload = () => {
        this._createTexture(o2, i3);
        n2.resolve(s2);
      };
      i3.src = `${t2}/${e5.pages[0]}`;
      i3.crossOrigin = "Anonymous";
    }).catch((e5) => {
      n2.reject();
      return { status: "error", msg: e5.toString() };
    });
  }
}
function jg() {
  return new Yr("screenFrame", { uniforms: { texture: "sampler2d" }, attributes: { corners: "vec3" }, vertexShader: `attribute vec2 corners;
            
            varying vec2 tc;
            void main(void) {
                gl_Position = vec4(corners, 0.0, 1.0);
                tc = corners * 0.5 + 0.5;
            }`, fragmentShader: `precision highp float;
            uniform sampler2D texture;
            
            varying vec2 tc;
            
            void main(void) {
                gl_FragColor = texture2D( texture, tc );
            }` });
}
var Yg = "#version 300 es\n\nin vec2 corners;\n\nout vec2 tc;\n\nvoid main(void) {\r\n    gl_Position = vec4(corners, 0.0, 1.0);\r\n    tc = corners * 0.5 + 0.5;\r\n}";
var qg = "#version 300 es\n\nprecision highp float;\n\n#ifndef saturate\r\n    #define saturate(a) clamp(a, 0.0, 1.0)\r\n#endif\n\nuniform sampler2D hdrBuffer;\n\nuniform float whitepoint;\r\nuniform float exposure;\r\nuniform float gamma;\n\nvec3 LinearToneMapping(vec3 color) {\r\n    return exposure * color;\r\n}\n\nvec3 ReinhardToneMapping2(vec3 color) {\r\n    return vec3(1.0) - exp(-color * exposure);\r\n}\n\nvec3 ReinhardToneMapping(vec3 color) {\r\n    color *= exposure;\r\n    return saturate(color / (vec3(1.0) + color));\r\n}\n\n#define Uncharted2Helper(x) max(((x * (0.15 * x + 0.10 * 0.50) + 0.20 * 0.02) / (x * (0.15 * x + 0.50) + 0.20 * 0.30)) - 0.02 / 0.30, vec3(0.0))\n\nvec3 Uncharted2ToneMapping(vec3 color) {\r\n    color *= exposure;\r\n    return saturate(Uncharted2Helper(color) / Uncharted2Helper(vec3(whitepoint)));\r\n}\n\nvec3 OptimizedCineonToneMapping(vec3 color) {\r\n    color *= exposure;\r\n    color = max(vec3(0.0), color - 0.004);\r\n    return pow((color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06), vec3(2.2));\r\n}\n\nvec3 ACESFilmicToneMapping(vec3 color) {\r\n    color *= exposure;\r\n    return saturate((color * (2.51 * color + 0.03)) / (color * (2.43 * color + 0.59) + 0.14));\r\n}\n\nin vec2 tc;\n\nlayout (location = 0) out vec4 fragColor;\n\nvoid main(void) {\r\n    vec4 hdrColor = texture(hdrBuffer, tc).rgba;\n\n    float oneByGamma = gamma / gamma;\r\n    float oneByWhitePoint = whitepoint / whitepoint;\r\n    vec3 mapped = ReinhardToneMapping2(hdrColor.rgb) * oneByGamma * oneByWhitePoint;\r\n    \n\n    mapped = pow(mapped, vec3(1.0 / gamma));\n\n    fragColor = vec4(mapped, hdrColor.a);\r\n}";
function $g() {
  return new Yr("toneMapping", { uniforms: { hdrBuffer: "sampler2d", exposure: "float", gamma: "float", whitepoint: "float" }, attributes: { corners: "vec3" }, vertexShader: Yg, fragmentShader: qg });
}
const Xg = 0;
let Zg = 0;
let Kg = 0;
let Qg = new Float32Array(2);
class Jg {
  constructor(e4, t2 = {}) {
    var _a2, _b;
    this.div = null;
    if (e4 instanceof pg) {
      this.handler = e4;
    } else {
      this.handler = new pg(e4, { pixelRatio: t2.dpi || window.devicePixelRatio + 0.15, autoActivate: true });
    }
    this.exposure = t2.exposure || 3.01;
    this.gamma = t2.gamma || 0.47;
    this.whitepoint = 1;
    this.brightThreshold = 0.9;
    this._renderNodesArr = [];
    this.renderNodes = {};
    this.activeCamera = new vf({ width: (_a2 = this.handler.canvas) == null ? void 0 : _a2.width, height: (_b = this.handler.canvas) == null ? void 0 : _b.height, eye: new Ke(0, 0, 0), look: new Ke(0, 0, -1), up: new Ke(0, 1, 0) });
    this.events = Eg(this);
    this.controls = {};
    if (t2.controls) {
      for (let e5 in t2.controls) {
        this.controls[t2.controls[e5].name] = t2.controls[e5];
      }
    }
    this.controlsBag = {};
    this.colorObjects = /* @__PURE__ */ new Map();
    this._pickingCallbacks = [];
    this.pickingFramebuffer = null;
    this._depthCallbacks = [];
    this.depthFramebuffer = null;
    let i2 = new URLSearchParams(location.search);
    let s2 = i2.get("og_msaa");
    if (s2) {
      this._msaa = Number(i2.get("og_msaa"));
    } else {
      this._msaa = t2.msaa != void 0 ? t2.msaa : Xg;
    }
    this._internalFormat = "RGBA16F";
    this._format = "RGBA";
    this._type = "FLOAT";
    this.sceneFramebuffer = null;
    this.blitFramebuffer = null;
    this.toneMappingFramebuffer = null;
    this._initialized = false;
    this.billboardsTextureAtlas = new Og();
    this.geoObjectsTextureAtlas = new Og();
    this.fontAtlas = new Wg(t2.fontsSrc);
    this._entityCollections = [[]];
    this._currentOutput = "screen";
    this._fnScreenFrame = null;
    this.labelWorker = new Xs(4);
    this.screenDepthFramebuffer = null;
    this.screenFramePositionBuffer = null;
    this.screenTexture = {};
    this.outputTexture = null;
    this._readPickingBuffer = this._readPickingBuffer_webgl2;
    if (t2.autoActivate || st(t2.autoActivate)) {
      this.start();
    }
  }
  enableBlendOneSrcAlpha() {
    let e4 = this.handler.gl;
    e4.enable(e4.BLEND);
    e4.blendEquation(e4.FUNC_ADD);
    e4.blendFunc(e4.ONE, e4.ONE_MINUS_SRC_ALPHA);
  }
  enableBlendDefault() {
    let e4 = this.handler.gl;
    e4.enable(e4.BLEND);
    e4.blendEquation(e4.FUNC_ADD);
    e4.blendFuncSeparate(e4.SRC_ALPHA, e4.ONE_MINUS_SRC_ALPHA, e4.ONE, e4.ONE);
  }
  setRelativeCenter(e4) {
    this.events.dispatch(this.events.changerelativecenter, e4 || this.activeCamera.eye);
  }
  setEventsActivity(e4) {
    this.events.active = e4;
  }
  addDepthCallback(e4, t2) {
    let i2 = Kg++;
    this._depthCallbacks.push({ id: i2, callback: t2, sender: e4 });
    return i2;
  }
  removeDepthCallback(e4) {
    for (let t2 = 0; t2 < this._depthCallbacks.length; t2++) {
      if (e4 === this._depthCallbacks[t2].id) {
        this._depthCallbacks.splice(t2, 1);
        break;
      }
    }
  }
  addPickingCallback(e4, t2) {
    let i2 = Zg++;
    this._pickingCallbacks.push({ id: i2, callback: t2, sender: e4 });
    return i2;
  }
  removePickingCallback(e4) {
    for (let t2 = 0; t2 < this._pickingCallbacks.length; t2++) {
      if (e4 === this._pickingCallbacks[t2].id) {
        this._pickingCallbacks.splice(t2, 1);
        break;
      }
    }
  }
  getPickingObject(e4, t2, i2) {
    return this.colorObjects.get(`${e4}_${t2}_${i2}`);
  }
  getPickingObjectArr(e4) {
    return this.colorObjects.get(`${e4[0]}_${e4[1]}_${e4[2]}`);
  }
  getPickingObject3v(e4) {
    return this.colorObjects.get(`${e4.x}_${e4.y}_${e4.z}`);
  }
  assignPickingColor(e4) {
    if (!e4._pickingColor || e4._pickingColor.isZero()) {
      let t2 = 0, i2 = 0, s2 = 0;
      let r2 = "0_0_0";
      while (!(t2 || i2 || s2) || this.colorObjects.has(r2)) {
        t2 = q(1, 255);
        i2 = q(1, 255);
        s2 = q(1, 255);
        r2 = `${t2}_${i2}_${s2}`;
      }
      if (!e4._pickingColor) {
        e4._pickingColor = new Ke(t2, i2, s2);
      } else {
        e4._pickingColor.set(t2, i2, s2);
      }
      e4._pickingColorU = new Float32Array([t2 / 255, i2 / 255, s2 / 255]);
      this.colorObjects.set(r2, e4);
    }
  }
  clearPickingColor(e4) {
    if (e4._pickingColor && !e4._pickingColor.isZero()) {
      let t2 = e4._pickingColor;
      if (!t2.isZero()) {
        this.colorObjects.delete(`${t2.x}_${t2.y}_${t2.z}`);
        t2.x = t2.y = t2.z = 0;
      }
    }
  }
  getWidth() {
    return this.handler.canvas.clientWidth;
  }
  getHeight() {
    return this.handler.canvas.clientHeight;
  }
  getCenter() {
    let e4 = this.handler.canvas;
    return new Qe(Math.round(e4.width * 0.5), Math.round(e4.height * 0.5));
  }
  getClientCenter() {
    let e4 = this.handler.canvas;
    return new Qe(Math.round(e4.clientWidth * 0.5), Math.round(e4.clientHeight * 0.5));
  }
  addControl(e4) {
    e4.addTo(this);
  }
  addControls(e4) {
    for (let t2 = 0; t2 < e4.length; t2++) {
      e4[t2].addTo(this);
    }
  }
  removeControl(e4) {
    e4.remove();
  }
  isInitialized() {
    return this._initialized;
  }
  initialize() {
    if (this._initialized) {
      return;
    } else {
      this._initialized = true;
    }
    this.handler.initialize();
    this.billboardsTextureAtlas.assignHandler(this.handler);
    this.geoObjectsTextureAtlas.assignHandler(this.handler);
    this.fontAtlas.assignHandler(this.handler);
    this.handler.setFrameCallback(() => {
      this.draw();
    });
    this.events.initialize();
    this.events.on("charkeypress", zl.KEY_APOSTROPHE, function() {
      Or.setVisibility(!Or.getVisibility());
    });
    this.handler.addProgram(jg());
    this.pickingFramebuffer = new u_(this.handler, { width: 640, height: 480, targets: [{ readAsync: true }] });
    this.pickingFramebuffer.init();
    this.depthFramebuffer = new u_(this.handler, { width: 640, height: 480, targets: [{ internalFormat: "RGBA", type: "UNSIGNED_BYTE", attachment: "COLOR_ATTACHMENT", readAsync: true }, { internalFormat: "RGBA16F", type: "FLOAT", attachment: "COLOR_ATTACHMENT", readAsync: true }], useDepth: true });
    this.depthFramebuffer.init();
    this.screenDepthFramebuffer = new u_(this.handler, { useDepth: false });
    this.screenDepthFramebuffer.init();
    if (this.handler.gl.type === "webgl") {
      this._readPickingBuffer = this._readPickingBuffer_webgl1;
      this.sceneFramebuffer = new u_(this.handler);
      this.sceneFramebuffer.init();
      this._fnScreenFrame = this._screenFrameNoMSAA;
      this.screenTexture = { screen: this.sceneFramebuffer.textures[0], picking: this.pickingFramebuffer.textures[0], depth: this.screenDepthFramebuffer.textures[0] };
    } else {
      let e4 = this.getMaxMSAA(this._internalFormat);
      if (this._msaa > e4) {
        this._msaa = e4;
      }
      this.handler.addPrograms([$g()]);
      this.handler.addPrograms([Dg()]);
      this.sceneFramebuffer = new mg(this.handler, { size: 1, msaa: this._msaa, internalFormat: this._internalFormat, filter: "LINEAR" });
      this.sceneFramebuffer.init();
      this.blitFramebuffer = new u_(this.handler, { size: 1, useDepth: false, targets: [{ internalFormat: this._internalFormat, format: this._format, type: this._type, filter: "NEAREST" }] });
      this.blitFramebuffer.init();
      this.toneMappingFramebuffer = new u_(this.handler, { useDepth: false });
      this.toneMappingFramebuffer.init();
      this._fnScreenFrame = this._screenFrameMSAA;
      this.screenTexture = { screen: this.toneMappingFramebuffer.textures[0], picking: this.pickingFramebuffer.textures[0], depth: this.screenDepthFramebuffer.textures[0], frustum: this.depthFramebuffer.textures[0] };
    }
    this.handler.ONCANVASRESIZE = () => {
      this._resizeStart();
      this.events.dispatch(this.events.resize, this.handler.canvas);
      this._resizeEnd();
      this.events.dispatch(this.events.resizeend, this.handler.canvas);
    };
    this.screenFramePositionBuffer = this.handler.createArrayBuffer(new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]), 2, 4);
    this.outputTexture = this.screenTexture.screen;
    this._initializeRenderNodes();
    this._initializeControls();
  }
  _initializeControls() {
    let e4 = this.controls;
    this.controls = {};
    for (let t2 in e4) {
      this.addControl(e4[t2]);
    }
  }
  resize() {
    this._resizeEnd();
  }
  setCurrentScreen(e4) {
    this._currentOutput = e4;
    if (this.screenTexture[e4]) {
      this.outputTexture = this.screenTexture[e4];
    }
  }
  _resizeStart() {
    let e4 = this.handler.canvas;
    this.activeCamera.setViewportSize(e4.width, e4.height);
    this.sceneFramebuffer.setSize(e4.width * 0.5, e4.height * 0.5);
    this.blitFramebuffer && this.blitFramebuffer.setSize(e4.width * 0.5, e4.height * 0.5, true);
  }
  _resizeEnd() {
    let e4 = this.handler.canvas;
    this.activeCamera.setViewportSize(e4.width, e4.height);
    this.sceneFramebuffer.setSize(e4.width, e4.height);
    this.blitFramebuffer && this.blitFramebuffer.setSize(e4.width, e4.height, true);
    this.toneMappingFramebuffer && this.toneMappingFramebuffer.setSize(e4.width, e4.height, true);
    this.screenDepthFramebuffer && this.screenDepthFramebuffer.setSize(e4.clientWidth, e4.clientHeight, true);
    if (this.handler.gl.type === "webgl") {
      this.screenTexture.screen = this.sceneFramebuffer.textures[0];
      this.screenTexture.picking = this.pickingFramebuffer.textures[0];
      this.screenTexture.depth = this.screenDepthFramebuffer.textures[0];
      this.screenTexture.frustum = this.depthFramebuffer.textures[0];
    } else {
      this.screenTexture.screen = this.toneMappingFramebuffer.textures[0];
      this.screenTexture.picking = this.pickingFramebuffer.textures[0];
      this.screenTexture.depth = this.screenDepthFramebuffer.textures[0];
      this.screenTexture.frustum = this.depthFramebuffer.textures[0];
    }
    this.setCurrentScreen(this._currentOutput);
  }
  removeNode(e4) {
    e4.remove();
  }
  addNode(e4) {
    if (!this.renderNodes[e4.name]) {
      e4.assign(this);
      this._renderNodesArr.unshift(e4);
      this.renderNodes[e4.name] = e4;
    } else {
      Or.logWrn(`Node name ${e4.name} already exists.`);
    }
  }
  _initializeRenderNodes() {
    for (let e4 = 0; e4 < this._renderNodesArr.length; e4++) {
      this._renderNodesArr[e4].initialize();
    }
  }
  addNodeBefore(e4, t2) {
    if (!this.renderNodes[e4.name]) {
      e4.assign(this);
      this.renderNodes[e4.name] = e4;
      for (let i2 = 0; i2 < this._renderNodesArr.length; i2++) {
        if (this._renderNodesArr[i2].isEqual(t2)) {
          this._renderNodesArr.splice(i2, 0, e4);
          break;
        }
      }
      this._renderNodesArr.unshift(e4);
    } else {
      Or.logWrn(`Node name ${e4.name} already exists.`);
    }
  }
  addNodes(e4) {
    for (let t2 = 0; t2 < e4.length; t2++) {
      this.addNode(e4[t2]);
    }
  }
  getMaxMSAA(e4) {
    let t2 = this.handler.gl;
    let i2 = t2.getInternalformatParameter(t2.RENDERBUFFER, t2[e4], t2.SAMPLES);
    return i2[0];
  }
  getMSAA() {
    return this._msaa;
  }
  enqueueEntityCollectionsToDraw(e4, t2 = 0) {
    if (!this._entityCollections[t2]) {
      this._entityCollections[t2] = [];
    }
    this._entityCollections[t2].push(...e4);
  }
  _drawEntityCollections(e4) {
    let t2 = this._entityCollections[e4];
    if (t2.length) {
      let e5 = this.handler.gl;
      this.enableBlendDefault();
      let i2 = t2.length;
      while (i2--) {
        t2[i2]._fadingOpacity && t2[i2].pointCloudHandler.draw();
      }
      i2 = t2.length;
      while (i2--) {
        let e6 = t2[i2];
        if (t2[i2]._fadingOpacity) {
          e6.events.dispatch(e6.events.draw, e6);
          t2[i2].geoObjectHandler.draw();
        }
      }
      e5.activeTexture(e5.TEXTURE0);
      e5.bindTexture(e5.TEXTURE_2D, this.billboardsTextureAtlas.texture);
      i2 = t2.length;
      while (i2--) {
        let e6 = t2[i2];
        e6._fadingOpacity && e6.billboardHandler.draw();
      }
      let s2 = this.fontAtlas.atlasesArr;
      for (i2 = 0; i2 < s2.length; i2++) {
        e5.activeTexture(e5.TEXTURE0 + i2);
        e5.bindTexture(e5.TEXTURE_2D, s2[i2].texture);
      }
      i2 = t2.length;
      while (i2--) {
        t2[i2]._fadingOpacity && t2[i2].labelHandler.draw();
      }
      i2 = t2.length;
      while (i2--) {
        t2[i2]._fadingOpacity && t2[i2].rayHandler.draw();
      }
      i2 = t2.length;
      while (i2--) {
        t2[i2]._fadingOpacity && t2[i2].polylineHandler.draw();
      }
      i2 = t2.length;
      while (i2--) {
        t2[i2]._fadingOpacity && t2[i2].stripHandler.draw();
      }
    }
  }
  _drawPickingEntityCollections(e4) {
    let t2 = this._entityCollections[e4];
    if (t2.length) {
      let e5 = t2.length;
      while (e5--) {
        t2[e5]._fadingOpacity && t2[e5].billboardHandler.drawPicking();
      }
      e5 = t2.length;
      while (e5--) {
        t2[e5]._fadingOpacity && t2[e5].geoObjectHandler.drawPicking();
      }
      e5 = t2.length;
      while (e5--) {
        t2[e5]._fadingOpacity && t2[e5].labelHandler.drawPicking();
      }
      e5 = t2.length;
      while (e5--) {
        t2[e5]._fadingOpacity && t2[e5].rayHandler.drawPicking();
      }
      e5 = t2.length;
      while (e5--) {
        t2[e5]._visibility && t2[e5].polylineHandler.drawPicking();
      }
      e5 = t2.length;
      while (e5--) {
        t2[e5]._visibility && t2[e5].stripHandler.drawPicking();
      }
    }
  }
  _drawDepthEntityCollections(e4) {
    let t2 = this._entityCollections[e4];
    if (t2.length) {
      let e5 = t2.length;
      while (e5--) {
        t2[e5]._fadingOpacity && t2[e5].geoObjectHandler.drawDepth();
      }
    }
  }
  _clearEntityCollectionQueue(e4) {
    this._entityCollections[e4].length = 0;
    this._entityCollections[e4] = [];
  }
  draw() {
    this.activeCamera.checkMoveEnd();
    let e4 = this.events;
    e4.handleEvents();
    let t2 = this.sceneFramebuffer;
    t2.activate();
    let i2 = this.handler, s2 = i2.gl;
    s2.clearColor(0, 0, 0, 1);
    s2.clear(s2.COLOR_BUFFER_BIT | s2.DEPTH_BUFFER_BIT);
    this.enableBlendDefault();
    e4.dispatch(e4.draw, this);
    let r2 = this.activeCamera.frustums;
    let n2 = e4.pointerEvent();
    let o2 = !e4.mouseState.leftButtonDown && !e4.mouseState.rightButtonDown;
    let a2 = this._renderNodesArr;
    let l2 = r2.length;
    while (l2--) {
      this.activeCamera.setCurrentFrustum(l2);
      s2.clear(s2.DEPTH_BUFFER_BIT);
      let t3 = a2.length;
      while (t3--) {
        a2[t3].preDrawNode();
      }
      t3 = a2.length;
      while (t3--) {
        this.enableBlendDefault();
        a2[t3].drawNode();
      }
      this._drawEntityCollections(0);
      e4.dispatch(e4.drawtransparent, this);
      if (n2 && o2) {
        this._drawPickingBuffer(0);
      }
      this._drawDepthBuffer(0);
      this._clearEntityCollectionQueue(0);
    }
    for (let e5 = 1; e5 < this._entityCollections.length; e5++) {
      s2.clear(s2.DEPTH_BUFFER_BIT);
      let t3 = r2.length;
      while (t3--) {
        this.activeCamera.setCurrentFrustum(t3);
        this._drawEntityCollections(e5);
        if (n2 && o2) {
          this._drawPickingBuffer(e5);
        }
        this._drawDepthBuffer(e5);
      }
      this._clearEntityCollectionQueue(e5);
    }
    t2.deactivate();
    this.blitFramebuffer && t2.blitTo(this.blitFramebuffer, 0);
    if (n2 && o2) {
      this._readPickingBuffer();
    }
    if (o2) {
      this._readDepthBuffer();
    }
    this._fnScreenFrame();
    e4.dispatch(e4.postdraw, this);
    e4.mouseState.wheelDelta = 0;
    e4.mouseState.justStopped = false;
    e4.mouseState.moving = false;
    e4.touchState.moving = false;
  }
  getImageDataURL(e4 = "image/png", t2 = 1) {
    this.draw();
    return this.handler.canvas ? this.handler.canvas.toDataURL(e4, t2) : "";
  }
  _screenFrameMSAA() {
    let e4 = this.handler;
    let t2 = e4.programs.toneMapping, i2 = t2._program, s2 = e4.gl;
    s2.disable(s2.DEPTH_TEST);
    s2.bindBuffer(s2.ARRAY_BUFFER, this.screenFramePositionBuffer);
    s2.vertexAttribPointer(i2.attributes.corners, 2, s2.FLOAT, false, 0, 0);
    this.toneMappingFramebuffer.activate();
    t2.activate();
    s2.activeTexture(s2.TEXTURE0);
    s2.bindTexture(s2.TEXTURE_2D, this.blitFramebuffer.textures[0]);
    s2.uniform1i(i2.uniforms.hdrBuffer, 0);
    s2.uniform1f(i2.uniforms.gamma, this.gamma);
    s2.uniform1f(i2.uniforms.exposure, this.exposure);
    s2.uniform1f(i2.uniforms.whitepoint, this.whitepoint);
    s2.drawArrays(s2.TRIANGLE_STRIP, 0, 4);
    this.toneMappingFramebuffer.deactivate();
    t2 = e4.programs.screenFrame;
    i2 = t2._program;
    t2.activate();
    s2.activeTexture(s2.TEXTURE0);
    s2.bindTexture(s2.TEXTURE_2D, this.outputTexture);
    s2.uniform1i(i2.uniforms.texture, 0);
    s2.drawArrays(s2.TRIANGLE_STRIP, 0, 4);
    s2.enable(s2.DEPTH_TEST);
  }
  _screenFrameNoMSAA() {
    let e4 = this.handler;
    let t2 = e4.programs.screenFrame, i2 = t2._program, s2 = e4.gl;
    s2.disable(s2.DEPTH_TEST);
    t2.activate();
    s2.activeTexture(s2.TEXTURE0);
    s2.bindTexture(s2.TEXTURE_2D, this.outputTexture);
    s2.uniform1i(i2.uniforms.texture, 0);
    s2.bindBuffer(s2.ARRAY_BUFFER, this.screenFramePositionBuffer);
    s2.vertexAttribPointer(i2.attributes.corners, 2, s2.FLOAT, false, 0, 0);
    s2.drawArrays(s2.TRIANGLE_STRIP, 0, 4);
    s2.enable(s2.DEPTH_TEST);
  }
  _drawPickingBuffer(e4) {
    this.pickingFramebuffer.activate();
    let t2 = this.handler;
    let i2 = t2.gl;
    if (this.activeCamera.isFirstPass && e4 === 0) {
      i2.clearColor(0, 0, 0, 1);
      i2.clear(i2.COLOR_BUFFER_BIT | i2.DEPTH_BUFFER_BIT);
    } else {
      i2.clear(i2.DEPTH_BUFFER_BIT);
    }
    i2.disable(i2.BLEND);
    if (e4 === 0) {
      let e5 = this._pickingCallbacks;
      for (let t3 = 0, i3 = e5.length; t3 < i3; t3++) {
        e5[t3].callback.call(e5[t3].sender);
      }
    }
    this._drawPickingEntityCollections(e4);
    i2.enable(i2.BLEND);
    this.pickingFramebuffer.deactivate();
  }
  _drawDepthBuffer(e4) {
    this.depthFramebuffer.activate();
    let t2 = this.handler;
    let i2 = t2.gl;
    i2.disable(i2.BLEND);
    if (this.activeCamera.isFirstPass && e4 === 0) {
      i2.clearColor(0, 0, 0, 1);
      i2.clear(i2.COLOR_BUFFER_BIT | i2.DEPTH_BUFFER_BIT);
    } else {
      i2.clear(i2.DEPTH_BUFFER_BIT);
    }
    if (e4 === 0) {
      let e5 = this._depthCallbacks;
      let t3 = e5.length;
      while (t3--) {
        e5[t3].callback.call(e5[t3].sender);
      }
    }
    this._drawDepthEntityCollections(e4);
    this.depthFramebuffer.deactivate();
  }
  _readDepthBuffer() {
    this.depthFramebuffer.readPixelBuffersAsync();
  }
  _readPickingBuffer_webgl1() {
    this.pickingFramebuffer.readPixelBuffersAsync();
  }
  _readPickingBuffer_webgl2() {
    this.pickingFramebuffer.readPixelBuffersAsync();
  }
  readPickingColor(e4, t2, i2) {
    var _a2;
    let s2 = this.pickingFramebuffer.width;
    let r2 = this.pickingFramebuffer.height;
    e4 = Math.round(e4 * s2);
    t2 = Math.round(t2 * r2);
    let n2 = (t2 * s2 + e4) * 4;
    let o2 = (_a2 = this.pickingFramebuffer) == null ? void 0 : _a2.pixelBuffers[0].data;
    if (o2) {
      i2[0] = o2[n2];
      i2[1] = o2[n2 + 1];
      i2[2] = o2[n2 + 2];
    }
  }
  readDepth(e4, t2, i2) {
    let s2 = new Float32Array(4);
    let r2 = new Uint8Array(4);
    this.depthFramebuffer.readData(e4, t2, r2, 0);
    this.depthFramebuffer.readData(e4, t2, s2, 1);
    i2[0] = s2[0];
    i2[1] = Math.round(r2[0] / 10) - 1;
  }
  getDistanceFromPixel(e4) {
    let t2 = this.activeCamera;
    let i2 = this.handler.canvas;
    let s2 = e4.x / i2.width;
    let r2 = (i2.height - e4.y) / i2.height;
    Qg[0] = Qg[1] = 0;
    let n2 = 0;
    this.readDepth(s2, r2, Qg);
    if (Qg[1] === -1) {
      return;
    }
    let o2 = Qg[0], a2 = t2.frustums[Qg[1]];
    if (!a2) return;
    let l2 = new $e(s2 * 2 - 1, r2 * 2 - 1, o2 * 2 - 1, 1);
    let h2 = a2.inverseProjectionMatrix.mulVec4(l2);
    let c2 = e4.direction || t2.unproject(e4.x, e4.y);
    n2 = -(h2.z / h2.w) / c2.dot(t2.getForward());
    return n2;
  }
  getCartesianFromPixel(e4) {
    let t2 = this.getDistanceFromPixel(e4);
    if (t2) {
      let i2 = e4.direction || this.activeCamera.unproject(e4.x, e4.y);
      return i2.scaleTo(t2).addA(this.activeCamera.eye);
    }
  }
  start() {
    if (!this._initialized) {
      this.initialize();
    }
    this.handler.start();
  }
  destroy() {
    for (let e4 in this.controls) {
      this.controls[e4].remove();
    }
    for (let e4 = 0; e4 < this._renderNodesArr.length; e4++) {
      this._renderNodesArr[e4].remove();
    }
    this.div = null;
    this._renderNodesArr = [];
    this.renderNodes = {};
    this.activeCamera = null;
    this.controls = {};
    this.controlsBag = {};
    this.colorObjects.clear();
    this.colorObjects = null;
    this._pickingCallbacks = [];
    this.pickingFramebuffer = null;
    this._tempPickingPix_ = null;
    this._depthCallbacks = [];
    this.depthFramebuffer = null;
    this.sceneFramebuffer = null;
    this.blitFramebuffer = null;
    this.toneMappingFramebuffer = null;
    this._entityCollections = [[]];
    this.handler.ONCANVASRESIZE = null;
    this.handler.destroy();
    this.handler = null;
    this._initialized = false;
  }
}
const ep = `/night.png`;
const tp = `/spec.png`;
const ip = "/res";
const sp = "globus_planet_";
const _rp = class _rp {
  constructor(e4) {
    this.$target = null;
    this._instanceID = `__globus${_rp.__counter__++ ? _rp.__counter__ : ""}__`;
    window[this._instanceID] = this;
    this._canvas = document.createElement("canvas");
    this._canvas.id = `canvas${this._instanceID}`;
    this._canvas.style.width = "100%";
    this._canvas.style.height = "100%";
    this._canvas.style.display = "block";
    this._canvas.style.opacity = "0.0";
    this._canvas.style.transition = "opacity 150ms";
    this.$inner = document.createElement("div");
    this.$inner.classList.add("og-inner");
    this.$inner.appendChild(this._canvas);
    this.$inner.attributions = document.createElement("div");
    if (e4.attributionContainer) {
      e4.attributionContainer.appendChild(this.$inner.attributions);
    } else {
      this.$inner.attributions.classList.add("og-attribution");
      this.$inner.appendChild(this.$inner.attributions);
    }
    if (e4.target) {
      this.attachTo(e4.target);
    }
    const t2 = (e5) => {
      e5.preventDefault();
    };
    this._canvas.onmouseenter = function() {
      document.addEventListener("mousewheel", t2, { capture: false, passive: false });
    };
    this._canvas.onmouseleave = function() {
      document.removeEventListener("mousewheel", t2);
    };
    this.renderer = new Jg(new pg(this._canvas, { autoActivate: false, pixelRatio: e4.dpi || window.devicePixelRatio + 0.15, context: { antialias: false, premultipliedAlpha: false, preserveDrawingBuffer: false } }), { autoActivate: false, msaa: e4.msaa, fontsSrc: e4.fontsSrc, gamma: e4.gamma, exposure: e4.exposure });
    this.renderer.div = this.$inner;
    if (e4.skybox) {
      this.renderer.addNode(e4.skybox);
    }
    this._planetName = e4.name ? e4.name : sp + _rp.__counter__;
    this.planet = new Bf({ name: this._planetName, frustums: e4.frustums, ellipsoid: e4.ellipsoid, maxGridSize: e4.maxGridSize, nightTextureSrc: e4.nightTextureSrc === null ? null : e4.nightTextureSrc || `${e4.resourcesSrc || ip}${ep}`, specularTextureSrc: e4.specularTextureSrc === null ? null : e4.specularTextureSrc || `${e4.resourcesSrc || ip}${tp}`, minAltitude: e4.minAltitude, maxAltitude: e4.maxAltitude || 15e6, maxEqualZoomAltitude: e4.maxEqualZoomAltitude, minEqualZoomAltitude: e4.minEqualZoomAltitude, minEqualZoomCameraSlope: e4.minEqualZoomCameraSlope, quadTreeStrategyPrototype: e4.quadTreeStrategyPrototype, maxLoadingRequests: e4.maxLoadingRequests, atmosphereEnabled: e4.atmosphereEnabled, transitionOpacityEnabled: e4.transitionOpacityEnabled, atmosphereParameters: e4.atmosphereParameters });
    if (e4.terrain) {
      if (Array.isArray(e4.terrain)) {
        this.planet.setTerrain(e4.terrain[0]);
      } else {
        this.planet.setTerrain(e4.terrain);
      }
    } else {
      this.planet.setTerrain(new Ff());
    }
    this.renderer.addNode(this.planet);
    if (e4.controls) {
      this.planet.addControls(e4.controls);
    } else {
      this.planet.addControls([new Wh(), new ch(), new Vh(), new Rl(), new Sh(), new as()]);
    }
    const i2 = this.renderer.controls;
    let s2;
    for (let e5 in i2) {
      if (i2[e5] instanceof Nh) {
        s2 = i2[e5];
        break;
      }
    }
    if (!s2) {
      this.sun = new Nh();
      this.planet.addControl(this.sun);
    } else {
      this.sun = s2;
    }
    if (e4.sun) {
      if (e4.sun.active !== void 0 && !e4.sun.active) {
        this.sun.deactivate();
      }
      if (e4.sun.stopped === true) {
        this.sun.stop();
      }
    }
    if (e4.layers) {
      this.planet.addLayers(e4.layers);
    }
    let r2 = e4.viewExtent;
    if (r2) {
      if (r2 instanceof Array) {
        this.planet.viewExtentArr(r2);
      } else {
        this.planet.viewExtent(r2);
      }
    }
    if (e4.autoActivate || st(e4.autoActivate)) {
      this.start();
    }
  }
  start() {
    this.renderer.start();
    this.fadeIn();
  }
  fadeIn() {
    this._canvas.style.opacity = "1.0";
  }
  fadeOut() {
    this._canvas.style.opacity = "0";
  }
  attachTo(e4, t2) {
    this.detach();
    let i2;
    if (e4 instanceof HTMLElement) {
      i2 = e4;
    } else {
      i2 = document.getElementById(e4) || document.querySelector(e4);
    }
    if (i2) {
      this.$target = i2;
      if (t2 && this.$target.firstChild) {
        this.$target.insertBefore(this.$inner, this.$target.firstChild);
      } else {
        i2.appendChild(this.$inner);
      }
    } else {
      console.warn(`Target container not found. Provided target: ${e4}`);
    }
  }
  detach() {
    if (this.$target) {
      this.$target.removeChild(this.$inner);
      this.$target = null;
    }
  }
  destroy() {
    this.detach();
    this.planet.layers.forEach((e4) => e4.remove());
    this.planet.destroy();
    this.renderer.destroy();
    window[this._instanceID] = null;
  }
};
_rp.__counter__ = 0;
let rp = _rp;
const np = new et(3396200, 3389508);
const op = new et(1737400, 1737400);
const ap = `<div class="og-popup {className}">
      <div class="og-popup-content-wrapper">
        <div class="og-popup-content"></div>
      </div>
      <div class="og-popup-tip-container">
        <div class="og-popup-tip"></div>
      </div>
      <div class="og-popup-toolbar">
        <div class="og-popup-btn og-popup-close">${ls}</div>
      </div>
      <div class="og-popup-title">{title}</div>
    </div>`;
const lp = ["open", "close"];
class hp extends ts {
  constructor(e4) {
    super({ template: ft(ap, { title: e4.title || "" }), classList: e4.className ? [e4.className] : [], ...e4 });
    this.events = this.events.registerNames(lp);
    this._content = e4.content || "";
    this.$content = null;
    this.$tip = null;
    this.$title = null;
    this._planet = e4.planet;
    this._offset = e4.offset || [0, 0];
    this._lonLat = At(e4.lonLat);
    this._cartPos = new Ke();
    this._visibility = e4.visibility || false;
    this.render();
  }
  _updatePosition() {
    this.setCartesian3v(this._cartPos);
  }
  setScreen(e4) {
    if (this._planet) {
      let t2 = this._planet.renderer.handler.pixelRatio;
      this.el.style.transform = `translate(${e4.x / t2 - this.clientWidth * 0.5}px, ${e4.y / t2 - this._planet.renderer.handler.canvas.clientHeight - this.$tip.clientHeight}px)`;
    }
  }
  get clientWidth() {
    return this.el ? this.el.clientWidth : 0;
  }
  get clientHeight() {
    return this.el ? this.el.clientHeight : 0;
  }
  setOffset(e4 = 0, t2 = 0) {
    this._offset[0] = e4;
    this._offset[1] = t2;
    if (this.el) {
      this.el.style.left = `${e4}px`;
      this.el.style.bottom = `${t2}px`;
    }
    return this;
  }
  render(e4) {
    super.render(e4);
    this.$content = this.select(".og-popup-content");
    this.$title = this.select(".og-popup-title");
    this.$tip = this.select(".og-popup-tip-container");
    this.setOffset(this._offset[0], this._offset[1]);
    this.setContent(this._content);
    this.setLonLat(this._lonLat);
    this.setVisibility(this._visibility);
    this.select(".og-popup-close").addEventListener("click", () => {
      this.hide();
    });
    return this;
  }
  setVisibility(e4) {
    if (e4) {
      this.show();
    } else {
      this.hide();
    }
    return this;
  }
  getContainer() {
    return this.$content;
  }
  getToolbarContainer() {
    return this.select(".og-popup-toolbar");
  }
  show() {
    this._visibility = true;
    if (this._planet) {
      this._planet.events.on("draw", this._updatePosition, this);
      this.appendTo(this._planet.renderer.div);
      this.events.dispatch(this.events.open, this);
    }
    return this;
  }
  hide() {
    this._visibility = false;
    if (this.el && this.el.parentNode) {
      this._planet.events.off("draw", this._updatePosition);
      this.el.parentNode.removeChild(this.el);
      this.events.dispatch(this.events.close, this);
    }
    return this;
  }
  setCartesian3v(e4, t2 = 0) {
    this._cartPos = e4;
    if (this._planet) {
      let i2 = this._planet.camera;
      let s2 = this._planet.ellipsoid.equatorialSize + t2, r2 = i2._lonLat.height;
      let n2 = e4.sub(i2.eye), o2 = Math.sqrt((s2 + r2) * (s2 + r2) - s2 * s2);
      if (o2 > n2.length() && i2.getForward().dot(n2.normalize()) > 0) {
        this.el.style.display = "block";
        this.setScreen(i2.project3v(e4));
      } else {
        this.el.style.display = "none";
      }
    }
    return this;
  }
  setTitle(e4) {
    if (this.$title) {
      this.$title.innerHTML = e4;
    }
  }
  setLonLat(e4) {
    this._lonLat = e4;
    if (this._planet) {
      this.setCartesian3v(this._planet.ellipsoid.lonLatToCartesian(e4), e4.height);
    }
  }
  setContent(e4) {
    if (e4) {
      this.clear();
      this._content = e4;
      if (this.$content) {
        if (typeof e4 === "string") {
          this.$content.innerHTML = e4;
        } else {
          this.$content.appendChild(e4);
        }
      }
    }
  }
  clear() {
    this._content = null;
    if (this.$content) {
      this.$content.innerHTML = "";
    }
  }
}
const cp = 5;
const dp = 5 / Math.pow(2, cp);
class up extends Q_ {
  constructor(e4, t2, i2, s2) {
    super(e4, t2, i2, s2);
    this._projection = hf;
    this.isPole = false;
    this._tileGroup = T_;
  }
  _getMaxZoom() {
    let e4 = 0;
    if (this._extent.northEast.lat > 85) {
      let t2 = Math.floor((90 - this._extent.northEast.lat) / dp);
      e4 = Math.floor(t2 / 16) + cp;
    } else if (this._extent.southWest.lat < -85) {
      let t2 = Math.floor((90 + this._extent.southWest.lat) / dp);
      e4 = Math.floor(t2 / 16) + cp;
    } else {
      e4 = 50;
    }
    return e4;
  }
  _assignTileYIndexes(e4) {
    const t2 = e4.getCenter().lat;
    this.tileY = w_(t2, e4.getHeight(), 90);
    this.tileYN = this.tileY - 1;
    this.tileYS = this.tileY + 1;
  }
  _assignTileXIndexes(e4) {
    let t2 = e4.getCenter().lon;
    this.tileX = w_(t2, e4.getWidth(), -180);
    let i2 = (1 << this.tileZoom) * 2;
    this.tileXE = (this.tileX + 1) % i2;
    this.tileXW = (i2 + this.tileX - 1) % i2;
  }
  getDefaultTexture() {
    return this.planet.solidTextureOne;
  }
}
class _p extends J_ {
  constructor(e4, t2, i2, s2, r2, n2) {
    super(e4, t2, i2, s2, r2, n2);
    this.strategy = e4;
  }
  createChildNodes() {
    const e4 = this.strategy;
    const t2 = this.extent;
    const i2 = t2.getWidth() * 0.5;
    const s2 = t2.getHeight() * 0.5;
    const r2 = t2.northEast;
    const n2 = t2.southWest;
    const o2 = new be(n2.lon + i2, n2.lat + s2);
    const a2 = this.childNodes;
    const l2 = this.layer._planet;
    const h2 = this.zoom + 1;
    a2[ps] = new _p(e4, ps, this, new Ye(new be(n2.lon, n2.lat + s2), new be(n2.lon + i2, r2.lat)), l2, h2);
    a2[ms] = new _p(e4, ms, this, new Ye(o2, new be(r2.lon, r2.lat)), l2, h2);
    a2[vs] = new _p(e4, vs, this, new Ye(new be(n2.lon, n2.lat), o2), l2, h2);
    a2[ys] = new _p(e4, ys, this, new Ye(new be(n2.lon + i2, n2.lat), new be(r2.lon, n2.lat + s2)), l2, h2);
  }
  _setExtentBounds() {
    this.bsphere.setFromExtent(this.layer._planet.ellipsoid, this.extent);
  }
  __setLonLat__(e4) {
    if (e4._lonLat.isZero()) {
      e4._lonLat = this.layer._planet.ellipsoid.cartesianToLonLat(e4._cartesian);
    }
    return e4._lonLat;
  }
  isVisible() {
    if (this.strategy._renderingNodesWest[this.nodeId]) {
      return true;
    } else if (this.strategy._renderingNodesEast[this.nodeId]) {
      return true;
    }
    return false;
  }
  isInside(e4) {
    return this.extent.isInside(e4._lonLat);
  }
  renderCollection(e4, t2, i2) {
    if (this.extent.southWest.lon < 0) {
      this.strategy._renderingNodesWest[this.nodeId] = true;
    } else {
      this.strategy._renderingNodesEast[this.nodeId] = true;
    }
    if (this.deferredEntities.length && !this._inTheQueue) {
      if (this.layer.async) {
        this.strategy._queueDeferredNode(this);
      } else {
        this.applyCollection();
      }
    }
    const s2 = this.entityCollection;
    s2._fadingOpacity = this.layer._fadingOpacity;
    s2.scaleByDistance = this.layer.scaleByDistance;
    s2.pickingScale = this.layer.pickingScale;
    if (!s2.isEmpty()) {
      e4.push(s2);
    }
  }
}
class fp extends q_ {
  constructor(e4, t2) {
    super(e4, t2);
    let i2 = e4._planet;
    this._entityCollectionsTreeWest = new _p(this, ps, null, Ye.createFromArray([-180, -90, 0, 90]), i2, 0);
    this._entityCollectionsTreeEast = new _p(this, ps, null, Ye.createFromArray([0, -90, 180, 90]), i2, 0);
    this._renderingNodesWest = {};
    this._renderingNodesEast = {};
  }
  insertEntity(e4, t2 = false) {
    if (e4._lonLat.lon < 0) {
      this._entityCollectionsTreeWest.__setLonLat__(e4);
      this._entityCollectionsTreeWest.insertEntity(e4, t2);
    } else {
      this._entityCollectionsTreeEast.__setLonLat__(e4);
      this._entityCollectionsTreeEast.insertEntity(e4, t2);
    }
  }
  setPickingEnabled(e4) {
    this._entityCollectionsTreeWest.traverseTree((t2) => {
      t2.entityCollection.setPickingEnabled(e4);
    });
    this._entityCollectionsTreeEast.traverseTree((t2) => {
      t2.entityCollection.setPickingEnabled(e4);
    });
  }
  dispose() {
    this._entityCollectionsTreeWest = null;
    this._entityCollectionsTreeEast = null;
    this._renderingNodesWest = {};
    this._renderingNodesEast = {};
  }
  insertEntities(e4) {
    let t2 = [], i2 = [];
    for (let s2 = 0, r2 = e4.length; s2 < r2; s2++) {
      let r3 = e4[s2];
      if (r3._lonLat.lon < 0) {
        t2.push(r3);
        this._entityCollectionsTreeWest.__setLonLat__(r3);
      } else {
        i2.push(r3);
        this._entityCollectionsTreeEast.__setLonLat__(r3);
      }
    }
    this._entityCollectionsTreeWest.buildTree(t2);
    this._entityCollectionsTreeEast.buildTree(i2);
  }
  collectVisibleEntityCollections(e4) {
    this._renderingNodesWest = {};
    this._renderingNodesEast = {};
    let t2 = this._layer._planet.quadTreeStrategy;
    this._secondPASS = [];
    this._entityCollectionsTreeWest.collectRenderCollectionsPASS1(t2._visibleNodesWest, e4);
    let i2 = this._secondPASS.length;
    while (i2--) {
      this._secondPASS[i2].collectRenderCollectionsPASS2(t2._visibleNodesWest, e4, this._secondPASS[i2].nodeId);
    }
    this._secondPASS = [];
    this._entityCollectionsTreeEast.collectRenderCollectionsPASS1(t2._visibleNodesEast, e4);
    i2 = this._secondPASS.length;
    while (i2--) {
      this._secondPASS[i2].collectRenderCollectionsPASS2(t2._visibleNodesEast, e4, this._secondPASS[i2].nodeId);
    }
  }
}
class gp extends $_ {
  constructor(e4) {
    super(e4, "Mars", hf);
    this._westExtent = Ye.createFromArray([-180, -90, 0, 90]);
    this._eastExtent = Ye.createFromArray([0, -90, 180, 90]);
    this._visibleNodesWest = {};
    this._visibleNodesEast = {};
  }
  init() {
    this._quadTreeList = [new j_(up, this.planet, 0, null, 0, this._westExtent), new j_(up, this.planet, 0, null, 0, this._eastExtent)];
  }
  getTileXY(e4, t2) {
    let i2 = t2, s2 = -1, r2 = -1, n2 = 1 << i2;
    if (e4.lon > 0) {
      s2 = w_(e4.lon, 180 / n2, 0) + n2;
    } else {
      s2 = w_(e4.lon, 180 / n2, -180);
    }
    r2 = w_(e4.lat, 180 / n2, 90);
    return [s2, r2, i2, T_];
  }
  getLonLatTileOffset(e4, t2, i2, s2, r2) {
    let n2 = e4;
    let o2 = new Ye();
    if (e4.lon > 0) {
      o2 = C_(t2 - (1 << s2), i2, s2, this._eastExtent);
    } else {
      o2 = C_(t2, i2, s2, this._westExtent);
    }
    let a2 = o2.getWidth() / (r2 - 1), l2 = o2.getHeight() / (r2 - 1);
    let h2 = r2 - Math.ceil((n2.lat - o2.southWest.lat) / l2) - 1, c2 = Math.floor((n2.lon - o2.southWest.lon) / a2);
    return [h2, c2];
  }
  createEntitiCollectionsTreeStrategy(e4, t2) {
    return new fp(e4, t2);
  }
  collectVisibleNode(e4) {
    let t2 = e4.segment.getExtent();
    if (t2.southWest.lon < 0) {
      this._visibleNodesWest[e4.nodeId] = e4;
    } else {
      this._visibleNodesEast[e4.nodeId] = e4;
    }
  }
  _clearVisibleNodes() {
    this._visibleNodesWest = {};
    this._visibleNodesEast = {};
  }
}
class pp extends $_ {
  constructor(e4) {
    super(e4, "EPSG4326", X_);
  }
  init() {
    this._quadTreeList = [new j_(up, this.planet, 0, null, 0, Ye.createFromArray([-180, -90, 0, 90])), new j_(up, this.planet, 0, null, 0, Ye.createFromArray([0, -90, 180, 90]))];
  }
}
class mp extends $_ {
  constructor(e4) {
    super(e4, "wgs84", X_);
  }
  init() {
    this._quadTreeList = [new j_(up, this.planet, 0, null, 0, Ye.createFromArray([-180, -90, 180, 90]))];
  }
}
const vp = { epsg4326: pp, earth: sf, equi: gp, wgs84: mp };
export {
  gr as ALIGN,
  Gf as BilTerrain,
  Ks as Billboard,
  og as Bing,
  vf as Camera,
  Ds as CanvasTiles,
  hg as Clock,
  ns as Control,
  sf as EarthQuadTreeStrategy,
  et as Ellipsoid,
  Ff as EmptyTerrain,
  zr as Entity,
  ko as EntityCollection,
  gp as EquiQuadTreeStrategy,
  Ji as Events,
  Ye as Extent,
  u_ as Framebuffer,
  eg as GeoImage,
  fr as GeoObject,
  tg as GeoTexture2d,
  ig as GeoVideo,
  rf as Geoid,
  er as Geometry,
  Qs as GeometryTypeEnum,
  rp as Globe,
  Qf as GlobusRgbTerrain,
  Nf as GlobusTerrain,
  pg as Handler,
  sg as KML,
  Is as LAYER_EVENTS,
  _r as LOCAL_FORWARD,
  mr as Label,
  ks as Layer,
  Fh as LightSource,
  tr as Line2,
  ir as Line3,
  be as LonLat,
  qe as Mat3,
  Xe as Mat4,
  Ms as Material,
  zd as MoveAxisEntity,
  mg as Multisample,
  ur as Object3d,
  rg as OpenStreetMap,
  or as Plane,
  Bf as Planet,
  yf as PlanetCamera,
  br as PointCloud,
  Rr as Polyline,
  hp as Popup,
  Yr as Program,
  $_ as QuadTreeStrategy,
  Ze as Quat,
  ar as Ray,
  Fr as RenderNode,
  Jg as Renderer,
  Yf as RgbTerrain,
  Ir as Strip,
  Qe as Vec2,
  Ke as Vec3,
  $e as Vec4,
  Ma as Vector,
  Uf as WMS,
  mp as Wgs84QuadTreeStrategy,
  Hf as XYZ,
  Ki as bv,
  Cu as control,
  zl as input,
  $i as jd,
  ag as layer,
  np as mars,
  ge as math,
  je as mercator,
  op as moon,
  vp as quadTreeStrategyType,
  Df as scene,
  Jf as terrain,
  si as utils,
  vg as webgl,
  tt as wgs84
};
//# sourceMappingURL=og.es.js.map
